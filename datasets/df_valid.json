{"_id":{"22849":{"$oid":"6527b2cd99826ba7e59313df"},"22732":{"$oid":"6527b28e99826ba7e5922a59"},"23384":{"$oid":"6527b1f099826ba7e590212a"},"23072":{"$oid":"6527b17999826ba7e58ec00e"},"23710":{"$oid":"6527b19199826ba7e58ee85a"},"23202":{"$oid":"6527b17c99826ba7e58ec760"},"22526":{"$oid":"6527b19199826ba7e58eeb4b"},"22867":{"$oid":"6527b1ab99826ba7e58f3bf0"},"23426":{"$oid":"6527b17999826ba7e58ec0e5"},"23323":{"$oid":"6527b19799826ba7e58ef55d"},"23705":{"$oid":"6527b17799826ba7e58ebc0b"},"23442":{"$oid":"6527b21499826ba7e5909451"},"23623":{"$oid":"6527b21599826ba7e590964c"},"23695":{"$oid":"6527b18699826ba7e58ed862"},"23228":{"$oid":"6527b17999826ba7e58ebdc6"},"23662":{"$oid":"6527b28999826ba7e5921934"},"23226":{"$oid":"6527b25999826ba7e5917114"},"22810":{"$oid":"6527b17c99826ba7e58ec6d0"},"23555":{"$oid":"6527b1b699826ba7e58f5d2a"},"22801":{"$oid":"6527b21b99826ba7e590a962"},"23526":{"$oid":"6527b1ec99826ba7e5901748"},"22929":{"$oid":"6527b20699826ba7e59068bf"},"23716":{"$oid":"6527b1f299826ba7e5902903"},"22888":{"$oid":"6527b21099826ba7e590868f"},"23125":{"$oid":"6527b2aa99826ba7e59290c1"},"22851":{"$oid":"6527b18199826ba7e58ecfbd"},"23565":{"$oid":"6527b2f499826ba7e593a5e3"},"22493":{"$oid":"6527b18699826ba7e58ed5b6"},"23685":{"$oid":"6527b2b599826ba7e592ba39"},"23231":{"$oid":"6527b2d799826ba7e59336a7"},"22936":{"$oid":"6527b29f99826ba7e59264d3"},"23120":{"$oid":"6527b25d99826ba7e5918314"},"23755":{"$oid":"6527b17e99826ba7e58eca97"},"23256":{"$oid":"6527b1b599826ba7e58f56f4"},"23020":{"$oid":"6527b1ec99826ba7e5901793"},"23392":{"$oid":"6527b26099826ba7e5918f81"},"23484":{"$oid":"6527b1c999826ba7e58f9dc7"},"23491":{"$oid":"6527b1d399826ba7e58fbfad"},"23047":{"$oid":"6527b18399826ba7e58ed27a"},"23313":{"$oid":"6527b2c799826ba7e592fc9d"},"23298":{"$oid":"6527b17399826ba7e58eb2a1"},"22839":{"$oid":"6527b18199826ba7e58eceec"},"22800":{"$oid":"6527b1c999826ba7e58f9ee7"},"23495":{"$oid":"6527b21499826ba7e5909303"},"22607":{"$oid":"6527b19999826ba7e58efa5c"},"23077":{"$oid":"6527b18199826ba7e58ecdff"},"23486":{"$oid":"6527b28e99826ba7e5922b85"},"22845":{"$oid":"6527b2a999826ba7e5928c78"},"23762":{"$oid":"6527b2b599826ba7e592bbf9"},"22780":{"$oid":"6527b23f99826ba7e591172e"},"23199":{"$oid":"6527b18d99826ba7e58ee0b3"},"22553":{"$oid":"6527b18899826ba7e58eda8d"},"23775":{"$oid":"6527b17799826ba7e58eba29"},"23670":{"$oid":"6527b17a99826ba7e58ec17f"},"23339":{"$oid":"6527b17c99826ba7e58ec5dd"},"23515":{"$oid":"6527b1a599826ba7e58f256b"},"23320":{"$oid":"6527b25999826ba7e5917389"},"23679":{"$oid":"6527b18899826ba7e58ed952"},"23312":{"$oid":"6527b18699826ba7e58ed5bb"},"23683":{"$oid":"6527b1e699826ba7e5900377"},"22914":{"$oid":"6527b18d99826ba7e58ee2f9"},"23509":{"$oid":"6527b18d99826ba7e58ee26d"},"23159":{"$oid":"6527b17399826ba7e58eb1a9"},"23245":{"$oid":"6527b1e699826ba7e590030a"},"22964":{"$oid":"6527b1f099826ba7e5902332"},"23112":{"$oid":"6527b18199826ba7e58ed04d"},"22684":{"$oid":"6527b28e99826ba7e5922a77"},"22624":{"$oid":"6527b17399826ba7e58eb38c"},"23613":{"$oid":"6527b18699826ba7e58ed4db"},"23655":{"$oid":"6527b21799826ba7e5909a46"},"22837":{"$oid":"6527b24199826ba7e5912079"},"22532":{"$oid":"6527b18b99826ba7e58edfe5"},"23152":{"$oid":"6527b26299826ba7e5919464"},"23543":{"$oid":"6527b18b99826ba7e58edd63"},"23370":{"$oid":"6527b1d399826ba7e58fc03a"},"22941":{"$oid":"6527b18899826ba7e58ed8ba"},"23682":{"$oid":"6527b18b99826ba7e58edcb7"},"23382":{"$oid":"6527b27099826ba7e591c7c8"},"23776":{"$oid":"6527b27499826ba7e591d398"},"23272":{"$oid":"6527b2ba99826ba7e592cf39"},"22859":{"$oid":"6527b17e99826ba7e58ec97c"},"23418":{"$oid":"6527b20499826ba7e5905f8c"},"23254":{"$oid":"6527b1e899826ba7e5900bd9"},"23811":{"$oid":"6527b1d499826ba7e58fc4f2"},"22773":{"$oid":"6527b18f99826ba7e58ee54f"},"23172":{"$oid":"6527b18699826ba7e58ed835"},"22656":{"$oid":"6527b1ab99826ba7e58f3c8e"},"23759":{"$oid":"6527b17e99826ba7e58ecb77"},"22979":{"$oid":"6527b18b99826ba7e58edce1"},"22731":{"$oid":"6527b27a99826ba7e591e679"},"23048":{"$oid":"6527b1df99826ba7e58fe6bf"},"23283":{"$oid":"6527b18199826ba7e58ecff0"},"23445":{"$oid":"6527b19399826ba7e58eeed5"},"22728":{"$oid":"6527b17c99826ba7e58ec834"},"23227":{"$oid":"6527b21b99826ba7e590ab2c"},"23519":{"$oid":"6527b19c99826ba7e58eff47"},"23186":{"$oid":"6527b2af99826ba7e592a4f0"},"23188":{"$oid":"6527b18d99826ba7e58ee361"},"22687":{"$oid":"6527b1ae99826ba7e58f441b"},"23055":{"$oid":"6527b1ae99826ba7e58f435f"},"22655":{"$oid":"6527b18899826ba7e58ed9ed"},"23022":{"$oid":"6527b17799826ba7e58ebcc1"},"22881":{"$oid":"6527b18b99826ba7e58edd5e"},"23821":{"$oid":"6527b1c199826ba7e58f8117"},"23802":{"$oid":"6527b1c099826ba7e58f804e"},"22820":{"$oid":"6527b18b99826ba7e58ede10"},"23026":{"$oid":"6527b19199826ba7e58ee8a8"},"22654":{"$oid":"6527b17399826ba7e58eb32b"},"23632":{"$oid":"6527b2ef99826ba7e59392fa"},"23080":{"$oid":"6527b1d399826ba7e58fc06e"},"23252":{"$oid":"6527b26a99826ba7e591af27"},"22676":{"$oid":"6527b1fd99826ba7e5904ced"},"22790":{"$oid":"6527b17399826ba7e58eb1de"},"23741":{"$oid":"6527b2ed99826ba7e5938a61"},"22976":{"$oid":"6527b19199826ba7e58eeac7"},"23684":{"$oid":"6527b2d799826ba7e5933877"},"23808":{"$oid":"6527b24099826ba7e5911a8a"},"22497":{"$oid":"6527b18399826ba7e58ed0fa"},"22779":{"$oid":"6527b2bc99826ba7e592d44b"},"23405":{"$oid":"6527b2e299826ba7e59367fe"},"23522":{"$oid":"6527b2e799826ba7e5937432"},"23406":{"$oid":"6527b18899826ba7e58edb6a"},"23061":{"$oid":"6527b26199826ba7e5919293"},"23738":{"$oid":"6527b22199826ba7e590bbb5"},"23161":{"$oid":"6527b18699826ba7e58ed71d"},"23758":{"$oid":"6527b19199826ba7e58ee948"},"23749":{"$oid":"6527b1da99826ba7e58fd532"},"22644":{"$oid":"6527b19599826ba7e58ef2b4"},"23507":{"$oid":"6527b17c99826ba7e58ec7ec"},"23446":{"$oid":"6527b19999826ba7e58efa92"},"23818":{"$oid":"6527b1e099826ba7e58fece4"},"23564":{"$oid":"6527b19199826ba7e58eea80"},"22680":{"$oid":"6527b28d99826ba7e5922456"},"23350":{"$oid":"6527b1a399826ba7e58f1ba0"},"23597":{"$oid":"6527b2a099826ba7e5926991"},"23584":{"$oid":"6527b2ab99826ba7e592942a"},"22683":{"$oid":"6527b2c099826ba7e592e6eb"},"22986":{"$oid":"6527b19999826ba7e58efb2a"},"22868":{"$oid":"6527b18d99826ba7e58ee325"},"23713":{"$oid":"6527b17399826ba7e58eb198"},"23626":{"$oid":"6527b18699826ba7e58ed6d1"},"23290":{"$oid":"6527b18199826ba7e58eccbf"},"22968":{"$oid":"6527b1fd99826ba7e5904bb0"},"23005":{"$oid":"6527b1c199826ba7e58f8249"},"22865":{"$oid":"6527b2a999826ba7e5928c89"},"23554":{"$oid":"6527b17c99826ba7e58ec622"},"23629":{"$oid":"6527b2ad99826ba7e5929b84"},"23068":{"$oid":"6527b20f99826ba7e59083f5"},"22486":{"$oid":"6527b18399826ba7e58ed1da"},"23609":{"$oid":"6527b2de99826ba7e593522c"},"22592":{"$oid":"6527b19399826ba7e58eedd5"},"22873":{"$oid":"6527b17999826ba7e58ebfd2"},"22930":{"$oid":"6527b17e99826ba7e58ecc76"},"22591":{"$oid":"6527b17999826ba7e58ebf8a"},"23168":{"$oid":"6527b22c99826ba7e590de14"},"22908":{"$oid":"6527b20699826ba7e5906a5a"},"23474":{"$oid":"6527b1dd99826ba7e58fe0b1"},"23785":{"$oid":"6527b18699826ba7e58ed81e"},"23520":{"$oid":"6527b18199826ba7e58ecead"},"23107":{"$oid":"6527b2e099826ba7e5935f4d"},"22579":{"$oid":"6527b19599826ba7e58ef168"},"22824":{"$oid":"6527b2e599826ba7e5937203"},"23478":{"$oid":"6527b18399826ba7e58ed3e3"},"22970":{"$oid":"6527b26799826ba7e591a3e0"},"23400":{"$oid":"6527b1ca99826ba7e58fa2b1"},"22856":{"$oid":"6527b18d99826ba7e58ee338"},"23035":{"$oid":"6527b18699826ba7e58ed59b"},"23195":{"$oid":"6527b19599826ba7e58ef316"},"23155":{"$oid":"6527b17c99826ba7e58ec70a"},"22993":{"$oid":"6527b17c99826ba7e58ec793"},"23225":{"$oid":"6527b2be99826ba7e592dc05"},"23567":{"$oid":"6527b18d99826ba7e58ee204"},"22685":{"$oid":"6527b19599826ba7e58ef148"},"23236":{"$oid":"6527b18b99826ba7e58edc5d"},"22924":{"$oid":"6527b18f99826ba7e58ee745"},"23536":{"$oid":"6527b17a99826ba7e58ec483"},"23586":{"$oid":"6527b17a99826ba7e58ec45d"},"23571":{"$oid":"6527b17399826ba7e58eb279"},"22971":{"$oid":"6527b2b499826ba7e592b4d8"},"22935":{"$oid":"6527b24099826ba7e5911ad9"},"22671":{"$oid":"6527b18199826ba7e58ecf28"},"23530":{"$oid":"6527b22899826ba7e590d165"},"22755":{"$oid":"6527b19799826ba7e58ef5df"},"23018":{"$oid":"6527b19399826ba7e58eed3e"},"22980":{"$oid":"6527b19399826ba7e58eee20"},"23594":{"$oid":"6527b2d299826ba7e593297b"},"23672":{"$oid":"6527b18f99826ba7e58ee714"},"23743":{"$oid":"6527b18399826ba7e58ed22e"},"23340":{"$oid":"6527b21399826ba7e5908fcb"},"23700":{"$oid":"6527b1f999826ba7e590400a"},"22690":{"$oid":"6527b1f099826ba7e5902318"},"22879":{"$oid":"6527b18f99826ba7e58ee54d"},"23757":{"$oid":"6527b18199826ba7e58eccfc"},"23622":{"$oid":"6527b17a99826ba7e58ec343"},"22808":{"$oid":"6527b17a99826ba7e58ec22d"},"22995":{"$oid":"6527b2a599826ba7e5927730"},"23239":{"$oid":"6527b18d99826ba7e58ee211"},"23354":{"$oid":"6527b17999826ba7e58ebebe"},"22855":{"$oid":"6527b23a99826ba7e59104f3"},"22985":{"$oid":"6527b2e299826ba7e5936637"},"23281":{"$oid":"6527b17599826ba7e58eb86e"},"23190":{"$oid":"6527b17399826ba7e58eb1d3"},"23562":{"$oid":"6527b1ba99826ba7e58f67ca"},"22700":{"$oid":"6527b17c99826ba7e58ec8a8"},"22515":{"$oid":"6527b18d99826ba7e58ee2ab"},"23449":{"$oid":"6527b18399826ba7e58ed3e8"},"23539":{"$oid":"6527b24099826ba7e5911b25"},"22781":{"$oid":"6527b29799826ba7e5924af1"},"23362":{"$oid":"6527b2a699826ba7e5927a38"},"23316":{"$oid":"6527b19399826ba7e58eed35"},"23428":{"$oid":"6527b17599826ba7e58eb5f2"},"22981":{"$oid":"6527b19199826ba7e58eeb06"},"23559":{"$oid":"6527b25999826ba7e5917099"},"22662":{"$oid":"6527b19799826ba7e58ef522"},"23618":{"$oid":"6527b18b99826ba7e58edfb8"},"22850":{"$oid":"6527b2bd99826ba7e592d91b"},"23127":{"$oid":"6527b18f99826ba7e58ee584"},"23331":{"$oid":"6527b1b899826ba7e58f5eff"},"23423":{"$oid":"6527b1db99826ba7e58fd8a1"},"23464":{"$oid":"6527b25999826ba7e59172e1"},"23518":{"$oid":"6527b17599826ba7e58eb61c"},"23019":{"$oid":"6527b1b599826ba7e58f569f"},"23276":{"$oid":"6527b19999826ba7e58ef877"},"22933":{"$oid":"6527b1e499826ba7e58ffd44"},"23452":{"$oid":"6527b17799826ba7e58ebce1"},"22844":{"$oid":"6527b2a899826ba7e59285eb"},"23389":{"$oid":"6527b1f999826ba7e59040d7"},"22638":{"$oid":"6527b28f99826ba7e5922f5c"},"22787":{"$oid":"6527b24099826ba7e5911d45"},"23243":{"$oid":"6527b1c599826ba7e58f937c"},"23744":{"$oid":"6527b1b699826ba7e58f596a"},"23180":{"$oid":"6527b18b99826ba7e58edfbe"},"23287":{"$oid":"6527b2cc99826ba7e59310d5"},"22977":{"$oid":"6527b2e899826ba7e5937b68"},"23108":{"$oid":"6527b2a399826ba7e592757c"},"23372":{"$oid":"6527b25599826ba7e5916457"},"23319":{"$oid":"6527b2b299826ba7e592afe0"},"23556":{"$oid":"6527b2ef99826ba7e593919e"},"23472":{"$oid":"6527b17e99826ba7e58ecb50"},"22677":{"$oid":"6527b1a999826ba7e58f33f3"},"22832":{"$oid":"6527b17999826ba7e58ebfca"},"23232":{"$oid":"6527b28c99826ba7e592226e"},"22635":{"$oid":"6527b1ef99826ba7e5901fbb"},"22766":{"$oid":"6527b2df99826ba7e5935b27"},"22682":{"$oid":"6527b29f99826ba7e5926550"},"23570":{"$oid":"6527b2d699826ba7e5933388"},"23404":{"$oid":"6527b21499826ba7e5909465"},"22809":{"$oid":"6527b17399826ba7e58eb4aa"},"23628":{"$oid":"6527b2ce99826ba7e5931690"},"23598":{"$oid":"6527b20f99826ba7e590831c"},"23147":{"$oid":"6527b2ad99826ba7e5929b51"},"23153":{"$oid":"6527b2e299826ba7e593664a"},"23590":{"$oid":"6527b17c99826ba7e58ec839"},"23453":{"$oid":"6527b19199826ba7e58eeac5"},"23023":{"$oid":"6527b17e99826ba7e58ecbc8"},"23788":{"$oid":"6527b22799826ba7e590ccf2"},"23572":{"$oid":"6527b29d99826ba7e5925cbb"},"23078":{"$oid":"6527b17799826ba7e58ebb84"},"23093":{"$oid":"6527b17599826ba7e58eb68b"},"22871":{"$oid":"6527b1ea99826ba7e5900d14"},"23179":{"$oid":"6527b1e299826ba7e58ff475"},"22966":{"$oid":"6527b26399826ba7e5919af1"},"23069":{"$oid":"6527b19199826ba7e58eea16"},"23714":{"$oid":"6527b19399826ba7e58eecc1"},"22650":{"$oid":"6527b2d599826ba7e5932e20"},"23095":{"$oid":"6527b2af99826ba7e592a25c"},"23459":{"$oid":"6527b2b599826ba7e592ba34"},"23262":{"$oid":"6527b18b99826ba7e58edf91"},"23156":{"$oid":"6527b2c399826ba7e592f2f0"},"22611":{"$oid":"6527b17c99826ba7e58ec609"},"23261":{"$oid":"6527b18699826ba7e58ed612"},"22898":{"$oid":"6527b2cd99826ba7e59314d8"},"23175":{"$oid":"6527b18399826ba7e58ed2bd"},"23160":{"$oid":"6527b1a499826ba7e58f209e"},"23003":{"$oid":"6527b17999826ba7e58ebd4f"},"23083":{"$oid":"6527b19599826ba7e58ef1cf"},"22782":{"$oid":"6527b1a499826ba7e58f201c"},"23761":{"$oid":"6527b24599826ba7e5912b4c"},"23812":{"$oid":"6527b24d99826ba7e5914a89"},"22830":{"$oid":"6527b19999826ba7e58ef9c7"},"23751":{"$oid":"6527b1ec99826ba7e5901710"},"23801":{"$oid":"6527b29499826ba7e59242f4"},"22947":{"$oid":"6527b17c99826ba7e58ec641"},"22620":{"$oid":"6527b19199826ba7e58eeb63"},"22712":{"$oid":"6527b17799826ba7e58ebb02"},"22907":{"$oid":"6527b24999826ba7e5913b52"},"23240":{"$oid":"6527b1a699826ba7e58f283d"},"22989":{"$oid":"6527b19799826ba7e58ef3c8"},"23681":{"$oid":"6527b23e99826ba7e591157d"},"23439":{"$oid":"6527b21999826ba7e590a3d7"},"22715":{"$oid":"6527b18199826ba7e58ece6f"},"22918":{"$oid":"6527b18199826ba7e58ece37"},"22799":{"$oid":"6527b17399826ba7e58eb1ac"},"23601":{"$oid":"6527b18f99826ba7e58ee64e"},"23322":{"$oid":"6527b19199826ba7e58eeb21"},"23441":{"$oid":"6527b1cc99826ba7e58faa57"},"23551":{"$oid":"6527b1bf99826ba7e58f7bfa"},"22786":{"$oid":"6527b19599826ba7e58ef096"},"22802":{"$oid":"6527b27499826ba7e591d543"},"22922":{"$oid":"6527b22699826ba7e590ca68"},"22765":{"$oid":"6527b17599826ba7e58eb7bf"},"22485":{"$oid":"6527b18d99826ba7e58ee324"},"22625":{"$oid":"6527b18199826ba7e58ecf26"},"23527":{"$oid":"6527b19399826ba7e58eed84"},"23109":{"$oid":"6527b24999826ba7e5913d58"},"23424":{"$oid":"6527b27f99826ba7e591fa7d"},"22934":{"$oid":"6527b17399826ba7e58eb252"},"22769":{"$oid":"6527b2b099826ba7e592a67c"},"23529":{"$oid":"6527b1f599826ba7e5903045"},"22711":{"$oid":"6527b1b499826ba7e58f51ea"},"23666":{"$oid":"6527b17399826ba7e58eb368"},"23052":{"$oid":"6527b2d599826ba7e5932e71"},"23165":{"$oid":"6527b18199826ba7e58ecd5d"},"23345":{"$oid":"6527b19c99826ba7e58eff2d"},"22730":{"$oid":"6527b23599826ba7e590f777"},"22708":{"$oid":"6527b18199826ba7e58ecfc5"},"23462":{"$oid":"6527b1f499826ba7e5902f51"},"23110":{"$oid":"6527b19399826ba7e58eee00"},"23411":{"$oid":"6527b1ba99826ba7e58f679c"},"22549":{"$oid":"6527b19399826ba7e58eeef4"},"23496":{"$oid":"6527b20e99826ba7e5907eaa"},"23163":{"$oid":"6527b17799826ba7e58ebb09"},"22853":{"$oid":"6527b17c99826ba7e58ec6c2"},"23669":{"$oid":"6527b29399826ba7e5923a34"},"22519":{"$oid":"6527b19199826ba7e58ee8c4"},"22754":{"$oid":"6527b22c99826ba7e590dfc4"},"22674":{"$oid":"6527b17c99826ba7e58ec712"},"23145":{"$oid":"6527b22399826ba7e590c37b"},"22653":{"$oid":"6527b17c99826ba7e58ec6dd"},"23049":{"$oid":"6527b1be99826ba7e58f77bc"},"23725":{"$oid":"6527b23199826ba7e590eccc"},"22694":{"$oid":"6527b17399826ba7e58eb2c0"},"22716":{"$oid":"6527b20699826ba7e5906a47"},"23353":{"$oid":"6527b20499826ba7e59061f2"},"22504":{"$oid":"6527b18199826ba7e58ecf7f"},"23548":{"$oid":"6527b26799826ba7e591a6d1"},"23326":{"$oid":"6527b2c699826ba7e592f9bd"},"22938":{"$oid":"6527b20d99826ba7e5907ab0"},"23581":{"$oid":"6527b18899826ba7e58ed867"},"23417":{"$oid":"6527b2e399826ba7e5936913"},"23541":{"$oid":"6527b17c99826ba7e58ec6cf"},"22499":{"$oid":"6527b17399826ba7e58eb506"},"23763":{"$oid":"6527b19599826ba7e58ef292"},"23552":{"$oid":"6527b1f299826ba7e59028d0"},"22910":{"$oid":"6527b19799826ba7e58ef539"},"23367":{"$oid":"6527b18399826ba7e58ed1f5"},"23754":{"$oid":"6527b17c99826ba7e58ec6e6"},"23309":{"$oid":"6527b18399826ba7e58ed1fe"},"23460":{"$oid":"6527b2bc99826ba7e592d20b"},"23248":{"$oid":"6527b2c799826ba7e592fb80"},"22835":{"$oid":"6527b28799826ba7e59212cc"},"22729":{"$oid":"6527b17999826ba7e58ebe18"},"23196":{"$oid":"6527b2e799826ba7e5937478"},"22878":{"$oid":"6527b18899826ba7e58ed864"},"23687":{"$oid":"6527b18f99826ba7e58ee44b"},"22917":{"$oid":"6527b19799826ba7e58ef646"},"23605":{"$oid":"6527b2c799826ba7e592fb9e"},"22475":{"$oid":"6527b18b99826ba7e58edccc"},"22821":{"$oid":"6527b17e99826ba7e58ecbd5"},"23463":{"$oid":"6527b1b699826ba7e58f5c2c"},"23510":{"$oid":"6527b18d99826ba7e58ee1d4"},"23659":{"$oid":"6527b2b999826ba7e592c9a8"},"22937":{"$oid":"6527b22d99826ba7e590e35a"},"22660":{"$oid":"6527b1b199826ba7e58f4b14"},"23259":{"$oid":"6527b28d99826ba7e59224c5"},"23768":{"$oid":"6527b2b299826ba7e592b083"},"22774":{"$oid":"6527b19999826ba7e58ef8dd"},"23708":{"$oid":"6527b19599826ba7e58ef0cd"},"22911":{"$oid":"6527b18699826ba7e58ed74a"},"22900":{"$oid":"6527b18f99826ba7e58ee447"},"22663":{"$oid":"6527b26f99826ba7e591c4b2"},"22641":{"$oid":"6527b23599826ba7e590fa84"},"22564":{"$oid":"6527b19799826ba7e58ef71e"},"22777":{"$oid":"6527b2f599826ba7e593a808"},"23604":{"$oid":"6527b19599826ba7e58ef367"},"22696":{"$oid":"6527b17e99826ba7e58ec92d"},"23039":{"$oid":"6527b1f199826ba7e59024f9"},"23139":{"$oid":"6527b2ba99826ba7e592ccc2"},"23044":{"$oid":"6527b18399826ba7e58ed2d6"},"23654":{"$oid":"6527b19999826ba7e58efac8"},"23059":{"$oid":"6527b17999826ba7e58ebf40"},"23007":{"$oid":"6527b19599826ba7e58ef00a"},"23783":{"$oid":"6527b17399826ba7e58eb277"},"23415":{"$oid":"6527b18b99826ba7e58edecc"},"23573":{"$oid":"6527b17e99826ba7e58ecb59"},"23719":{"$oid":"6527b1c099826ba7e58f7f04"},"22842":{"$oid":"6527b2ab99826ba7e5929565"},"23656":{"$oid":"6527b24099826ba7e5911e54"},"22847":{"$oid":"6527b19999826ba7e58ef9c6"},"22783":{"$oid":"6527b2e999826ba7e5937ded"},"22736":{"$oid":"6527b2dc99826ba7e59349cb"},"23170":{"$oid":"6527b25399826ba7e5915f22"},"23425":{"$oid":"6527b1dc99826ba7e58fda46"},"22636":{"$oid":"6527b18d99826ba7e58ee0cf"},"23154":{"$oid":"6527b28999826ba7e5921940"},"22718":{"$oid":"6527b25899826ba7e5916dae"},"22675":{"$oid":"6527b2bc99826ba7e592d0c0"},"22789":{"$oid":"6527b18b99826ba7e58edf35"},"23493":{"$oid":"6527b19799826ba7e58ef796"},"23578":{"$oid":"6527b2c999826ba7e59309a2"},"23616":{"$oid":"6527b19399826ba7e58eed7e"},"22767":{"$oid":"6527b19199826ba7e58ee9cf"},"23234":{"$oid":"6527b2d199826ba7e5932575"},"23310":{"$oid":"6527b22d99826ba7e590e11d"},"22647":{"$oid":"6527b18899826ba7e58edc49"},"23786":{"$oid":"6527b2df99826ba7e59358ee"},"23736":{"$oid":"6527b1d399826ba7e58fc20a"},"23420":{"$oid":"6527b1f899826ba7e5903dbf"},"22818":{"$oid":"6527b2e999826ba7e5937d8c"},"23368":{"$oid":"6527b2c199826ba7e592ea97"},"23770":{"$oid":"6527b22299826ba7e590bf0d"},"23299":{"$oid":"6527b17e99826ba7e58ecad1"},"23636":{"$oid":"6527b1ec99826ba7e59016bb"},"22594":{"$oid":"6527b17799826ba7e58eb950"},"22885":{"$oid":"6527b2e399826ba7e5936a8d"},"23501":{"$oid":"6527b2ce99826ba7e593177b"},"23336":{"$oid":"6527b29099826ba7e5923162"},"23537":{"$oid":"6527b18399826ba7e58ed187"},"22719":{"$oid":"6527b17a99826ba7e58ec45e"},"22699":{"$oid":"6527b19199826ba7e58eea99"},"23257":{"$oid":"6527b19999826ba7e58efae2"},"23158":{"$oid":"6527b27b99826ba7e591ea6d"},"22639":{"$oid":"6527b17799826ba7e58ebbc2"},"23813":{"$oid":"6527b19e99826ba7e58f08ba"},"23296":{"$oid":"6527b26899826ba7e591a9bf"},"23711":{"$oid":"6527b18699826ba7e58ed57c"},"23407":{"$oid":"6527b18899826ba7e58eda80"},"22890":{"$oid":"6527b19799826ba7e58ef6e5"},"23364":{"$oid":"6527b19999826ba7e58efa6b"},"23208":{"$oid":"6527b19999826ba7e58efb0d"},"22951":{"$oid":"6527b20a99826ba7e5907511"},"23015":{"$oid":"6527b17999826ba7e58ebd53"},"22664":{"$oid":"6527b1df99826ba7e58fe834"},"23201":{"$oid":"6527b2b999826ba7e592cbec"},"23528":{"$oid":"6527b2f899826ba7e593ba0e"},"23358":{"$oid":"6527b27699826ba7e591d65f"},"23314":{"$oid":"6527b22199826ba7e590bc84"},"22758":{"$oid":"6527b18b99826ba7e58eddb8"},"23731":{"$oid":"6527b2ad99826ba7e5929be5"},"23269":{"$oid":"6527b19799826ba7e58ef772"},"22581":{"$oid":"6527b19999826ba7e58efa82"},"23699":{"$oid":"6527b19999826ba7e58efafe"},"23612":{"$oid":"6527b2e999826ba7e5937eeb"},"23098":{"$oid":"6527b19799826ba7e58ef54f"},"23422":{"$oid":"6527b2d999826ba7e5933f45"},"23634":{"$oid":"6527b2c299826ba7e592eecc"},"23328":{"$oid":"6527b18399826ba7e58ed332"},"22962":{"$oid":"6527b17599826ba7e58eb7ea"},"23065":{"$oid":"6527b1b999826ba7e58f6254"},"22814":{"$oid":"6527b17799826ba7e58eb9f7"},"23136":{"$oid":"6527b2b099826ba7e592a884"},"23244":{"$oid":"6527b17399826ba7e58eb158"},"22659":{"$oid":"6527b26499826ba7e5919e3d"},"22791":{"$oid":"6527b2be99826ba7e592dbf1"},"22507":{"$oid":"6527b19999826ba7e58ef99e"},"23631":{"$oid":"6527b18199826ba7e58ecfd7"},"23599":{"$oid":"6527b1c799826ba7e58f9b29"},"23443":{"$oid":"6527b18d99826ba7e58ee285"},"22877":{"$oid":"6527b27b99826ba7e591ea12"},"23121":{"$oid":"6527b26899826ba7e591ab4a"},"22634":{"$oid":"6527b24599826ba7e5912d7a"},"23166":{"$oid":"6527b1e499826ba7e58ffc0a"},"22740":{"$oid":"6527b19599826ba7e58ef015"},"23661":{"$oid":"6527b1e699826ba7e5900504"},"23307":{"$oid":"6527b2f499826ba7e593a42c"},"22739":{"$oid":"6527b17599826ba7e58eb621"},"22733":{"$oid":"6527b25999826ba7e5917321"},"22950":{"$oid":"6527b17799826ba7e58ebb80"},"22939":{"$oid":"6527b2bc99826ba7e592d47c"},"22574":{"$oid":"6527b18f99826ba7e58ee61c"},"23238":{"$oid":"6527b20799826ba7e5906cd3"},"22649":{"$oid":"6527b18d99826ba7e58ee26a"},"22646":{"$oid":"6527b1c399826ba7e58f8927"},"22882":{"$oid":"6527b18699826ba7e58ed72d"},"23207":{"$oid":"6527b17399826ba7e58eb3ed"},"23209":{"$oid":"6527b17e99826ba7e58ecc26"},"22775":{"$oid":"6527b17599826ba7e58eb6f3"},"23102":{"$oid":"6527b1da99826ba7e58fd39d"},"23305":{"$oid":"6527b17399826ba7e58eb3ec"},"22763":{"$oid":"6527b29399826ba7e5923946"},"23067":{"$oid":"6527b18899826ba7e58eda15"},"23553":{"$oid":"6527b17799826ba7e58ebc86"},"22905":{"$oid":"6527b2f799826ba7e593b0cc"},"23042":{"$oid":"6527b17c99826ba7e58ec81f"},"22698":{"$oid":"6527b29099826ba7e59232d4"},"23036":{"$oid":"6527b19599826ba7e58ef18f"},"22559":{"$oid":"6527b18199826ba7e58ecf8a"},"23767":{"$oid":"6527b1a399826ba7e58f1d2c"},"23311":{"$oid":"6527b27e99826ba7e591f497"},"23647":{"$oid":"6527b19999826ba7e58ef937"},"23511":{"$oid":"6527b17399826ba7e58eb3d5"},"23450":{"$oid":"6527b17c99826ba7e58ec705"},"23271":{"$oid":"6527b2f899826ba7e593b5a7"},"23266":{"$oid":"6527b19999826ba7e58efa99"},"22992":{"$oid":"6527b24699826ba7e59131a2"},"23489":{"$oid":"6527b2ad99826ba7e5929c2a"},"22540":{"$oid":"6527b19999826ba7e58efad0"},"23697":{"$oid":"6527b23b99826ba7e5910957"},"23505":{"$oid":"6527b1f599826ba7e59032dc"},"22529":{"$oid":"6527b18199826ba7e58ecf3c"},"23698":{"$oid":"6527b20d99826ba7e5907ddf"},"23001":{"$oid":"6527b1ec99826ba7e5901642"},"23242":{"$oid":"6527b26c99826ba7e591b8eb"},"22693":{"$oid":"6527b1f499826ba7e5902e46"},"23373":{"$oid":"6527b22999826ba7e590d5cb"},"23157":{"$oid":"6527b1f299826ba7e5902b87"},"23137":{"$oid":"6527b29899826ba7e5924d8f"},"23388":{"$oid":"6527b29999826ba7e59252a9"},"22566":{"$oid":"6527b17e99826ba7e58ecb37"},"23106":{"$oid":"6527b17599826ba7e58eb7ae"},"22637":{"$oid":"6527b21999826ba7e590a4e2"},"23675":{"$oid":"6527b2e499826ba7e5936ce4"},"22861":{"$oid":"6527b18899826ba7e58eda1c"},"22480":{"$oid":"6527b19799826ba7e58ef5f8"},"23054":{"$oid":"6527b1ff99826ba7e59053e2"},"23275":{"$oid":"6527b2aa99826ba7e5928f90"},"23497":{"$oid":"6527b17c99826ba7e58ec621"},"23149":{"$oid":"6527b19999826ba7e58efa80"},"23822":{"$oid":"6527b1a499826ba7e58f21eb"},"23668":{"$oid":"6527b18d99826ba7e58ee1ea"},"23431":{"$oid":"6527b1db99826ba7e58fd73a"},"23002":{"$oid":"6527b1cf99826ba7e58fb47a"},"23533":{"$oid":"6527b23e99826ba7e591167e"},"23694":{"$oid":"6527b22199826ba7e590bb39"},"23549":{"$oid":"6527b1d199826ba7e58fb8e6"},"23619":{"$oid":"6527b18d99826ba7e58ee2ad"},"23117":{"$oid":"6527b1a399826ba7e58f1e9e"},"22909":{"$oid":"6527b22b99826ba7e590dbe6"},"22803":{"$oid":"6527b23f99826ba7e5911965"},"22864":{"$oid":"6527b17c99826ba7e58ec851"},"22531":{"$oid":"6527b18399826ba7e58ed261"},"23523":{"$oid":"6527b17a99826ba7e58ec46c"},"22643":{"$oid":"6527b17999826ba7e58ec0ca"},"23644":{"$oid":"6527b18899826ba7e58ed971"},"23347":{"$oid":"6527b1c599826ba7e58f925d"},"22595":{"$oid":"6527b19599826ba7e58ef29f"},"23764":{"$oid":"6527b17999826ba7e58ebf69"},"23602":{"$oid":"6527b2f499826ba7e593a542"},"23797":{"$oid":"6527b1d099826ba7e58fb68a"},"23338":{"$oid":"6527b28799826ba7e59212c9"},"22761":{"$oid":"6527b18199826ba7e58ecf47"},"23062":{"$oid":"6527b28599826ba7e5920d47"},"22491":{"$oid":"6527b18899826ba7e58edaff"},"22863":{"$oid":"6527b20699826ba7e5906818"},"23140":{"$oid":"6527b17799826ba7e58ebaca"},"22623":{"$oid":"6527b19799826ba7e58ef48f"},"23722":{"$oid":"6527b1ba99826ba7e58f6803"},"22665":{"$oid":"6527b25899826ba7e5916d6b"},"23012":{"$oid":"6527b2b999826ba7e592c97e"},"23610":{"$oid":"6527b2c499826ba7e592f6b4"},"22661":{"$oid":"6527b22799826ba7e590cd4b"},"22991":{"$oid":"6527b1e399826ba7e58ff831"},"22944":{"$oid":"6527b26899826ba7e591a9b5"},"22776":{"$oid":"6527b28199826ba7e591fdbc"},"23575":{"$oid":"6527b18d99826ba7e58ee36c"},"23658":{"$oid":"6527b19399826ba7e58eed50"},"23348":{"$oid":"6527b22199826ba7e590b92f"},"23071":{"$oid":"6527b2af99826ba7e592a265"},"23641":{"$oid":"6527b22299826ba7e590bfd1"},"22833":{"$oid":"6527b18899826ba7e58ed87e"},"23772":{"$oid":"6527b17799826ba7e58ebc98"},"22838":{"$oid":"6527b1fc99826ba7e5904a34"},"22476":{"$oid":"6527b17399826ba7e58eb2d0"},"23032":{"$oid":"6527b17999826ba7e58ebe51"},"23773":{"$oid":"6527b27e99826ba7e591f1c5"},"22846":{"$oid":"6527b27b99826ba7e591e9f2"},"23131":{"$oid":"6527b29199826ba7e5923452"},"22710":{"$oid":"6527b17a99826ba7e58ec3e6"},"23546":{"$oid":"6527b1e399826ba7e58ff924"},"23278":{"$oid":"6527b1ae99826ba7e58f4440"},"22819":{"$oid":"6527b29e99826ba7e592625c"},"23538":{"$oid":"6527b18399826ba7e58ed46f"},"23084":{"$oid":"6527b17e99826ba7e58ecbdc"},"23760":{"$oid":"6527b18b99826ba7e58edf76"},"23707":{"$oid":"6527b2c399826ba7e592f17f"},"22975":{"$oid":"6527b17999826ba7e58ebea1"},"23321":{"$oid":"6527b2a999826ba7e5928d99"},"23301":{"$oid":"6527b1f999826ba7e590405b"},"23215":{"$oid":"6527b22599826ba7e590c5c6"},"23614":{"$oid":"6527b27099826ba7e591c8db"},"22688":{"$oid":"6527b2e799826ba7e59374e1"},"22681":{"$oid":"6527b18199826ba7e58ecdf4"},"22678":{"$oid":"6527b17a99826ba7e58ec3c3"},"23494":{"$oid":"6527b22599826ba7e590c5bd"},"22751":{"$oid":"6527b2dd99826ba7e5934d7f"},"22642":{"$oid":"6527b17c99826ba7e58ec83b"},"22753":{"$oid":"6527b2bc99826ba7e592d421"},"22972":{"$oid":"6527b2cb99826ba7e5930acb"},"23356":{"$oid":"6527b18b99826ba7e58eddcc"},"23315":{"$oid":"6527b19399826ba7e58eefb1"},"23337":{"$oid":"6527b2e599826ba7e59371f4"},"23376":{"$oid":"6527b18399826ba7e58ed379"},"22988":{"$oid":"6527b28999826ba7e59218f5"},"23260":{"$oid":"6527b2ef99826ba7e593963c"},"23706":{"$oid":"6527b2f899826ba7e593b624"},"22829":{"$oid":"6527b19399826ba7e58eec7c"},"23401":{"$oid":"6527b1a499826ba7e58f20b8"},"22794":{"$oid":"6527b2c199826ba7e592e955"},"22984":{"$oid":"6527b18699826ba7e58ed667"},"22994":{"$oid":"6527b2ee99826ba7e5938eff"},"23214":{"$oid":"6527b17a99826ba7e58ec3e8"},"23396":{"$oid":"6527b17999826ba7e58ebf12"},"23031":{"$oid":"6527b23399826ba7e590f291"},"23130":{"$oid":"6527b17799826ba7e58eb942"},"22606":{"$oid":"6527b18b99826ba7e58edd58"},"23000":{"$oid":"6527b19e99826ba7e58f0a26"},"22720":{"$oid":"6527b17799826ba7e58eb971"},"23297":{"$oid":"6527b2f499826ba7e593a429"},"22815":{"$oid":"6527b26399826ba7e591985f"},"23771":{"$oid":"6527b24399826ba7e591242e"},"23490":{"$oid":"6527b26a99826ba7e591b047"},"23363":{"$oid":"6527b17799826ba7e58ebd03"},"23778":{"$oid":"6527b2d299826ba7e593289f"},"23092":{"$oid":"6527b22399826ba7e590c1ea"},"23306":{"$oid":"6527b2eb99826ba7e593824c"},"23637":{"$oid":"6527b20d99826ba7e5907b65"},"23171":{"$oid":"6527b25b99826ba7e5917962"},"23222":{"$oid":"6527b20599826ba7e59066d1"},"22895":{"$oid":"6527b29199826ba7e5923630"},"23653":{"$oid":"6527b19799826ba7e58ef631"},"23263":{"$oid":"6527b22d99826ba7e590e0fd"},"22999":{"$oid":"6527b2a899826ba7e5928748"},"23040":{"$oid":"6527b18399826ba7e58ed320"},"23146":{"$oid":"6527b24a99826ba7e5914133"},"22902":{"$oid":"6527b18699826ba7e58ed6ea"},"23729":{"$oid":"6527b20599826ba7e59065be"},"23580":{"$oid":"6527b2dc99826ba7e5934c03"},"22744":{"$oid":"6527b21599826ba7e590998e"},"23223":{"$oid":"6527b18899826ba7e58eda0c"},"22697":{"$oid":"6527b24899826ba7e5913628"},"23008":{"$oid":"6527b18f99826ba7e58ee716"},"23517":{"$oid":"6527b23099826ba7e590eb48"},"22834":{"$oid":"6527b26a99826ba7e591b4a6"},"23642":{"$oid":"6527b19599826ba7e58eefd4"},"23249":{"$oid":"6527b19999826ba7e58ef9bd"},"23182":{"$oid":"6527b17c99826ba7e58ec5d2"},"23079":{"$oid":"6527b23b99826ba7e5910729"},"23063":{"$oid":"6527b17399826ba7e58eb466"},"23091":{"$oid":"6527b19399826ba7e58eecf7"},"22778":{"$oid":"6527b22299826ba7e590bdb4"},"23355":{"$oid":"6527b1a299826ba7e58f1a7a"},"23333":{"$oid":"6527b2ef99826ba7e5938f85"},"23378":{"$oid":"6527b22899826ba7e590d1ef"},"23419":{"$oid":"6527b2c099826ba7e592e545"},"23466":{"$oid":"6527b25999826ba7e59171e4"},"23451":{"$oid":"6527b2ed99826ba7e593894d"},"23268":{"$oid":"6527b24f99826ba7e5914da4"},"22746":{"$oid":"6527b17999826ba7e58ebed9"},"23292":{"$oid":"6527b24899826ba7e5913914"},"22886":{"$oid":"6527b21599826ba7e590992a"},"22827":{"$oid":"6527b17999826ba7e58ec0e1"},"23692":{"$oid":"6527b17799826ba7e58ebbcb"},"23351":{"$oid":"6527b18f99826ba7e58ee6d6"},"23558":{"$oid":"6527b21899826ba7e5909e21"},"22727":{"$oid":"6527b18d99826ba7e58ee04c"},"23651":{"$oid":"6527b18b99826ba7e58edc65"},"23488":{"$oid":"6527b19399826ba7e58eeeda"},"23440":{"$oid":"6527b17799826ba7e58ebad3"},"22919":{"$oid":"6527b17e99826ba7e58ec9e6"},"23774":{"$oid":"6527b25299826ba7e5915974"},"22771":{"$oid":"6527b17799826ba7e58ebab0"},"22536":{"$oid":"6527b18699826ba7e58ed565"},"22750":{"$oid":"6527b18399826ba7e58ed44e"},"22945":{"$oid":"6527b18b99826ba7e58ede3f"},"22788":{"$oid":"6527b19999826ba7e58efacc"},"23361":{"$oid":"6527b18f99826ba7e58ee646"},"23134":{"$oid":"6527b17599826ba7e58eb78f"},"22757":{"$oid":"6527b17e99826ba7e58ecbea"},"23726":{"$oid":"6527b2b799826ba7e592c33a"},"23104":{"$oid":"6527b25c99826ba7e5917c3f"},"23782":{"$oid":"6527b19799826ba7e58ef3c5"},"22825":{"$oid":"6527b17399826ba7e58eb4a3"},"23303":{"$oid":"6527b2a199826ba7e5926b1e"},"22875":{"$oid":"6527b2bc99826ba7e592d18b"},"23657":{"$oid":"6527b17799826ba7e58eba18"},"22973":{"$oid":"6527b18b99826ba7e58eded1"},"23447":{"$oid":"6527b17799826ba7e58ebcec"},"23128":{"$oid":"6527b1e499826ba7e58ffb00"},"23673":{"$oid":"6527b2aa99826ba7e59290d8"},"23678":{"$oid":"6527b2f899826ba7e593ba08"},"23289":{"$oid":"6527b1be99826ba7e58f77fb"},"23167":{"$oid":"6527b17799826ba7e58eb9b5"},"23132":{"$oid":"6527b18d99826ba7e58ee3b0"},"23200":{"$oid":"6527b29999826ba7e59251c2"},"23624":{"$oid":"6527b1e799826ba7e5900660"},"22651":{"$oid":"6527b1a199826ba7e58f1037"},"22841":{"$oid":"6527b17599826ba7e58eb5ea"},"22956":{"$oid":"6527b17399826ba7e58eb27d"},"22959":{"$oid":"6527b1b499826ba7e58f54ea"},"23606":{"$oid":"6527b17799826ba7e58ebcc7"},"23514":{"$oid":"6527b26299826ba7e59195cd"},"23191":{"$oid":"6527b23499826ba7e590f6d2"},"23800":{"$oid":"6527b1ca99826ba7e58fa2ca"},"23566":{"$oid":"6527b21b99826ba7e590aa61"},"23300":{"$oid":"6527b18899826ba7e58edc0b"},"22792":{"$oid":"6527b2a699826ba7e5927a6b"},"23360":{"$oid":"6527b18699826ba7e58ed6be"},"22798":{"$oid":"6527b17e99826ba7e58ec9b1"},"23277":{"$oid":"6527b19999826ba7e58ef923"},"23051":{"$oid":"6527b18d99826ba7e58ee1a5"},"23513":{"$oid":"6527b17799826ba7e58eba2d"},"23603":{"$oid":"6527b17c99826ba7e58ec5a3"},"23302":{"$oid":"6527b1d899826ba7e58fcf06"},"22703":{"$oid":"6527b17a99826ba7e58ec334"},"23090":{"$oid":"6527b18699826ba7e58ed6f6"},"23210":{"$oid":"6527b18199826ba7e58ed080"},"23379":{"$oid":"6527b18199826ba7e58ecd83"},"23374":{"$oid":"6527b17e99826ba7e58eca6a"},"23089":{"$oid":"6527b19799826ba7e58ef456"},"23479":{"$oid":"6527b2f499826ba7e593a4ec"},"22567":{"$oid":"6527b17c99826ba7e58ec5ed"},"22848":{"$oid":"6527b18f99826ba7e58ee5d8"},"22748":{"$oid":"6527b19199826ba7e58eea5a"},"23798":{"$oid":"6527b20999826ba7e5907193"},"22974":{"$oid":"6527b22299826ba7e590bfad"},"23732":{"$oid":"6527b17a99826ba7e58ec286"},"22713":{"$oid":"6527b26699826ba7e591a190"},"22923":{"$oid":"6527b22799826ba7e590cef7"},"22858":{"$oid":"6527b17399826ba7e58eb266"},"23473":{"$oid":"6527b19399826ba7e58eec3d"},"23784":{"$oid":"6527b25f99826ba7e59188d7"},"23608":{"$oid":"6527b19599826ba7e58ef1da"},"23591":{"$oid":"6527b25899826ba7e5916fb3"},"23635":{"$oid":"6527b1ec99826ba7e590179d"},"23189":{"$oid":"6527b18199826ba7e58ecfa5"},"23430":{"$oid":"6527b17999826ba7e58ebefa"},"23129":{"$oid":"6527b2a999826ba7e5928d2d"},"23294":{"$oid":"6527b19999826ba7e58ef8c1"},"22887":{"$oid":"6527b1c599826ba7e58f9254"},"23816":{"$oid":"6527b2ae99826ba7e5929efe"},"23645":{"$oid":"6527b18199826ba7e58ecdb0"},"23267":{"$oid":"6527b19199826ba7e58eebda"},"22704":{"$oid":"6527b2d899826ba7e5933c0b"},"22583":{"$oid":"6527b19999826ba7e58ef819"},"22481":{"$oid":"6527b19599826ba7e58ef298"},"23611":{"$oid":"6527b1b499826ba7e58f5215"},"23096":{"$oid":"6527b19599826ba7e58ef146"},"23375":{"$oid":"6527b18199826ba7e58ece24"},"22734":{"$oid":"6527b19199826ba7e58ee8ff"},"23366":{"$oid":"6527b26699826ba7e591a021"},"23408":{"$oid":"6527b17c99826ba7e58ec7d4"},"23185":{"$oid":"6527b2ab99826ba7e5929549"},"23689":{"$oid":"6527b19599826ba7e58ef1f6"},"23703":{"$oid":"6527b28199826ba7e591fe69"},"22889":{"$oid":"6527b1f299826ba7e59028af"},"23205":{"$oid":"6527b1f099826ba7e59021f0"},"23569":{"$oid":"6527b23699826ba7e590fe47"},"23480":{"$oid":"6527b2ce99826ba7e59317a3"},"23395":{"$oid":"6527b1b499826ba7e58f5393"},"23006":{"$oid":"6527b19399826ba7e58eec19"},"22706":{"$oid":"6527b18d99826ba7e58ee2f6"},"23391":{"$oid":"6527b26499826ba7e5919bfc"},"23017":{"$oid":"6527b18399826ba7e58ed0fb"},"23021":{"$oid":"6527b18b99826ba7e58edf45"},"23674":{"$oid":"6527b18199826ba7e58ecff8"},"23535":{"$oid":"6527b2a399826ba7e59275c9"},"23410":{"$oid":"6527b24499826ba7e591292e"},"23184":{"$oid":"6527b29199826ba7e5923655"},"23544":{"$oid":"6527b18899826ba7e58ed9cb"},"22961":{"$oid":"6527b1c099826ba7e58f7eda"},"23011":{"$oid":"6527b21599826ba7e59096a6"},"23765":{"$oid":"6527b18199826ba7e58ed076"},"22860":{"$oid":"6527b1a199826ba7e58f117e"},"22737":{"$oid":"6527b2c799826ba7e592fe79"},"22726":{"$oid":"6527b19999826ba7e58efa56"},"22707":{"$oid":"6527b2df99826ba7e593566c"},"23279":{"$oid":"6527b20f99826ba7e5908522"},"22823":{"$oid":"6527b1a799826ba7e58f2de0"},"23525":{"$oid":"6527b19799826ba7e58ef432"},"23250":{"$oid":"6527b19799826ba7e58ef4b9"},"22949":{"$oid":"6527b17399826ba7e58eb42f"},"22608":{"$oid":"6527b18699826ba7e58ed7c8"},"22869":{"$oid":"6527b18399826ba7e58ed2aa"},"22982":{"$oid":"6527b19999826ba7e58ef82e"},"23690":{"$oid":"6527b17399826ba7e58eb2e8"},"23413":{"$oid":"6527b17599826ba7e58eb638"},"22965":{"$oid":"6527b17399826ba7e58eb2f3"},"23476":{"$oid":"6527b2f299826ba7e5939b9d"},"23747":{"$oid":"6527b18f99826ba7e58ee4b0"},"23013":{"$oid":"6527b17a99826ba7e58ec174"},"23004":{"$oid":"6527b1a199826ba7e58f0fb2"},"23577":{"$oid":"6527b18f99826ba7e58ee50c"},"23111":{"$oid":"6527b1a299826ba7e58f195d"},"23458":{"$oid":"6527b24699826ba7e59130e4"},"22797":{"$oid":"6527b17e99826ba7e58eca71"},"23563":{"$oid":"6527b2ef99826ba7e59390ca"},"23352":{"$oid":"6527b2d699826ba7e59332c5"},"23433":{"$oid":"6527b27399826ba7e591cef2"},"23696":{"$oid":"6527b28c99826ba7e5922192"},"22668":{"$oid":"6527b18b99826ba7e58ee028"},"23485":{"$oid":"6527b1c999826ba7e58f9bca"},"22721":{"$oid":"6527b1ec99826ba7e590177f"},"23274":{"$oid":"6527b18b99826ba7e58ede1c"},"22666":{"$oid":"6527b18399826ba7e58ed45e"},"23304":{"$oid":"6527b17a99826ba7e58ec296"},"23308":{"$oid":"6527b19199826ba7e58eea69"},"23652":{"$oid":"6527b18f99826ba7e58ee6db"},"23421":{"$oid":"6527b26899826ba7e591a7e0"},"23380":{"$oid":"6527b1c399826ba7e58f8c01"},"23532":{"$oid":"6527b27a99826ba7e591e6f2"},"22807":{"$oid":"6527b18d99826ba7e58ee078"},"23435":{"$oid":"6527b17e99826ba7e58ec918"},"23359":{"$oid":"6527b19799826ba7e58ef6c5"},"23676":{"$oid":"6527b17599826ba7e58eb7ce"},"22813":{"$oid":"6527b25899826ba7e5916f19"},"22880":{"$oid":"6527b2de99826ba7e593513a"},"22892":{"$oid":"6527b24a99826ba7e5913f13"},"23429":{"$oid":"6527b18f99826ba7e58ee701"},"22793":{"$oid":"6527b2f899826ba7e593b426"},"22513":{"$oid":"6527b19599826ba7e58ef06a"},"22983":{"$oid":"6527b17e99826ba7e58ec8dc"},"23582":{"$oid":"6527b17a99826ba7e58ec478"},"23194":{"$oid":"6527b17599826ba7e58eb61a"},"23393":{"$oid":"6527b17399826ba7e58eb438"},"22963":{"$oid":"6527b26699826ba7e591a26a"},"22954":{"$oid":"6527b18f99826ba7e58ee6e7"},"23341":{"$oid":"6527b2b099826ba7e592a69f"},"23034":{"$oid":"6527b18699826ba7e58ed4da"},"22514":{"$oid":"6527b18899826ba7e58eda08"},"23454":{"$oid":"6527b18b99826ba7e58eddf3"},"23402":{"$oid":"6527b25f99826ba7e5918b95"},"23126":{"$oid":"6527b17c99826ba7e58ec865"},"23557":{"$oid":"6527b17399826ba7e58eb208"},"22826":{"$oid":"6527b2a799826ba7e5928099"},"22843":{"$oid":"6527b2b099826ba7e592a778"},"23471":{"$oid":"6527b2ef99826ba7e59394fb"},"23288":{"$oid":"6527b17c99826ba7e58ec5c0"},"23545":{"$oid":"6527b1cb99826ba7e58fa747"},"22913":{"$oid":"6527b22c99826ba7e590df41"},"22691":{"$oid":"6527b1f599826ba7e590333c"},"23119":{"$oid":"6527b1b999826ba7e58f64df"},"23087":{"$oid":"6527b23c99826ba7e5910bdf"},"23627":{"$oid":"6527b17a99826ba7e58ec178"},"23779":{"$oid":"6527b18f99826ba7e58ee72a"},"23444":{"$oid":"6527b1dc99826ba7e58fdd33"},"23470":{"$oid":"6527b18699826ba7e58ed847"},"23461":{"$oid":"6527b17599826ba7e58eb7e5"},"22955":{"$oid":"6527b2e599826ba7e59370b2"},"22921":{"$oid":"6527b17799826ba7e58ebc0c"},"23750":{"$oid":"6527b19999826ba7e58ef8d5"},"23475":{"$oid":"6527b17c99826ba7e58ec511"},"23787":{"$oid":"6527b17e99826ba7e58ec935"},"22672":{"$oid":"6527b17e99826ba7e58ec921"},"23009":{"$oid":"6527b19799826ba7e58ef715"},"23076":{"$oid":"6527b17399826ba7e58eb1f7"},"23780":{"$oid":"6527b2cb99826ba7e5930dbb"},"23589":{"$oid":"6527b17a99826ba7e58ec1b0"},"23198":{"$oid":"6527b19999826ba7e58efa00"},"23246":{"$oid":"6527b17399826ba7e58eb332"},"23506":{"$oid":"6527b2f699826ba7e593aea4"},"23625":{"$oid":"6527b27f99826ba7e591f85c"},"23487":{"$oid":"6527b17c99826ba7e58ec545"},"23335":{"$oid":"6527b29399826ba7e5923e27"},"23086":{"$oid":"6527b18d99826ba7e58ee2e9"},"23057":{"$oid":"6527b1bc99826ba7e58f6ce1"},"22759":{"$oid":"6527b1d199826ba7e58fb994"},"22978":{"$oid":"6527b26799826ba7e591a578"},"23592":{"$oid":"6527b1ef99826ba7e5901eca"},"23123":{"$oid":"6527b18f99826ba7e58ee61d"},"23100":{"$oid":"6527b17999826ba7e58ebf10"},"22618":{"$oid":"6527b19399826ba7e58eef56"},"23291":{"$oid":"6527b18699826ba7e58ed559"},"23024":{"$oid":"6527b1bd99826ba7e58f7205"},"23029":{"$oid":"6527b19999826ba7e58ef850"},"23114":{"$oid":"6527b2b199826ba7e592aaaa"},"22998":{"$oid":"6527b19399826ba7e58eeced"},"22738":{"$oid":"6527b18699826ba7e58ed599"},"23330":{"$oid":"6527b18899826ba7e58ed930"},"22893":{"$oid":"6527b19799826ba7e58ef43a"},"22705":{"$oid":"6527b18399826ba7e58ed256"},"23745":{"$oid":"6527b29399826ba7e5923e16"},"23600":{"$oid":"6527b25799826ba7e5916924"},"22940":{"$oid":"6527b2bc99826ba7e592d01e"},"23503":{"$oid":"6527b19199826ba7e58ee9a1"},"22997":{"$oid":"6527b26299826ba7e59195b5"},"23746":{"$oid":"6527b2a899826ba7e5928780"},"23014":{"$oid":"6527b18399826ba7e58ed40f"},"22717":{"$oid":"6527b17599826ba7e58eb7de"},"23720":{"$oid":"6527b17799826ba7e58eba85"},"23766":{"$oid":"6527b18f99826ba7e58ee60f"},"23646":{"$oid":"6527b20799826ba7e5906e81"},"23730":{"$oid":"6527b18199826ba7e58ecece"},"22484":{"$oid":"6527b17999826ba7e58ebd1c"},"22673":{"$oid":"6527b19799826ba7e58ef4f8"},"22987":{"$oid":"6527b19799826ba7e58ef5f0"},"23270":{"$oid":"6527b28e99826ba7e5922a9b"},"23671":{"$oid":"6527b1cc99826ba7e58faa5f"},"22709":{"$oid":"6527b1cc99826ba7e58faada"},"23740":{"$oid":"6527b19199826ba7e58ee95f"},"23638":{"$oid":"6527b2b999826ba7e592c977"},"22804":{"$oid":"6527b2d299826ba7e593297f"},"22770":{"$oid":"6527b20d99826ba7e5907ae7"},"23438":{"$oid":"6527b19399826ba7e58eef54"},"23781":{"$oid":"6527b1b499826ba7e58f52f8"},"23492":{"$oid":"6527b29f99826ba7e5926525"},"23344":{"$oid":"6527b18b99826ba7e58eddc8"},"23691":{"$oid":"6527b1e899826ba7e5900a49"},"23264":{"$oid":"6527b19999826ba7e58ef9f3"},"22545":{"$oid":"6527b18699826ba7e58ed767"},"23737":{"$oid":"6527b22399826ba7e590c40d"},"22542":{"$oid":"6527b18f99826ba7e58ee717"},"22657":{"$oid":"6527b25699826ba7e591681e"},"23206":{"$oid":"6527b17a99826ba7e58ec220"},"23468":{"$oid":"6527b19999826ba7e58efa85"},"23255":{"$oid":"6527b17a99826ba7e58ec436"},"23477":{"$oid":"6527b25d99826ba7e5918144"},"23483":{"$oid":"6527b19c99826ba7e58efd42"},"22870":{"$oid":"6527b2a999826ba7e5928cec"},"23150":{"$oid":"6527b26099826ba7e5918e06"},"22488":{"$oid":"6527b17599826ba7e58eb75b"},"23357":{"$oid":"6527b18399826ba7e58ed124"},"23550":{"$oid":"6527b26399826ba7e591986f"},"23343":{"$oid":"6527b19999826ba7e58ef86f"},"22597":{"$oid":"6527b19999826ba7e58efb0b"},"23144":{"$oid":"6527b2a299826ba7e5927170"},"23371":{"$oid":"6527b1e499826ba7e58ffb72"},"22689":{"$oid":"6527b17399826ba7e58eb381"},"22927":{"$oid":"6527b1e699826ba7e59002d3"},"23414":{"$oid":"6527b17999826ba7e58ebf37"},"22899":{"$oid":"6527b18699826ba7e58ed747"},"23204":{"$oid":"6527b18b99826ba7e58edd90"},"23216":{"$oid":"6527b29e99826ba7e592614c"},"23151":{"$oid":"6527b24a99826ba7e5913ff3"},"22562":{"$oid":"6527b18699826ba7e58ed60e"},"22812":{"$oid":"6527b1f899826ba7e5903e73"},"22764":{"$oid":"6527b17399826ba7e58eb419"},"23203":{"$oid":"6527b2c099826ba7e592e58b"},"23516":{"$oid":"6527b19999826ba7e58ef9d8"},"23796":{"$oid":"6527b2aa99826ba7e5928f94"},"23164":{"$oid":"6527b18d99826ba7e58ee384"},"23724":{"$oid":"6527b1fe99826ba7e590509e"},"22530":{"$oid":"6527b19399826ba7e58eec77"},"22512":{"$oid":"6527b17399826ba7e58eb429"},"23064":{"$oid":"6527b27e99826ba7e591f502"},"23056":{"$oid":"6527b1df99826ba7e58fe6d3"},"23082":{"$oid":"6527b17a99826ba7e58ec2ab"},"22679":{"$oid":"6527b17e99826ba7e58ecbf4"},"22752":{"$oid":"6527b2aa99826ba7e5928dc3"},"23066":{"$oid":"6527b17c99826ba7e58ec89b"},"22795":{"$oid":"6527b18899826ba7e58ed97a"},"23221":{"$oid":"6527b19599826ba7e58ef21a"},"23081":{"$oid":"6527b1e899826ba7e5900a8a"},"23387":{"$oid":"6527b2c899826ba7e5930315"},"23212":{"$oid":"6527b18899826ba7e58ed86e"},"23122":{"$oid":"6527b1db99826ba7e58fd8ab"},"23073":{"$oid":"6527b19399826ba7e58eec9d"},"23455":{"$oid":"6527b17399826ba7e58eb3d7"},"22960":{"$oid":"6527b17599826ba7e58eb830"},"23465":{"$oid":"6527b17a99826ba7e58ec225"},"23693":{"$oid":"6527b2f699826ba7e593ab2b"},"23777":{"$oid":"6527b17799826ba7e58ebbc6"},"23712":{"$oid":"6527b19599826ba7e58ef150"},"23416":{"$oid":"6527b1a499826ba7e58f2168"},"22990":{"$oid":"6527b18899826ba7e58edb1c"},"23595":{"$oid":"6527b18b99826ba7e58edfa6"},"23499":{"$oid":"6527b17c99826ba7e58ec5b5"},"23141":{"$oid":"6527b17a99826ba7e58ec197"},"22805":{"$oid":"6527b1c999826ba7e58f9d93"},"23791":{"$oid":"6527b27f99826ba7e591fa9f"},"23097":{"$oid":"6527b27999826ba7e591e26c"},"23193":{"$oid":"6527b18399826ba7e58ed390"},"23045":{"$oid":"6527b27699826ba7e591d971"},"23229":{"$oid":"6527b17c99826ba7e58ec79a"},"23113":{"$oid":"6527b2c899826ba7e592ff3a"},"23704":{"$oid":"6527b2d799826ba7e593382c"},"23324":{"$oid":"6527b1cb99826ba7e58fa5d1"},"22722":{"$oid":"6527b2e199826ba7e59361a5"},"22692":{"$oid":"6527b1f299826ba7e5902abf"},"22915":{"$oid":"6527b29e99826ba7e59260fd"},"23218":{"$oid":"6527b2dd99826ba7e5934e16"},"23282":{"$oid":"6527b17c99826ba7e58ec644"},"23162":{"$oid":"6527b25f99826ba7e5918b71"},"22817":{"$oid":"6527b17e99826ba7e58eca88"},"23593":{"$oid":"6527b18399826ba7e58ed2df"},"23217":{"$oid":"6527b17999826ba7e58ebf44"},"22831":{"$oid":"6527b2bc99826ba7e592d0ca"},"23752":{"$oid":"6527b19199826ba7e58ee8c8"},"23630":{"$oid":"6527b18699826ba7e58ed739"},"22523":{"$oid":"6527b17c99826ba7e58ec7f1"},"23094":{"$oid":"6527b18399826ba7e58ed31f"},"23394":{"$oid":"6527b19999826ba7e58ef89d"},"22560":{"$oid":"6527b19799826ba7e58ef60d"},"23434":{"$oid":"6527b2be99826ba7e592dd40"},"23030":{"$oid":"6527b29099826ba7e5923165"},"23531":{"$oid":"6527b17999826ba7e58ebd65"},"23542":{"$oid":"6527b18399826ba7e58ed342"},"22725":{"$oid":"6527b1fc99826ba7e5904905"},"23327":{"$oid":"6527b18b99826ba7e58eddfa"},"22884":{"$oid":"6527b2d899826ba7e5933c1c"},"22742":{"$oid":"6527b17e99826ba7e58ecb35"},"22472":{"$oid":"6527b18f99826ba7e58ee6c2"},"22957":{"$oid":"6527b19199826ba7e58ee8f0"},"22568":{"$oid":"6527b19599826ba7e58ef1b6"},"23795":{"$oid":"6527b26d99826ba7e591bd84"},"22866":{"$oid":"6527b1c199826ba7e58f83e8"},"23230":{"$oid":"6527b2e899826ba7e5937960"},"23660":{"$oid":"6527b2d199826ba7e5932453"},"23177":{"$oid":"6527b18f99826ba7e58ee441"},"22580":{"$oid":"6527b17999826ba7e58ebe3a"},"23500":{"$oid":"6527b19599826ba7e58ef2ad"},"23677":{"$oid":"6527b2c299826ba7e592eec5"},"23508":{"$oid":"6527b20499826ba7e590623e"},"23138":{"$oid":"6527b19799826ba7e58ef53e"},"22904":{"$oid":"6527b23a99826ba7e59104c1"},"23615":{"$oid":"6527b29e99826ba7e5926160"},"23211":{"$oid":"6527b18d99826ba7e58ee1e2"},"23286":{"$oid":"6527b18b99826ba7e58edceb"},"22648":{"$oid":"6527b1d899826ba7e58fd252"},"23318":{"$oid":"6527b1a999826ba7e58f32d9"},"23620":{"$oid":"6527b22799826ba7e590cf9f"},"23116":{"$oid":"6527b18399826ba7e58ed3dd"},"23169":{"$oid":"6527b25a99826ba7e5917823"},"23273":{"$oid":"6527b17599826ba7e58eb83d"},"22903":{"$oid":"6527b18f99826ba7e58ee6d4"},"23317":{"$oid":"6527b27999826ba7e591e31b"},"22785":{"$oid":"6527b18f99826ba7e58ee708"},"23709":{"$oid":"6527b19799826ba7e58ef435"},"23680":{"$oid":"6527b20e99826ba7e5908119"},"23220":{"$oid":"6527b26899826ba7e591ab32"},"22894":{"$oid":"6527b18199826ba7e58ed011"},"22749":{"$oid":"6527b18b99826ba7e58ee02e"},"22563":{"$oid":"6527b19799826ba7e58ef60f"},"23649":{"$oid":"6527b25e99826ba7e5918541"},"23403":{"$oid":"6527b17e99826ba7e58eca6c"},"23219":{"$oid":"6527b27799826ba7e591dbad"},"22702":{"$oid":"6527b29199826ba7e5923741"},"22772":{"$oid":"6527b28599826ba7e5920df7"},"23369":{"$oid":"6527b18b99826ba7e58eddd8"},"22836":{"$oid":"6527b17c99826ba7e58ec68d"},"23224":{"$oid":"6527b2a799826ba7e592805c"},"23381":{"$oid":"6527b1ca99826ba7e58fa24c"},"22857":{"$oid":"6527b18b99826ba7e58eddbc"},"23265":{"$oid":"6527b17e99826ba7e58eca20"},"22756":{"$oid":"6527b2a299826ba7e5926ec9"},"22572":{"$oid":"6527b17599826ba7e58eb55b"},"23377":{"$oid":"6527b18199826ba7e58ece64"},"22928":{"$oid":"6527b28b99826ba7e5921dd3"},"23588":{"$oid":"6527b18f99826ba7e58ee4e7"},"23118":{"$oid":"6527b18199826ba7e58ed058"},"23293":{"$oid":"6527b18399826ba7e58ed1f4"},"23178":{"$oid":"6527b17e99826ba7e58ec962"},"23701":{"$oid":"6527b24999826ba7e5913c76"},"22967":{"$oid":"6527b18d99826ba7e58ee0cc"},"22645":{"$oid":"6527b24b99826ba7e5914399"},"23621":{"$oid":"6527b2bd99826ba7e592d8bf"},"22952":{"$oid":"6527b19399826ba7e58eee85"},"23174":{"$oid":"6527b18399826ba7e58ed125"},"22610":{"$oid":"6527b18b99826ba7e58edf1c"},"23176":{"$oid":"6527b18b99826ba7e58ede32"},"23723":{"$oid":"6527b2b899826ba7e592c63e"},"23824":{"$oid":"6527b29399826ba7e5923903"},"23718":{"$oid":"6527b17399826ba7e58eb3e9"},"23103":{"$oid":"6527b28f99826ba7e5922ee0"},"23197":{"$oid":"6527b19199826ba7e58eeb5c"},"23469":{"$oid":"6527b17a99826ba7e58ec2df"},"23728":{"$oid":"6527b28599826ba7e5921060"},"23574":{"$oid":"6527b17399826ba7e58eb255"},"22958":{"$oid":"6527b18d99826ba7e58ee223"},"22806":{"$oid":"6527b18199826ba7e58eccec"},"22558":{"$oid":"6527b18f99826ba7e58ee514"},"22585":{"$oid":"6527b17a99826ba7e58ec133"},"22896":{"$oid":"6527b1b199826ba7e58f49e2"},"23742":{"$oid":"6527b19799826ba7e58ef4b2"},"23033":{"$oid":"6527b1a299826ba7e58f1a60"},"22874":{"$oid":"6527b18f99826ba7e58ee4e8"},"23233":{"$oid":"6527b26e99826ba7e591bed5"},"23702":{"$oid":"6527b26499826ba7e5919ba4"},"22840":{"$oid":"6527b17399826ba7e58eb2e2"},"23247":{"$oid":"6527b2f899826ba7e593b442"},"23342":{"$oid":"6527b2bf99826ba7e592e109"},"22743":{"$oid":"6527b17999826ba7e58ebf43"},"23427":{"$oid":"6527b1f499826ba7e5902db0"},"22897":{"$oid":"6527b2ac99826ba7e5929615"},"23070":{"$oid":"6527b18699826ba7e58ed4c3"},"22524":{"$oid":"6527b18d99826ba7e58ee0c1"},"23346":{"$oid":"6527b23899826ba7e591012f"},"23383":{"$oid":"6527b20199826ba7e5905737"},"23285":{"$oid":"6527b17399826ba7e58eb414"},"23534":{"$oid":"6527b18899826ba7e58ed900"},"22828":{"$oid":"6527b2dc99826ba7e5934c57"},"23640":{"$oid":"6527b17999826ba7e58ebf1c"},"22876":{"$oid":"6527b1bc99826ba7e58f6f3e"},"23085":{"$oid":"6527b18699826ba7e58ed481"},"23058":{"$oid":"6527b17399826ba7e58eb3d4"},"23385":{"$oid":"6527b19399826ba7e58eef65"},"22686":{"$oid":"6527b2b299826ba7e592af12"},"23115":{"$oid":"6527b19399826ba7e58eec8c"},"22724":{"$oid":"6527b19199826ba7e58eeadb"},"22872":{"$oid":"6527b1ef99826ba7e5901f4d"},"22925":{"$oid":"6527b18f99826ba7e58ee6e8"},"23099":{"$oid":"6527b17599826ba7e58eb543"},"22609":{"$oid":"6527b19199826ba7e58ee8c2"},"23050":{"$oid":"6527b1f599826ba7e590303d"},"23504":{"$oid":"6527b18899826ba7e58ed8fa"},"22811":{"$oid":"6527b1e499826ba7e58ffb32"},"23409":{"$oid":"6527b24899826ba7e591392b"},"23253":{"$oid":"6527b26699826ba7e591a202"},"23502":{"$oid":"6527b24c99826ba7e591475a"},"22916":{"$oid":"6527b28399826ba7e592089b"},"22948":{"$oid":"6527b28999826ba7e592195b"},"23010":{"$oid":"6527b18d99826ba7e58ee1cf"},"23482":{"$oid":"6527b2f599826ba7e593a749"},"22547":{"$oid":"6527b17599826ba7e58eb6d1"},"23717":{"$oid":"6527b23499826ba7e590f378"},"23135":{"$oid":"6527b19599826ba7e58ef17d"},"22912":{"$oid":"6527b18699826ba7e58ed5ff"},"23561":{"$oid":"6527b17399826ba7e58eb4be"},"23540":{"$oid":"6527b17a99826ba7e58ec123"},"23365":{"$oid":"6527b17c99826ba7e58ec55a"},"23181":{"$oid":"6527b28999826ba7e5921be2"},"23739":{"$oid":"6527b22199826ba7e590b939"},"23664":{"$oid":"6527b18d99826ba7e58ee33b"},"23667":{"$oid":"6527b2d299826ba7e593281c"},"22926":{"$oid":"6527b18f99826ba7e58ee6b0"},"23721":{"$oid":"6527b2df99826ba7e5935c93"},"23025":{"$oid":"6527b18899826ba7e58edb40"},"22854":{"$oid":"6527b1cd99826ba7e58fad47"},"22822":{"$oid":"6527b28799826ba7e5921273"},"23596":{"$oid":"6527b1d899826ba7e58fcf6b"},"22852":{"$oid":"6527b28899826ba7e59216ef"},"23587":{"$oid":"6527b27f99826ba7e591f5e2"},"23756":{"$oid":"6527b17599826ba7e58eb787"},"22695":{"$oid":"6527b19199826ba7e58eeb44"},"22601":{"$oid":"6527b19199826ba7e58eea47"},"23576":{"$oid":"6527b19999826ba7e58ef9b0"},"22747":{"$oid":"6527b17c99826ba7e58ec7f3"},"23607":{"$oid":"6527b23399826ba7e590efdd"},"23386":{"$oid":"6527b18399826ba7e58ed459"},"22596":{"$oid":"6527b18399826ba7e58ed3d5"},"23397":{"$oid":"6527b19d99826ba7e58f0159"},"22862":{"$oid":"6527b1e799826ba7e5900617"},"23075":{"$oid":"6527b27799826ba7e591dbce"},"23295":{"$oid":"6527b18699826ba7e58ed5df"},"23665":{"$oid":"6527b21399826ba7e5908e8f"},"22667":{"$oid":"6527b18899826ba7e58eda37"},"23633":{"$oid":"6527b19399826ba7e58eef78"},"23639":{"$oid":"6527b1f499826ba7e5903023"},"22796":{"$oid":"6527b19999826ba7e58ef9ca"},"23467":{"$oid":"6527b18d99826ba7e58ee2e3"},"23334":{"$oid":"6527b17c99826ba7e58ec8b3"},"22762":{"$oid":"6527b18d99826ba7e58ee16b"},"22932":{"$oid":"6527b2f799826ba7e593b0a9"},"23727":{"$oid":"6527b17a99826ba7e58ec271"},"22701":{"$oid":"6527b1bc99826ba7e58f6de9"},"23547":{"$oid":"6527b2e399826ba7e5936b06"},"23456":{"$oid":"6527b18199826ba7e58ecf6a"},"23579":{"$oid":"6527b25999826ba7e59170dd"},"23524":{"$oid":"6527b22b99826ba7e590d902"},"22996":{"$oid":"6527b18199826ba7e58ed02e"},"22946":{"$oid":"6527b18f99826ba7e58ee61b"},"22920":{"$oid":"6527b1d399826ba7e58fbf45"},"22931":{"$oid":"6527b19999826ba7e58ef8ba"},"23436":{"$oid":"6527b19399826ba7e58eeded"},"23769":{"$oid":"6527b19999826ba7e58ef9dd"},"23753":{"$oid":"6527b18199826ba7e58ecf64"},"23101":{"$oid":"6527b18699826ba7e58ed5ae"},"23399":{"$oid":"6527b19599826ba7e58ef191"},"23688":{"$oid":"6527b17c99826ba7e58ec722"},"22590":{"$oid":"6527b17599826ba7e58eb61b"},"22621":{"$oid":"6527b17799826ba7e58ebc1a"},"22521":{"$oid":"6527b19199826ba7e58eeb94"},"23027":{"$oid":"6527b1c999826ba7e58f9c8d"},"23043":{"$oid":"6527b1be99826ba7e58f7675"},"22883":{"$oid":"6527b17599826ba7e58eb73a"},"23148":{"$oid":"6527b22399826ba7e590c1f2"},"23241":{"$oid":"6527b21499826ba7e590935b"},"22760":{"$oid":"6527b1c699826ba7e58f955b"},"23329":{"$oid":"6527b19399826ba7e58eee87"},"23412":{"$oid":"6527b19799826ba7e58ef629"},"23074":{"$oid":"6527b2f899826ba7e593b332"},"22652":{"$oid":"6527b18f99826ba7e58ee732"},"23498":{"$oid":"6527b18b99826ba7e58edcf6"},"23060":{"$oid":"6527b18f99826ba7e58ee691"},"22582":{"$oid":"6527b17799826ba7e58eba3c"},"23133":{"$oid":"6527b17e99826ba7e58ecae1"},"23325":{"$oid":"6527b19799826ba7e58ef653"},"23105":{"$oid":"6527b2e499826ba7e5936d05"},"23650":{"$oid":"6527b18699826ba7e58ed607"},"23143":{"$oid":"6527b29099826ba7e592309f"},"23448":{"$oid":"6527b19199826ba7e58ee8bf"},"23349":{"$oid":"6527b29f99826ba7e592637b"},"23583":{"$oid":"6527b2f899826ba7e593b7f2"},"23173":{"$oid":"6527b20e99826ba7e5907ff2"},"23390":{"$oid":"6527b1d599826ba7e58fc8d9"},"23748":{"$oid":"6527b2f399826ba7e593a21a"},"23512":{"$oid":"6527b17399826ba7e58eb49f"},"22714":{"$oid":"6527b17a99826ba7e58ec32d"},"23648":{"$oid":"6527b17a99826ba7e58ec3b6"},"23142":{"$oid":"6527b1dd99826ba7e58fdf3b"},"22605":{"$oid":"6527b18699826ba7e58ed804"},"23053":{"$oid":"6527b2b099826ba7e592a64d"},"22602":{"$oid":"6527b17a99826ba7e58ec16d"},"23192":{"$oid":"6527b17c99826ba7e58ec54e"},"23187":{"$oid":"6527b19999826ba7e58ef973"},"22741":{"$oid":"6527b18b99826ba7e58edc71"},"23037":{"$oid":"6527b23b99826ba7e5910a79"},"22969":{"$oid":"6527b17599826ba7e58eb5a7"},"22784":{"$oid":"6527b18399826ba7e58ed0f8"},"22670":{"$oid":"6527b20799826ba7e5906d3f"},"23807":{"$oid":"6527b28e99826ba7e5922a93"},"23643":{"$oid":"6527b23a99826ba7e5910668"},"23617":{"$oid":"6527b22d99826ba7e590e0df"},"23041":{"$oid":"6527b18b99826ba7e58edc8d"},"23437":{"$oid":"6527b1de99826ba7e58fe2b5"},"22498":{"$oid":"6527b19999826ba7e58efa55"},"22735":{"$oid":"6527b19d99826ba7e58f013f"},"22816":{"$oid":"6527b1a799826ba7e58f2cf0"},"23124":{"$oid":"6527b18d99826ba7e58ee2c2"},"22901":{"$oid":"6527b1b199826ba7e58f4c53"},"23568":{"$oid":"6527b29399826ba7e5923d70"},"23663":{"$oid":"6527b21199826ba7e5908bbe"},"23585":{"$oid":"6527b17a99826ba7e58ec15c"},"22627":{"$oid":"6527b18f99826ba7e58ee6f9"},"22487":{"$oid":"6527b19999826ba7e58ef8cc"},"22953":{"$oid":"6527b2dc99826ba7e5934a17"},"22669":{"$oid":"6527b1fa99826ba7e59046f1"},"23235":{"$oid":"6527b17a99826ba7e58ec3a6"},"22906":{"$oid":"6527b28c99826ba7e592232e"},"22586":{"$oid":"6527b19799826ba7e58ef60a"},"23284":{"$oid":"6527b25399826ba7e591604a"},"23560":{"$oid":"6527b2f899826ba7e593b889"},"23792":{"$oid":"6527b26a99826ba7e591b69e"},"23028":{"$oid":"6527b1f899826ba7e5903c79"},"23398":{"$oid":"6527b17599826ba7e58eb68f"},"23088":{"$oid":"6527b27f99826ba7e591fbb8"},"23686":{"$oid":"6527b17a99826ba7e58ec175"},"22768":{"$oid":"6527b1b399826ba7e58f4dd5"},"22522":{"$oid":"6527b18f99826ba7e58ee483"},"22723":{"$oid":"6527b24699826ba7e5912eb0"},"23237":{"$oid":"6527b29899826ba7e5924bae"},"23016":{"$oid":"6527b2eb99826ba7e5938150"},"22745":{"$oid":"6527b2de99826ba7e5935406"},"23715":{"$oid":"6527b28599826ba7e5921047"},"23734":{"$oid":"6527b17599826ba7e58eb921"},"22658":{"$oid":"6527b2ee99826ba7e5938f44"},"22640":{"$oid":"6527b1e099826ba7e58fec52"},"22571":{"$oid":"6527b19399826ba7e58eed31"},"23183":{"$oid":"6527b18d99826ba7e58ee399"},"22891":{"$oid":"6527b2e399826ba7e59368cd"},"23251":{"$oid":"6527b1fa99826ba7e5904436"},"23432":{"$oid":"6527b26499826ba7e5919e98"},"23735":{"$oid":"6527b18399826ba7e58ed27c"},"23258":{"$oid":"6527b29e99826ba7e5925f9f"},"23521":{"$oid":"6527b17a99826ba7e58ec240"},"23046":{"$oid":"6527b17599826ba7e58eb6a2"},"23481":{"$oid":"6527b2a799826ba7e5928463"},"23733":{"$oid":"6527b1d899826ba7e58fcf9a"},"23332":{"$oid":"6527b18f99826ba7e58ee793"},"23038":{"$oid":"6527b19199826ba7e58ee971"},"23280":{"$oid":"6527b2b499826ba7e592b6b3"},"23213":{"$oid":"6527b17999826ba7e58ebe9a"},"23457":{"$oid":"6527b18899826ba7e58ed8a0"},"22943":{"$oid":"6527b2ee99826ba7e5938ec8"},"22942":{"$oid":"6527b19599826ba7e58ef0ac"}},"func":{"22849":"static header_cache_t *pop_hcache_open(struct PopData *pop_data, const char *path)\n{\n  struct Url url;\n  char p[LONG_STRING];\n\n  if (!pop_data || !pop_data->conn)\n    return mutt_hcache_open(HeaderCache, path, NULL);\n\n  mutt_account_tourl(&pop_data->conn->account, &url);\n  url.path = HC_FNAME;\n  url_tostring(&url, p, sizeof(p), U_PATH);\n  return mutt_hcache_open(HeaderCache, p, pop_hcache_namer);\n}","22732":"R_API RBinJavaBootStrapMethod *r_bin_java_bootstrap_method_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tRBinJavaBootStrapArgument *bsm_arg = NULL;\n\tut32 i = 0;\n\tut64 offset = 0;\n\tRBinJavaBootStrapMethod *bsm = R_NEW0 (RBinJavaBootStrapMethod);\n\tif (!bsm) {\n\t\t\n\t\treturn bsm;\n\t}\n\tmemset (bsm, 0, sizeof (RBinJavaBootStrapMethod));\n\tbsm->file_offset = buf_offset;\n\tbsm->bootstrap_method_ref = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tbsm->num_bootstrap_arguments = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tbsm->bootstrap_arguments = r_list_new ();\n\tfor (i = 0; i < bsm->num_bootstrap_arguments; i++) {\n\t\tif (offset >= sz) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tbsm_arg = r_bin_java_bootstrap_method_argument_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (bsm_arg) {\n\t\t\toffset += bsm_arg->size;\n\t\t\tr_list_append (bsm->bootstrap_arguments, (void *) bsm_arg);\n\t\t} else {\n\t\t\t\n\t\t}\n\t}\n\tbsm->size = offset;\n\treturn bsm;\n}","23384":"ip_ruby_cmd_core(arg)\n    struct cmd_body_arg *arg;\n{\n    volatile VALUE ret;\n    int thr_crit_bup;\n\n    DUMP1(\"STR\");\n    thr_crit_bup = rb_thread_critical;\n    rb_thread_critical = Qfalse;\n    ret = rb_apply(arg->receiver, arg->method, arg->args);\n    DUMP2(\"STR\"PRIxVALUE, ret);\n    rb_thread_critical = thr_crit_bup;\n    DUMP1(\"STR\");\n\n    return ret;\n}","23072":"static int php_stream_temp_cast(php_stream *stream, int castas, void **ret TSRMLS_DC)\n{\n\tphp_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n\tphp_stream *file;\n\tsize_t memsize;\n\tchar *membuf;\n\toff_t pos;\n\n\tassert(ts != NULL);\n\n\tif (!ts->innerstream) {\n\t\treturn FAILURE;\n\t}\n\tif (php_stream_is(ts->innerstream, PHP_STREAM_IS_STDIO)) {\n\t\treturn php_stream_cast(ts->innerstream, castas, ret, 0);\n\t}\n\n\t\n\n\tif (ret == NULL && castas == PHP_STREAM_AS_STDIO) {\n\t\treturn SUCCESS;\n\t}\n\n\t\n\tif (ret == NULL) {\n\t\treturn FAILURE;\n\t}\n\n\t\n\tmembuf = php_stream_memory_get_buffer(ts->innerstream, &memsize);\n\tfile = php_stream_fopen_tmpfile();\n\tphp_stream_write(file, membuf, memsize);\n\tpos = php_stream_tell(ts->innerstream);\n\t\n\tphp_stream_free_enclosed(ts->innerstream, PHP_STREAM_FREE_CLOSE);\n\tts->innerstream = file;\n\tphp_stream_encloses(stream, ts->innerstream);\n\tphp_stream_seek(ts->innerstream, pos, SEEK_SET);\n\n\treturn php_stream_cast(ts->innerstream, castas, ret, 1);\n}","23710":"static void ConvertLoopSequence(ModSample &smp, STPLoopList &loopList)\n{\n\t\n\t\n\tif(!smp.HasSampleData() || loopList.size() < 2) return;\n\n\tModSample newSmp = smp;\n\tnewSmp.nLength = 0;\n\tnewSmp.pSample = nullptr;\n\n\tsize_t numLoops = loopList.size();\n\n\t\n\tfor(size_t i = 0; i < numLoops; i++)\n\t{\n\t\tSTPLoopInfo &info = loopList[i];\n\n\t\t\n\t\t\n\t\tif((newSmp.nLength + info.loopLength > MAX_SAMPLE_LENGTH) ||\n\t\t   (info.loopLength > MAX_SAMPLE_LENGTH) ||\n\t\t   (info.loopStart + info.loopLength > smp.nLength))\n\t\t{\n\t\t\tnumLoops = i;\n\t\t\tbreak;\n\t\t}\n\n\t\tnewSmp.nLength += info.loopLength;\n\t}\n\n\tif(!newSmp.AllocateSample())\n\t{\n\t\treturn;\n\t}\n\n\t\n\tSmpLength start = 0;\n\n\tfor(size_t i = 0; i < numLoops; i++)\n\t{\n\t\tSTPLoopInfo &info = loopList[i];\n\n\t\tmemcpy(newSmp.pSample8 + start, smp.pSample8 + info.loopStart, info.loopLength);\n\n\t\t\n\t\tinfo.loopStart = start;\n\t\tif(i > 0 && i <= mpt::size(newSmp.cues))\n\t\t{\n\t\t\tnewSmp.cues[i - 1] = start;\n\t\t}\n\t\tstart += info.loopLength;\n\t}\n\n\t\n\tsmp.FreeSample();\n\tsmp = newSmp;\n\n\tsmp.nLoopStart = 0;\n\tsmp.nLoopEnd = smp.nLength;\n\tsmp.uFlags.set(CHN_LOOP);\n}","23202":"int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tu16 offset = sizeof(struct ipv6hdr);\n\tstruct ipv6_opt_hdr *exthdr =\n\t\t\t\t(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\n\twhile (offset + 1 <= packet_len) {\n\n\t\tswitch (**nexthdr) {\n\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\n\t\toffset += ipv6_optlen(exthdr);\n\t\t*nexthdr = &exthdr->nexthdr;\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t}\n\n\treturn offset;\n}","22526":"static void SerializeGltfSampler(Sampler &sampler, json &o) {\n  if (sampler.magFilter != -1) {\n    SerializeNumberProperty(\"STR\", sampler.magFilter, o);\n  }\n  if (sampler.minFilter != -1) {\n    SerializeNumberProperty(\"STR\", sampler.minFilter, o);\n  }\n  \n  SerializeNumberProperty(\"STR\", sampler.wrapS, o);\n  SerializeNumberProperty(\"STR\", sampler.wrapT, o);\n\n  if (sampler.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"STR\", sampler.extras, o);\n  }\n}","22867":"int do_sigtimedwait(const sigset_t *which, siginfo_t *info,\n\t\t\tconst struct timespec *ts)\n{\n\tstruct task_struct *tsk = current;\n\tlong timeout = MAX_SCHEDULE_TIMEOUT;\n\tsigset_t mask = *which;\n\tint sig;\n\n\tif (ts) {\n\t\tif (!timespec_valid(ts))\n\t\t\treturn -EINVAL;\n\t\ttimeout = timespec_to_jiffies(ts);\n\t\t\n\t\tif (ts->tv_sec || ts->tv_nsec)\n\t\t\ttimeout++;\n\t}\n\n\t\n\tsigdelsetmask(&mask, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\tsignotset(&mask);\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\tsig = dequeue_signal(tsk, &mask, info);\n\tif (!sig && timeout) {\n\t\t\n\t\ttsk->real_blocked = tsk->blocked;\n\t\tsigandsets(&tsk->blocked, &tsk->blocked, &mask);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\t__set_task_blocked(tsk, &tsk->real_blocked);\n\t\tsiginitset(&tsk->real_blocked, 0);\n\t\tsig = dequeue_signal(tsk, &mask, info);\n\t}\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (sig)\n\t\treturn sig;\n\treturn timeout ? -EINTR : -EAGAIN;\n}","23426":"PHP_FUNCTION(bcpow)\n{\n\tchar *left, *right;\n\tint left_len, right_len;\n\tlong scale_param = 0;\n\tbc_num first, second, result;\n\tint scale = BCG(bc_precision), argc = ZEND_NUM_ARGS();\n\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"STR\", &left, &left_len, &right, &right_len, &scale_param) == FAILURE) {\n\t\treturn;\n\t}\n\t\n\tif (argc == 3) {\n\t\tscale = (int) ((int)scale_param < 0) ? 0 : scale_param;\n\t}\n\n\tbc_init_num(&first TSRMLS_CC);\n\tbc_init_num(&second TSRMLS_CC);\n\tbc_init_num(&result TSRMLS_CC);\n\tphp_str2num(&first, left TSRMLS_CC);\n\tphp_str2num(&second, right TSRMLS_CC);\n\tbc_raise (first, second, &result, scale TSRMLS_CC);\n\n\tif (result->n_scale > scale) {\n\t\tresult->n_scale = scale;\n\t}\n\n\tZ_STRVAL_P(return_value) = bc_num2str(result);\n\tZ_STRLEN_P(return_value) = strlen(Z_STRVAL_P(return_value));\n\tZ_TYPE_P(return_value) = IS_STRING;\n\tbc_free_num(&first);\n\tbc_free_num(&second);\n\tbc_free_num(&result);\n\treturn;\n}","23323":"  FilterConfigSharedPtr getConfig() {\n    envoy::extensions::filters::http::oauth2::v3::OAuth2Config p;\n    auto* endpoint = p.mutable_token_endpoint();\n    endpoint->set_cluster(\"STR\");\n    endpoint->set_uri(\"STR\");\n    endpoint->mutable_timeout()->set_seconds(1);\n    p.set_redirect_uri(\"STR\" + TEST_CALLBACK);\n    p.mutable_redirect_path_matcher()->mutable_path()->set_exact(TEST_CALLBACK);\n    p.set_authorization_endpoint(\"STR\");\n    p.mutable_signout_path()->mutable_path()->set_exact(\"STR\");\n    p.set_forward_bearer_token(true);\n    p.add_auth_scopes(\"STR\");\n    p.add_auth_scopes(\"STR\");\n    p.add_auth_scopes(\"STR\");\n    p.add_resources(\"STR\");\n    p.add_resources(\"STR\");\n    p.add_resources(\"STR\");\n    auto* matcher = p.add_pass_through_matcher();\n    matcher->set_name(\"STR\");\n    matcher->mutable_string_match()->set_exact(\"STR\");\n    auto credentials = p.mutable_credentials();\n    credentials->set_client_id(TEST_CLIENT_ID);\n    credentials->mutable_token_secret()->set_name(\"STR\");\n    credentials->mutable_hmac_secret()->set_name(\"STR\");\n    \n    \n\n    MessageUtil::validate(p, ProtobufMessage::getStrictValidationVisitor());\n\n    \n    auto secret_reader = std::make_shared<MockSecretReader>();\n    FilterConfigSharedPtr c = std::make_shared<FilterConfig>(p, factory_context_.cluster_manager_,\n                                                             secret_reader, scope_, \"STR\");\n\n    return c;\n  }","23705":"static inline int xsave_state_booting(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\n\tWARN_ON(system_state != SYSTEM_BOOTING);\n\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\tasm volatile(\"STR\"\n\t\t\t\"STR\"\n\t\t\t: : \"STR\" (hmask)\n\t\t\t:   \"STR\");\n\telse\n\t\tasm volatile(\"STR\"\n\t\t\t\"STR\"\n\t\t\t: : \"STR\" (hmask)\n\t\t\t:   \"STR\");\n\n\tasm volatile(xstate_fault\n\t\t     : \"STR\" (0)\n\t\t     : \"STR\");\n\n\treturn err;\n}","23442":"pk_transaction_percentage_cb (PkBackendJob *job,\n\t\t\t      guint percentage,\n\t\t\t      PkTransaction *transaction)\n{\n\t\n\ttransaction->priv->percentage = percentage;\n\tpk_transaction_emit_property_changed (transaction,\n\t\t\t\t\t      \"STR\",\n\t\t\t\t\t      g_variant_new_uint32 (percentage));\n}","23623":"xfs_dinode_calc_crc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dinode\t*dip)\n{\n\tuint32_t\t\tcrc;\n\n\tif (dip->di_version < 3)\n\t\treturn;\n\n\tASSERT(xfs_sb_version_hascrc(&mp->m_sb));\n\tcrc = xfs_start_cksum_update((char *)dip, mp->m_sb.sb_inodesize,\n\t\t\t      XFS_DINODE_CRC_OFF);\n\tdip->di_crc = xfs_end_cksum(crc);\n}","23695":"static int ib_prctl_set(struct task_struct *task, unsigned long ctrl)\n{\n\tswitch (ctrl) {\n\tcase PR_SPEC_ENABLE:\n\t\tif (spectre_v2_user == SPECTRE_V2_USER_NONE)\n\t\t\treturn 0;\n\t\t\n\t\tif (spectre_v2_user == SPECTRE_V2_USER_STRICT ||\n\t\t    spectre_v2_user == SPECTRE_V2_USER_STRICT_PREFERRED)\n\t\t\treturn -EPERM;\n\t\ttask_clear_spec_ib_disable(task);\n\t\ttask_update_spec_tif(task);\n\t\tbreak;\n\tcase PR_SPEC_DISABLE:\n\tcase PR_SPEC_FORCE_DISABLE:\n\t\t\n\t\tif (spectre_v2_user == SPECTRE_V2_USER_NONE)\n\t\t\treturn -EPERM;\n\t\tif (spectre_v2_user == SPECTRE_V2_USER_STRICT ||\n\t\t    spectre_v2_user == SPECTRE_V2_USER_STRICT_PREFERRED)\n\t\t\treturn 0;\n\t\ttask_set_spec_ib_disable(task);\n\t\tif (ctrl == PR_SPEC_FORCE_DISABLE)\n\t\t\ttask_set_spec_ib_force_disable(task);\n\t\ttask_update_spec_tif(task);\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\treturn 0;\n}","23228":"SPL_METHOD(Array, getChildren)\n{\n\tzval *object = getThis(), **entry, *flags;\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tHashTable *aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (spl_array_object_verify_pos(intern, aht TSRMLS_CC) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (zend_hash_get_current_data_ex(aht, (void **) &entry, &intern->pos) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (Z_TYPE_PP(entry) == IS_OBJECT) {\n\t\tif ((intern->ar_flags & SPL_ARRAY_CHILD_ARRAYS_ONLY) != 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (instanceof_function(Z_OBJCE_PP(entry), Z_OBJCE_P(getThis()) TSRMLS_CC)) {\n\t\t\tRETURN_ZVAL(*entry, 1, 0);\n\t\t}\n\t}\n\n\tMAKE_STD_ZVAL(flags);\n\tZVAL_LONG(flags, SPL_ARRAY_USE_OTHER | intern->ar_flags);\n\tspl_instantiate_arg_ex2(Z_OBJCE_P(getThis()), &return_value, 0, *entry, flags TSRMLS_CC);\n\tzval_ptr_dtor(&flags);\n}","23662":"f_argv(typval_T *argvars, typval_T *rettv)\n{\n    int\t\tidx;\n    aentry_T\t*arglist = NULL;\n    int\t\targcount = -1;\n\n    if (in_vim9script()\n\t    && (check_for_opt_number_arg(argvars, 0) == FAIL\n\t\t|| (argvars[0].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_number_arg(argvars, 1) == FAIL)))\n\treturn;\n\n    if (argvars[0].v_type != VAR_UNKNOWN)\n    {\n\tif (argvars[1].v_type == VAR_UNKNOWN)\n\t{\n\t    arglist = ARGLIST;\n\t    argcount = ARGCOUNT;\n\t}\n\telse if (argvars[1].v_type == VAR_NUMBER\n\t\t\t\t\t   && tv_get_number(&argvars[1]) == -1)\n\t{\n\t    arglist = GARGLIST;\n\t    argcount = GARGCOUNT;\n\t}\n\telse\n\t{\n\t    win_T\t*wp = find_win_by_nr_or_id(&argvars[1]);\n\n\t    if (wp != NULL)\n\t    {\n\t\t\n\t\targlist = WARGLIST(wp);\n\t\targcount = WARGCOUNT(wp);\n\t    }\n\t}\n\n\trettv->v_type = VAR_STRING;\n\trettv->vval.v_string = NULL;\n\tidx = tv_get_number_chk(&argvars[0], NULL);\n\tif (arglist != NULL && idx >= 0 && idx < argcount)\n\t    rettv->vval.v_string = vim_strsave(alist_name(&arglist[idx]));\n\telse if (idx == -1)\n\t    get_arglist_as_rettv(arglist, argcount, rettv);\n    }\n    else\n\tget_arglist_as_rettv(ARGLIST, ARGCOUNT, rettv);\n}","23226":"const char *load_elf_strerror(int error)\n{\n    switch (error) {\n    case 0:\n        return \"STR\";\n    case ELF_LOAD_FAILED:\n        return \"STR\";\n    case ELF_LOAD_NOT_ELF:\n        return \"STR\";\n    case ELF_LOAD_WRONG_ARCH:\n        return \"STR\";\n    case ELF_LOAD_WRONG_ENDIAN:\n        return \"STR\";\n    case ELF_LOAD_TOO_BIG:\n        return \"STR\";\n    default:\n        return \"STR\";\n    }\n}","22810":"static int install_thread_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tBUG_ON(new->thread_keyring);\n\n\tret = install_thread_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}","23555":"static int dev_ifsioc_locked(struct net *net, struct ifreq *ifr, unsigned int cmd)\n{\n\tint err;\n\tstruct net_device *dev = dev_get_by_name_rcu(net, ifr->ifr_name);\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tswitch (cmd) {\n\tcase SIOCGIFFLAGS:\t\n\t\tifr->ifr_flags = (short) dev_get_flags(dev);\n\t\treturn 0;\n\n\tcase SIOCGIFMETRIC:\t\n\t\tifr->ifr_metric = 0;\n\t\treturn 0;\n\n\tcase SIOCGIFMTU:\t\n\t\tifr->ifr_mtu = dev->mtu;\n\t\treturn 0;\n\n\tcase SIOCGIFHWADDR:\n\t\tif (!dev->addr_len)\n\t\t\tmemset(ifr->ifr_hwaddr.sa_data, 0, sizeof ifr->ifr_hwaddr.sa_data);\n\t\telse\n\t\t\tmemcpy(ifr->ifr_hwaddr.sa_data, dev->dev_addr,\n\t\t\t       min(sizeof ifr->ifr_hwaddr.sa_data, (size_t) dev->addr_len));\n\t\tifr->ifr_hwaddr.sa_family = dev->type;\n\t\treturn 0;\n\n\tcase SIOCGIFSLAVE:\n\t\terr = -EINVAL;\n\t\tbreak;\n\n\tcase SIOCGIFMAP:\n\t\tifr->ifr_map.mem_start = dev->mem_start;\n\t\tifr->ifr_map.mem_end   = dev->mem_end;\n\t\tifr->ifr_map.base_addr = dev->base_addr;\n\t\tifr->ifr_map.irq       = dev->irq;\n\t\tifr->ifr_map.dma       = dev->dma;\n\t\tifr->ifr_map.port      = dev->if_port;\n\t\treturn 0;\n\n\tcase SIOCGIFINDEX:\n\t\tifr->ifr_ifindex = dev->ifindex;\n\t\treturn 0;\n\n\tcase SIOCGIFTXQLEN:\n\t\tifr->ifr_qlen = dev->tx_queue_len;\n\t\treturn 0;\n\n\tdefault:\n\t\t\n\t\tWARN_ON(1);\n\t\terr = -EINVAL;\n\t\tbreak;\n\n\t}\n\treturn err;\n}","22801":"void TDStretch::acceptNewOverlapLength(int newOverlapLength)\r\n{\r\n    int prevOvl;\r\n\r\n    assert(newOverlapLength >= 0);\r\n    prevOvl = overlapLength;\r\n    overlapLength = newOverlapLength;\r\n\r\n    if (overlapLength > prevOvl)\r\n    {\r\n        delete[] pMidBufferUnaligned;\r\n\r\n        pMidBufferUnaligned = new SAMPLETYPE[overlapLength * channels + 16 \/ sizeof(SAMPLETYPE)];\r\n        \n        pMidBuffer = (SAMPLETYPE *)SOUNDTOUCH_ALIGN_POINTER_16(pMidBufferUnaligned);\r\n\r\n        clearMidBuffer();\r\n    }\r\n}\r","23526":"static int packet_rcv_fanout(struct sk_buff *skb, struct net_device *dev,\n\t\t\t     struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct packet_fanout *f = pt->af_packet_priv;\n\tunsigned int num = READ_ONCE(f->num_members);\n\tstruct net *net = read_pnet(&f->net);\n\tstruct packet_sock *po;\n\tunsigned int idx;\n\n\tif (!net_eq(dev_net(dev), net) || !num) {\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\tif (fanout_has_flag(f, PACKET_FANOUT_FLAG_DEFRAG)) {\n\t\tskb = ip_check_defrag(net, skb, IP_DEFRAG_AF_PACKET);\n\t\tif (!skb)\n\t\t\treturn 0;\n\t}\n\tswitch (f->type) {\n\tcase PACKET_FANOUT_HASH:\n\tdefault:\n\t\tidx = fanout_demux_hash(f, skb, num);\n\t\tbreak;\n\tcase PACKET_FANOUT_LB:\n\t\tidx = fanout_demux_lb(f, skb, num);\n\t\tbreak;\n\tcase PACKET_FANOUT_CPU:\n\t\tidx = fanout_demux_cpu(f, skb, num);\n\t\tbreak;\n\tcase PACKET_FANOUT_RND:\n\t\tidx = fanout_demux_rnd(f, skb, num);\n\t\tbreak;\n\tcase PACKET_FANOUT_QM:\n\t\tidx = fanout_demux_qm(f, skb, num);\n\t\tbreak;\n\tcase PACKET_FANOUT_ROLLOVER:\n\t\tidx = fanout_demux_rollover(f, skb, 0, false, num);\n\t\tbreak;\n\tcase PACKET_FANOUT_CBPF:\n\tcase PACKET_FANOUT_EBPF:\n\t\tidx = fanout_demux_bpf(f, skb, num);\n\t\tbreak;\n\t}\n\n\tif (fanout_has_flag(f, PACKET_FANOUT_FLAG_ROLLOVER))\n\t\tidx = fanout_demux_rollover(f, skb, idx, true, num);\n\n\tpo = pkt_sk(f->arr[idx]);\n\treturn po->prot_hook.func(skb, dev, &po->prot_hook, orig_dev);\n}","22929":"static void event_channel_mode(IRC_SERVER_REC *server, const char *data,\n\t\t\t       const char *nick)\n{\n\tIRC_CHANNEL_REC *chanrec;\n\tchar *params, *channel, *mode;\n\n\tg_return_if_fail(data != NULL);\n\n\tparams = event_get_params(data, 3 | PARAM_FLAG_GETREST,\n\t\t\t\t  NULL, &channel, &mode);\n\tchanrec = irc_channel_find(server, channel);\n\tif (chanrec != NULL) {\n\t\tif (chanrec->key != NULL && strchr(mode, 'k') == NULL) {\n\t\t\t\n                        parse_channel_modes(chanrec, NULL, \"STR\", TRUE);\n\t\t}\n\t\tparse_channel_modes(chanrec, nick, mode, FALSE);\n\t\tchannel_got_query(chanrec, CHANNEL_QUERY_MODE);\n\t}\n\n\tg_free(params);\n}","23716":"bash_backward_shellword (count, key)\n     int count, key;\n{\n  size_t slen;\n  int sindex, c, p;\n  DECLARE_MBSTATE;\n  \n  if (count < 0)\n    return (bash_forward_shellword (-count, key));\n\n  p = rl_point;\n  slen = rl_end;\n  \n  while (count)\n    {\n      if (p == 0)\n\t{\n\t  rl_point = 0;\n\t  return 0;\n\t}\n\n      \n      while (p > 0)\n\t{\n\t  c = rl_line_buffer[p];\n\t  if (WORDDELIM (c) && char_is_quoted (rl_line_buffer, p) == 0)\n\t    BACKUP_CHAR (rl_line_buffer, slen, p);\n\t  break;\n\t}\n\n      if (p == 0)\n\t{\n\t  rl_point = 0;\n\t  return 0;\n\t}\n\n      \n      while (p > 0)\n\t{\n\t  c = rl_line_buffer[p];\n\t  if (WORDDELIM (c) && char_is_quoted (rl_line_buffer, p) == 0)\n\t    break;\n\t  BACKUP_CHAR (rl_line_buffer, slen, p);\n\t}\n\n      count--;\n    }\n\n  rl_point = p;\n  return 0;\n}","22888":"      static bool is_inf(const cimg_int64) { return false; }","23125":"struct page *f2fs_get_read_data_page(struct inode *inode, pgoff_t index,\n\t\t\t\t\t\tint op_flags, bool for_write)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct dnode_of_data dn;\n\tstruct page *page;\n\tstruct extent_info ei = {0,0,0};\n\tint err;\n\n\tpage = f2fs_grab_cache_page(mapping, index, for_write);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (f2fs_lookup_extent_cache(inode, index, &ei)) {\n\t\tdn.data_blkaddr = ei.blk + index - ei.fofs;\n\t\tif (!f2fs_is_valid_blkaddr(F2FS_I_SB(inode), dn.data_blkaddr,\n\t\t\t\t\t\tDATA_GENERIC_ENHANCE_READ)) {\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto put_err;\n\t\t}\n\t\tgoto got_it;\n\t}\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = f2fs_get_dnode_of_data(&dn, index, LOOKUP_NODE);\n\tif (err)\n\t\tgoto put_err;\n\tf2fs_put_dnode(&dn);\n\n\tif (unlikely(dn.data_blkaddr == NULL_ADDR)) {\n\t\terr = -ENOENT;\n\t\tgoto put_err;\n\t}\n\tif (dn.data_blkaddr != NEW_ADDR &&\n\t\t\t!f2fs_is_valid_blkaddr(F2FS_I_SB(inode),\n\t\t\t\t\t\tdn.data_blkaddr,\n\t\t\t\t\t\tDATA_GENERIC_ENHANCE)) {\n\t\terr = -EFSCORRUPTED;\n\t\tgoto put_err;\n\t}\ngot_it:\n\tif (PageUptodate(page)) {\n\t\tunlock_page(page);\n\t\treturn page;\n\t}\n\n\t\n\tif (dn.data_blkaddr == NEW_ADDR) {\n\t\tzero_user_segment(page, 0, PAGE_SIZE);\n\t\tif (!PageUptodate(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn page;\n\t}\n\n\terr = f2fs_submit_page_read(inode, page, dn.data_blkaddr);\n\tif (err)\n\t\tgoto put_err;\n\treturn page;\n\nput_err:\n\tf2fs_put_page(page, 1);\n\treturn ERR_PTR(err);\n}","22851":"ews_backend_constructed (GObject *object)\n{\n\tEBackend *backend;\n\tESource *source;\n\tESourceAuthentication *auth_extension;\n\tconst gchar *extension_name;\n\tgchar *host = NULL;\n\tguint16 port = 0;\n\n\t\n\tG_OBJECT_CLASS (e_ews_backend_parent_class)->constructed (object);\n\n\tbackend = E_BACKEND (object);\n\tsource = e_backend_get_source (backend);\n\n\t\n\te_server_side_source_set_remote_creatable (\n\t\tE_SERVER_SIDE_SOURCE (source), TRUE);\n\n\t\n\textension_name = E_SOURCE_EXTENSION_AUTHENTICATION;\n\tauth_extension = e_source_get_extension (source, extension_name);\n\n\tif (e_backend_get_destination_address (backend, &host, &port)) {\n\t\te_source_authentication_set_host (auth_extension, host);\n\t\te_source_authentication_set_port (auth_extension, port);\n\t}\n\n\tg_free (host);\n\n\t\n\te_backend_set_connectable (backend, NULL);\n}","23565":"void TABLE::mark_table_for_reopen()\n{\n  THD *thd= in_use;\n  DBUG_ASSERT(thd);\n  thd->locked_tables_list.mark_table_for_reopen(thd, this);\n}","22493":"    CharArray(int len) {\n      buf = new char[len]();\n    }","23685":"void bnep_net_setup(struct net_device *dev)\n{\n\n\tmemset(dev->broadcast, 0xff, ETH_ALEN);\n\tdev->addr_len = ETH_ALEN;\n\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->netdev_ops = &bnep_netdev_ops;\n\n\tdev->watchdog_timeo  = HZ * 2;\n}","23231":"static sasl_mechanism_t *find_mechanism(char *name)\n{\n\tmowgli_node_t *n;\n\tsasl_mechanism_t *mptr;\n\n\tMOWGLI_ITER_FOREACH(n, sasl_mechanisms.head)\n\t{\n\t\tmptr = n->data;\n\t\tif(!strcmp(mptr->name, name))\n\t\t\treturn mptr;\n\t}\n\n\tslog(LG_DEBUG, \"STR\", name);\n\n\treturn NULL;\n}","22936":"getmntdirbackward (const char *name, struct mntentchn *mcprev) {\n\tstruct mntentchn *mc, *mc0;\n\n\tmc0 = mtab_head();\n\tif (!mcprev)\n\t\tmcprev = mc0;\n\tfor (mc = mcprev->prev; mc && mc != mc0; mc = mc->prev)\n\t\tif (streq(mc->m.mnt_dir, name))\n\t\t\treturn mc;\n\treturn NULL;\n}","23120":"mp_int64 PlayerGeneric::getSyncCount() const\n{\n\tif (player)\n\t\treturn player->getSyncCount();\n\t\t\n\treturn 0;\n}","23755":"check_owner_password_V4(std::string& user_password,\n                        std::string const& owner_password,\n                        QPDF::EncryptionData const& data)\n{\n    \n\n    unsigned char key[OU_key_bytes_V4];\n    compute_O_rc4_key(user_password, owner_password, data, key);\n    unsigned char O_data[key_bytes];\n    memcpy(O_data, QUtil::unsigned_char_pointer(data.getO()), key_bytes);\n    iterate_rc4(O_data, key_bytes, key, data.getLengthBytes(),\n                (data.getR() >= 3) ? 20 : 1, true);\n    std::string new_user_password =\n        std::string(reinterpret_cast<char*>(O_data), key_bytes);\n    bool result = false;\n    if (check_user_password(new_user_password, data))\n    {\n        result = true;\n        user_password = new_user_password;\n    }\n    return result;\n}","23256":"ipv6_add_addr(struct inet6_dev *idev, const struct in6_addr *addr,\n\t      const struct in6_addr *peer_addr, int pfxlen,\n\t      int scope, u32 flags, u32 valid_lft, u32 prefered_lft)\n{\n\tstruct inet6_ifaddr *ifa = NULL;\n\tstruct rt6_info *rt;\n\tunsigned int hash;\n\tint err = 0;\n\tint addr_type = ipv6_addr_type(addr);\n\n\tif (addr_type == IPV6_ADDR_ANY ||\n\t    addr_type & IPV6_ADDR_MULTICAST ||\n\t    (!(idev->dev->flags & IFF_LOOPBACK) &&\n\t     addr_type & IPV6_ADDR_LOOPBACK))\n\t\treturn ERR_PTR(-EADDRNOTAVAIL);\n\n\trcu_read_lock_bh();\n\tif (idev->dead) {\n\t\terr = -ENODEV;\t\t\t\n\t\tgoto out2;\n\t}\n\n\tif (idev->cnf.disable_ipv6) {\n\t\terr = -EACCES;\n\t\tgoto out2;\n\t}\n\n\tspin_lock(&addrconf_hash_lock);\n\n\t\n\tif (ipv6_chk_same_addr(dev_net(idev->dev), addr, idev->dev)) {\n\t\tADBG((\"STR\"));\n\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tifa = kzalloc(sizeof(struct inet6_ifaddr), GFP_ATOMIC);\n\n\tif (ifa == NULL) {\n\t\tADBG((\"STR\"));\n\t\terr = -ENOBUFS;\n\t\tgoto out;\n\t}\n\n\trt = addrconf_dst_alloc(idev, addr, false);\n\tif (IS_ERR(rt)) {\n\t\terr = PTR_ERR(rt);\n\t\tgoto out;\n\t}\n\n\tifa->addr = *addr;\n\tif (peer_addr)\n\t\tifa->peer_addr = *peer_addr;\n\n\tspin_lock_init(&ifa->lock);\n\tspin_lock_init(&ifa->state_lock);\n\tsetup_timer(&ifa->dad_timer, addrconf_dad_timer,\n\t\t    (unsigned long)ifa);\n\tINIT_HLIST_NODE(&ifa->addr_lst);\n\tifa->scope = scope;\n\tifa->prefix_len = pfxlen;\n\tifa->flags = flags | IFA_F_TENTATIVE;\n\tifa->valid_lft = valid_lft;\n\tifa->prefered_lft = prefered_lft;\n\tifa->cstamp = ifa->tstamp = jiffies;\n\tifa->tokenized = false;\n\n\tifa->rt = rt;\n\n\tifa->idev = idev;\n\tin6_dev_hold(idev);\n\t\n\tin6_ifa_hold(ifa);\n\n\t\n\thash = inet6_addr_hash(addr);\n\n\thlist_add_head_rcu(&ifa->addr_lst, &inet6_addr_lst[hash]);\n\tspin_unlock(&addrconf_hash_lock);\n\n\twrite_lock(&idev->lock);\n\t\n\tipv6_link_dev_addr(idev, ifa);\n\n#ifdef CONFIG_IPV6_PRIVACY\n\tif (ifa->flags&IFA_F_TEMPORARY) {\n\t\tlist_add(&ifa->tmp_list, &idev->tempaddr_list);\n\t\tin6_ifa_hold(ifa);\n\t}\n#endif\n\n\tin6_ifa_hold(ifa);\n\twrite_unlock(&idev->lock);\nout2:\n\trcu_read_unlock_bh();\n\n\tif (likely(err == 0))\n\t\tinet6addr_notifier_call_chain(NETDEV_UP, ifa);\n\telse {\n\t\tkfree(ifa);\n\t\tifa = ERR_PTR(err);\n\t}\n\n\treturn ifa;\nout:\n\tspin_unlock(&addrconf_hash_lock);\n\tgoto out2;\n}","23020":"static void xrun(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\ttrace_xrun(substream);\n\tif (runtime->tstamp_mode == SNDRV_PCM_TSTAMP_ENABLE)\n\t\tsnd_pcm_gettime(runtime, (struct timespec *)&runtime->status->tstamp);\n\tsnd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);\n\tif (xrun_debug(substream, XRUN_DEBUG_BASIC)) {\n\t\tchar name[16];\n\t\tsnd_pcm_debug_name(substream, name, sizeof(name));\n\t\tpcm_warn(substream->pcm, \"STR\", name);\n\t\tdump_stack_on_xrun(substream);\n\t}\n}","23392":"static bool pp_suppress_error(errflags severity)\n{\n    \n    if (istk && istk->conds &&\n\t((severity & ERR_PP_PRECOND) ?\n\t istk->conds->state == COND_NEVER :\n\t !emitting(istk->conds->state)))\n        return true;\n\n    return false;\n}","23484":"int check_frequency(struct wif *wi[], int cards)\n{\n    int i, freq;\n    for(i=0; i<cards; i++)\n    {\n        freq = wi_get_freq(wi[i]);\n        if(freq < 0) continue;\n        if(G.frequency[i] != freq)\n        {\n            memset(G.message, '\\x00', sizeof(G.message));\n            snprintf(G.message, sizeof(G.message), \"STR\", wi_get_ifname(wi[i]), freq);\n            wi_set_freq(wi[i], G.frequency[i]);\n        }\n    }\n    return 0;\n}","23491":"static bool create_directory_if_missing(const path &dirpath)\n{\n\terror_code ec;\n\tbfs::file_status fs = bfs::status(dirpath, ec);\n\tif (error_except_not_found(ec)) {\n\t\tERR_FS << \"STR\" << ec.message() << '\\n';\n\t\treturn false;\n\t} else if (bfs::is_directory(fs)) {\n\t\tDBG_FS << \"STR\";\n\t\treturn true;\n\t} else if (bfs::exists(fs)) {\n\t\tERR_FS << \"STR\";\n\t\treturn false;\n\t}\n\n\tbool created = bfs::create_directory(dirpath, ec);\n\tif (ec) {\n\t\tERR_FS << \"STR\" << ec.message() << '\\n';\n\t}\n\treturn created;\n}","23047":"vhost_user_reset_owner(struct virtio_net **pdev,\n\t\t\tstruct VhostUserMsg *msg __rte_unused,\n\t\t\tint main_fd __rte_unused)\n{\n\tstruct virtio_net *dev = *pdev;\n\tvhost_destroy_device_notify(dev);\n\n\tcleanup_device(dev, 0);\n\treset_device(dev);\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}","23313":"ssl_connect_init_proxy(struct connectdata *conn, int sockindex)\n{\n  DEBUGASSERT(conn->bits.proxy_ssl_connected[sockindex]);\n  if(ssl_connection_complete == conn->ssl[sockindex].state &&\n     !conn->proxy_ssl[sockindex].use) {\n    struct ssl_backend_data *pbdata;\n\n    if(!(Curl_ssl->supports & SSLSUPP_HTTPS_PROXY))\n      return CURLE_NOT_BUILT_IN;\n\n    \n    pbdata = conn->proxy_ssl[sockindex].backend;\n    conn->proxy_ssl[sockindex] = conn->ssl[sockindex];\n\n    DEBUGASSERT(pbdata != NULL);\n\n    memset(&conn->ssl[sockindex], 0, sizeof(conn->ssl[sockindex]));\n    memset(pbdata, 0, Curl_ssl->sizeof_ssl_backend_data);\n\n    conn->ssl[sockindex].backend = pbdata;\n  }\n  return CURLE_OK;\n}","23298":"static void async_main_request_sent(void *private_data, BOOL success)\n{\n\tstruct winbindd_async_request *state =\n\t\ttalloc_get_type_abort(private_data, struct winbindd_async_request);\n\n\tif (!success) {\n\t\tDEBUG(5, (\"STR\"));\n\n\t\tstate->response->length = sizeof(struct winbindd_response);\n\t\tstate->response->result = WINBINDD_ERROR;\n\t\tstate->continuation(state->private_data, False);\n\t\treturn;\n\t}\n\n\tif (state->request->extra_len == 0) {\n\t\tasync_request_sent(private_data, True);\n\t\treturn;\n\t}\n\n\tsetup_async_write(&state->child->event, state->request->extra_data.data,\n\t\t\t  state->request->extra_len,\n\t\t\t  async_request_sent, state);\n}","22839":"sparse_dump_region (struct tar_sparse_file *file, size_t i)\n{\n  union block *blk;\n  off_t bytes_left = file->stat_info->sparse_map[i].numbytes;\n\n  if (!lseek_or_error (file, file->stat_info->sparse_map[i].offset))\n    return false;\n\n  while (bytes_left > 0)\n    {\n      size_t bufsize = (bytes_left > BLOCKSIZE) ? BLOCKSIZE : bytes_left;\n      size_t bytes_read;\n\n      blk = find_next_block ();\n      bytes_read = safe_read (file->fd, blk->buffer, bufsize);\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n          read_diag_details (file->stat_info->orig_file_name,\n\t                     (file->stat_info->sparse_map[i].offset\n\t\t\t      + file->stat_info->sparse_map[i].numbytes\n\t\t\t      - bytes_left),\n\t\t\t     bufsize);\n\t  return false;\n\t}\n\n      memset (blk->buffer + bytes_read, 0, BLOCKSIZE - bytes_read);\n      bytes_left -= bytes_read;\n      file->dumped_size += bytes_read;\n      set_next_block_after (blk);\n    }\n\n  return true;\n}","22800":"xfs_rw_ilock_demote(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\ttype)\n{\n\txfs_ilock_demote(ip, type);\n\tif (type & XFS_IOLOCK_EXCL)\n\t\tmutex_unlock(&VFS_I(ip)->i_mutex);\n}","23495":"dir_close(VALUE dir)\n{\n    struct dir_data *dirp;\n\n    dirp = dir_get(dir);\n    if (!dirp->dir) return Qnil;\n    closedir(dirp->dir);\n    dirp->dir = NULL;\n\n    return Qnil;\n}","22607":"AP_DECLARE(void) ap_update_vhost_from_headers(request_rec *r)\n{\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    const char *host_header = apr_table_get(r->headers_in, \"STR\");\n    int is_v6literal = 0;\n    int have_hostname_from_url = 0;\n\n    if (r->hostname) {\n        \n        have_hostname_from_url = 1;\n        is_v6literal = fix_hostname(r, NULL, conf->http_conformance);\n    }\n    else if (host_header != NULL) {\n        is_v6literal = fix_hostname(r, host_header, conf->http_conformance);\n    }\n    if (r->status != HTTP_OK)\n        return;\n\n    if (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE) {\n        \n        if (have_hostname_from_url && host_header != NULL) {\n            const char *repl = construct_host_header(r, is_v6literal);\n            apr_table_setn(r->headers_in, \"STR\", repl);\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02417)\n                          \"STR\"\n                          \"STR\", host_header, repl);\n        }\n    }\n\n    \n    if (r->connection->vhost_lookup_data) {\n        if (r->hostname)\n            check_hostalias(r);\n        else\n            check_serverpath(r);\n    }\n}","23077":"static inline int parse_value_and_bound(const string &input, long *output, const long lower_bound, const long upper_bound, const long default_val)\n{\n  if (!input.empty()) {\n    char *endptr;\n    *output = strtol(input.c_str(), &endptr, 10);\n    if (endptr) {\n      if (endptr == input.c_str()) return -EINVAL;\n      while (*endptr && isspace(*endptr)) \n        endptr++;\n      if (*endptr) {\n        return -EINVAL;\n      }\n    }\n    if(*output > upper_bound) {\n      *output = upper_bound;\n    }\n    if(*output < lower_bound) {\n      *output = lower_bound;\n    }\n  } else {\n    *output = default_val;\n  }\n\n  return 0;\n}","23486":"ENTROPY_DEBUG(const char *label, unsigned long entropy) {\n  if (getDebugLevel(\"STR\", 0) >= 1u) {\n    fprintf(stderr, \"STR\", label,\n            (int)sizeof(entropy) * 2, entropy, (unsigned long)sizeof(entropy));\n  }\n  return entropy;\n}","22845":"static ZIPARCHIVE_METHOD(getCommentIndex)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long index, flags = 0;\n\tconst char * comment;\n\tint comment_len = 0;\n\tstruct zip_stat sb;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"STR\",\n\t\t\t\t&index, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\tcomment = zip_get_file_comment(intern, index, &comment_len, (int)flags);\n\tRETURN_STRINGL((char *)comment, (zend_long)comment_len);\n}","23762":"static int SetBoolean(int val, byte* output)\n{\n    output[0] = ASN_BOOLEAN;\n    output[1] = 1;\n    output[2] = val ? -1 : 0;\n\n    return 3;\n}","22780":"bgp_rx_keepalive(struct bgp_conn *conn)\n{\n  struct bgp_proto *p = conn->bgp;\n\n  BGP_TRACE(D_PACKETS, \"STR\");\n  bgp_start_timer(conn->hold_timer, conn->hold_time);\n  switch (conn->state)\n    {\n    case BS_OPENCONFIRM:\n      bgp_conn_enter_established_state(conn);\n      break;\n    case BS_ESTABLISHED:\n      break;\n    default:\n      bgp_error(conn, 5, fsm_err_subcode[conn->state], NULL, 0);\n    }\n}","23199":"PJ_DEF(void) pjmedia_rtcp_rx_rtcp( pjmedia_rtcp_session *sess,\n\t\t\t\t   const void *pkt,\n\t\t\t\t   pj_size_t size)\n{\n    pj_uint8_t *p, *p_end;\n\n    p = (pj_uint8_t*)pkt;\n    p_end = p + size;\n    while (p < p_end) {\n\tpjmedia_rtcp_common *common = (pjmedia_rtcp_common*)p;\n\tunsigned len;\n\n\tlen = (pj_ntohs((pj_uint16_t)common->length)+1) * 4;\n\tif (p + len > p_end)\n\t    break;\n\n\tswitch(common->pt) {\n\tcase RTCP_SR:\n\tcase RTCP_RR:\n\tcase RTCP_XR:\n\t    parse_rtcp_report(sess, p, len);\n\t    break;\n\tcase RTCP_SDES:\n\t    parse_rtcp_sdes(sess, p, len);\n\t    break;\n\tcase RTCP_BYE:\n\t    parse_rtcp_bye(sess, p, len);\n\t    break;\n\tcase RTCP_RTPFB:\n\tcase RTCP_PSFB:\n\t    parse_rtcp_fb(sess, p, len);\n\t    break;\n\tdefault:\n\t    \n\t    TRACE_((sess->name, \"STR\",\n\t\t    common->pt));\n\t    break;\n\t}\n\n\tp += len;\n    }\n}","22553":"wsrep_cb_status_t wsrep_sst_donate_cb (void* app_ctx, void* recv_ctx,\n                                       const void* msg, size_t msg_len,\n                                       const wsrep_gtid_t* current_gtid,\n                                       const char* state, size_t state_len,\n                                       bool bypass)\n{\n  \n  local_status.set(WSREP_MEMBER_DONOR);\n\n  const char* method = (char*)msg;\n  size_t method_len  = strlen (method);\n  const char* data   = method + method_len + 1;\n\n  char uuid_str[37];\n  wsrep_uuid_print (&current_gtid->uuid, uuid_str, sizeof(uuid_str));\n\n  wsp::env env(NULL);\n  if (env.error())\n  {\n    WSREP_ERROR(\"STR\", -env.error());\n    return WSREP_CB_FAILURE;\n  }\n\n  int ret;\n  if ((ret= sst_append_auth_env(env, sst_auth_real)))\n  {\n    WSREP_ERROR(\"STR\", ret);\n    return WSREP_CB_FAILURE;\n  }\n\n  if (!strcmp (WSREP_SST_MYSQLDUMP, method))\n  {\n    ret = sst_donate_mysqldump(data, &current_gtid->uuid, uuid_str,\n                               current_gtid->seqno, bypass, env());\n  }\n  else\n  {\n    ret = sst_donate_other(method, data, uuid_str,\n                           current_gtid->seqno, bypass, env());\n  }\n\n  return (ret >= 0 ? WSREP_CB_SUCCESS : WSREP_CB_FAILURE);\n}","23775":"PHP_FUNCTION(sqlite_factory)\n{\n\tlong mode = 0666;\n\tchar *filename, *fullpath = NULL;\n\tint filename_len;\n\tzval *errmsg = NULL;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, sqlite_ce_exception, &error_handling TSRMLS_CC);\n\tif (FAILURE == zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"STR\",\n\t\t\t\t&filename, &filename_len, &mode, &errmsg)) {\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\tRETURN_NULL();\n\t}\n\tif (errmsg) {\n\t\tzval_dtor(errmsg);\n\t\tZVAL_NULL(errmsg);\n\t}\n\n\tif (strncmp(filename, \"STR\") - 1)) {\n\t\t\n\t\tif (!(fullpath = expand_filepath(filename, NULL TSRMLS_CC))) {\n\t\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\t\tRETURN_NULL();\n\t\t}\n\n\t\tif ((PG(safe_mode) && (!php_checkuid(fullpath, NULL, CHECKUID_CHECK_FILE_AND_DIR))) ||\n\t\t\t\tphp_check_open_basedir(fullpath TSRMLS_CC)) {\n\t\t\tefree(fullpath);\n\t\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\t\tRETURN_NULL();\n\t\t}\n\t}\n\n\tphp_sqlite_open(fullpath ? fullpath : filename, (int)mode, NULL, return_value, errmsg, return_value TSRMLS_CC);\n\tif (fullpath) {\n\t\tefree(fullpath);\n\t}\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}","23670":"PHP_FUNCTION(locale_get_display_variant) \n{\n    get_icu_disp_value_src_php( LOC_VARIANT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}","23339":"static int vnc_refresh_server_surface(VncDisplay *vd)\n{\n    int y;\n    uint8_t *guest_row;\n    uint8_t *server_row;\n    int cmp_bytes;\n    VncState *vs;\n    int has_dirty = 0;\n\n    struct timeval tv = { 0, 0 };\n\n    if (!vd->non_adaptive) {\n        gettimeofday(&tv, NULL);\n        has_dirty = vnc_update_stats(vd, &tv);\n    }\n\n    \n    cmp_bytes = 16 * ds_get_bytes_per_pixel(vd->ds);\n    if (cmp_bytes > vd->ds->surface->linesize) {\n        cmp_bytes = vd->ds->surface->linesize;\n    }\n    guest_row  = vd->guest.ds->data;\n    server_row = vd->server->data;\n    for (y = 0; y < vd->guest.ds->height; y++) {\n        if (!bitmap_empty(vd->guest.dirty[y], VNC_DIRTY_BITS)) {\n            int x;\n            uint8_t *guest_ptr;\n            uint8_t *server_ptr;\n\n            guest_ptr  = guest_row;\n            server_ptr = server_row;\n\n            for (x = 0; x + 15 < vd->guest.ds->width;\n                    x += 16, guest_ptr += cmp_bytes, server_ptr += cmp_bytes) {\n                if (!test_and_clear_bit((x \/ 16), vd->guest.dirty[y]))\n                    continue;\n                if (memcmp(server_ptr, guest_ptr, cmp_bytes) == 0)\n                    continue;\n                memcpy(server_ptr, guest_ptr, cmp_bytes);\n                if (!vd->non_adaptive)\n                    vnc_rect_updated(vd, x, y, &tv);\n                QTAILQ_FOREACH(vs, &vd->clients, next) {\n                    set_bit((x \/ 16), vs->dirty[y]);\n                }\n                has_dirty++;\n            }\n        }\n        guest_row  += ds_get_linesize(vd->ds);\n        server_row += ds_get_linesize(vd->ds);\n    }\n    return has_dirty;\n}","23515":"mono_image_add_stream_zero (MonoDynamicStream *stream, guint32 len)\n{\n\tguint32 idx;\n\t\n\tmake_room_in_stream (stream, stream->index + len);\n\tmemset (stream->data + stream->index, 0, len);\n\tidx = stream->index;\n\tstream->index += len;\n\treturn idx;\n}","23320":"TEST_F(HttpConnectionManagerImplTest, Http10Rejected) {\n  setup(false, \"\");\n  RequestDecoder* decoder = nullptr;\n  NiceMock<MockResponseEncoder> encoder;\n  EXPECT_CALL(*codec_, protocol()).Times(AnyNumber()).WillRepeatedly(Return(Protocol::Http10));\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> Http::Status {\n    decoder = &conn_manager_->newStream(encoder);\n    RequestHeaderMapPtr headers{\n        new TestRequestHeaderMapImpl{{\"STR\"}}};\n    decoder->decodeHeaders(std::move(headers), true);\n    data.drain(4);\n    return Http::okStatus();\n  }));\n\n  EXPECT_CALL(encoder, encodeHeaders(_, true))\n      .WillOnce(Invoke([](const ResponseHeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"STR\", headers.getStatusValue());\n        EXPECT_EQ(\"STR\", headers.getConnectionValue());\n      }));\n\n  Buffer::OwnedImpl fake_input(\"STR\");\n  conn_manager_->onData(fake_input, false);\n}","23679":"GetNumSameData(const byte * curPtr, const int maxnum)\n{\n    int count = 1;\n\n    if (1 == maxnum) {\n        return (1);\n    }\n    while (*curPtr == *(curPtr + count) && maxnum > count) {\n        count++;\n    }\n\n    return (count);\n}","23312":"    inline int check(int itemSize, int nItems=1, bool wait=true)\n    {\n      if (ptr + itemSize * nItems > end) {\n        if (ptr + itemSize > end)\n          return overrun(itemSize, nItems, wait);\n\n        nItems = (end - ptr) \/ itemSize;\n      }\n      return nItems;\n    }","23683":"static int l2tp_ip6_connect(struct sock *sk, struct sockaddr *uaddr,\n\t\t\t    int addr_len)\n{\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *) uaddr;\n\tstruct sockaddr_in6\t*usin = (struct sockaddr_in6 *) uaddr;\n\tstruct in6_addr\t*daddr;\n\tint\taddr_type;\n\tint rc;\n\n\tif (sock_flag(sk, SOCK_ZAPPED)) \n\t\treturn -EINVAL;\n\n\tif (addr_len < sizeof(*lsa))\n\t\treturn -EINVAL;\n\n\tif (usin->sin6_family != AF_INET6)\n\t\treturn -EINVAL;\n\n\taddr_type = ipv6_addr_type(&usin->sin6_addr);\n\tif (addr_type & IPV6_ADDR_MULTICAST)\n\t\treturn -EINVAL;\n\n\tif (addr_type & IPV6_ADDR_MAPPED) {\n\t\tdaddr = &usin->sin6_addr;\n\t\tif (ipv4_is_multicast(daddr->s6_addr32[3]))\n\t\t\treturn -EINVAL;\n\t}\n\n\trc = ip6_datagram_connect(sk, uaddr, addr_len);\n\n\tlock_sock(sk);\n\n\tl2tp_ip6_sk(sk)->peer_conn_id = lsa->l2tp_conn_id;\n\n\twrite_lock_bh(&l2tp_ip6_lock);\n\thlist_del_init(&sk->sk_bind_node);\n\tsk_add_bind_node(sk, &l2tp_ip6_bind_table);\n\twrite_unlock_bh(&l2tp_ip6_lock);\n\n\trelease_sock(sk);\n\n\treturn rc;\n}","22914":"processFinished(struct module_qstate* qstate, struct iter_qstate* iq,\n\tint id)\n{\n\tlog_query_info(VERB_QUERY, \"STR\", \n\t\t&qstate->qinfo);\n\n\t\n\tif(!qstate->no_cache_store && iq->query_for_pside_glue\n\t\t&& !iq->pside_glue)\n\t\t\titer_store_parentside_neg(qstate->env, &qstate->qinfo,\n\t\t\t\tiq->deleg_msg?iq->deleg_msg->rep:\n\t\t\t\t(iq->response?iq->response->rep:NULL));\n\tif(!iq->response) {\n\t\tverbose(VERB_ALGO, \"STR\");\n\t\terrinf(qstate, \"STR\");\n\t\treturn error_response(qstate, id, LDNS_RCODE_SERVFAIL);\n\t}\n\n\t\n\tiq->response->rep->flags |= BIT_RA;\n\n\t\n\t\n\tiq->response->rep->flags &= ~BIT_AA;\n\n\t\n\tiq->response->rep->flags |= BIT_QR;\n\n\t\n\tqstate->ext_state[id] = module_finished;\n\n\t\n\t\n\n\t\n\tif(iq->an_prepend_list || iq->ns_prepend_list) {\n\t\tif(!iter_prepend(iq, iq->response, qstate->region)) {\n\t\t\tlog_err(\"STR\");\n\t\t\treturn error_response(qstate, id, LDNS_RCODE_SERVFAIL);\n\t\t}\n\t\t\n\t\tiq->response->qinfo = qstate->qinfo;\n\t\t\n\t\tiq->response->rep->security = sec_status_unchecked;\n\t\t\n\t\tif(!qstate->no_cache_store && qstate->query_flags&BIT_RD) {\n\t\t\titer_dns_store(qstate->env, &qstate->qinfo, \n\t\t\t\tiq->response->rep, 0, qstate->prefetch_leeway,\n\t\t\t\tiq->dp&&iq->dp->has_parent_side_NS,\n\t\t\t\tqstate->region, qstate->query_flags);\n\t\t}\n\t}\n\tqstate->return_rcode = LDNS_RCODE_NOERROR;\n\tqstate->return_msg = iq->response;\n\treturn 0;\n}","23509":"bool is_ready_for_join(const pid_t pid) {\n\tEUID_ASSERT();\n\t\n\tchar *fname;\n\tif (asprintf(&fname, \"STR\", pid, RUN_JOIN_FILE) == -1)\n\t\terrExit(\"STR\");\n\tEUID_ROOT();\n\tint fd = open(fname, O_RDONLY|O_CLOEXEC);\n\tEUID_USER();\n\tfree(fname);\n\tif (fd == -1)\n\t\treturn false;\n\tstruct stat s;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"STR\");\n\tif (!S_ISREG(s.st_mode) || s.st_uid != 0 || s.st_size != 1) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\tchar status;\n\tif (read(fd, &status, 1) == 1 && status == SANDBOX_DONE) {\n\t\tclose(fd);\n\t\treturn true;\n\t}\n\tclose(fd);\n\treturn false;\n}","23159":"static u64 sched_slice(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\treturn calc_delta_mine(__sched_period(cfs_rq->nr_running),\n\t\t\t       se->load.weight, &cfs_rq->load);\n}","23245":"d_to_lfp(double d)\n{\n\tl_fixedpt_t lfp;\n\tlfp.int_partl = (uint32_t)d;\n\tlfp.fractionl = (uint32_t)((d - lfp.int_partl) * UINT_MAX);\n\tlfp.int_partl = htonl(lfp.int_partl);\n\tlfp.fractionl = htonl(lfp.fractionl);\n\treturn lfp;\n}","22964":"__do_kmalloc_node(size_t size, gfp_t flags, int node, unsigned long caller)\n{\n\tstruct kmem_cache *cachep;\n\tvoid *ret;\n\n\tcachep = kmalloc_slab(size, flags);\n\tif (unlikely(ZERO_OR_NULL_PTR(cachep)))\n\t\treturn cachep;\n\tret = kmem_cache_alloc_node_trace(cachep, flags, node, size);\n\tkasan_kmalloc(cachep, ret, size, flags);\n\n\treturn ret;\n}","23112":" *\/\nstatic int\nkex_method_diffie_hellman_group_exchange_sha256_key_exchange\n(LIBSSH2_SESSION * session, key_exchange_state_low_t * key_state)\n{\n    unsigned long p_len, g_len;\n    int ret = 0;\n    int rc;\n\n    if(key_state->state == libssh2_NB_state_idle) {\n        key_state->p = _libssh2_bn_init();\n        key_state->g = _libssh2_bn_init();\n        \n#ifdef LIBSSH2_DH_GEX_NEW\n        key_state->request[0] = SSH_MSG_KEX_DH_GEX_REQUEST;\n        _libssh2_htonu32(key_state->request + 1, LIBSSH2_DH_GEX_MINGROUP);\n        _libssh2_htonu32(key_state->request + 5, LIBSSH2_DH_GEX_OPTGROUP);\n        _libssh2_htonu32(key_state->request + 9, LIBSSH2_DH_GEX_MAXGROUP);\n        key_state->request_len = 13;\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \"STR\");\n#else\n        key_state->request[0] = SSH_MSG_KEX_DH_GEX_REQUEST_OLD;\n        _libssh2_htonu32(key_state->request + 1, LIBSSH2_DH_GEX_OPTGROUP);\n        key_state->request_len = 5;\n        _libssh2_debug(session, LIBSSH2_TRACE_KEX,\n                       \"STR\");\n#endif\n\n        key_state->state = libssh2_NB_state_created;\n    }\n\n    if(key_state->state == libssh2_NB_state_created) {\n        rc = _libssh2_transport_send(session, key_state->request,\n                                     key_state->request_len, NULL, 0);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n            return rc;\n        }\n        else if(rc) {\n            ret = _libssh2_error(session, rc,\n                                 \"STR\");\n            goto dh_gex_clean_exit;\n        }\n\n        key_state->state = libssh2_NB_state_sent;\n    }\n\n    if(key_state->state == libssh2_NB_state_sent) {\n        rc = _libssh2_packet_require(session, SSH_MSG_KEX_DH_GEX_GROUP,\n                                     &key_state->data, &key_state->data_len,\n                                     0, NULL, 0, &key_state->req_state);\n        if(rc == LIBSSH2_ERROR_EAGAIN) {\n            return rc;\n        }\n        else if(rc) {\n            ret = _libssh2_error(session, rc,\n                                 \"STR\");\n            goto dh_gex_clean_exit;\n        }\n\n        key_state->state = libssh2_NB_state_sent1;\n    }\n\n    if(key_state->state == libssh2_NB_state_sent1) {\n        unsigned char *s = key_state->data + 1;\n        p_len = _libssh2_ntohu32(s);\n        s += 4;\n        _libssh2_bn_from_bin(key_state->p, p_len, s);\n        s += p_len;\n\n        g_len = _libssh2_ntohu32(s);\n        s += 4;\n        _libssh2_bn_from_bin(key_state->g, g_len, s);\n\n        ret = diffie_hellman_sha256(session, key_state->g, key_state->p, p_len,\n                                    SSH_MSG_KEX_DH_GEX_INIT,\n                                    SSH_MSG_KEX_DH_GEX_REPLY,\n                                    key_state->data + 1,\n                                    key_state->data_len - 1,\n                                    &key_state->exchange_state);\n        if(ret == LIBSSH2_ERROR_EAGAIN) {\n            return ret;\n        }\n\n        LIBSSH2_FREE(session, key_state->data);\n    }\n\n  dh_gex_clean_exit:\n    key_state->state = libssh2_NB_state_idle;\n    _libssh2_bn_free(key_state->g);\n    key_state->g = NULL;\n    _libssh2_bn_free(key_state->p);\n    key_state->p = NULL;\n","22684":"R_API RBinJavaStackMapFrame *r_bin_java_build_stack_frame_from_local_variable_table(RBinJavaObj *bin, RBinJavaAttrInfo *attr) {\n\tRBinJavaStackMapFrame *sf = r_bin_java_default_stack_frame ();\n\tRBinJavaLocalVariableAttribute *lvattr = NULL;\n\tRBinJavaVerificationObj *type_item;\n\tRListIter *iter = NULL;\n\tut32 value_cnt = 0;\n\tut8 value;\n\tif (!sf || !bin || !attr || attr->type != R_BIN_JAVA_ATTR_TYPE_LOCAL_VARIABLE_TABLE_ATTR) {\n\t\teprintf (\"STR\");\n\t\treturn sf;\n\t}\n\tsf->number_of_locals = attr->info.local_variable_table_attr.table_length;\n\tr_list_foreach (attr->info.local_variable_table_attr.local_variable_table, iter, lvattr) {\n\t\tut32 pos = 0;\n\t\t\n\t\twhile (lvattr->descriptor[pos] == '[') {\n\t\t\tpos++;\n\t\t}\n\t\tvalue = lvattr->descriptor[pos];\n\t\t\n\t\tswitch (value) {\n\t\tcase 'I':\n\t\tcase 'Z':\n\t\tcase 'S':\n\t\tcase 'B':\n\t\tcase 'C':\n\t\t\ttype_item = r_bin_java_verification_info_from_type (bin, R_BIN_JAVA_STACKMAP_INTEGER, 0);\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\ttype_item = r_bin_java_verification_info_from_type (bin, R_BIN_JAVA_STACKMAP_FLOAT, 0);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\ttype_item = r_bin_java_verification_info_from_type (bin, R_BIN_JAVA_STACKMAP_DOUBLE, 0);\n\t\t\tbreak;\n\t\tcase 'J':\n\t\t\ttype_item = r_bin_java_verification_info_from_type (bin, R_BIN_JAVA_STACKMAP_LONG, 0);\n\t\t\tbreak;\n\t\tcase 'L':\n\t\t\t\n\t\t\t\n\t\t{\n\t\t\tut16 idx = r_bin_java_find_cp_class_ref_from_name_idx (bin, lvattr->name_idx);\n\t\t\ttype_item = r_bin_java_verification_info_from_type (bin, R_BIN_JAVA_STACKMAP_OBJECT, idx);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"STR\"\n\t\t\t\t\"STR\", lvattr->name, lvattr->descriptor);\n\t\t\ttype_item = r_bin_java_verification_info_from_type (bin, R_BIN_JAVA_STACKMAP_NULL, 0);\n\t\t}\n\t\tif (type_item) {\n\t\t\tr_list_append (sf->local_items, (void *) type_item);\n\t\t}\n\t\tvalue_cnt++;\n\t}\n\tif (value_cnt != attr->info.local_variable_table_attr.table_length) {\n\t\tIFDBG eprintf(\"STR\"\n\t\t\"STR\",\n\t\tattr->info.local_variable_table_attr.table_length, value_cnt);\n\t}\n\treturn sf;\n}","22624":"get_glyph_class (gunichar   charcode,\n\t\t HB_UShort *class)\n{\n  \n  if ((charcode >= 0xFB50 && charcode <= 0xFDFF) || \n      (charcode >= 0xFE70 && charcode <= 0XFEFF))   \n    return FALSE;\n\n  switch ((int) g_unichar_type (charcode))\n    {\n    case G_UNICODE_COMBINING_MARK:\n    case G_UNICODE_ENCLOSING_MARK:\n    case G_UNICODE_NON_SPACING_MARK:\n      *class = 3;\t\t\n      return TRUE;\n    case G_UNICODE_UNASSIGNED:\n    case G_UNICODE_PRIVATE_USE:\n      return FALSE;\t\t\n    default:\n      *class = 1;               \n      return TRUE;\n    }\n}","23613":"struct clock_source *dce80_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}","23655":"      ShardData(\n\tstring lock_name, string ordering_lock,\n\tuint64_t max_tok_per_prio, uint64_t min_cost, CephContext *cct,\n\tio_queue opqueue)\n\t: sdata_lock(lock_name.c_str(), false, true, false, cct),\n\t  sdata_op_ordering_lock(ordering_lock.c_str(), false, true,\n\t\t\t\t false, cct) {\n\tif (opqueue == io_queue::weightedpriority) {\n\t  pqueue = std::unique_ptr\n\t    <WeightedPriorityQueue<pair<spg_t,PGQueueable>,entity_inst_t>>(\n\t      new WeightedPriorityQueue<pair<spg_t,PGQueueable>,entity_inst_t>(\n\t\tmax_tok_per_prio, min_cost));\n\t} else if (opqueue == io_queue::prioritized) {\n\t  pqueue = std::unique_ptr\n\t    <PrioritizedQueue<pair<spg_t,PGQueueable>,entity_inst_t>>(\n\t      new PrioritizedQueue<pair<spg_t,PGQueueable>,entity_inst_t>(\n\t\tmax_tok_per_prio, min_cost));\n\t} else if (opqueue == io_queue::mclock_opclass) {\n\t  pqueue = std::unique_ptr\n\t    <ceph::mClockOpClassQueue>(new ceph::mClockOpClassQueue(cct));\n\t} else if (opqueue == io_queue::mclock_client) {\n\t  pqueue = std::unique_ptr\n\t    <ceph::mClockClientQueue>(new ceph::mClockClientQueue(cct));\n\t}\n      }","22837":"void giveup_all(struct task_struct *tsk)\n{\n\tunsigned long usermsr;\n\n\tif (!tsk->thread.regs)\n\t\treturn;\n\n\tcheck_if_tm_restore_required(tsk);\n\n\tusermsr = tsk->thread.regs->msr;\n\n\tif ((usermsr & msr_all_available) == 0)\n\t\treturn;\n\n\tmsr_check_and_set(msr_all_available);\n\n\tWARN_ON((usermsr & MSR_VSX) && !((usermsr & MSR_FP) && (usermsr & MSR_VEC)));\n\n#ifdef CONFIG_PPC_FPU\n\tif (usermsr & MSR_FP)\n\t\t__giveup_fpu(tsk);\n#endif\n#ifdef CONFIG_ALTIVEC\n\tif (usermsr & MSR_VEC)\n\t\t__giveup_altivec(tsk);\n#endif\n#ifdef CONFIG_SPE\n\tif (usermsr & MSR_SPE)\n\t\t__giveup_spe(tsk);\n#endif\n\n\tmsr_check_and_clear(msr_all_available);\n}","22532":"static bool bpf_map_is_rdonly(const struct bpf_map *map)\n{\n\treturn (map->map_flags & BPF_F_RDONLY_PROG) && map->frozen;\n}","23152":"  const HeaderEntry* getInline(Handle handle) const override {\n    ASSERT(handle.it_->second < inlineHeadersSize());\n    return constInlineHeaders()[handle.it_->second];\n  }","23543":"static int fuse_getattr(const struct path *path, struct kstat *stat,\n\t\t\tu32 request_mask, unsigned int flags)\n{\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\n\tif (!fuse_allow_current_process(fc)) {\n\t\tif (!request_mask) {\n\t\t\t\n\t\t\tstat->result_mask = 0;\n\t\t\tstat->dev = inode->i_sb->s_dev;\n\t\t\treturn 0;\n\t\t}\n\t\treturn -EACCES;\n\t}\n\n\treturn fuse_update_get_attr(inode, NULL, stat, request_mask, flags);\n}","23370":"static void cmd_set_speed(IDEState *s, uint8_t* buf)\n{\n    ide_atapi_cmd_ok(s);\n}","22941":"BOOL update_write_cache_brush_order(wStream* s, const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags)\n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\n\tif (!Stream_EnsureRemainingCapacity(s,\n\t                                    update_approximate_cache_brush_order(cache_brush, flags)))\n\t\treturn FALSE;\n\n\tiBitmapFormat = BPP_BMF[cache_brush->bpp];\n\tStream_Write_UINT8(s, cache_brush->index);  \n\tStream_Write_UINT8(s, iBitmapFormat);       \n\tStream_Write_UINT8(s, cache_brush->cx);     \n\tStream_Write_UINT8(s, cache_brush->cy);     \n\tStream_Write_UINT8(s, cache_brush->style);  \n\tStream_Write_UINT8(s, cache_brush->length); \n\n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"STR\", cache_brush->length);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Write_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif (!update_compress_brush(s, cache_brush->data, cache_brush->bpp))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\n\t\t\t\tint scanline = (cache_brush->bpp \/ 8) * 8;\n\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Write(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn TRUE;\n}","23682":"    Status explain(OperationContext* opCtx,\n                   const OpMsgRequest& request,\n                   ExplainOptions::Verbosity verbosity,\n                   rpc::ReplyBuilderInterface* result) const override {\n        std::string dbname = request.getDatabase().toString();\n        const BSONObj& cmdObj = request.body;\n        \n        \n        boost::optional<AutoGetCollectionForReadCommand> ctx;\n        ctx.emplace(opCtx,\n                    CommandHelpers::parseNsOrUUID(dbname, cmdObj),\n                    AutoGetCollection::ViewMode::kViewsPermitted);\n        const auto nss = ctx->getNss();\n\n        const ExtensionsCallbackReal extensionsCallback(opCtx, &nss);\n        auto parsedDistinct =\n            uassertStatusOK(ParsedDistinct::parse(opCtx, nss, cmdObj, extensionsCallback, true));\n\n        if (ctx->getView()) {\n            \n            ctx.reset();\n\n            auto viewAggregation = parsedDistinct.asAggregationCommand();\n            if (!viewAggregation.isOK()) {\n                return viewAggregation.getStatus();\n            }\n\n            auto viewAggRequest =\n                AggregationRequest::parseFromBSON(nss, viewAggregation.getValue(), verbosity);\n            if (!viewAggRequest.isOK()) {\n                return viewAggRequest.getStatus();\n            }\n\n            return runAggregate(\n                opCtx, nss, viewAggRequest.getValue(), viewAggregation.getValue(), result);\n        }\n\n        Collection* const collection = ctx->getCollection();\n\n        auto executor = uassertStatusOK(\n            getExecutorDistinct(opCtx, collection, QueryPlannerParams::DEFAULT, &parsedDistinct));\n\n        auto bodyBuilder = result->getBodyBuilder();\n        Explain::explainStages(executor.get(), collection, verbosity, &bodyBuilder);\n        return Status::OK();\n    }","23382":"static void sdhci_sysbus_realize(DeviceState *dev, Error **errp)\n{\n    ERRP_GUARD();\n    SDHCIState *s = SYSBUS_SDHCI(dev);\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n\n    sdhci_common_realize(s, errp);\n    if (*errp) {\n        return;\n    }\n\n    if (s->dma_mr) {\n        s->dma_as = &s->sysbus_dma_as;\n        address_space_init(s->dma_as, s->dma_mr, \"STR\");\n    } else {\n        \n        s->dma_as = &address_space_memory;\n    }\n\n    sysbus_init_irq(sbd, &s->irq);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n}","23776":"static noinline int tree_mod_log_insert_key(struct extent_buffer *eb, int slot,\n\t\tenum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\tint ret;\n\n\tif (!tree_mod_need_log(eb->fs_info, eb))\n\t\treturn 0;\n\n\ttm = alloc_tree_mod_elem(eb, slot, op, flags);\n\tif (!tm)\n\t\treturn -ENOMEM;\n\n\tif (tree_mod_dont_log(eb->fs_info, eb)) {\n\t\tkfree(tm);\n\t\treturn 0;\n\t}\n\n\tret = __tree_mod_log_insert(eb->fs_info, tm);\n\twrite_unlock(&eb->fs_info->tree_mod_log_lock);\n\tif (ret)\n\t\tkfree(tm);\n\n\treturn ret;\n}","23272":"jwk_valid_for_deriving_keys(const json_t* jwk)\n{\n    return jwk_valid_for(jwk, \"STR\");\n}","22859":"ldns_str2rdf_long_str(ldns_rdf **rd, const char *str)\n{\n\tuint8_t *data, *dp, ch = 0;\n\tsize_t length;\n\n\t\n\tdp = data = LDNS_XMALLOC(uint8_t, strlen(str));\n        if (! data) {\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\n\t\n\twhile (parse_char(&ch, &str)) {\n\t\t*dp++ = ch;\n\t\tif (dp - data > LDNS_MAX_RDFLEN) {\n\t\t\tLDNS_FREE(data);\n\t\t\treturn LDNS_STATUS_INVALID_STR;\n\t\t}\n\t}\n\tif (! str) {\n\t\treturn LDNS_STATUS_SYNTAX_BAD_ESCAPE;\n\t}\n\tlength = (size_t)(dp - data);\n\n\t\n\tdata = LDNS_XREALLOC(dp = data, uint8_t, length);\n\tif (! data) {\n\t\tLDNS_FREE(dp);\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\n\t\n\t*rd = ldns_rdf_new(LDNS_RDF_TYPE_LONG_STR, length, data);\n\tif (! *rd) {\n\t\tLDNS_FREE(data);\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\treturn LDNS_STATUS_OK;\n}","23418":"ofputil_decode_port_mod(const struct ofp_header *oh,\n                        struct ofputil_port_mod *pm, bool loose)\n{\n    memset(pm, 0, sizeof *pm);\n\n    struct ofpbuf b = ofpbuf_const_initializer(oh, ntohs(oh->length));\n    enum ofpraw raw = ofpraw_pull_assert(&b);\n\n    enum ofperr error;\n    if (raw == OFPRAW_OFPT10_PORT_MOD) {\n        error = ofputil_decode_ofp10_port_mod(b.data, pm);\n    } else if (raw == OFPRAW_OFPT11_PORT_MOD) {\n        error = ofputil_decode_ofp11_port_mod(b.data, pm);\n    } else if (raw == OFPRAW_OFPT14_PORT_MOD) {\n        error = ofputil_decode_ofp14_port_mod(&b, loose, pm);\n    } else if (raw == OFPRAW_OFPT16_PORT_MOD) {\n        error = ofputil_decode_ofp16_port_mod(&b, loose, pm);\n    } else {\n        error = OFPERR_OFPBRC_BAD_TYPE;\n    }\n\n    pm->config &= pm->mask;\n    return error;\n}","23254":"static void brcmf_report_wowl_wakeind(struct wiphy *wiphy, struct brcmf_if *ifp)\n{\n\tstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\n\tstruct brcmf_wowl_wakeind_le wake_ind_le;\n\tstruct cfg80211_wowlan_wakeup wakeup_data;\n\tstruct cfg80211_wowlan_wakeup *wakeup;\n\tu32 wakeind;\n\ts32 err;\n\tint timeout;\n\n\terr = brcmf_fil_iovar_data_get(ifp, \"STR\", &wake_ind_le,\n\t\t\t\t       sizeof(wake_ind_le));\n\tif (err) {\n\t\tbrcmf_err(\"STR\", err);\n\t\treturn;\n\t}\n\n\twakeind = le32_to_cpu(wake_ind_le.ucode_wakeind);\n\tif (wakeind & (BRCMF_WOWL_MAGIC | BRCMF_WOWL_DIS | BRCMF_WOWL_BCN |\n\t\t       BRCMF_WOWL_RETR | BRCMF_WOWL_NET |\n\t\t       BRCMF_WOWL_PFN_FOUND)) {\n\t\twakeup = &wakeup_data;\n\t\tmemset(&wakeup_data, 0, sizeof(wakeup_data));\n\t\twakeup_data.pattern_idx = -1;\n\n\t\tif (wakeind & BRCMF_WOWL_MAGIC) {\n\t\t\tbrcmf_dbg(INFO, \"STR\");\n\t\t\twakeup_data.magic_pkt = true;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_DIS) {\n\t\t\tbrcmf_dbg(INFO, \"STR\");\n\t\t\twakeup_data.disconnect = true;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_BCN) {\n\t\t\tbrcmf_dbg(INFO, \"STR\");\n\t\t\twakeup_data.disconnect = true;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_RETR) {\n\t\t\tbrcmf_dbg(INFO, \"STR\");\n\t\t\twakeup_data.disconnect = true;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_NET) {\n\t\t\tbrcmf_dbg(INFO, \"STR\");\n\t\t\t\n\t\t\twakeup_data.pattern_idx = 0;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_PFN_FOUND) {\n\t\t\tbrcmf_dbg(INFO, \"STR\");\n\t\t\ttimeout = wait_event_timeout(cfg->wowl.nd_data_wait,\n\t\t\t\tcfg->wowl.nd_data_completed,\n\t\t\t\tBRCMF_ND_INFO_TIMEOUT);\n\t\t\tif (!timeout)\n\t\t\t\tbrcmf_err(\"STR\");\n\t\t\telse\n\t\t\t\twakeup_data.net_detect = cfg->wowl.nd_info;\n\t\t}\n\t\tif (wakeind & BRCMF_WOWL_GTK_FAILURE) {\n\t\t\tbrcmf_dbg(INFO, \"STR\");\n\t\t\twakeup_data.gtk_rekey_failure = true;\n\t\t}\n\t} else {\n\t\twakeup = NULL;\n\t}\n\tcfg80211_report_wowlan_wakeup(&ifp->vif->wdev, wakeup, GFP_KERNEL);\n}","23811":"uint32_t pcnet_ioport_readl(void *opaque, uint32_t addr)\n{\n    PCNetState *s = opaque;\n    uint32_t val = -1;\n    pcnet_poll_timer(s);\n    if (BCR_DWIO(s)) {\n        switch (addr & 0x0f) {\n        case 0x00: \n            val = pcnet_csr_readw(s, s->rap);\n            break;\n        case 0x04:\n            val = s->rap;\n            break;\n        case 0x08:\n            pcnet_s_reset(s);\n            val = 0;\n            break;\n        case 0x0c:\n            val = pcnet_bcr_readw(s, s->rap);\n            break;\n        }\n    }\n    pcnet_update_irq(s);\n#ifdef PCNET_DEBUG_IO\n    printf(\"STR\", addr, val);\n#endif\n    return val;\n}","22773":"mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t   struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sk_buff\t\t*skb;\n\tstruct sock\t\t*sk = sock->sk;\n\tstruct sockaddr_mISDN\t*maddr;\n\n\tint\t\tcopied, err;\n\n\tif (*debug & DEBUG_SOCKET)\n\t\tprintk(KERN_DEBUG \"STR\",\n\t\t       __func__, (int)len, flags, _pms(sk)->ch.nr,\n\t\t       sk->sk_protocol);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tif (sk->sk_state == MISDN_CLOSED)\n\t\treturn 0;\n\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tif (msg->msg_namelen >= sizeof(struct sockaddr_mISDN)) {\n\t\tmsg->msg_namelen = sizeof(struct sockaddr_mISDN);\n\t\tmaddr = (struct sockaddr_mISDN *)msg->msg_name;\n\t\tmaddr->family = AF_ISDN;\n\t\tmaddr->dev = _pms(sk)->dev->id;\n\t\tif ((sk->sk_protocol == ISDN_P_LAPD_TE) ||\n\t\t    (sk->sk_protocol == ISDN_P_LAPD_NT)) {\n\t\t\tmaddr->channel = (mISDN_HEAD_ID(skb) >> 16) & 0xff;\n\t\t\tmaddr->tei =  (mISDN_HEAD_ID(skb) >> 8) & 0xff;\n\t\t\tmaddr->sapi = mISDN_HEAD_ID(skb) & 0xff;\n\t\t} else {\n\t\t\tmaddr->channel = _pms(sk)->ch.nr;\n\t\t\tmaddr->sapi = _pms(sk)->ch.addr & 0xFF;\n\t\t\tmaddr->tei =  (_pms(sk)->ch.addr >> 8) & 0xFF;\n\t\t}\n\t} else {\n\t\tif (msg->msg_namelen)\n\t\t\tprintk(KERN_WARNING \"STR\",\n\t\t\t       __func__, msg->msg_namelen);\n\t\tmsg->msg_namelen = 0;\n\t}\n\n\tcopied = skb->len + MISDN_HEADER_LEN;\n\tif (len < copied) {\n\t\tif (flags & MSG_PEEK)\n\t\t\tatomic_dec(&skb->users);\n\t\telse\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\treturn -ENOSPC;\n\t}\n\tmemcpy(skb_push(skb, MISDN_HEADER_LEN), mISDN_HEAD_P(skb),\n\t       MISDN_HEADER_LEN);\n\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\n\tmISDN_sock_cmsg(sk, msg, skb);\n\n\tskb_free_datagram(sk, skb);\n\n\treturn err ? : copied;\n}","23172":"TEST_F(Http1ServerConnectionImplTest, ManyTrailersRejected) {\n  \n  testTrailersExceedLimit(createHeaderFragment(101), true);\n}","22656":"_gnutls_gen_cert_server_certificate (gnutls_session_t session,\n                                     gnutls_buffer_st * data)\n{\n  switch (session->security_parameters.cert_type)\n    {\n#ifdef ENABLE_OPENPGP\n    case GNUTLS_CRT_OPENPGP:\n      return _gnutls_gen_openpgp_certificate (session, data);\n#endif\n    case GNUTLS_CRT_X509:\n      return _gnutls_gen_x509_crt (session, data);\n    default:\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n}","23759":"static void LoadOpenCLDevices(MagickCLEnv clEnv)\n{\n  cl_context_properties\n    properties[3];\n\n  cl_device_id\n    *devices;\n\n  cl_int\n    status;\n\n  cl_platform_id\n    *platforms;\n\n  cl_uint\n    i,\n    j,\n    next,\n    number_devices,\n    number_platforms;\n\n  size_t\n    length;\n\n  number_platforms=0;\n  if (openCL_library->clGetPlatformIDs(0,NULL,&number_platforms) != CL_SUCCESS)\n    return;\n  if (number_platforms == 0)\n    return;\n  platforms=(cl_platform_id *) AcquireMagickMemory(number_platforms*\n    sizeof(cl_platform_id));\n  if (platforms == (cl_platform_id *) NULL)\n    return;\n  if (openCL_library->clGetPlatformIDs(number_platforms,platforms,NULL) != CL_SUCCESS)\n    {\n       platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n       return;\n    }\n  for (i = 0; i < number_platforms; i++)\n  {\n    number_devices=GetOpenCLDeviceCount(clEnv,platforms[i]);\n    if (number_devices == 0)\n      platforms[i]=(cl_platform_id) NULL;\n    else\n      clEnv->number_devices+=number_devices;\n  }\n  if (clEnv->number_devices == 0)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  clEnv->devices=(MagickCLDevice *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(MagickCLDevice));\n  if (clEnv->devices == (MagickCLDevice *) NULL)\n    {\n      RelinquishMagickCLDevices(clEnv);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      return;\n    }\n  (void) ResetMagickMemory(clEnv->devices,0,clEnv->number_devices*\n    sizeof(MagickCLDevice));\n  devices=(cl_device_id *) AcquireQuantumMemory(clEnv->number_devices,\n    sizeof(cl_device_id));\n  if (devices == (cl_device_id *) NULL)\n    {\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  clEnv->number_contexts=(size_t) number_platforms;\n  clEnv->contexts=(cl_context *) AcquireQuantumMemory(clEnv->number_contexts,\n    sizeof(cl_context));\n  if (clEnv->contexts == (cl_context *) NULL)\n    {\n      devices=(cl_device_id *) RelinquishMagickMemory(devices);\n      platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n      RelinquishMagickCLDevices(clEnv);\n      return;\n    }\n  next=0;\n  for (i = 0; i < number_platforms; i++)\n  {\n    if (platforms[i] == (cl_platform_id) NULL)\n      continue;\n\n    status=clEnv->library->clGetDeviceIDs(platforms[i],CL_DEVICE_TYPE_CPU | \n      CL_DEVICE_TYPE_GPU,(cl_uint) clEnv->number_devices,devices,&number_devices);\n    if (status != CL_SUCCESS)\n      continue;\n\n    properties[0]=CL_CONTEXT_PLATFORM;\n    properties[1]=(cl_context_properties) platforms[i];\n    properties[2]=0;\n    clEnv->contexts[i]=openCL_library->clCreateContext(properties,number_devices,\n      devices,NULL,NULL,&status);\n    if (status != CL_SUCCESS)\n      continue;\n\n    for (j = 0; j < number_devices; j++,next++)\n    {\n      MagickCLDevice\n        device;\n\n      device=AcquireMagickCLDevice();\n      if (device == (MagickCLDevice) NULL)\n        break;\n\n      device->context=clEnv->contexts[i];\n      device->deviceID=devices[j];\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,0,NULL,\n        &length);\n      device->platform_name=AcquireQuantumMemory(length,\n        sizeof(*device->platform_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_NAME,length,\n        device->platform_name,NULL);\n\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,0,NULL,\n        &length);\n      device->vendor_name=AcquireQuantumMemory(length,\n        sizeof(*device->vendor_name));\n      openCL_library->clGetPlatformInfo(platforms[i],CL_PLATFORM_VENDOR,length,\n        device->vendor_name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,0,NULL,\n        &length);\n      device->name=AcquireQuantumMemory(length,sizeof(*device->name));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_NAME,length,\n        device->name,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,0,NULL,\n        &length);\n      device->version=AcquireQuantumMemory(length,sizeof(*device->version));\n      openCL_library->clGetDeviceInfo(devices[j],CL_DRIVER_VERSION,length,\n        device->version,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_CLOCK_FREQUENCY,\n        sizeof(cl_uint),&device->max_clock_frequency,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_MAX_COMPUTE_UNITS,\n        sizeof(cl_uint),&device->max_compute_units,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_TYPE,\n        sizeof(cl_device_type),&device->type,NULL);\n\n      openCL_library->clGetDeviceInfo(devices[j],CL_DEVICE_LOCAL_MEM_SIZE,\n        sizeof(cl_ulong),&device->local_memory_size,NULL);\n\n      clEnv->devices[next]=device;\n    }\n  }\n  if (next != clEnv->number_devices)\n    RelinquishMagickCLDevices(clEnv);\n  platforms=(cl_platform_id *) RelinquishMagickMemory(platforms);\n  devices=(cl_device_id *) RelinquishMagickMemory(devices);\n}","22979":"findNextBorderPixel(l_int32    w,\n                    l_int32    h,\n                    l_uint32  *data,\n                    l_int32    wpl,\n                    l_int32    px,\n                    l_int32    py,\n                    l_int32   *pqpos,\n                    l_int32   *pnpx,\n                    l_int32   *pnpy)\n{\nl_int32    qpos, i, pos, npx, npy, val;\nl_uint32  *line;\n\n    qpos = *pqpos;\n    for (i = 1; i < 8; i++) {\n        pos = (qpos + i) % 8;\n        npx = px + xpostab[pos];\n        npy = py + ypostab[pos];\n        line = data + npy * wpl;\n        val = GET_DATA_BIT(line, npx);\n        if (val) {\n            *pnpx = npx;\n            *pnpy = npy;\n            *pqpos = qpostab[pos];\n            return 0;\n        }\n    }\n\n    return 1;\n}","22731":"static int io_recv(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_buffer *kbuf;\n\tstruct io_sr_msg *sr = &req->sr_msg;\n\tstruct msghdr msg;\n\tvoid __user *buf = sr->buf;\n\tstruct socket *sock;\n\tstruct iovec iov;\n\tunsigned flags;\n\tint min_ret = 0;\n\tint ret, cflags = 0;\n\tbool force_nonblock = issue_flags & IO_URING_F_NONBLOCK;\n\n\tsock = sock_from_file(req->file);\n\tif (unlikely(!sock))\n\t\treturn -ENOTSOCK;\n\n\tif (req->flags & REQ_F_BUFFER_SELECT) {\n\t\tkbuf = io_recv_buffer_select(req, !force_nonblock);\n\t\tif (IS_ERR(kbuf))\n\t\t\treturn PTR_ERR(kbuf);\n\t\tbuf = u64_to_user_ptr(kbuf->addr);\n\t}\n\n\tret = import_single_range(READ, buf, sr->len, &iov, &msg.msg_iter);\n\tif (unlikely(ret))\n\t\tgoto out_free;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_namelen = 0;\n\tmsg.msg_iocb = NULL;\n\tmsg.msg_flags = 0;\n\n\tflags = req->sr_msg.msg_flags;\n\tif (force_nonblock)\n\t\tflags |= MSG_DONTWAIT;\n\tif (flags & MSG_WAITALL)\n\t\tmin_ret = iov_iter_count(&msg.msg_iter);\n\n\tret = sock_recvmsg(sock, &msg, flags);\n\tif (force_nonblock && ret == -EAGAIN)\n\t\treturn -EAGAIN;\n\tif (ret == -ERESTARTSYS)\n\t\tret = -EINTR;\nout_free:\n\tif (req->flags & REQ_F_BUFFER_SELECTED)\n\t\tcflags = io_put_recv_kbuf(req);\n\tif (ret < min_ret || ((flags & MSG_WAITALL) && (msg.msg_flags & (MSG_TRUNC | MSG_CTRUNC))))\n\t\treq_set_fail_links(req);\n\t__io_req_complete(req, issue_flags, ret, cflags);\n\treturn 0;\n}","23048":"static int devinet_conf_proc(struct ctl_table *ctl, int write,\n\t\t\t     void __user *buffer,\n\t\t\t     size_t *lenp, loff_t *ppos)\n{\n\tint old_value = *(int *)ctl->data;\n\tint ret = proc_dointvec(ctl, write, buffer, lenp, ppos);\n\tint new_value = *(int *)ctl->data;\n\n\tif (write) {\n\t\tstruct ipv4_devconf *cnf = ctl->extra1;\n\t\tstruct net *net = ctl->extra2;\n\t\tint i = (int *)ctl->data - cnf->data;\n\t\tint ifindex;\n\n\t\tset_bit(i, cnf->state);\n\n\t\tif (cnf == net->ipv4.devconf_dflt)\n\t\t\tdevinet_copy_dflt_conf(net, i);\n\t\tif (i == IPV4_DEVCONF_ACCEPT_LOCAL - 1 ||\n\t\t    i == IPV4_DEVCONF_ROUTE_LOCALNET - 1)\n\t\t\tif ((new_value == 0) && (old_value != 0))\n\t\t\t\trt_cache_flush(net);\n\n\t\tif (i == IPV4_DEVCONF_RP_FILTER - 1 &&\n\t\t    new_value != old_value) {\n\t\t\tifindex = devinet_conf_ifindex(net, cnf);\n\t\t\tinet_netconf_notify_devconf(net, NETCONFA_RP_FILTER,\n\t\t\t\t\t\t    ifindex, cnf);\n\t\t}\n\t\tif (i == IPV4_DEVCONF_PROXY_ARP - 1 &&\n\t\t    new_value != old_value) {\n\t\t\tifindex = devinet_conf_ifindex(net, cnf);\n\t\t\tinet_netconf_notify_devconf(net, NETCONFA_PROXY_NEIGH,\n\t\t\t\t\t\t    ifindex, cnf);\n\t\t}\n\t\tif (i == IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN - 1 &&\n\t\t    new_value != old_value) {\n\t\t\tifindex = devinet_conf_ifindex(net, cnf);\n\t\t\tinet_netconf_notify_devconf(net, NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN,\n\t\t\t\t\t\t    ifindex, cnf);\n\t\t}\n\t}\n\n\treturn ret;\n}","23283":"static int num_pages_spanned(struct iovec *iov)\n{\n\treturn\n\t((PAGE_ALIGN((unsigned long)iov->iov_base + iov->iov_len) -\n\t((unsigned long)iov->iov_base & PAGE_MASK)) >> PAGE_SHIFT);\n}","23445":"get_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ip6t_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (s->target_offset == sizeof(struct ip6t_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t    t->verdict < 0 &&\n\t\t    unconditional(&s->ipv6)) {\n\t\t\t\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;\n}","22728":"i_alloc_struct_array_immovable(gs_memory_t * mem, uint num_elements,\n                           gs_memory_type_ptr_t pstype, client_name_t cname)\n{\n    gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem;\n    obj_header_t *obj;\n\n#ifdef MEMENTO\n    if (Memento_failThisEvent())\n        return NULL;\n#endif\n\n    ALLOC_CHECK_SIZE(mem,pstype);\n    obj = alloc_obj(imem,\n                    (ulong) num_elements * pstype->ssize,\n                    pstype, ALLOC_IMMOVABLE | ALLOC_DIRECT, cname);\n    if_debug7m('A', mem, \"STR\",\n               alloc_trace_space(imem), client_name_string(cname),\n               struct_type_name_string(pstype),\n               (ulong) num_elements * pstype->ssize,\n               num_elements, pstype->ssize, (ulong) obj);\n    return (char *)obj;\n}","23227":"void imap_free_header_data (IMAP_HEADER_DATA** data)\n{\n  if (*data)\n  {\n    \n    mutt_free_list (&((*data)->keywords));\n    FREE (data); \n  }\n}","23519":"static long do_splice_to(struct file *in, loff_t *ppos,\n\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t unsigned int flags)\n{\n\tint ret;\n\n\tif (unlikely(!in->f_op || !in->f_op->splice_read))\n\t\treturn -EINVAL;\n\n\tif (unlikely(!(in->f_mode & FMODE_READ)))\n\t\treturn -EBADF;\n\n\tret = rw_verify_area(READ, in, ppos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\treturn in->f_op->splice_read(in, ppos, pipe, len, flags);\n}","23186":"static inline int pic_is_unused(H264Context *h, Picture *pic)\n{\n    if (pic->f.data[0] == NULL)\n        return 1;\n    if (pic->needs_realloc && !(pic->reference & DELAYED_PIC_REF))\n        return 1;\n    return 0;\n}","23188":"static ssize_t runtime_enabled_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tif (dev->power.disable_depth && (dev->power.runtime_auto == false))\n\t\treturn sprintf(buf, \"STR\");\n\tif (dev->power.disable_depth)\n\t\treturn sprintf(buf, \"STR\");\n\tif (dev->power.runtime_auto == false)\n\t\treturn sprintf(buf, \"STR\");\n\treturn sprintf(buf, \"STR\");\n}","22687":"restore_fpu_state(struct pt_regs *regs, __siginfo_fpu_t __user *fpu)\n{\n\tint err;\n#ifdef CONFIG_SMP\n\tif (test_tsk_thread_flag(current, TIF_USEDFPU))\n\t\tregs->psr &= ~PSR_EF;\n#else\n\tif (current == last_task_used_math) {\n\t\tlast_task_used_math = NULL;\n\t\tregs->psr &= ~PSR_EF;\n\t}\n#endif\n\tset_used_math();\n\tclear_tsk_thread_flag(current, TIF_USEDFPU);\n\n\tif (!access_ok(VERIFY_READ, fpu, sizeof(*fpu)))\n\t\treturn -EFAULT;\n\n\terr = __copy_from_user(&current->thread.float_regs[0], &fpu->si_float_regs[0],\n\t\t\t       (sizeof(unsigned long) * 32));\n\terr |= __get_user(current->thread.fsr, &fpu->si_fsr);\n\terr |= __get_user(current->thread.fpqdepth, &fpu->si_fpqdepth);\n\tif (current->thread.fpqdepth != 0)\n\t\terr |= __copy_from_user(&current->thread.fpqueue[0],\n\t\t\t\t\t&fpu->si_fpqueue[0],\n\t\t\t\t\t((sizeof(unsigned long) +\n\t\t\t\t\t(sizeof(unsigned long *)))*16));\n\treturn err;\n}","23055":"static int cap_sk_alloc_security(struct sock *sk, int family, gfp_t priority)\n{\n\treturn 0;\n}","22655":"static ssize_t do_rbd_remove(struct bus_type *bus,\n\t\t\t     const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct rbd_device *rbd_dev = NULL;\n\tstruct list_head *tmp;\n\tint dev_id;\n\tchar opt_buf[6];\n\tbool force = false;\n\tint ret;\n\n\tdev_id = -1;\n\topt_buf[0] = '\\0';\n\tsscanf(buf, \"STR\", &dev_id, opt_buf);\n\tif (dev_id < 0) {\n\t\tpr_err(\"STR\");\n\t\treturn -EINVAL;\n\t}\n\tif (opt_buf[0] != '\\0') {\n\t\tif (!strcmp(opt_buf, \"STR\")) {\n\t\t\tforce = true;\n\t\t} else {\n\t\t\tpr_err(\"STR\", opt_buf);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = -ENOENT;\n\tspin_lock(&rbd_dev_list_lock);\n\tlist_for_each(tmp, &rbd_dev_list) {\n\t\trbd_dev = list_entry(tmp, struct rbd_device, node);\n\t\tif (rbd_dev->dev_id == dev_id) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!ret) {\n\t\tspin_lock_irq(&rbd_dev->lock);\n\t\tif (rbd_dev->open_count && !force)\n\t\t\tret = -EBUSY;\n\t\telse if (test_and_set_bit(RBD_DEV_FLAG_REMOVING,\n\t\t\t\t\t  &rbd_dev->flags))\n\t\t\tret = -EINPROGRESS;\n\t\tspin_unlock_irq(&rbd_dev->lock);\n\t}\n\tspin_unlock(&rbd_dev_list_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tif (force) {\n\t\t\n\t\tblk_mq_freeze_queue(rbd_dev->disk->queue);\n\t\tblk_set_queue_dying(rbd_dev->disk->queue);\n\t}\n\n\tdel_gendisk(rbd_dev->disk);\n\tspin_lock(&rbd_dev_list_lock);\n\tlist_del_init(&rbd_dev->node);\n\tspin_unlock(&rbd_dev_list_lock);\n\tdevice_del(&rbd_dev->dev);\n\n\trbd_dev_image_unlock(rbd_dev);\n\trbd_dev_device_release(rbd_dev);\n\trbd_dev_image_release(rbd_dev);\n\trbd_dev_destroy(rbd_dev);\n\treturn count;\n}","23022":"int main(int argc, char **argv)\n{\n  int error;\n  my_bool first_argument_uses_wildcards=0;\n  char *wild;\n  MYSQL mysql;\n  MY_INIT(argv[0]);\n\n  my_getopt_use_args_separator= TRUE;\n  if (load_defaults(\"STR\",load_default_groups,&argc,&argv))\n    exit(1);\n  my_getopt_use_args_separator= FALSE;\n\n  get_options(&argc,&argv);\n\n  wild=0;\n  if (argc)\n  {\n    char *pos= argv[argc-1], *to;\n    for (to= pos ; *pos ; pos++, to++)\n    {\n      switch (*pos) {\n      case '*':\n\t*pos= '%';\n\tfirst_argument_uses_wildcards= 1;\n\tbreak;\n      case '?':\n\t*pos= '_';\n\tfirst_argument_uses_wildcards= 1;\n\tbreak;\n      case '%':\n      case '_':\n\tfirst_argument_uses_wildcards= 1;\n\tbreak;\n      case '\\\\':\n\tpos++;\n      default: break;\n      }\n      *to= *pos;\n    }    \n    *to= *pos; \n  }\n  if (first_argument_uses_wildcards)\n    wild= argv[--argc];\n  else if (argc == 3)\t\t\t\n    wild= argv[--argc];\n\n  if (argc > 2)\n  {\n    fprintf(stderr,\"STR\",my_progname);\n    exit(1);\n  }\n  mysql_init(&mysql);\n  if (opt_compress)\n    mysql_options(&mysql,MYSQL_OPT_COMPRESS,NullS);\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(&mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n\t\t  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(&mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(&mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(&mysql,MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*)&opt_ssl_verify_server_cert);\n#endif\n  if (opt_protocol)\n    mysql_options(&mysql,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(&mysql,MYSQL_OPT_BIND,opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(&mysql,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);\n#endif\n  mysql_options(&mysql, MYSQL_SET_CHARSET_NAME, default_charset);\n\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(&mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(&mysql, MYSQL_DEFAULT_AUTH, opt_default_auth);\n\n  mysql_options(&mysql, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(&mysql, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 \"STR\");\n  if (!(mysql_real_connect(&mysql,host,user,opt_password,\n\t\t\t   (first_argument_uses_wildcards) ? \"\" :\n                           argv[0],opt_mysql_port,opt_mysql_unix_port,\n\t\t\t   0)))\n  {\n    fprintf(stderr,\"STR\",my_progname,mysql_error(&mysql));\n    exit(1);\n  }\n  mysql.reconnect= 1;\n\n  switch (argc) {\n  case 0:  error=list_dbs(&mysql,wild); break;\n  case 1:\n    if (opt_status)\n      error=list_table_status(&mysql,argv[0],wild);\n    else\n      error=list_tables(&mysql,argv[0],wild);\n    break;\n  default:\n    if (opt_status && ! wild)\n      error=list_table_status(&mysql,argv[0],argv[1]);\n    else\n      error=list_fields(&mysql,argv[0],argv[1],wild);\n    break;\n  }\n  mysql_close(&mysql);\t\t\t\n  my_free(opt_password);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  my_free(shared_memory_base_name);\n#endif\n  my_end(my_end_arg);\n  exit(error ? 1 : 0);\n  return 0;\t\t\t\t\n}","22881":"static struct dentry *fuse_lookup(struct inode *dir, struct dentry *entry,\n\t\t\t\t  unsigned int flags)\n{\n\tint err;\n\tstruct fuse_entry_out outarg;\n\tstruct inode *inode;\n\tstruct dentry *newent;\n\tbool outarg_valid = true;\n\tbool locked;\n\n\tlocked = fuse_lock_inode(dir);\n\terr = fuse_lookup_name(dir->i_sb, get_node_id(dir), &entry->d_name,\n\t\t\t       &outarg, &inode);\n\tfuse_unlock_inode(dir, locked);\n\tif (err == -ENOENT) {\n\t\toutarg_valid = false;\n\t\terr = 0;\n\t}\n\tif (err)\n\t\tgoto out_err;\n\n\terr = -EIO;\n\tif (inode && get_node_id(inode) == FUSE_ROOT_ID)\n\t\tgoto out_iput;\n\n\tnewent = d_splice_alias(inode, entry);\n\terr = PTR_ERR(newent);\n\tif (IS_ERR(newent))\n\t\tgoto out_err;\n\n\tentry = newent ? newent : entry;\n\tif (outarg_valid)\n\t\tfuse_change_entry_timeout(entry, &outarg);\n\telse\n\t\tfuse_invalidate_entry_cache(entry);\n\n\tif (inode)\n\t\tfuse_advise_use_readdirplus(dir);\n\treturn newent;\n\n out_iput:\n\tiput(inode);\n out_err:\n\treturn ERR_PTR(err);\n}","23821":"static struct sctp_packet *sctp_ootb_pkt_new(struct net *net,\n\t\t\t\t\t     const struct sctp_association *asoc,\n\t\t\t\t\t     const struct sctp_chunk *chunk)\n{\n\tstruct sctp_packet *packet;\n\tstruct sctp_transport *transport;\n\t__u16 sport;\n\t__u16 dport;\n\t__u32 vtag;\n\n\t\n\tsport = ntohs(chunk->sctp_hdr->dest);\n\tdport = ntohs(chunk->sctp_hdr->source);\n\n\t\n\tif (asoc) {\n\t\t\n\t\tswitch (chunk->chunk_hdr->type) {\n\t\tcase SCTP_CID_INIT_ACK:\n\t\t{\n\t\t\tsctp_initack_chunk_t *initack;\n\n\t\t\tinitack = (sctp_initack_chunk_t *)chunk->chunk_hdr;\n\t\t\tvtag = ntohl(initack->init_hdr.init_tag);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tvtag = asoc->peer.i.init_tag;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t\n\t\tswitch (chunk->chunk_hdr->type) {\n\t\tcase SCTP_CID_INIT:\n\t\t{\n\t\t\tsctp_init_chunk_t *init;\n\n\t\t\tinit = (sctp_init_chunk_t *)chunk->chunk_hdr;\n\t\t\tvtag = ntohl(init->init_hdr.init_tag);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tvtag = ntohl(chunk->sctp_hdr->vtag);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\ttransport = sctp_transport_new(net, sctp_source(chunk), GFP_ATOMIC);\n\tif (!transport)\n\t\tgoto nomem;\n\n\t\n\tsctp_transport_route(transport, (union sctp_addr *)&chunk->dest,\n\t\t\t     sctp_sk(net->sctp.ctl_sock));\n\n\tpacket = sctp_packet_init(&transport->packet, transport, sport, dport);\n\tpacket = sctp_packet_config(packet, vtag, 0);\n\n\treturn packet;\n\nnomem:\n\treturn NULL;\n}","23802":"static unsigned long nfs_reqs_to_commit(struct nfs_commit_info *cinfo)\n{\n\treturn 0;\n}","22820":"lys_node_free(struct lys_node *node, void (*private_destructor)(const struct lys_node *node, void *priv), int shallow)\n{\n    struct ly_ctx *ctx;\n    struct lys_node *sub, *next;\n\n    if (!node) {\n        return;\n    }\n\n    assert(node->module);\n    assert(node->module->ctx);\n\n    ctx = node->module->ctx;\n\n    \n    if (node->priv && private_destructor) {\n        private_destructor(node, node->priv);\n    }\n\n    \n    lydict_remove(ctx, node->name);\n    if (!(node->nodetype & (LYS_INPUT | LYS_OUTPUT))) {\n        lys_iffeature_free(ctx, node->iffeature, node->iffeature_size, shallow, private_destructor);\n        lydict_remove(ctx, node->dsc);\n        lydict_remove(ctx, node->ref);\n    }\n\n    if (!shallow && !(node->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n        LY_TREE_FOR_SAFE(node->child, next, sub) {\n            lys_node_free(sub, private_destructor, 0);\n        }\n    }\n\n    lys_extension_instances_free(ctx, node->ext, node->ext_size, private_destructor);\n\n    \n    switch (node->nodetype) {\n    case LYS_CONTAINER:\n        lys_container_free(ctx, (struct lys_node_container *)node, private_destructor);\n        break;\n    case LYS_CHOICE:\n        lys_when_free(ctx, ((struct lys_node_choice *)node)->when, private_destructor);\n        break;\n    case LYS_LEAF:\n        lys_leaf_free(ctx, (struct lys_node_leaf *)node, private_destructor);\n        break;\n    case LYS_LEAFLIST:\n        lys_leaflist_free(ctx, (struct lys_node_leaflist *)node, private_destructor);\n        break;\n    case LYS_LIST:\n        lys_list_free(ctx, (struct lys_node_list *)node, private_destructor);\n        break;\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        lys_anydata_free(ctx, (struct lys_node_anydata *)node, private_destructor);\n        break;\n    case LYS_USES:\n        lys_uses_free(ctx, (struct lys_node_uses *)node, private_destructor);\n        break;\n    case LYS_CASE:\n        lys_when_free(ctx, ((struct lys_node_case *)node)->when, private_destructor);\n        break;\n    case LYS_AUGMENT:\n        \n        break;\n    case LYS_GROUPING:\n        lys_grp_free(ctx, (struct lys_node_grp *)node, private_destructor);\n        break;\n    case LYS_RPC:\n    case LYS_ACTION:\n        lys_rpc_action_free(ctx, (struct lys_node_rpc_action *)node, private_destructor);\n        break;\n    case LYS_NOTIF:\n        lys_notif_free(ctx, (struct lys_node_notif *)node, private_destructor);\n        break;\n    case LYS_INPUT:\n    case LYS_OUTPUT:\n        lys_inout_free(ctx, (struct lys_node_inout *)node, private_destructor);\n        break;\n    case LYS_EXT:\n    case LYS_UNKNOWN:\n        LOGINT(ctx);\n        break;\n    }\n\n    \n    lys_node_unlink(node);\n    free(node);\n}","23026":"TPM_EO_Unmarshal(TPM_EO *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = UINT16_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n\t  case TPM_EO_EQ:\n\t  case TPM_EO_NEQ:\n\t  case TPM_EO_SIGNED_GT:\n\t  case TPM_EO_UNSIGNED_GT:\n\t  case TPM_EO_SIGNED_LT:\n\t  case TPM_EO_UNSIGNED_LT:\n\t  case TPM_EO_SIGNED_GE:\n\t  case TPM_EO_UNSIGNED_GE:\n\t  case TPM_EO_SIGNED_LE:\n\t  case TPM_EO_UNSIGNED_LE:\n\t  case TPM_EO_BITSET:\n\t  case TPM_EO_BITCLEAR:\n\t    break;\n\t  default:\n\t    rc = TPM_RC_VALUE;\n\t}\n    }\n    return rc;\n}","22654":"int gnutls_x509_crt_get_serial(gnutls_x509_crt_t cert, void *result,\n\t\t\t       size_t * result_size)\n{\n    int ret;\n\n    if (cert == NULL) {\n\tgnutls_assert();\n\treturn GNUTLS_E_INVALID_REQUEST;\n    }\n\n    if ((ret =\n\t asn1_read_value(cert->cert, \"STR\", result,\n\t\t\t result_size)) < 0) {\n\tgnutls_assert();\n\treturn _gnutls_asn2err(ret);\n    }\n\n    return 0;\n}","23632":"int _gnutls_get_session_ticket_decryption_key(gnutls_session_t session,\n\t\t\t\t\t      const gnutls_datum_t *ticket_data,\n\t\t\t\t\t      gnutls_datum_t *key_name,\n\t\t\t\t\t      gnutls_datum_t *mac_key,\n\t\t\t\t\t      gnutls_datum_t *enc_key)\n{\n\tint retval;\n\tgnutls_datum_t key = {\n\t\t.data = session->key.session_ticket_key,\n\t\t.size = TICKET_MASTER_KEY_SIZE\n\t};\n\n\tif (unlikely(session == NULL || ticket_data == NULL || ticket_data->data == NULL))\n\t\treturn gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);\n\n\tif (ticket_data->size < TICKET_KEY_NAME_SIZE)\n\t\treturn gnutls_assert_val(GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE);\n\n\tif ((retval = rotate(session)) < 0)\n\t\treturn gnutls_assert_val(retval);\n\n\t\n\tif (memcmp(ticket_data->data,\n\t\t   &key.data[NAME_POS],\n\t\t   TICKET_KEY_NAME_SIZE) == 0)\n\t\tgoto key_found;\n\n\tkey.size = TICKET_MASTER_KEY_SIZE;\n\tkey.data = session->key.previous_ticket_key;\n\n\t\n\tif ((retval = rotate_back_and_peek(session, key.data)) < 0)\n\t\treturn gnutls_assert_val(retval);\n\n\tif (memcmp(ticket_data->data,\n\t\t   &key.data[NAME_POS],\n\t\t   TICKET_KEY_NAME_SIZE) == 0)\n\t\tgoto key_found;\n\n\treturn GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE;\n\nkey_found:\n\tif (key_name) {\n\t\tkey_name->data = &key.data[NAME_POS];\n\t\tkey_name->size = TICKET_KEY_NAME_SIZE;\n\t}\n\tif (mac_key) {\n\t\tmac_key->data = &key.data[MAC_SECRET_POS];\n\t\tmac_key->size = TICKET_MAC_SECRET_SIZE;\n\t}\n\tif (enc_key) {\n\t\tenc_key->data = &key.data[KEY_POS];\n\t\tenc_key->size = TICKET_CIPHER_KEY_SIZE;\n\t}\n\n\treturn GNUTLS_E_SUCCESS;\n}","23080":"static int lxc_attach_remount_sys_proc(void)\n{\n\tint ret;\n\n\tret = unshare(CLONE_NEWNS);\n\tif (ret < 0) {\n\t\tSYSERROR(\"STR\");\n\t\treturn -1;\n\t}\n\n\tif (detect_shared_rootfs()) {\n\t\tif (mount(NULL, \"STR\", NULL, MS_SLAVE|MS_REC, NULL)) {\n\t\t\tSYSERROR(\"STR\");\n\t\t\tERROR(\"STR\");\n\t\t}\n\t}\n\n\t\n\tret = umount2(\"STR\", MNT_DETACH);\n\tif (ret < 0) {\n\t\tSYSERROR(\"STR\");\n\t\treturn -1;\n\t}\n\n\tret = mount(\"STR\", 0, NULL);\n\tif (ret < 0) {\n\t\tSYSERROR(\"STR\");\n\t\treturn -1;\n\t}\n\n\t\n\tret = umount2(\"STR\", MNT_DETACH);\n\tif (ret < 0 && errno != EINVAL) {\n\t\tSYSERROR(\"STR\");\n\t\treturn -1;\n\t} else if (ret == 0) {\n\t\t\n\t\tret = mount(\"STR\", 0, NULL);\n\t\tif (ret < 0) {\n\t\t\tSYSERROR(\"STR\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}","23252":"static int gup_pte_range(pmd_t pmd, unsigned long addr, unsigned long end,\n\t\t\t unsigned int flags, struct page **pages, int *nr)\n{\n\treturn 0;\n}","22676":"COMPAT_SYSCALL_DEFINE5(mq_timedsend, mqd_t, mqdes,\n\t\t       const char __user *, u_msg_ptr,\n\t\t       compat_size_t, msg_len, unsigned int, msg_prio,\n\t\t       const struct compat_timespec __user *, u_abs_timeout)\n{\n\tstruct timespec ts, *p = NULL;\n\tif (u_abs_timeout) {\n\t\tint res = compat_prepare_timeout(u_abs_timeout, &ts);\n\t\tif (res)\n\t\t\treturn res;\n\t\tp = &ts;\n\t}\n\treturn do_mq_timedsend(mqdes, u_msg_ptr, msg_len, msg_prio, p);\n}","22790":"static struct sctp_auth_bytes *sctp_auth_create_key(__u32 key_len, gfp_t gfp)\n{\n\tstruct sctp_auth_bytes *key;\n\n\t\n\tkey = kmalloc(sizeof(struct sctp_auth_bytes) + key_len, gfp);\n\tif (!key)\n\t\treturn NULL;\n\n\tkey->len = key_len;\n\tatomic_set(&key->refcnt, 1);\n\tSCTP_DBG_OBJCNT_INC(keys);\n\n\treturn key;\n}","23741":"tilde_initialize ()\n{\n  static int times_called = 0;\n\n  \n  tilde_expansion_preexpansion_hook = bash_special_tilde_expansions;\n\n  \n  if (times_called++ == 0)\n    {\n      bash_tilde_prefixes = strvec_create (3);\n      bash_tilde_prefixes[0] = \"STR\";\n      bash_tilde_prefixes[1] = \"STR\";\n      bash_tilde_prefixes[2] = (char *)NULL;\n\n      bash_tilde_prefixes2 = strvec_create (2);\n      bash_tilde_prefixes2[0] = \"STR\";\n      bash_tilde_prefixes2[1] = (char *)NULL;\n\n      tilde_additional_prefixes = bash_tilde_prefixes;\n\n      bash_tilde_suffixes = strvec_create (3);\n      bash_tilde_suffixes[0] = \"STR\";\n      bash_tilde_suffixes[1] = \"STR\";\t\n      bash_tilde_suffixes[2] = (char *)NULL;\n\n      tilde_additional_suffixes = bash_tilde_suffixes;\n\n      bash_tilde_suffixes2 = strvec_create (2);\n      bash_tilde_suffixes2[0] = \"STR\";\n      bash_tilde_suffixes2[1] = (char *)NULL;\n    }\n}","22976":"Status genTableRowsForSqliteTable(const fs::path& sqlite_db,\n                                  const std::string& sqlite_query,\n                                  TableRows& results,\n                                  bool respect_locking) {\n  sqlite3* db = nullptr;\n  if (!pathExists(sqlite_db).ok()) {\n    return Status(1, \"STR\");\n  }\n\n  auto rc = sqlite3_open_v2(\n      sqlite_db.string().c_str(),\n      &db,\n      (SQLITE_OPEN_READONLY | SQLITE_OPEN_PRIVATECACHE | SQLITE_OPEN_NOMUTEX),\n      getSystemVFS(respect_locking));\n  if (rc != SQLITE_OK || db == nullptr) {\n    VLOG(1) << \"STR\"\n            << getStringForSQLiteReturnCode(rc);\n    if (db != nullptr) {\n      sqlite3_close(db);\n    }\n    return Status(1, \"STR\");\n  }\n\n  sqlite3_stmt* stmt = nullptr;\n  rc = sqlite3_prepare_v2(db, sqlite_query.c_str(), -1, &stmt, nullptr);\n  if (rc != SQLITE_OK) {\n    sqlite3_close(db);\n    VLOG(1) << \"STR\" << sqlite_db;\n    return Status(rc, \"STR\");\n  }\n\n  while ((sqlite3_step(stmt)) == SQLITE_ROW) {\n    auto s = genSqliteTableRow(stmt, results, sqlite_db);\n    if (!s.ok()) {\n      break;\n    }\n  }\n\n  \n  sqlite3_finalize(stmt);\n  sqlite3_close(db);\n\n  return Status{};\n}","23684":"static void GTextFieldGrabPrimarySelection(GTextField *gt) {\n    int ss = gt->sel_start, se = gt->sel_end;\n\n    GDrawGrabSelection(gt->g.base,sn_primary);\n    gt->sel_start = ss; gt->sel_end = se;\n    GDrawAddSelectionType(gt->g.base,sn_primary,\"STR\",gt,gt->sel_end-gt->sel_start,\n\t    sizeof(unichar_t),\n\t    genunicodedata,noop);\n    GDrawAddSelectionType(gt->g.base,sn_primary,\"STR\",gt,gt->sel_end-gt->sel_start,\n\t    sizeof(char),\n\t    genutf8data,noop);\n    GDrawAddSelectionType(gt->g.base,sn_primary,\"STR\",gt,gt->sel_end-gt->sel_start,\n\t    sizeof(char),\n\t    genutf8data,noop);\n    GDrawAddSelectionType(gt->g.base,sn_primary,\"STR\",gt,gt->sel_end-gt->sel_start,\n\t    sizeof(char),\n\t    genlocaldata,noop);\n}","23808":"absl::optional<CelValue> ResponseWrapper::operator[](CelValue key) const {\n  if (!key.IsString()) {\n    return {};\n  }\n  auto value = key.StringOrDie().value();\n  if (value == Code) {\n    auto code = info_.responseCode();\n    if (code.has_value()) {\n      return CelValue::CreateInt64(code.value());\n    }\n  } else if (value == Size) {\n    return CelValue::CreateInt64(info_.bytesSent());\n  } else if (value == Headers) {\n    return CelValue::CreateMap(&headers_);\n  } else if (value == Trailers) {\n    return CelValue::CreateMap(&trailers_);\n  }\n  return {};\n}","22497":"void brcmf_rx_event(struct device *dev, struct sk_buff *skb)\n{\n\tstruct brcmf_if *ifp;\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\n\tbrcmf_dbg(EVENT, \"STR\", dev_name(dev), skb);\n\n\tif (brcmf_rx_hdrpull(drvr, skb, &ifp))\n\t\treturn;\n\n\tbrcmf_fweh_process_skb(ifp->drvr, skb);\n\tbrcmu_pkt_buf_free_skb(skb);\n}","22779":"static int __init hugetlb_init(void)\n{\n\tint i;\n\n\tBUILD_BUG_ON(sizeof_field(struct page, private) * BITS_PER_BYTE <\n\t\t\t__NR_HPAGEFLAGS);\n\n\tif (!hugepages_supported()) {\n\t\tif (hugetlb_max_hstate || default_hstate_max_huge_pages)\n\t\t\tpr_warn(\"STR\");\n\t\treturn 0;\n\t}\n\n\t\n\thugetlb_add_hstate(HUGETLB_PAGE_ORDER);\n\tif (!parsed_default_hugepagesz) {\n\t\t\n\t\tdefault_hstate_idx = hstate_index(size_to_hstate(HPAGE_SIZE));\n\t\tif (default_hstate_max_huge_pages) {\n\t\t\tif (default_hstate.max_huge_pages) {\n\t\t\t\tchar buf[32];\n\n\t\t\t\tstring_get_size(huge_page_size(&default_hstate),\n\t\t\t\t\t1, STRING_UNITS_2, buf, 32);\n\t\t\t\tpr_warn(\"STR\",\n\t\t\t\t\tdefault_hstate.max_huge_pages, buf);\n\t\t\t\tpr_warn(\"STR\",\n\t\t\t\t\tdefault_hstate_max_huge_pages);\n\t\t\t}\n\t\t\tdefault_hstate.max_huge_pages =\n\t\t\t\tdefault_hstate_max_huge_pages;\n\n\t\t\tfor (i = 0; i < nr_online_nodes; i++)\n\t\t\t\tdefault_hstate.max_huge_pages_node[i] =\n\t\t\t\t\tdefault_hugepages_in_node[i];\n\t\t}\n\t}\n\n\thugetlb_cma_check();\n\thugetlb_init_hstates();\n\tgather_bootmem_prealloc();\n\treport_hugepages();\n\n\thugetlb_sysfs_init();\n\thugetlb_register_all_nodes();\n\thugetlb_cgroup_file_init();\n\n#ifdef CONFIG_SMP\n\tnum_fault_mutexes = roundup_pow_of_two(8 * num_possible_cpus());\n#else\n\tnum_fault_mutexes = 1;\n#endif\n\thugetlb_fault_mutex_table =\n\t\tkmalloc_array(num_fault_mutexes, sizeof(struct mutex),\n\t\t\t      GFP_KERNEL);\n\tBUG_ON(!hugetlb_fault_mutex_table);\n\n\tfor (i = 0; i < num_fault_mutexes; i++)\n\t\tmutex_init(&hugetlb_fault_mutex_table[i]);\n\treturn 0;\n}","23405":"UINT16_Marshal(UINT16 *source, BYTE **buffer, INT32 *size)\n{\n    if (buffer != NULL) {\n\tif ((size == NULL) || ((UINT32)*size >= sizeof(UINT16))) {\n\n\t    (*buffer)[0] = (BYTE)((*source >> 8) & 0xff);\n\t    (*buffer)[1] = (BYTE)((*source >> 0) & 0xff);\n\t    *buffer += sizeof(UINT16);\n\n\t    if (size != NULL) {\n\t\t*size -= sizeof(UINT16);\n\t    }\n\t}\n\telse {\n\t    pAssert(FALSE);\n\t}\n    }\n    return sizeof(UINT16);\n}","23522":"int ssl3_get_next_proto(SSL *s)\n\t{\n\tint ok;\n\tint proto_len, padding_len;\n\tlong n;\n\tconst unsigned char *p;\n\n\t\n\tif (!s->s3->next_proto_neg_seen)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_NEXT_PROTO,SSL_R_GOT_NEXT_PROTO_WITHOUT_EXTENSION);\n\t\treturn -1;\n\t\t}\n\n\tn=s->method->ssl_get_message(s,\n\t\tSSL3_ST_SR_NEXT_PROTO_A,\n\t\tSSL3_ST_SR_NEXT_PROTO_B,\n\t\tSSL3_MT_NEXT_PROTO,\n\t\t514,  \n\t\t&ok);\n\n\tif (!ok)\n\t\treturn((int)n);\n\n\t\n\tif (!s->s3->change_cipher_spec)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_NEXT_PROTO,SSL_R_GOT_NEXT_PROTO_BEFORE_A_CCS);\n\t\treturn -1;\n\t\t}\n\n\tif (n < 2)\n\t\treturn 0;  \n\n\tp=(unsigned char *)s->init_msg;\n\n\t\n\tproto_len = p[0];\n\tif (proto_len + 2 > s->init_num)\n\t\treturn 0;\n\tpadding_len = p[proto_len + 1];\n\tif (proto_len + padding_len + 2 != s->init_num)\n\t\treturn 0;\n\n\ts->next_proto_negotiated = OPENSSL_malloc(proto_len);\n\tif (!s->next_proto_negotiated)\n\t\t{\n\t\tSSLerr(SSL_F_SSL3_GET_NEXT_PROTO,ERR_R_MALLOC_FAILURE);\n\t\treturn 0;\n\t\t}\n\tmemcpy(s->next_proto_negotiated, p + 1, proto_len);\n\ts->next_proto_negotiated_len = proto_len;\n\n\treturn 1;\n\t}","23406":"OPJ_BOOL opj_tcd_encode_tile(opj_tcd_t *p_tcd,\n                             OPJ_UINT32 p_tile_no,\n                             OPJ_BYTE *p_dest,\n                             OPJ_UINT32 * p_data_written,\n                             OPJ_UINT32 p_max_length,\n                             opj_codestream_info_t *p_cstr_info,\n                             opj_event_mgr_t *p_manager)\n{\n\n    if (p_tcd->cur_tp_num == 0) {\n\n        p_tcd->tcd_tileno = p_tile_no;\n        p_tcd->tcp = &p_tcd->cp->tcps[p_tile_no];\n\n        \n        if (p_cstr_info)  {\n            OPJ_UINT32 l_num_packs = 0;\n            OPJ_UINT32 i;\n            opj_tcd_tilecomp_t *l_tilec_idx =\n                &p_tcd->tcd_image->tiles->comps[0];        \n            opj_tccp_t *l_tccp = p_tcd->tcp->tccps; \n\n            for (i = 0; i < l_tilec_idx->numresolutions; i++) {\n                opj_tcd_resolution_t *l_res_idx = &l_tilec_idx->resolutions[i];\n\n                p_cstr_info->tile[p_tile_no].pw[i] = (int)l_res_idx->pw;\n                p_cstr_info->tile[p_tile_no].ph[i] = (int)l_res_idx->ph;\n\n                l_num_packs += l_res_idx->pw * l_res_idx->ph;\n                p_cstr_info->tile[p_tile_no].pdx[i] = (int)l_tccp->prcw[i];\n                p_cstr_info->tile[p_tile_no].pdy[i] = (int)l_tccp->prch[i];\n            }\n            p_cstr_info->tile[p_tile_no].packet = (opj_packet_info_t*) opj_calloc((\n                    OPJ_SIZE_T)p_cstr_info->numcomps * (OPJ_SIZE_T)p_cstr_info->numlayers *\n                                                  l_num_packs,\n                                                  sizeof(opj_packet_info_t));\n            if (!p_cstr_info->tile[p_tile_no].packet) {\n                \n                return OPJ_FALSE;\n            }\n        }\n        \n\n        \n        \n        if (! opj_tcd_dc_level_shift_encode(p_tcd)) {\n            return OPJ_FALSE;\n        }\n        \n\n        \n        if (! opj_tcd_mct_encode(p_tcd)) {\n            return OPJ_FALSE;\n        }\n        \n\n        \n        if (! opj_tcd_dwt_encode(p_tcd)) {\n            return OPJ_FALSE;\n        }\n        \n\n        \n        if (! opj_tcd_t1_encode(p_tcd)) {\n            return OPJ_FALSE;\n        }\n        \n\n        \n        if (! opj_tcd_rate_allocate_encode(p_tcd, p_dest, p_max_length,\n                                           p_cstr_info, p_manager)) {\n            return OPJ_FALSE;\n        }\n        \n\n    }\n    \n\n    \n    if (p_cstr_info) {\n        p_cstr_info->index_write = 1;\n    }\n    \n\n    if (! opj_tcd_t2_encode(p_tcd, p_dest, p_data_written, p_max_length,\n                            p_cstr_info, p_manager)) {\n        return OPJ_FALSE;\n    }\n    \n\n    \n\n    return OPJ_TRUE;\n}","23061":"static int decode_attr_type(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *type)\n{\n\t__be32 *p;\n\tint ret = 0;\n\n\t*type = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_TYPE - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_TYPE)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\treturn -EIO;\n\t\t*type = be32_to_cpup(p);\n\t\tif (*type < NF4REG || *type > NF4NAMEDATTR) {\n\t\t\tdprintk(\"STR\", __func__, *type);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbitmap[0] &= ~FATTR4_WORD0_TYPE;\n\t\tret = NFS_ATTR_FATTR_TYPE;\n\t}\n\tdprintk(\"STR\", __func__, nfs_type2fmt[*type]);\n\treturn ret;\n}","23738":"static int call_extract_if_dead(struct connectdata *conn, void *param)\n{\n  struct prunedead *p = (struct prunedead *)param;\n  if(extract_if_dead(conn, p->data)) {\n    \n    p->extracted = conn;\n    return 1;\n  }\n  return 0; \n}","23161":"vhost_backend_cleanup(struct virtio_net *dev)\n{\n\tif (dev->mem) {\n\t\tfree_mem_region(dev);\n\t\trte_free(dev->mem);\n\t\tdev->mem = NULL;\n\t}\n\n\trte_free(dev->guest_pages);\n\tdev->guest_pages = NULL;\n\n\tif (dev->log_addr) {\n\t\tmunmap((void *)(uintptr_t)dev->log_addr, dev->log_size);\n\t\tdev->log_addr = 0;\n\t}\n\n\tif (dev->inflight_info) {\n\t\tif (dev->inflight_info->addr) {\n\t\t\tmunmap(dev->inflight_info->addr,\n\t\t\t       dev->inflight_info->size);\n\t\t\tdev->inflight_info->addr = NULL;\n\t\t}\n\n\t\tif (dev->inflight_info->fd > 0) {\n\t\t\tclose(dev->inflight_info->fd);\n\t\t\tdev->inflight_info->fd = -1;\n\t\t}\n\n\t\tfree(dev->inflight_info);\n\t\tdev->inflight_info = NULL;\n\t}\n\n\tif (dev->slave_req_fd >= 0) {\n\t\tclose(dev->slave_req_fd);\n\t\tdev->slave_req_fd = -1;\n\t}\n\n\tif (dev->postcopy_ufd >= 0) {\n\t\tclose(dev->postcopy_ufd);\n\t\tdev->postcopy_ufd = -1;\n\t}\n\n\tdev->postcopy_listening = 0;\n}","23758":"void AveragePool(const float* input_data, const Dims<4>& input_dims, int stride,\n                 int pad_width, int pad_height, int filter_width,\n                 int filter_height, float* output_data,\n                 const Dims<4>& output_dims) {\n  AveragePool<Ac>(input_data, input_dims, stride, stride, pad_width, pad_height,\n                  filter_width, filter_height, output_data, output_dims);\n}","23749":"static int sco_sock_getsockopt_old(struct socket *sock, int optname,\n\t\t\t\t   char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_options opts;\n\tstruct sco_conninfo cinfo;\n\tint len, err = 0;\n\n\tBT_DBG(\"STR\", sk);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase SCO_OPTIONS:\n\t\tif (sk->sk_state != BT_CONNECTED &&\n\t\t    !(sk->sk_state == BT_CONNECT2 &&\n\t\t      test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags))) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\topts.mtu = sco_pi(sk)->conn->mtu;\n\n\t\tBT_DBG(\"STR\", opts.mtu);\n\n\t\tlen = min_t(unsigned int, len, sizeof(opts));\n\t\tif (copy_to_user(optval, (char *)&opts, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase SCO_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED &&\n\t\t    !(sk->sk_state == BT_CONNECT2 &&\n\t\t      test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags))) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(&cinfo, 0, sizeof(cinfo));\n\t\tcinfo.hci_handle = sco_pi(sk)->conn->hcon->handle;\n\t\tmemcpy(cinfo.dev_class, sco_pi(sk)->conn->hcon->dev_class, 3);\n\n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *)&cinfo, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}","22644":"QPDFXRefEntry::getObjStreamNumber() const\n{\n    if (this->type != 2)\n    {\n\tthrow std::logic_error(\n\t    \"STR\");\n    }\n    return this->field1;\n}","23507":"setup_connection (GsmXSMPClient *client)\n{\n        GIOChannel    *channel;\n        int            fd;\n\n        g_debug (\"STR\");\n\n        fd = IceConnectionNumber (client->priv->ice_connection);\n        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n        channel = g_io_channel_unix_new (fd);\n        client->priv->watch_id = g_io_add_watch (channel,\n                                                 G_IO_IN | G_IO_ERR,\n                                                 (GIOFunc)client_iochannel_watch,\n                                                 client);\n        g_io_channel_unref (channel);\n\n        client->priv->protocol_timeout = g_timeout_add_seconds (5,\n                                                                (GSourceFunc)_client_protocol_timeout,\n                                                                client);\n\n        set_description (client);\n\n        g_debug (\"STR\", client->priv->description);\n}","23446":"NCURSES_SP_NAME(_nc_do_color) (NCURSES_SP_DCLx\n\t\t\t       int old_pair,\n\t\t\t       int pair,\n\t\t\t       int reverse,\n\t\t\t       NCURSES_SP_OUTC outc)\n{\n#ifdef USE_TERM_DRIVER\n    CallDriver_4(SP_PARM, td_docolor, old_pair, pair, reverse, outc);\n#else\n    int fg = COLOR_DEFAULT;\n    int bg = COLOR_DEFAULT;\n    int old_fg = -1;\n    int old_bg = -1;\n\n    if (!ValidPair(SP_PARM, pair)) {\n\treturn;\n    } else if (pair != 0) {\n\tif (set_color_pair) {\n\t    TPUTS_TRACE(\"STR\");\n\t    NCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\t    TPARM_1(set_color_pair, pair),\n\t\t\t\t    1, outc);\n\t    return;\n\t} else if (SP_PARM != 0) {\n\t    if (_nc_pair_content(SP_PARM, pair, &fg, &bg) == ERR)\n\t\treturn;\n\t}\n    }\n\n    if (old_pair >= 0\n\t&& SP_PARM != 0\n\t&& _nc_pair_content(SP_PARM, old_pair, &old_fg, &old_bg) != ERR) {\n\tif ((isDefaultColor(fg) && !isDefaultColor(old_fg))\n\t    || (isDefaultColor(bg) && !isDefaultColor(old_bg))) {\n#if NCURSES_EXT_FUNCS\n\t    \n\t    if (SP_PARM->_has_sgr_39_49\n\t\t&& isDefaultColor(old_bg)\n\t\t&& !isDefaultColor(old_fg)) {\n\t\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx \"STR\", 1, outc);\n\t    } else if (SP_PARM->_has_sgr_39_49\n\t\t       && isDefaultColor(old_fg)\n\t\t       && !isDefaultColor(old_bg)) {\n\t\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx \"STR\", 1, outc);\n\t    } else\n#endif\n\t\treset_color_pair(NCURSES_SP_ARG);\n\t}\n    } else {\n\treset_color_pair(NCURSES_SP_ARG);\n\tif (old_pair < 0 && pair <= 0)\n\t    return;\n    }\n\n#if NCURSES_EXT_FUNCS\n    if (isDefaultColor(fg))\n\tfg = default_fg(NCURSES_SP_ARG);\n    if (isDefaultColor(bg))\n\tbg = default_bg(NCURSES_SP_ARG);\n#endif\n\n    if (reverse) {\n\tint xx = fg;\n\tfg = bg;\n\tbg = xx;\n    }\n\n    TR(TRACE_ATTRS, (\"STR\", pair,\n\t\t     fg, bg));\n\n    if (!isDefaultColor(fg)) {\n\tset_foreground_color(NCURSES_SP_ARGx fg, outc);\n    }\n    if (!isDefaultColor(bg)) {\n\tset_background_color(NCURSES_SP_ARGx bg, outc);\n    }\n#endif\n}","23818":"xhtmlIsEmpty(xmlNodePtr node) {\n    if (node == NULL)\n\treturn(-1);\n    if (node->type != XML_ELEMENT_NODE)\n\treturn(0);\n    if ((node->ns != NULL) && (!xmlStrEqual(node->ns->href, XHTML_NS_NAME)))\n\treturn(0);\n    if (node->children != NULL)\n\treturn(0);\n    switch (node->name[0]) {\n\tcase 'a':\n\t    if (xmlStrEqual(node->name, BAD_CAST \"STR\"))\n\t\treturn(1);\n\t    return(0);\n\tcase 'b':\n\t    if (xmlStrEqual(node->name, BAD_CAST \"STR\"))\n\t\treturn(1);\n\t    if (xmlStrEqual(node->name, BAD_CAST \"STR\"))\n\t\treturn(1);\n\t    if (xmlStrEqual(node->name, BAD_CAST \"STR\"))\n\t\treturn(1);\n\t    return(0);\n\tcase 'c':\n\t    if (xmlStrEqual(node->name, BAD_CAST \"STR\"))\n\t\treturn(1);\n\t    return(0);\n\tcase 'f':\n\t    if (xmlStrEqual(node->name, BAD_CAST \"STR\"))\n\t\treturn(1);\n\t    return(0);\n\tcase 'h':\n\t    if (xmlStrEqual(node->name, BAD_CAST \"STR\"))\n\t\treturn(1);\n\t    return(0);\n\tcase 'i':\n\t    if (xmlStrEqual(node->name, BAD_CAST \"STR\"))\n\t\treturn(1);\n\t    if (xmlStrEqual(node->name, BAD_CAST \"STR\"))\n\t\treturn(1);\n\t    if (xmlStrEqual(node->name, BAD_CAST \"STR\"))\n\t\treturn(1);\n\t    return(0);\n\tcase 'l':\n\t    if (xmlStrEqual(node->name, BAD_CAST \"STR\"))\n\t\treturn(1);\n\t    return(0);\n\tcase 'm':\n\t    if (xmlStrEqual(node->name, BAD_CAST \"STR\"))\n\t\treturn(1);\n\t    return(0);\n\tcase 'p':\n\t    if (xmlStrEqual(node->name, BAD_CAST \"STR\"))\n\t\treturn(1);\n\t    return(0);\n    }\n    return(0);\n}","23564":"hugetlbfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct inode * inode;\n\tstruct dentry * root;\n\tint ret;\n\tstruct hugetlbfs_config config;\n\tstruct hugetlbfs_sb_info *sbinfo;\n\n\tsave_mount_options(sb, data);\n\n\tconfig.nr_blocks = -1; \n\tconfig.nr_inodes = -1; \n\tconfig.uid = current_fsuid();\n\tconfig.gid = current_fsgid();\n\tconfig.mode = 0755;\n\tconfig.hstate = &default_hstate;\n\tret = hugetlbfs_parse_options(data, &config);\n\tif (ret)\n\t\treturn ret;\n\n\tsbinfo = kmalloc(sizeof(struct hugetlbfs_sb_info), GFP_KERNEL);\n\tif (!sbinfo)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = sbinfo;\n\tsbinfo->hstate = config.hstate;\n\tspin_lock_init(&sbinfo->stat_lock);\n\tsbinfo->max_blocks = config.nr_blocks;\n\tsbinfo->free_blocks = config.nr_blocks;\n\tsbinfo->max_inodes = config.nr_inodes;\n\tsbinfo->free_inodes = config.nr_inodes;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_blocksize = huge_page_size(config.hstate);\n\tsb->s_blocksize_bits = huge_page_shift(config.hstate);\n\tsb->s_magic = HUGETLBFS_MAGIC;\n\tsb->s_op = &hugetlbfs_ops;\n\tsb->s_time_gran = 1;\n\tinode = hugetlbfs_get_root(sb, &config);\n\tif (!inode)\n\t\tgoto out_free;\n\n\troot = d_alloc_root(inode);\n\tif (!root) {\n\t\tiput(inode);\n\t\tgoto out_free;\n\t}\n\tsb->s_root = root;\n\treturn 0;\nout_free:\n\tkfree(sbinfo);\n\treturn -ENOMEM;\n}","22680":"int tipc_dump_done(struct netlink_callback *cb)\n{\n\tstruct rhashtable_iter *hti = (void *)cb->args[4];\n\n\trhashtable_walk_exit(hti);\n\tkfree(hti);\n\treturn 0;\n}","23350":"int smb_vfs_call_sys_acl_get_perm(struct vfs_handle_struct *handle,\n\t\t\t\t  SMB_ACL_PERMSET_T permset,\n\t\t\t\t  SMB_ACL_PERM_T perm)\n{\n\tVFS_FIND(sys_acl_get_perm);\n\treturn handle->fns->sys_acl_get_perm(handle, permset, perm);\n}","23597":"static void dumpnode(Renode *node)\n{\n\tRune *p;\n\tif (!node) { printf(\"STR\"); return; }\n\tswitch (node->type) {\n\tcase P_CAT: printf(\"STR\"); break;\n\tcase P_ALT: printf(\"STR\"); break;\n\tcase P_REP:\n\t\tprintf(node->ng ? \"STR\", node->m, node->n);\n\t\tdumpnode(node->x);\n\t\tprintf(\"STR\");\n\t\tbreak;\n\tcase P_BOL: printf(\"STR\"); break;\n\tcase P_EOL: printf(\"STR\"); break;\n\tcase P_WORD: printf(\"STR\"); break;\n\tcase P_NWORD: printf(\"STR\"); break;\n\tcase P_PAR: printf(\"STR\"); break;\n\tcase P_PLA: printf(\"STR\"); break;\n\tcase P_NLA: printf(\"STR\"); break;\n\tcase P_ANY: printf(\"STR\"); break;\n\tcase P_CHAR: printf(\"STR\", node->c); break;\n\tcase P_CCLASS:\n\t\tprintf(\"STR\");\n\t\tfor (p = node->cc->spans; p < node->cc->end; p += 2) printf(\"STR\", p[0], p[1]);\n\t\tprintf(\"STR\");\n\t\tbreak;\n\tcase P_NCCLASS:\n\t\tprintf(\"STR\");\n\t\tfor (p = node->cc->spans; p < node->cc->end; p += 2) printf(\"STR\", p[0], p[1]);\n\t\tprintf(\"STR\");\n\t\tbreak;\n\tcase P_REF: printf(\"STR\", node->n); break;\n\t}\n}","23584":"static gboolean avdtp_reconf_cmd(struct avdtp *session, uint8_t transaction,\n\t\t\t\t\tstruct seid_req *req, int size)\n{\n\tstruct conf_rej rej;\n\n\trej.error = AVDTP_NOT_SUPPORTED_COMMAND;\n\trej.category = 0x00;\n\n\treturn avdtp_send(session, transaction, AVDTP_MSG_TYPE_REJECT,\n\t\t\t\t\tAVDTP_RECONFIGURE, &rej, sizeof(rej));\n}","22683":"uint32_t CompactProtocolWriter::writeListEnd() {\n  return 0;\n}","22986":"static void tulip_desc_read(TULIPState *s, hwaddr p,\n        struct tulip_descriptor *desc)\n{\n    const MemTxAttrs attrs = MEMTXATTRS_UNSPECIFIED;\n\n    if (s->csr[0] & CSR0_DBO) {\n        ldl_be_pci_dma(&s->dev, p, &desc->status, attrs);\n        ldl_be_pci_dma(&s->dev, p + 4, &desc->control, attrs);\n        ldl_be_pci_dma(&s->dev, p + 8, &desc->buf_addr1, attrs);\n        ldl_be_pci_dma(&s->dev, p + 12, &desc->buf_addr2, attrs);\n    } else {\n        ldl_le_pci_dma(&s->dev, p, &desc->status, attrs);\n        ldl_le_pci_dma(&s->dev, p + 4, &desc->control, attrs);\n        ldl_le_pci_dma(&s->dev, p + 8, &desc->buf_addr1, attrs);\n        ldl_le_pci_dma(&s->dev, p + 12, &desc->buf_addr2, attrs);\n    }\n}","22868":"static int psi_fop_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tpsi_trigger_replace(&seq->private, NULL);\n\treturn single_release(inode, file);\n}","23713":"int fcntl_dirnotify(int fd, struct file *filp, unsigned long arg)\n{\n\tstruct dnotify_struct *dn;\n\tstruct dnotify_struct *odn;\n\tstruct dnotify_struct **prev;\n\tstruct inode *inode;\n\tfl_owner_t id = current->files;\n\tint error = 0;\n\n\tif ((arg & ~DN_MULTISHOT) == 0) {\n\t\tdnotify_flush(filp, id);\n\t\treturn 0;\n\t}\n\tif (!dir_notify_enable)\n\t\treturn -EINVAL;\n\tinode = filp->f_path.dentry->d_inode;\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn -ENOTDIR;\n\tdn = kmem_cache_alloc(dn_cache, GFP_KERNEL);\n\tif (dn == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock(&inode->i_lock);\n\tprev = &inode->i_dnotify;\n\twhile ((odn = *prev) != NULL) {\n\t\tif ((odn->dn_owner == id) && (odn->dn_filp == filp)) {\n\t\t\todn->dn_fd = fd;\n\t\t\todn->dn_mask |= arg;\n\t\t\tinode->i_dnotify_mask |= arg & ~DN_MULTISHOT;\n\t\t\tgoto out_free;\n\t\t}\n\t\tprev = &odn->dn_next;\n\t}\n\n\terror = __f_setown(filp, task_pid(current), PIDTYPE_PID, 0);\n\tif (error)\n\t\tgoto out_free;\n\n\tdn->dn_mask = arg;\n\tdn->dn_fd = fd;\n\tdn->dn_filp = filp;\n\tdn->dn_owner = id;\n\tinode->i_dnotify_mask |= arg & ~DN_MULTISHOT;\n\tdn->dn_next = inode->i_dnotify;\n\tinode->i_dnotify = dn;\n\tspin_unlock(&inode->i_lock);\n\n\tif (filp->f_op && filp->f_op->dir_notify)\n\t\treturn filp->f_op->dir_notify(filp, arg);\n\treturn 0;\n\nout_free:\n\tspin_unlock(&inode->i_lock);\n\tkmem_cache_free(dn_cache, dn);\n\treturn error;\n}","23626":"void AES128GCM_OnWireRxHandler::reset_rx_handler()\n{\n  if(1 != EVP_DecryptInit_ex(ectx.get(), nullptr, nullptr, nullptr,\n\treinterpret_cast<const unsigned char*>(&nonce))) {\n    throw std::runtime_error(\"STR\");\n  }\n  ++nonce.random_seq;\n}","23290":"static int hardware_enable(void *garbage)\n{\n\tint cpu = raw_smp_processor_id();\n\tu64 phys_addr = __pa(per_cpu(vmxarea, cpu));\n\tu64 old, test_bits;\n\n\tif (read_cr4() & X86_CR4_VMXE)\n\t\treturn -EBUSY;\n\n\tINIT_LIST_HEAD(&per_cpu(vcpus_on_cpu, cpu));\n\trdmsrl(MSR_IA32_FEATURE_CONTROL, old);\n\n\ttest_bits = FEATURE_CONTROL_LOCKED;\n\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\tif (tboot_enabled())\n\t\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX;\n\n\tif ((old & test_bits) != test_bits) {\n\t\t\n\t\twrmsrl(MSR_IA32_FEATURE_CONTROL, old | test_bits);\n\t}\n\twrite_cr4(read_cr4() | X86_CR4_VMXE); \n\n\tif (vmm_exclusive) {\n\t\tkvm_cpu_vmxon(phys_addr);\n\t\tept_sync_global();\n\t}\n\n\treturn 0;\n}","22968":"get_nonprimary_guard_idle_timeout(void)\n{\n  return networkstatus_get_param(NULL,\n                                 \"STR\",\n                                 DFLT_NONPRIMARY_GUARD_IDLE_TIMEOUT,\n                                 1, INT32_MAX);\n}","23005":"void HRangeAnalysis::RollBackTo(int index) {\n  for (int i = index + 1; i < changed_ranges_.length(); ++i) {\n    changed_ranges_[i]->RemoveLastAddedRange();\n  }\n  changed_ranges_.Rewind(index + 1);\n}","22865":"static ZIPARCHIVE_METHOD(getArchiveComment)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tzend_long flags = 0;\n\tconst char * comment;\n\tint comment_len = 0;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"STR\", &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tcomment = zip_get_archive_comment(intern, &comment_len, (int)flags);\n\tif(comment==NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL((char *)comment, (zend_long)comment_len);\n}","23554":"QStandardItem* PeerListWidget::addPeer(const QString& ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer)\n{\n    int row = m_listModel->rowCount();\n    \n    m_listModel->insertRow(row);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP), ip, Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::IP_HIDDEN), ip);\n    if (m_resolveCountries) {\n        const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country());\n        if (!ico.isNull()) {\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole);\n            const QString countryName = Net::GeoIPManager::CountryName(peer.country());\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole);\n        }\n        else {\n            m_missingFlags.insert(ip);\n        }\n    }\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), peer.client());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance());\n    QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\"STR\")));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\"STR\")), Qt::ToolTipRole);\n\n    return m_listModel->item(row, PeerListDelegate::IP);\n}","23629":"GF_Err dinf_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataInformationBox *dinf;\n\tGF_Err e = gf_isom_box_array_read(s, bs);\n\tif (e) {\n\t\treturn e;\n\t}\n\tdinf = (GF_DataInformationBox *)s;\n\tif (!dinf->dref) {\n\t\tif (! (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"STR\"));\n\t\t}\n\t\tdinf->dref = (GF_DataReferenceBox *) gf_isom_box_new_parent(&dinf->child_boxes, GF_ISOM_BOX_TYPE_DREF);\n\t}\n\treturn GF_OK;\n}","23068":"static int __mlock_posix_error_return(long retval)\n{\n\tif (retval == -EFAULT)\n\t\tretval = -ENOMEM;\n\telse if (retval == -ENOMEM)\n\t\tretval = -EAGAIN;\n\treturn retval;\n}","22486":"int hci_conn_check_link_mode(struct hci_conn *conn)\n{\n\tBT_DBG(\"STR\", conn);\n\n\t\n\tif (hci_dev_test_flag(conn->hdev, HCI_SC_ONLY)) {\n\t\tif (!hci_conn_sc_enabled(conn) ||\n\t\t    !test_bit(HCI_CONN_AES_CCM, &conn->flags) ||\n\t\t    conn->key_type != HCI_LK_AUTH_COMBINATION_P256)\n\t\t\treturn 0;\n\t}\n\n\tif (hci_conn_ssp_enabled(conn) &&\n\t    !test_bit(HCI_CONN_ENCRYPT, &conn->flags))\n\t\treturn 0;\n\n\t\n\tif (conn->enc_key_size < HCI_MIN_ENC_KEY_SIZE)\n\t\treturn 0;\n\n\treturn 1;\n}","23609":"static inline u64 paravirt_steal_clock(int cpu)\n{\n\treturn PVOP_CALL1(u64, time.steal_clock, cpu);\n}","22592":"static int cmv_process_header(CmvContext *s, const uint8_t *buf, const uint8_t *buf_end)\n{\n    int pal_start, pal_count, i, ret, fps;\n\n    if(buf_end - buf < 16) {\n        av_log(s->avctx, AV_LOG_WARNING, \"STR\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->width  = AV_RL16(&buf[4]);\n    s->height = AV_RL16(&buf[6]);\n\n    ret = ff_set_dimensions(s->avctx, s->width, s->height);\n    if (ret < 0)\n        return ret;\n\n    fps = AV_RL16(&buf[10]);\n    if (fps > 0)\n        s->avctx->time_base = (AVRational){ 1, fps };\n\n    pal_start = AV_RL16(&buf[12]);\n    pal_count = AV_RL16(&buf[14]);\n\n    buf += 16;\n    for (i=pal_start; i<pal_start+pal_count && i<AVPALETTE_COUNT && buf_end - buf >= 3; i++) {\n        s->palette[i] = AV_RB24(buf);\n        buf += 3;\n    }\n\n    return 0;\n}","22873":"void flush_tlb_current_task(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tpreempt_disable();\n\n\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);\n\tlocal_flush_tlb();\n\ttrace_tlb_flush(TLB_LOCAL_SHOOTDOWN, TLB_FLUSH_ALL);\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, 0UL, TLB_FLUSH_ALL);\n\tpreempt_enable();\n}","22930":"void Mounter::mount(const QString &url, const QString &mountPoint, int uid, int gid, int pid)\n{\n    if (calledFromDBus()) {\n        registerPid(pid);\n    }\n\n    qWarning() << url << mountPoint << uid << gid;\n    QUrl u(url);\n    int st=-1;\n\n    if (u.scheme()==\"STR\" && mpOk(mountPoint)) {\n        QString user=u.userName();\n        QString domain;\n        QString password=u.password();\n        int port=u.port();\n\n        #if QT_VERSION < 0x050000\n        if (u.hasQueryItem(\"STR\")) {\n            domain=u.queryItemValue(\"STR\");\n        }\n        #else\n        QUrlQuery q(u);\n        if (q.hasQueryItem(\"STR\")) {\n            domain=q.queryItemValue(\"STR\");\n        }\n        #endif\n\n        QTemporaryFile *temp=0;\n\n        if (!password.isEmpty()) {\n            temp=new QTemporaryFile();\n            if (temp && temp->open()) {\n                QTextStream str(temp);\n                if (!user.isEmpty()) {\n                    str << \"STR\" << user << endl;\n                }\n                str << \"STR\" << password << endl;\n                if (!domain.isEmpty()) {\n                    str << \"STR\" << domain << endl;\n                }\n            }\n        }\n\n        QString path=fixPath(u.host()+\"STR\"+u.path());\n        while (!path.startsWith(\"STR\")) {\n            path=\"STR\"+path;\n        }\n\n\n\n\n\n\n\n\n\n        QProcess *proc=new QProcess(this);\n        connect(proc, SIGNAL(finished(int)), SLOT(mountResult(int)));\n        proc->setProperty(\"STR\", mountPoint);\n        proc->setProperty(\"STR\", pid);\n        proc->start(QLatin1String(INSTALL_PREFIX\"STR\"),\n                    QStringList() << path << mountPoint\n                    << \"STR\" <<\n                    (temp ? (\"STR\") : QString())+\n                    \"STR\"+QString::number(gid)+\n                    (445==port || port<1 ? QString() : \"STR\"+QString::number(port))+\n                    (temp || user.isEmpty() ? QString() : (\"STR\"+user))+\n                    (temp || domain.isEmpty() ? QString() : (\"STR\"+domain))+\n                    (temp ? QString() : \"STR\"), QIODevice::WriteOnly);\n        if (temp) {\n            tempFiles.insert(proc, temp);\n        }\n        procCount++;\n        return;\n    }\n    emit mountStatus(mountPoint, pid, st);\n}","22591":"static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tunsigned char max_level = 0;\n\tint unix_sock_count = 0;\n\n\tfor (i = scm->fp->count - 1; i >= 0; i--) {\n\t\tstruct sock *sk = unix_get_socket(scm->fp->fp[i]);\n\n\t\tif (sk) {\n\t\t\tunix_sock_count++;\n\t\t\tmax_level = max(max_level,\n\t\t\t\t\tunix_sk(sk)->recursion_level);\n\t\t}\n\t}\n\tif (unlikely(max_level > MAX_RECURSION_LEVEL))\n\t\treturn -ETOOMANYREFS;\n\n\t\n\tUNIXCB(skb).fp = scm_fp_dup(scm->fp);\n\tif (!UNIXCB(skb).fp)\n\t\treturn -ENOMEM;\n\n\tif (unix_sock_count) {\n\t\tfor (i = scm->fp->count - 1; i >= 0; i--)\n\t\t\tunix_inflight(scm->fp->fp[i]);\n\t}\n\treturn max_level;\n}","23168":"dns_zone_settask(dns_zone_t *zone, isc_task_t *task) {\n\tREQUIRE(DNS_ZONE_VALID(zone));\n\n\tLOCK_ZONE(zone);\n\tif (zone->task != NULL)\n\t\tisc_task_detach(&zone->task);\n\tisc_task_attach(task, &zone->task);\n\tZONEDB_LOCK(&zone->dblock, isc_rwlocktype_read);\n\tif (zone->db != NULL)\n\t\tdns_db_settask(zone->db, zone->task);\n\tZONEDB_UNLOCK(&zone->dblock, isc_rwlocktype_read);\n\tUNLOCK_ZONE(zone);\n}","22908":"int x_stat(const char *fname, STRUCT_STAT *fst, STRUCT_STAT *xst)\n{\n\tint ret = do_stat(fname, fst);\n\tif ((ret < 0 || get_stat_xattr(fname, -1, fst, xst) < 0) && xst)\n\t\txst->st_mode = 0;\n\treturn ret;\n}","23474":"static bool is_pointer_value(struct verifier_env *env, int regno)\n{\n\tif (env->allow_ptr_leaks)\n\t\treturn false;\n\n\tswitch (env->cur_state.regs[regno].type) {\n\tcase UNKNOWN_VALUE:\n\tcase CONST_IMM:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}","23785":"  Http2CodecImplTestFixture(Http2SettingsTuple client_settings, Http2SettingsTuple server_settings)\n      : client_settings_(client_settings), server_settings_(server_settings) {}","23520":"nfsd4_verify_copy(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t  stateid_t *src_stateid, struct file **src,\n\t\t  stateid_t *dst_stateid, struct file **dst)\n{\n\t__be32 status;\n\n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->save_fh,\n\t\t\t\t\t    src_stateid, RD_STATE, src, NULL);\n\tif (status) {\n\t\tdprintk(\"STR\", __func__);\n\t\tgoto out;\n\t}\n\n\tstatus = nfs4_preprocess_stateid_op(rqstp, cstate, &cstate->current_fh,\n\t\t\t\t\t    dst_stateid, WR_STATE, dst, NULL);\n\tif (status) {\n\t\tdprintk(\"STR\", __func__);\n\t\tgoto out_put_src;\n\t}\n\n\t\n\tif (!S_ISREG(file_inode(*src)->i_mode) ||\n\t    !S_ISREG(file_inode(*dst)->i_mode)) {\n\t\tstatus = nfserr_wrong_type;\n\t\tgoto out_put_dst;\n\t}\n\nout:\n\treturn status;\nout_put_dst:\n\tfput(*dst);\nout_put_src:\n\tfput(*src);\n\tgoto out;\n}","23107":"bool r_pkcs7_parse_digestalgorithmidentifier (RPKCS7DigestAlgorithmIdentifiers *dai, RASN1Object *object) {\n\tut32 i;\n\tif (!dai && !object) {\n\t\treturn false;\n\t}\n\tif (object->list.length > 0) {\n\t\tdai->elements = (RX509AlgorithmIdentifier **) calloc (object->list.length, sizeof (RX509AlgorithmIdentifier*));\n\t\tif (!dai->elements) {\n\t\t\treturn false;\n\t\t}\n\t\tdai->length = object->list.length;\n\t\tfor (i = 0; i < dai->length; ++i) {\n\t\t\t\n\t\t\t\n\t\t\tdai->elements[i] = (RX509AlgorithmIdentifier *) malloc (sizeof (RX509AlgorithmIdentifier));\n\t\t\t\n\t\t\t\n\t\t\tif (dai->elements[i]) {\n\t\t\t\t\n\t\t\t\tmemset (dai->elements[i], 0, sizeof (RX509AlgorithmIdentifier));\n\t\t\t\tr_x509_parse_algorithmidentifier (dai->elements[i], object->list.objects[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}","22579":"  static port::StatusOr<CudnnRnnSequenceTensorDescriptor> Create(\n      GpuExecutor* parent, int max_seq_length, int batch_size, int data_size,\n      const absl::Span<const int>& seq_lengths, bool time_major,\n      cudnnDataType_t data_type) {\n    CHECK_GT(max_seq_length, 0);\n    int dims[] = {batch_size, data_size, 1};\n    int strides[] = {dims[1] * dims[2], dims[2], 1};\n    TensorDescriptor tensor_desc = CreateTensorDescriptor();\n    RETURN_IF_CUDNN_ERROR(cudnnSetTensorNdDescriptor(\n        tensor_desc.get(), data_type,\n        sizeof(dims) \/ sizeof(dims[0]), dims,\n        strides));\n    const int* seq_lengths_array = seq_lengths.data();\n    RNNDataDescriptor data_desc = CreateRNNDataDescriptor();\n    float padding_fill = 0.0f;\n    cudnnRNNDataLayout_t layout;\n    if (time_major) {\n      layout = CUDNN_RNN_DATA_LAYOUT_SEQ_MAJOR_UNPACKED;\n    } else {\n      layout = CUDNN_RNN_DATA_LAYOUT_BATCH_MAJOR_UNPACKED;\n    }\n    RETURN_IF_CUDNN_ERROR(cudnnSetRNNDataDescriptor(\n        data_desc.get(),  data_type,\n        layout,\n        max_seq_length,\n        batch_size, data_size,\n        seq_lengths_array,\n         (void*)&padding_fill));\n    return CudnnRnnSequenceTensorDescriptor(\n        parent, max_seq_length, batch_size, data_size, data_type,\n        std::move(data_desc), std::move(tensor_desc));\n  }","22824":"static int process_proxy_cond_adders(unsigned int letters[26],\n\tconst char *cond, const char **cond_end, int *pos, int indent)\n\t{\n\tint ok;\n\tchar c;\n\n\tif (debug)\n\t\tprocess_proxy_debug(indent,\n\t\t\t\"STR\",\n\t\t\t*pos, cond);\n\n\tok = process_proxy_cond_multipliers(letters, cond, cond_end, pos,\n\t\tindent + 1);\n\tcond = *cond_end;\n\tif (ok < 0)\n\t\tgoto end;\n\n\twhile(ok >= 0)\n\t\t{\n\t\twhile(isspace((int)*cond))\n\t\t\t{\n\t\t\tcond++; (*pos)++;\n\t\t\t}\n\t\tc = *cond;\n\n\t\tswitch(c)\n\t\t\t{\n\t\tcase '|':\n\t\t\t{\n\t\t\tint save_ok = ok;\n\n\t\t\tcond++; (*pos)++;\n\t\t\tok = process_proxy_cond_multipliers(letters,\n\t\t\t\tcond, cond_end, pos, indent + 1);\n\t\t\tcond = *cond_end;\n\t\t\tif (ok < 0)\n\t\t\t\tbreak;\n\n\t\t\tswitch(c)\n\t\t\t\t{\n\t\t\tcase '|':\n\t\t\t\tok |= save_ok;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"STR\"\n\t\t\t\t\t\"STR\");\n\t\t\t\tEXIT(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto end;\n\t\t\t}\n\t\t}\n end:\n\tif (debug)\n\t\tprocess_proxy_debug(indent,\n\t\t\t\"STR\",\n\t\t\t*pos, cond, ok);\n\n\t*cond_end = cond;\n\treturn ok;\n\t}","23478":"static int __init pf_init(void)\n{\t\t\t\t\n\tstruct pf_unit *pf;\n\tint unit;\n\n\tif (disable)\n\t\treturn -EINVAL;\n\n\tpf_init_units();\n\n\tif (pf_detect())\n\t\treturn -ENODEV;\n\tpf_busy = 0;\n\n\tif (register_blkdev(major, name)) {\n\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)\n\t\t\tput_disk(pf->disk);\n\t\treturn -EBUSY;\n\t}\n\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tstruct gendisk *disk = pf->disk;\n\n\t\tif (!pf->present)\n\t\t\tcontinue;\n\t\tdisk->private_data = pf;\n\t\tadd_disk(disk);\n\t}\n\treturn 0;\n}","22970":"intrusive_ptr<Expression> ExpressionFieldPath::optimize() {\n    if (_variable == Variables::kRemoveId) {\n        \n        return ExpressionConstant::create(getExpressionContext(), Value());\n    }\n\n    if (getExpressionContext()->variables.hasConstantValue(_variable)) {\n        return ExpressionConstant::create(getExpressionContext(), evaluate(Document()));\n    }\n\n    return intrusive_ptr<Expression>(this);\n}","23400":"krb5_gss_context_time(minor_status, context_handle, time_rec)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    OM_uint32 *time_rec;\n{\n    krb5_error_code code;\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_timestamp now;\n    krb5_deltat lifetime;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (ctx->terminated || !ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    if ((code = krb5_timeofday(ctx->k5_context, &now))) {\n        *minor_status = code;\n        save_error_info(*minor_status, ctx->k5_context);\n        return(GSS_S_FAILURE);\n    }\n\n    if ((lifetime = ctx->krb_times.endtime - now) <= 0) {\n        *time_rec = 0;\n        *minor_status = 0;\n        return(GSS_S_CONTEXT_EXPIRED);\n    } else {\n        *time_rec = lifetime;\n        *minor_status = 0;\n        return(GSS_S_COMPLETE);\n    }\n}","22856":"ssize_t __weak cpu_show_tsx_async_abort(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn sprintf(buf, \"STR\");\n}","23035":"static int ieee80211_change_station(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *dev, const u8 *mac,\n\t\t\t\t    struct station_parameters *params)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct sta_info *sta;\n\tstruct ieee80211_sub_if_data *vlansdata;\n\tenum cfg80211_station_type statype;\n\tint err;\n\n\tmutex_lock(&local->sta_mtx);\n\n\tsta = sta_info_get_bss(sdata, mac);\n\tif (!sta) {\n\t\terr = -ENOENT;\n\t\tgoto out_err;\n\t}\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (sdata->u.mesh.user_mpm)\n\t\t\tstatype = CFG80211_STA_MESH_PEER_USER;\n\t\telse\n\t\t\tstatype = CFG80211_STA_MESH_PEER_KERNEL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tstatype = CFG80211_STA_IBSS;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (!test_sta_flag(sta, WLAN_STA_TDLS_PEER)) {\n\t\t\tstatype = CFG80211_STA_AP_STA;\n\t\t\tbreak;\n\t\t}\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tstatype = CFG80211_STA_TDLS_PEER_ACTIVE;\n\t\telse\n\t\t\tstatype = CFG80211_STA_TDLS_PEER_SETUP;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (test_sta_flag(sta, WLAN_STA_ASSOC))\n\t\t\tstatype = CFG80211_STA_AP_CLIENT;\n\t\telse\n\t\t\tstatype = CFG80211_STA_AP_CLIENT_UNASSOC;\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\terr = cfg80211_check_station_change(wiphy, params, statype);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (params->vlan && params->vlan != sta->sdata->dev) {\n\t\tvlansdata = IEEE80211_DEV_TO_SUB_IF(params->vlan);\n\n\t\tif (params->vlan->ieee80211_ptr->use_4addr) {\n\t\t\tif (vlansdata->u.vlan.sta) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\trcu_assign_pointer(vlansdata->u.vlan.sta, sta);\n\t\t\t__ieee80211_check_fast_rx_iface(vlansdata);\n\t\t}\n\n\t\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t\t    sta->sdata->u.vlan.sta)\n\t\t\tRCU_INIT_POINTER(sta->sdata->u.vlan.sta, NULL);\n\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tieee80211_vif_dec_num_mcast(sta->sdata);\n\n\t\tsta->sdata = vlansdata;\n\t\tieee80211_check_fast_xmit(sta);\n\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tieee80211_vif_inc_num_mcast(sta->sdata);\n\n\t\tcfg80211_send_layer2_update(sta->sdata->dev, sta->sta.addr);\n\t}\n\n\terr = sta_apply_parameters(local, sta, params);\n\tif (err)\n\t\tgoto out_err;\n\n\tmutex_unlock(&local->sta_mtx);\n\n\tif ((sdata->vif.type == NL80211_IFTYPE_AP ||\n\t     sdata->vif.type == NL80211_IFTYPE_AP_VLAN) &&\n\t    sta->known_smps_mode != sta->sdata->bss->req_smps &&\n\t    test_sta_flag(sta, WLAN_STA_AUTHORIZED) &&\n\t    sta_info_tx_streams(sta) != 1) {\n\t\tht_dbg(sta->sdata,\n\t\t       \"STR\",\n\t\t       sta->sta.addr);\n\t\tieee80211_send_smps_action(sta->sdata,\n\t\t\tsta->sdata->bss->req_smps,\n\t\t\tsta->sta.addr,\n\t\t\tsta->sdata->vif.bss_conf.bssid);\n\t}\n\n\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t    params->sta_flags_mask & BIT(NL80211_STA_FLAG_AUTHORIZED)) {\n\t\tieee80211_recalc_ps(local);\n\t\tieee80211_recalc_ps_vif(sdata);\n\t}\n\n\treturn 0;\nout_err:\n\tmutex_unlock(&local->sta_mtx);\n\treturn err;\n}","23195":"static size_t ZSTD_encodeSequences(\n            void* dst, size_t dstCapacity,\n            FSE_CTable const* CTable_MatchLength, BYTE const* mlCodeTable,\n            FSE_CTable const* CTable_OffsetBits, BYTE const* ofCodeTable,\n            FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,\n            seqDef const* sequences, size_t nbSeq, int longOffsets, int bmi2)\n{\n#if DYNAMIC_BMI2\n    if (bmi2) {\n        return ZSTD_encodeSequences_bmi2(dst, dstCapacity,\n                                         CTable_MatchLength, mlCodeTable,\n                                         CTable_OffsetBits, ofCodeTable,\n                                         CTable_LitLength, llCodeTable,\n                                         sequences, nbSeq, longOffsets);\n    }\n#endif\n    (void)bmi2;\n    return ZSTD_encodeSequences_default(dst, dstCapacity,\n                                        CTable_MatchLength, mlCodeTable,\n                                        CTable_OffsetBits, ofCodeTable,\n                                        CTable_LitLength, llCodeTable,\n                                        sequences, nbSeq, longOffsets);\n}","23155":"static struct sk_buff *macsec_decrypt(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev,\n\t\t\t\t      struct macsec_rx_sa *rx_sa,\n\t\t\t\t      sci_t sci,\n\t\t\t\t      struct macsec_secy *secy)\n{\n\tint ret;\n\tstruct scatterlist *sg;\n\tunsigned char *iv;\n\tstruct aead_request *req;\n\tstruct macsec_eth_header *hdr;\n\tu16 icv_len = secy->icv_len;\n\n\tmacsec_skb_cb(skb)->valid = false;\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treq = macsec_alloc_req(rx_sa->key.tfm, &iv, &sg);\n\tif (!req) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\thdr = (struct macsec_eth_header *)skb->data;\n\tmacsec_fill_iv(iv, sci, ntohl(hdr->packet_number));\n\n\tsg_init_table(sg, MAX_SKB_FRAGS + 1);\n\tskb_to_sgvec(skb, sg, 0, skb->len);\n\n\tif (hdr->tci_an & MACSEC_TCI_E) {\n\t\t\n\t\tint len = skb->len - macsec_hdr_len(macsec_skb_cb(skb)->has_sci);\n\n\t\taead_request_set_crypt(req, sg, sg, len, iv);\n\t\taead_request_set_ad(req, macsec_hdr_len(macsec_skb_cb(skb)->has_sci));\n\t\tskb = skb_unshare(skb, GFP_ATOMIC);\n\t\tif (!skb) {\n\t\t\taead_request_free(req);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t} else {\n\t\t\n\t\taead_request_set_crypt(req, sg, sg, icv_len, iv);\n\t\taead_request_set_ad(req, skb->len - icv_len);\n\t}\n\n\tmacsec_skb_cb(skb)->req = req;\n\tskb->dev = dev;\n\taead_request_set_callback(req, 0, macsec_decrypt_done, skb);\n\n\tdev_hold(dev);\n\tret = crypto_aead_decrypt(req);\n\tif (ret == -EINPROGRESS) {\n\t\treturn ERR_PTR(ret);\n\t} else if (ret != 0) {\n\t\t\n\t\tif (ret != -EBADMSG) {\n\t\t\tkfree_skb(skb);\n\t\t\tskb = ERR_PTR(ret);\n\t\t}\n\t} else {\n\t\tmacsec_skb_cb(skb)->valid = true;\n\t}\n\tdev_put(dev);\n\n\taead_request_free(req);\n\n\treturn skb;\n}","22993":"radix__arch_get_unmapped_area_topdown(struct file *filp,\n\t\t\t\t     const unsigned long addr0,\n\t\t\t\t     const unsigned long len,\n\t\t\t\t     const unsigned long pgoff,\n\t\t\t\t     const unsigned long flags)\n{\n\tstruct vm_area_struct *vma;\n\tstruct mm_struct *mm = current->mm;\n\tunsigned long addr = addr0;\n\tstruct vm_unmapped_area_info info;\n\n\tif (unlikely(addr > mm->context.addr_limit &&\n\t\t     mm->context.addr_limit != TASK_SIZE))\n\t\tmm->context.addr_limit = TASK_SIZE;\n\n\t\n\tif (len > mm->task_size - mmap_min_addr)\n\t\treturn -ENOMEM;\n\n\tif (flags & MAP_FIXED)\n\t\treturn addr;\n\n\t\n\tif (addr) {\n\t\taddr = PAGE_ALIGN(addr);\n\t\tvma = find_vma(mm, addr);\n\t\tif (mm->task_size - len >= addr && addr >= mmap_min_addr &&\n\t\t\t\t(!vma || addr + len <= vma->vm_start))\n\t\t\treturn addr;\n\t}\n\n\tinfo.flags = VM_UNMAPPED_AREA_TOPDOWN;\n\tinfo.length = len;\n\tinfo.low_limit = max(PAGE_SIZE, mmap_min_addr);\n\tinfo.high_limit = mm->mmap_base;\n\tinfo.align_mask = 0;\n\n\tif (addr > DEFAULT_MAP_WINDOW)\n\t\tinfo.high_limit += mm->context.addr_limit - DEFAULT_MAP_WINDOW;\n\n\taddr = vm_unmapped_area(&info);\n\tif (!(addr & ~PAGE_MASK))\n\t\treturn addr;\n\tVM_BUG_ON(addr != -ENOMEM);\n\n\t\n\treturn radix__arch_get_unmapped_area(filp, addr0, len, pgoff, flags);\n}","23225":"void Commissioner::ClearJoiners(void)\n{\n    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n    {\n        joiner->mValid = false;\n    }\n\n    SendCommissionerSet();\n}","23567":"int nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\t\t\t      u32 result)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_FW_DOWNLOAD);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_string(msg, NFC_ATTR_FIRMWARE_NAME, firmware_name) ||\n\t    nla_put_u32(msg, NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS, result) ||\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}","22685":"static void hugetlb_vm_op_close(struct vm_area_struct *vma)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct resv_map *reservations = vma_resv_map(vma);\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tunsigned long reserve;\n\tunsigned long start;\n\tunsigned long end;\n\n\tif (reservations) {\n\t\tstart = vma_hugecache_offset(h, vma, vma->vm_start);\n\t\tend = vma_hugecache_offset(h, vma, vma->vm_end);\n\n\t\treserve = (end - start) -\n\t\t\tregion_count(&reservations->regions, start, end);\n\n\t\tkref_put(&reservations->refs, resv_map_release);\n\n\t\tif (reserve) {\n\t\t\thugetlb_acct_memory(h, -reserve);\n\t\t\thugepage_subpool_put_pages(spool, reserve);\n\t\t}\n\t}\n}","23236":"int iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,\n\t\t\t enum iscsi_param param, char *buf)\n{\n\tstruct iscsi_conn *conn = cls_conn->dd_data;\n\tint len;\n\n\tswitch(param) {\n\tcase ISCSI_PARAM_PING_TMO:\n\t\tlen = sprintf(buf, \"STR\", conn->ping_timeout);\n\t\tbreak;\n\tcase ISCSI_PARAM_RECV_TMO:\n\t\tlen = sprintf(buf, \"STR\", conn->recv_timeout);\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_RECV_DLENGTH:\n\t\tlen = sprintf(buf, \"STR\", conn->max_recv_dlength);\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_XMIT_DLENGTH:\n\t\tlen = sprintf(buf, \"STR\", conn->max_xmit_dlength);\n\t\tbreak;\n\tcase ISCSI_PARAM_HDRDGST_EN:\n\t\tlen = sprintf(buf, \"STR\", conn->hdrdgst_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_DATADGST_EN:\n\t\tlen = sprintf(buf, \"STR\", conn->datadgst_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_IFMARKER_EN:\n\t\tlen = sprintf(buf, \"STR\", conn->ifmarker_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_OFMARKER_EN:\n\t\tlen = sprintf(buf, \"STR\", conn->ofmarker_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_EXP_STATSN:\n\t\tlen = sprintf(buf, \"STR\", conn->exp_statsn);\n\t\tbreak;\n\tcase ISCSI_PARAM_PERSISTENT_PORT:\n\t\tlen = sprintf(buf, \"STR\", conn->persistent_port);\n\t\tbreak;\n\tcase ISCSI_PARAM_PERSISTENT_ADDRESS:\n\t\tlen = sprintf(buf, \"STR\", conn->persistent_address);\n\t\tbreak;\n\tcase ISCSI_PARAM_STATSN:\n\t\tlen = sprintf(buf, \"STR\", conn->statsn);\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_SEGMENT_SIZE:\n\t\tlen = sprintf(buf, \"STR\", conn->max_segment_size);\n\t\tbreak;\n\tcase ISCSI_PARAM_KEEPALIVE_TMO:\n\t\tlen = sprintf(buf, \"STR\", conn->keepalive_tmo);\n\t\tbreak;\n\tcase ISCSI_PARAM_LOCAL_PORT:\n\t\tlen = sprintf(buf, \"STR\", conn->local_port);\n\t\tbreak;\n\tcase ISCSI_PARAM_TCP_TIMESTAMP_STAT:\n\t\tlen = sprintf(buf, \"STR\", conn->tcp_timestamp_stat);\n\t\tbreak;\n\tcase ISCSI_PARAM_TCP_NAGLE_DISABLE:\n\t\tlen = sprintf(buf, \"STR\", conn->tcp_nagle_disable);\n\t\tbreak;\n\tcase ISCSI_PARAM_TCP_WSF_DISABLE:\n\t\tlen = sprintf(buf, \"STR\", conn->tcp_wsf_disable);\n\t\tbreak;\n\tcase ISCSI_PARAM_TCP_TIMER_SCALE:\n\t\tlen = sprintf(buf, \"STR\", conn->tcp_timer_scale);\n\t\tbreak;\n\tcase ISCSI_PARAM_TCP_TIMESTAMP_EN:\n\t\tlen = sprintf(buf, \"STR\", conn->tcp_timestamp_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_IP_FRAGMENT_DISABLE:\n\t\tlen = sprintf(buf, \"STR\", conn->fragment_disable);\n\t\tbreak;\n\tcase ISCSI_PARAM_IPV4_TOS:\n\t\tlen = sprintf(buf, \"STR\", conn->ipv4_tos);\n\t\tbreak;\n\tcase ISCSI_PARAM_IPV6_TC:\n\t\tlen = sprintf(buf, \"STR\", conn->ipv6_traffic_class);\n\t\tbreak;\n\tcase ISCSI_PARAM_IPV6_FLOW_LABEL:\n\t\tlen = sprintf(buf, \"STR\", conn->ipv6_flow_label);\n\t\tbreak;\n\tcase ISCSI_PARAM_IS_FW_ASSIGNED_IPV6:\n\t\tlen = sprintf(buf, \"STR\", conn->is_fw_assigned_ipv6);\n\t\tbreak;\n\tcase ISCSI_PARAM_TCP_XMIT_WSF:\n\t\tlen = sprintf(buf, \"STR\", conn->tcp_xmit_wsf);\n\t\tbreak;\n\tcase ISCSI_PARAM_TCP_RECV_WSF:\n\t\tlen = sprintf(buf, \"STR\", conn->tcp_recv_wsf);\n\t\tbreak;\n\tcase ISCSI_PARAM_LOCAL_IPADDR:\n\t\tlen = sprintf(buf, \"STR\", conn->local_ipaddr);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn len;\n}","22924":"static u64 __skb_get_nlattr(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n\n\tif (skb_is_nonlinear(skb))\n\t\treturn 0;\n\n\tif (A > skb->len - sizeof(struct nlattr))\n\t\treturn 0;\n\n\tnla = nla_find((struct nlattr *) &skb->data[A], skb->len - A, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\n\treturn 0;\n}","23536":"  GC_INNER void * GC_debug_generic_malloc_inner_ignore_off_page(size_t lb,\n                                                                int k)\n  {\n    void * result = GC_generic_malloc_inner_ignore_off_page(\n                                                lb + DEBUG_BYTES, k);\n\n    if (result == 0) {\n        GC_err_printf(\"STR\",\n                       (unsigned long) lb);\n        return(0);\n    }\n    if (!GC_debugging_started) {\n        GC_start_debugging_inner();\n    }\n    ADD_CALL_CHAIN(result, GC_RETURN_ADDR);\n    return (GC_store_debug_info_inner(result, (word)lb, \"STR\", 0));\n  }","23586":"do_file(char const *const fname)\n{\n\ttable_sort_t custom_sort;\n\tElf32_Ehdr *ehdr = mmap_file(fname);\n\n\tehdr_curr = ehdr;\n\tswitch (ehdr->e_ident[EI_DATA]) {\n\tdefault:\n\t\tfprintf(stderr, \"STR\",\n\t\t\tehdr->e_ident[EI_DATA], fname);\n\t\tfail_file();\n\t\tbreak;\n\tcase ELFDATA2LSB:\n\t\tr = rle;\n\t\tr2 = r2le;\n\t\tr8 = r8le;\n\t\tw = wle;\n\t\tw2 = w2le;\n\t\tw8 = w8le;\n\t\tbreak;\n\tcase ELFDATA2MSB:\n\t\tr = rbe;\n\t\tr2 = r2be;\n\t\tr8 = r8be;\n\t\tw = wbe;\n\t\tw2 = w2be;\n\t\tw8 = w8be;\n\t\tbreak;\n\t}  \n\tif (memcmp(ELFMAG, ehdr->e_ident, SELFMAG) != 0\n\t||  r2(&ehdr->e_type) != ET_EXEC\n\t||  ehdr->e_ident[EI_VERSION] != EV_CURRENT) {\n\t\tfprintf(stderr, \"STR\", fname);\n\t\tfail_file();\n\t}\n\n\tcustom_sort = NULL;\n\tswitch (r2(&ehdr->e_machine)) {\n\tdefault:\n\t\tfprintf(stderr, \"STR\",\n\t\t\tr2(&ehdr->e_machine), fname);\n\t\tfail_file();\n\t\tbreak;\n\tcase EM_386:\n\tcase EM_X86_64:\n\tcase EM_S390:\n\t\tcustom_sort = sort_relative_table;\n\t\tbreak;\n\tcase EM_ARCOMPACT:\n\tcase EM_ARCV2:\n\tcase EM_ARM:\n\tcase EM_AARCH64:\n\tcase EM_MICROBLAZE:\n\tcase EM_MIPS:\n\tcase EM_XTENSA:\n\t\tbreak;\n\t}  \n\n\tswitch (ehdr->e_ident[EI_CLASS]) {\n\tdefault:\n\t\tfprintf(stderr, \"STR\",\n\t\t\tehdr->e_ident[EI_CLASS], fname);\n\t\tfail_file();\n\t\tbreak;\n\tcase ELFCLASS32:\n\t\tif (r2(&ehdr->e_ehsize) != sizeof(Elf32_Ehdr)\n\t\t||  r2(&ehdr->e_shentsize) != sizeof(Elf32_Shdr)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"STR\", fname);\n\t\t\tfail_file();\n\t\t}\n\t\tdo32(ehdr, fname, custom_sort);\n\t\tbreak;\n\tcase ELFCLASS64: {\n\t\tElf64_Ehdr *const ghdr = (Elf64_Ehdr *)ehdr;\n\t\tif (r2(&ghdr->e_ehsize) != sizeof(Elf64_Ehdr)\n\t\t||  r2(&ghdr->e_shentsize) != sizeof(Elf64_Shdr)) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"STR\", fname);\n\t\t\tfail_file();\n\t\t}\n\t\tdo64(ghdr, fname, custom_sort);\n\t\tbreak;\n\t}\n\t}  \n\n\tcleanup();\n}","23571":"static void ima_adpcm_reset2 (_AFmoduleinst *i)\n{\n\tima_adpcm_data\t*d = (ima_adpcm_data *) i->modspec;\n\tint\t\tframesPerBlock;\n\n\tframesPerBlock = d->samplesPerBlock \/ d->track->f.channelCount;\n\n\td->track->fpos_next_frame = d->track->fpos_first_frame +\n\t\td->blockAlign * (d->track->nextfframe \/ framesPerBlock);\n\td->track->frames2ignore += d->framesToIgnore;\n\n\tassert(d->track->nextfframe % framesPerBlock == 0);\n}","22971":"const char *resolve_gitdir_gently(const char *suspect, int *return_error_code)\n{\n\tif (is_git_directory(suspect))\n\t\treturn suspect;\n\treturn read_gitfile_gently(suspect, return_error_code);\n}","22935":"TEST_F(HttpConnectionManagerImplTest, PerStreamIdleTimeoutAfterBidiData) {\n  setup(false, \"\");\n  ON_CALL(route_config_provider_.route_config_->route_->route_entry_, idleTimeout())\n      .WillByDefault(Return(std::chrono::milliseconds(10)));\n  proxy_100_continue_ = true;\n\n  \n  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());\n\n  EXPECT_CALL(filter_factory_, createFilterChain(_))\n      .WillRepeatedly(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {\n        callbacks.addStreamDecoderFilter(filter);\n      }));\n  EXPECT_CALL(filter_callbacks_.connection_.dispatcher_, deferredDelete_(_));\n\n  \n  \n  Event::MockTimer* idle_timer = setUpTimer();\n  StreamDecoder* decoder;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance& data) -> void {\n    decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\"STR\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    decoder->decodeHeaders(std::move(headers), false);\n\n    HeaderMapPtr response_continue_headers{new TestHeaderMapImpl{{\"STR\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    filter->callbacks_->encode100ContinueHeaders(std::move(response_continue_headers));\n\n    HeaderMapPtr response_headers{new TestHeaderMapImpl{{\"STR\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    filter->callbacks_->encodeHeaders(std::move(response_headers), false);\n\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    decoder->decodeData(data, false);\n\n    HeaderMapPtr trailers{new TestHeaderMapImpl{{\"STR\"}}};\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    decoder->decodeTrailers(std::move(trailers));\n\n    Buffer::OwnedImpl fake_response(\"STR\");\n    EXPECT_CALL(*idle_timer, enableTimer(_, _));\n    filter->callbacks_->encodeData(fake_response, false);\n\n    EXPECT_CALL(*idle_timer, disableTimer());\n    idle_timer->invokeCallback();\n\n    data.drain(4);\n  }));\n\n  \n  EXPECT_CALL(response_encoder_, encode100ContinueHeaders(_));\n\n  \n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false))\n      .WillOnce(Invoke([](const HeaderMap& headers, bool) -> void {\n        EXPECT_EQ(\"STR\", headers.Status()->value().getStringView());\n      }));\n\n  std::string response_body;\n  EXPECT_CALL(response_encoder_, encodeData(_, false)).WillOnce(AddBufferToString(&response_body));\n\n  Buffer::OwnedImpl fake_input(\"STR\");\n  conn_manager_->onData(fake_input, false);\n\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_idle_timeout_.value());\n  EXPECT_EQ(\"STR\", response_body);\n}","22671":"static int i2c_ddc_rx(I2CSlave *i2c)\n{\n    I2CDDCState *s = I2CDDC(i2c);\n\n    int value;\n    value = s->edid_blob[s->reg];\n    s->reg++;\n    return value;\n}","23530":"static void write_leases(void)\n{\n\tint fd;\n\tunsigned i;\n\tleasetime_t curr;\n\tint64_t written_at;\n\n\tfd = open_or_warn(server_config.lease_file, O_WRONLY|O_CREAT|O_TRUNC);\n\tif (fd < 0)\n\t\treturn;\n\n\tcurr = written_at = time(NULL);\n\n\twritten_at = SWAP_BE64(written_at);\n\tfull_write(fd, &written_at, sizeof(written_at));\n\n\tfor (i = 0; i < server_config.max_leases; i++) {\n\t\tleasetime_t tmp_time;\n\n\t\tif (g_leases[i].lease_nip == 0)\n\t\t\tcontinue;\n\n\t\t\n\t\ttmp_time = g_leases[i].expires;\n\n\t\tg_leases[i].expires -= curr;\n\t\tif ((signed_leasetime_t) g_leases[i].expires < 0)\n\t\t\tg_leases[i].expires = 0;\n\t\tg_leases[i].expires = htonl(g_leases[i].expires);\n\n\t\t\n\t\tfull_write(fd, &g_leases[i], sizeof(g_leases[i]));\n\n\t\t\n\t\tg_leases[i].expires = tmp_time;\n\t}\n\tclose(fd);\n\n\tif (server_config.notify_file) {\n\t\tchar *argv[3];\n\t\targv[0] = server_config.notify_file;\n\t\targv[1] = server_config.lease_file;\n\t\targv[2] = NULL;\n\t\tspawn_and_wait(argv);\n\t}\n}","22755":"deinit_pci(struct vmctx *ctx)\n{\n\tstruct pci_vdev_ops *ops;\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tstruct funcinfo *fi;\n\tint bus, slot, func;\n\tsize_t lowmem;\n\tstruct mem_range mr;\n\n\t\n\tbzero(&mr, sizeof(struct mem_range));\n\tmr.name = \"STR\";\n\tmr.base = PCI_EMUL_ECFG_BASE;\n\tmr.size = PCI_EMUL_ECFG_SIZE;\n\tunregister_mem(&mr);\n\n\t\n\tlowmem = vm_get_lowmem_size(ctx);\n\tbzero(&mr, sizeof(struct mem_range));\n\tmr.name = \"STR\";\n\tmr.base = lowmem;\n\tmr.size = (4ULL * 1024 * 1024 * 1024) - lowmem;\n\tunregister_mem_fallback(&mr);\n\n\t\n\tbzero(&mr, sizeof(struct mem_range));\n\tmr.name = \"STR\";\n\tmr.base = PCI_EMUL_MEMBASE64;\n\tmr.size = PCI_EMUL_MEMLIMIT64 - PCI_EMUL_MEMBASE64;\n\tunregister_mem_fallback(&mr);\n\n\tfor (bus = 0; bus < MAXBUSES; bus++) {\n\t\tbi = pci_businfo[bus];\n\t\tif (bi == NULL)\n\t\t\tcontinue;\n\n\t\tfor (slot = 0; slot < MAXSLOTS; slot++) {\n\t\t\tsi = &bi->slotinfo[slot];\n\t\t\tfor (func = 0; func < MAXFUNCS; func++) {\n\t\t\t\tfi = &si->si_funcs[func];\n\t\t\t\tif (fi->fi_name == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tops = pci_emul_finddev(fi->fi_name);\n\t\t\t\tassert(ops != NULL);\n\n\t\t\t\tpr_notice(\"STR\", fi->fi_name);\n\t\t\t\tpci_emul_deinit(ctx, ops, bus, slot,\n\t\t\t\t    func, fi);\n\t\t\t}\n\t\t}\n\t}\n}","23018":"static int fsmMkdir(const char *path, mode_t mode)\n{\n    int rc = mkdir(path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \"STR\", __func__,\n\t       path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}","22980":"static bool is_partition_in_criterias(\n        const std::string& partition,\n        const std::vector<Criteria>& criterias)\n{\n    bool returned_value = false;\n\n    for (auto criteria_it = criterias.begin(); !returned_value &&\n            criteria_it != criterias.end(); ++criteria_it)\n    {\n        for (auto part : (*criteria_it).partitions)\n        {\n            if (StringMatching::matchString(partition.c_str(), part.c_str()))\n            {\n                returned_value = true;\n                break;\n            }\n        }\n    }\n\n    return returned_value;\n}","23594":"int unit_name_from_path_instance(const char *prefix, const char *path, const char *suffix, char **ret) {\n        _cleanup_free_ char *p = NULL, *s = NULL;\n        int r;\n\n        assert(prefix);\n        assert(path);\n        assert(suffix);\n        assert(ret);\n\n        if (!unit_prefix_is_valid(prefix))\n                return -EINVAL;\n\n        if (!unit_suffix_is_valid(suffix))\n                return -EINVAL;\n\n        r = unit_name_path_escape(path, &p);\n        if (r < 0)\n                return r;\n\n        s = strjoin(prefix, \"STR\", p, suffix);\n        if (!s)\n                return -ENOMEM;\n\n        if (strlen(s) >= UNIT_NAME_MAX) \n                return -ENAMETOOLONG;\n\n        \n        if (!unit_name_is_valid(s, UNIT_NAME_INSTANCE))\n                return -EINVAL;\n\n        *ret = TAKE_PTR(s);\n        return 0;\n}","23672":"MONGO_EXPORT mongo_cursor *gridfile_get_chunks( gridfile *gfile, int start, int size ) {\n    bson_iterator it;\n    bson_oid_t id;\n    bson gte;\n    bson query;\n    bson orderby;\n    bson command;\n    mongo_cursor *cursor;\n\n    bson_find( &it, gfile->meta, \"STR\" );\n    id = *bson_iterator_oid( &it );\n\n    bson_init( &query );\n    bson_append_oid( &query, \"STR\", &id );\n    if ( size == 1 ) {\n        bson_append_int( &query, \"STR\", start );\n    }\n    else {\n        bson_init( &gte );\n        bson_append_int( &gte, \"STR\", start );\n        bson_finish( &gte );\n        bson_append_bson( &query, \"STR\", &gte );\n        bson_destroy( &gte );\n    }\n    bson_finish( &query );\n\n    bson_init( &orderby );\n    bson_append_int( &orderby, \"STR\", 1 );\n    bson_finish( &orderby );\n\n    bson_init( &command );\n    bson_append_bson( &command, \"STR\", &query );\n    bson_append_bson( &command, \"STR\", &orderby );\n    bson_finish( &command );\n\n    cursor = mongo_find( gfile->gfs->client, gfile->gfs->chunks_ns,\n                         &command, NULL, size, 0, 0 );\n\n    bson_destroy( &command );\n    bson_destroy( &query );\n    bson_destroy( &orderby );\n\n    return cursor;\n}","23743":"static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\trcu_read_lock();\n\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n\trcu_read_unlock();\n}","23340":"void sas_ata_task_abort(struct sas_task *task)\n{\n\tstruct ata_queued_cmd *qc = task->uldd_task;\n\tstruct completion *waiting;\n\n\t\n\tif (qc->scsicmd) {\n\t\tstruct request_queue *q = qc->scsicmd->device->request_queue;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(q->queue_lock, flags);\n\t\tblk_abort_request(qc->scsicmd->request);\n\t\tspin_unlock_irqrestore(q->queue_lock, flags);\n\t\treturn;\n\t}\n\n\t\n\tqc->flags &= ~ATA_QCFLAG_ACTIVE;\n\tqc->flags |= ATA_QCFLAG_FAILED;\n\tqc->err_mask |= AC_ERR_TIMEOUT;\n\twaiting = qc->private_data;\n\tcomplete(waiting);\n}","23700":"void CLASS parse_smal(int offset, int fsize)\n{\n  int ver;\n\n  fseek(ifp, offset + 2, SEEK_SET);\n  order = 0x4949;\n  ver = fgetc(ifp);\n  if (ver == 6)\n    fseek(ifp, 5, SEEK_CUR);\n  if (get4() != fsize)\n    return;\n  if (ver > 6)\n    data_offset = get4();\n  raw_height = height = get2();\n  raw_width = width = get2();\n  strcpy(make, \"STR\");\n  sprintf(model, \"STR\", ver, width, height);\n  if (ver == 6)\n    load_raw = &CLASS smal_v6_load_raw;\n  if (ver == 9)\n    load_raw = &CLASS smal_v9_load_raw;\n}","22690":"static void *alloc_slabmgmt(struct kmem_cache *cachep,\n\t\t\t\t   struct page *page, int colour_off,\n\t\t\t\t   gfp_t local_flags, int nodeid)\n{\n\tvoid *freelist;\n\tvoid *addr = page_address(page);\n\n\tpage->s_mem = addr + colour_off;\n\tpage->active = 0;\n\n\tif (OBJFREELIST_SLAB(cachep))\n\t\tfreelist = NULL;\n\telse if (OFF_SLAB(cachep)) {\n\t\t\n\t\tfreelist = kmem_cache_alloc_node(cachep->freelist_cache,\n\t\t\t\t\t      local_flags, nodeid);\n\t\tif (!freelist)\n\t\t\treturn NULL;\n\t} else {\n\t\t\n\t\tfreelist = addr + (PAGE_SIZE << cachep->gfporder) -\n\t\t\t\tcachep->freelist_size;\n\t}\n\n\treturn freelist;\n}","22879":"static int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,\n\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied;\n\tint err = 0;\n\n\tlock_sock(sk);\n\t\n\tif (sk->sk_type == SOCK_SEQPACKET && sk->sk_state != TCP_ESTABLISHED) {\n\t\terr =  -ENOTCONN;\n\t\tgoto out;\n\t}\n\n\t\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tif (!ax25_sk(sk)->pidincl)\n\t\tskb_pull(skb, 1);\t\t\n\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\n\tif (msg->msg_namelen != 0) {\n\t\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\t\tax25_digi digi;\n\t\tax25_address src;\n\t\tconst unsigned char *mac = skb_mac_header(skb);\n\n\t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n\t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\n\t\t\t\t&digi, NULL, NULL);\n\t\tsax->sax25_family = AF_AX25;\n\t\t\n\t\tsax->sax25_ndigis = digi.ndigi;\n\t\tsax->sax25_call   = src;\n\n\t\tif (sax->sax25_ndigis != 0) {\n\t\t\tint ct;\n\t\t\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)sax;\n\n\t\t\tfor (ct = 0; ct < digi.ndigi; ct++)\n\t\t\t\tfsa->fsa_digipeater[ct] = digi.calls[ct];\n\t\t}\n\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_ax25);\n\t}\n\n\tskb_free_datagram(sk, skb);\n\terr = copied;\n\nout:\n\trelease_sock(sk);\n\n\treturn err;\n}","23757":"static void exif_thumbnail_extract(image_info_type *ImageInfo, char *offset, size_t length TSRMLS_DC) {\n\tif (ImageInfo->Thumbnail.data) {\n\t\texif_error_docref(\"STR\");\n\t\treturn; \n\t}\n\tif (!ImageInfo->read_thumbnail)\t{\n\t\treturn; \n\t}\n\t\n\tif (ImageInfo->Thumbnail.size >= 65536\n\t || ImageInfo->Thumbnail.size <= 0\n\t || ImageInfo->Thumbnail.offset <= 0\n\t) {\n\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"STR\");\n\t\treturn;\n\t}\n\t\n\tif ((ImageInfo->Thumbnail.offset + ImageInfo->Thumbnail.size) > length) {\n\t\tEXIF_ERRLOG_THUMBEOF(ImageInfo)\n\t\treturn;\n\t}\n\tImageInfo->Thumbnail.data = estrndup(offset + ImageInfo->Thumbnail.offset, ImageInfo->Thumbnail.size);\n\texif_thumbnail_build(ImageInfo TSRMLS_CC);\n}","23622":"_g_file_remove_directory (GFile         *directory,\n\t\t\t  GCancellable  *cancellable,\n\t\t\t  GError       **error)\n{\n\tGFileEnumerator *enumerator;\n\tGFileInfo       *info;\n\tgboolean         error_occurred = FALSE;\n\n\tif (directory == NULL)\n\t\treturn TRUE;\n\n\tenumerator = g_file_enumerate_children (directory,\n\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_NAME \"STR\"\n\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_TYPE,\n\t\t\t\t\t        0,\n\t\t\t\t\t        cancellable,\n\t\t\t\t\t        error);\n\n\twhile (! error_occurred && (info = g_file_enumerator_next_file (enumerator, cancellable, error)) != NULL) {\n\t\tGFile *child;\n\n\t\tchild = g_file_get_child (directory, g_file_info_get_name (info));\n\t\tswitch (g_file_info_get_file_type (info)) {\n\t\tcase G_FILE_TYPE_DIRECTORY:\n\t\t\tif (! _g_file_remove_directory (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (! g_file_delete (child, cancellable, error))\n\t\t\t\terror_occurred = TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tg_object_unref (child);\n\t\tg_object_unref (info);\n\t}\n\n\tif (! error_occurred && ! g_file_delete (directory, cancellable, error))\n \t\terror_occurred = TRUE;\n\n\tg_object_unref (enumerator);\n\n\treturn ! error_occurred;\n}","22808":"   Does a self test of the module \"STR\" *\/\nPHP_FUNCTION(mcrypt_module_self_test)\n{\n\tMCRYPT_GET_MODE_DIR_ARGS(algorithms_dir);\n\t\n\tif (mcrypt_module_self_test(module, dir) == 0) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}","22995":"static void cfsk_put(struct cflayer *layr)\n{\n\tstruct caifsock *cf_sk = container_of(layr, struct caifsock, layer);\n\tsock_put(&cf_sk->sk);\n}","23239":"int nfc_data_exchange(struct nfc_dev *dev, u32 target_idx, struct sk_buff *skb,\n\t\t      data_exchange_cb_t cb, void *cb_context)\n{\n\tint rc;\n\n\tpr_debug(\"STR\",\n\t\t dev_name(&dev->dev), target_idx, skb->len);\n\n\tdevice_lock(&dev->dev);\n\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\tif (dev->rf_mode == NFC_RF_INITIATOR && dev->active_target != NULL) {\n\t\tif (dev->active_target->idx != target_idx) {\n\t\t\trc = -EADDRNOTAVAIL;\n\t\t\tkfree_skb(skb);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (dev->ops->check_presence)\n\t\t\tdel_timer_sync(&dev->check_pres_timer);\n\n\t\trc = dev->ops->im_transceive(dev, dev->active_target, skb, cb,\n\t\t\t\t\t     cb_context);\n\n\t\tif (!rc && dev->ops->check_presence && !dev->shutting_down)\n\t\t\tmod_timer(&dev->check_pres_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n\t} else if (dev->rf_mode == NFC_RF_TARGET && dev->ops->tm_send != NULL) {\n\t\trc = dev->ops->tm_send(dev, skb);\n\t} else {\n\t\trc = -ENOTCONN;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}","23354":"spnego_gss_process_context_token(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\t\tconst gss_buffer_t token_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_process_context_token(minor_status,\n\t\t\t\t\tcontext_handle,\n\t\t\t\t\ttoken_buffer);\n\n\treturn (ret);\n}","22855":"static int cqspi_prep(struct spi_nor *nor, enum spi_nor_ops ops)\n{\n\tstruct cqspi_flash_pdata *f_pdata = nor->priv;\n\tstruct cqspi_st *cqspi = f_pdata->cqspi;\n\n\tmutex_lock(&cqspi->bus_mutex);\n\n\treturn 0;\n}","22985":"void fmtutil_atari_help_palbits(deark *c)\n{\n\tde_msg(c, \"STR\"\n\t\t\"STR\");\n}","23281":"xps_begin_opacity(xps_document *doc, const fz_matrix *ctm, const fz_rect *area,\n\tchar *base_uri, xps_resource *dict,\n\tchar *opacity_att, fz_xml *opacity_mask_tag)\n{\n\tfloat opacity;\n\n\tif (!opacity_att && !opacity_mask_tag)\n\t\treturn;\n\n\topacity = 1;\n\tif (opacity_att)\n\t\topacity = fz_atof(opacity_att);\n\n\tif (opacity_mask_tag && !strcmp(fz_xml_tag(opacity_mask_tag), \"STR\"))\n\t{\n\t\tchar *scb_opacity_att = fz_xml_att(opacity_mask_tag, \"STR\");\n\t\tchar *scb_color_att = fz_xml_att(opacity_mask_tag, \"STR\");\n\t\tif (scb_opacity_att)\n\t\t\topacity = opacity * fz_atof(scb_opacity_att);\n\t\tif (scb_color_att)\n\t\t{\n\t\t\tfz_colorspace *colorspace;\n\t\t\tfloat samples[32];\n\t\t\txps_parse_color(doc, base_uri, scb_color_att, &colorspace, samples);\n\t\t\topacity = opacity * samples[0];\n\t\t}\n\t\topacity_mask_tag = NULL;\n\t}\n\n\tif (doc->opacity_top + 1 < nelem(doc->opacity))\n\t{\n\t\tdoc->opacity[doc->opacity_top + 1] = doc->opacity[doc->opacity_top] * opacity;\n\t\tdoc->opacity_top++;\n\t}\n\n\tif (opacity_mask_tag)\n\t{\n\t\tfz_begin_mask(doc->dev, area, 0, NULL, NULL);\n\t\txps_parse_brush(doc, ctm, area, base_uri, dict, opacity_mask_tag);\n\t\tfz_end_mask(doc->dev);\n\t}\n}","23190":"static int sctp_setsockopt_auth_chunk(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authchunk val;\n\n\tif (optlen != sizeof(struct sctp_authchunk))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&val, optval, optlen))\n\t\treturn -EFAULT;\n\n\tswitch (val.sauth_chunk) {\n\t\tcase SCTP_CID_INIT:\n\t\tcase SCTP_CID_INIT_ACK:\n\t\tcase SCTP_CID_SHUTDOWN_COMPLETE:\n\t\tcase SCTP_CID_AUTH:\n\t\t\treturn -EINVAL;\n\t}\n\n\t\n\treturn sctp_auth_ep_add_chunkid(sctp_sk(sk)->ep, val.sauth_chunk);\n}","23562":"void* Type_Text_Description_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)\n{\n    return (void*) cmsMLUdup((cmsMLU*) Ptr);\n\n    cmsUNUSED_PARAMETER(n);\n    cmsUNUSED_PARAMETER(self);\n}","22700":"gss_context_time (minor_status,\n                  context_handle,\n                  time_rec)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nOM_uint32 *\t\ttime_rec;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n\n    if (time_rec == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    \n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\n\tif (mech->gss_context_time) {\n\t    status = mech->gss_context_time(\n\t\t\t\t\t    minor_status,\n\t\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t\t    time_rec);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n    return (GSS_S_BAD_MECH);\n}","22515":"void rose_start_hbtimer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tdel_timer(&rose->timer);\n\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->hb;\n\n\tadd_timer(&rose->timer);\n}","23449":"static void __exit pcd_exit(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (cd->present) {\n\t\t\tdel_gendisk(cd->disk);\n\t\t\tpi_release(cd->pi);\n\t\t\tunregister_cdrom(&cd->info);\n\t\t}\n\t\tblk_cleanup_queue(cd->disk->queue);\n\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\tput_disk(cd->disk);\n\t}\n\tunregister_blkdev(major, name);\n\tpi_unregister_driver(par_drv);\n}","23539":"TEST_P(Http2CodecImplTest, ResponseDataFloodMitigationDisabled) {\n  Runtime::LoaderSingleton::getExisting()->mergeValues(\n      {{\"STR\"}});\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  \n  EXPECT_CALL(server_connection_, write(_, _))\n      .Times(Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES + 2);\n  EXPECT_CALL(response_decoder_, decodeHeaders_(_, false)).Times(1);\n  EXPECT_CALL(response_decoder_, decodeData(_, false))\n      .Times(Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES);\n  TestHeaderMapImpl response_headers{{\"STR\"}};\n  response_encoder_->encodeHeaders(response_headers, false);\n  \n  for (uint32_t i = 0; i < Http2Settings::DEFAULT_MAX_OUTBOUND_FRAMES; ++i) {\n    Buffer::OwnedImpl data(\"STR\");\n    EXPECT_NO_THROW(response_encoder_->encodeData(data, false));\n  }\n  \n  \n  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  EXPECT_NO_THROW(client_->sendPendingFrames());\n}","22781":"\nstatic void __io_poll_execute(struct io_kiocb *req, int mask, __poll_t events)\n{\n\treq->cqe.res = mask;\n\t\n\treq->apoll_events = events;\n\tif (req->opcode == IORING_OP_POLL_ADD)\n\t\treq->io_task_work.func = io_poll_task_func;\n\telse\n\t\treq->io_task_work.func = io_apoll_task_func;\n\n\ttrace_io_uring_task_add(req->ctx, req, req->cqe.user_data, req->opcode, mask);\n\tio_req_task_work_add(req);","23362":"Bool gf_media_aom_probe_annexb(GF_BitStream *bs)\n{\n\tBool res = GF_TRUE;\n\tu64 init_pos = gf_bs_get_position(bs);\n\tu64 sz = gf_av1_leb128_read(bs, NULL);\n\tif (!sz) res = GF_FALSE;\n\twhile (sz > 0) {\n\t\tu8 Leb128Bytes = 0;\n\t\tu64 frame_unit_size = gf_av1_leb128_read(bs, &Leb128Bytes);\n\n\t\tif (!frame_unit_size) {\n\t\t\tres = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sz < Leb128Bytes + frame_unit_size) {\n\t\t\tres = GF_FALSE;\n\t\t\tbreak;\n\t\t}\n\t\tsz -= Leb128Bytes + frame_unit_size;\n\n\t\twhile (frame_unit_size > 0) {\n\t\t\tObuType obu_type;\n\t\t\tu64 pos, obu_length = gf_av1_leb128_read(bs, &Leb128Bytes);\n\t\t\tif (frame_unit_size < Leb128Bytes + obu_length) {\n\t\t\t\tres = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos = gf_bs_get_position(bs);\n\t\t\tframe_unit_size -= Leb128Bytes;\n\n\t\t\tu8 tid, sid;\n\t\t\tBool extflag, has_size;\n\t\t\tGF_Err e = gf_av1_parse_obu_header(bs, &obu_type, &extflag, &has_size, &tid, &sid);\n\t\t\tif (e) {\n\t\t\t\tres = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (has_size) {\n\t\t\t\tobu_length = (u32)gf_av1_leb128_read(bs, NULL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (obu_length >= 1 + extflag) {\n\t\t\t\t\tobu_length = obu_length - 1 - extflag;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres = GF_FALSE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu32 hdr_size = (u32)(gf_bs_get_position(bs) - pos);\n\t\t\tobu_length += hdr_size;\n\n\t\t\tif (frame_unit_size < obu_length) {\n\t\t\t\tres = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tframe_unit_size -= obu_length;\n\t\t\tgf_bs_skip_bytes(bs, obu_length - hdr_size);\n\t\t}\n\t\tif (!res) break;\n\t}\n\tgf_bs_seek(bs, init_pos);\n\treturn res;\n}","23316":"        void stop()\n        {\n#ifdef CROW_ENABLE_SSL\n            if (ssl_used_)\n            {\n                if (ssl_server_) { ssl_server_->stop(); }\n            }\n            else\n#endif\n            {\n                std::vector<crow::websocket::connection*> websockets_to_close = websockets_;\n                for (auto websocket : websockets_to_close)\n                {\n                    CROW_LOG_INFO << \"STR\" << websocket;\n                    websocket->close(\"STR\");\n                }\n                if (server_) { server_->stop(); }\n            }\n        }","23428":"goa_ews_client_autodiscover (GoaEwsClient        *client,\n                             const gchar         *email,\n                             const gchar         *password,\n                             const gchar         *username,\n                             const gchar         *server,\n                             GCancellable        *cancellable,\n                             GAsyncReadyCallback  callback,\n                             gpointer             user_data)\n{\n  AutodiscoverData *data;\n  AutodiscoverAuthData *auth;\n  gchar *url1;\n  gchar *url2;\n  xmlDoc *doc;\n  xmlOutputBuffer *buf;\n\n  g_return_if_fail (GOA_IS_EWS_CLIENT (client));\n  g_return_if_fail (email != NULL || email[0] != '\\0');\n  g_return_if_fail (password != NULL || password[0] != '\\0');\n  g_return_if_fail (username != NULL || username[0] != '\\0');\n  g_return_if_fail (server != NULL || server[0] != '\\0');\n  g_return_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable));\n\n  doc = ews_client_create_autodiscover_xml (email);\n  buf = xmlAllocOutputBuffer (NULL);\n  xmlNodeDumpOutput (buf, doc, xmlDocGetRootElement (doc), 0, 1, NULL);\n  xmlOutputBufferFlush (buf);\n\n  url1 = g_strdup_printf (\"STR\", server);\n  url2 = g_strdup_printf (\"STR\", server);\n\n  \n  data = g_slice_new0 (AutodiscoverData);\n  data->buf = buf;\n  data->res = g_simple_async_result_new (G_OBJECT (client), callback, user_data, goa_ews_client_autodiscover);\n  data->msgs[0] = ews_client_create_msg_for_url (url1, buf);\n  data->msgs[1] = ews_client_create_msg_for_url (url2, buf);\n  data->session = soup_session_async_new_with_options (SOUP_SESSION_USE_NTLM, TRUE,\n                                                       SOUP_SESSION_USE_THREAD_CONTEXT, TRUE,\n                                                       NULL);\n  if (cancellable != NULL)\n    {\n      data->cancellable = g_object_ref (cancellable);\n      data->cancellable_id = g_cancellable_connect (data->cancellable,\n                                                    G_CALLBACK (ews_client_autodiscover_cancelled_cb),\n                                                    data,\n                                                    NULL);\n      g_simple_async_result_set_check_cancellable (data->res, data->cancellable);\n    }\n\n  auth = g_slice_new0 (AutodiscoverAuthData);\n  auth->username = g_strdup (username);\n  auth->password = g_strdup (password);\n  g_signal_connect_data (data->session,\n                         \"STR\",\n                         G_CALLBACK (ews_client_authenticate),\n                         auth,\n                         ews_client_autodiscover_auth_data_free,\n                         0);\n\n  soup_session_queue_message (data->session, data->msgs[0], ews_client_autodiscover_response_cb, data);\n  soup_session_queue_message (data->session, data->msgs[1], ews_client_autodiscover_response_cb, data);\n\n  g_free (url2);\n  g_free (url1);\n  xmlFreeDoc (doc);\n}","22981":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TfLiteTensor* hits;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 1, &hits));\n  const TfLiteTensor* lookup;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &lookup));\n  const TfLiteTensor* key;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &key));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &value));\n\n  const int num_rows = SizeOfDimension(value, 0);\n  const int row_bytes = value->bytes \/ num_rows;\n  void* pointer = nullptr;\n  DynamicBuffer buf;\n\n  for (int i = 0; i < SizeOfDimension(lookup, 0); i++) {\n    int idx = -1;\n    pointer = bsearch(&(lookup->data.i32[i]), key->data.i32, num_rows,\n                      sizeof(int32_t), greater);\n    if (pointer != nullptr) {\n      idx = (reinterpret_cast<char*>(pointer) - (key->data.raw)) \/\n            sizeof(int32_t);\n    }\n\n    if (idx >= num_rows || idx < 0) {\n      if (output->type == kTfLiteString) {\n        buf.AddString(nullptr, 0);\n      } else {\n        memset(output->data.raw + i * row_bytes, 0, row_bytes);\n      }\n      hits->data.uint8[i] = 0;\n    } else {\n      if (output->type == kTfLiteString) {\n        buf.AddString(GetString(value, idx));\n      } else {\n        memcpy(output->data.raw + i * row_bytes,\n               value->data.raw + idx * row_bytes, row_bytes);\n      }\n      hits->data.uint8[i] = 1;\n    }\n  }\n  if (output->type == kTfLiteString) {\n    buf.WriteToTensorAsVector(output);\n  }\n\n  return kTfLiteOk;\n}","23559":"f_reg_recording(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    return_register(reg_recording, rettv);\n}","22662":"PrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n\n  SgxParams *const sgx_params =\n      reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n  sgx_params->input_size = 0;\n  sgx_params->input = nullptr;\n  if (input) {\n    sgx_params->input_size = input->MessageSize();\n    if (sgx_params->input_size > 0) {\n      \n      sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n      input->Serialize(const_cast<void *>(sgx_params->input));\n    }\n  }\n  sgx_params->output_size = 0;\n  sgx_params->output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n  if (sgx_params->input) {\n    untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n  }\n  if (sgx_params->output) {\n    \n    \n    output->Deserialize(sgx_params->output, sgx_params->output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n  }\n  return PrimitiveStatus::OkStatus();\n}","23618":"qemuProcessHandleMonitorEOF(qemuMonitorPtr mon,\n                            virDomainObjPtr vm,\n                            void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n    struct qemuProcessEvent *processEvent;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"STR\", vm, vm->def->name);\n\n    priv = vm->privateData;\n    if (priv->beingDestroyed) {\n        VIR_DEBUG(\"STR\");\n        goto cleanup;\n    }\n\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n\n    processEvent->eventType = QEMU_PROCESS_EVENT_MONITOR_EOF;\n    processEvent->vm = virObjectRef(vm);\n\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        qemuProcessEventFree(processEvent);\n        goto cleanup;\n    }\n\n    \n    qemuMonitorUnregister(mon);\n\n    \n    qemuDomainDestroyNamespace(driver, vm);\n\n cleanup:\n    virObjectUnlock(vm);\n}","22850":"static AddressTree* get_allowed_nets(lua_State* vm) {\n  AddressTree *ptree;\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"STR\", __FUNCTION__);\n\n  lua_getglobal(vm, CONST_ALLOWED_NETS);\n  ptree = (AddressTree*)lua_touserdata(vm, lua_gettop(vm));\n  \n  return(ptree);\n}","23127":"BufferedRandomDevice::BufferedRandomDevice(size_t bufferSize)\n  : bufferSize_(bufferSize),\n    buffer_(new unsigned char[bufferSize]),\n    ptr_(buffer_.get() + bufferSize) {  \n}","23331":"keydirection2ascii (int kd, bool remote)\n{\n  if (kd == KEY_DIRECTION_BIDIRECTIONAL)\n    return NULL;\n  else if (kd == KEY_DIRECTION_NORMAL)\n    return remote ? \"STR\";\n  else if (kd == KEY_DIRECTION_INVERSE)\n    return remote ? \"STR\";\n  else\n    {\n      ASSERT (0);\n    }\n  return NULL; \n}","23423":"PyImaging_BitDecoderNew(PyObject* self, PyObject* args)\n{\n    ImagingDecoderObject* decoder;\n\n    char* mode;\n    int bits  = 8;\n    int pad   = 8;\n    int fill  = 0;\n    int sign  = 0;\n    int ystep = 1;\n    if (!PyArg_ParseTuple(args, \"STR\", &mode, &bits, &pad, &fill,\n                          &sign, &ystep))\n        return NULL;\n\n    if (strcmp(mode, \"STR\") != 0) {\n        PyErr_SetString(PyExc_ValueError, \"STR\");\n        return NULL;\n    }\n\n    decoder = PyImaging_DecoderNew(sizeof(BITSTATE));\n    if (decoder == NULL)\n        return NULL;\n\n    decoder->decode = ImagingBitDecode;\n\n    decoder->state.ystep = ystep;\n\n    ((BITSTATE*)decoder->state.context)->bits = bits;\n    ((BITSTATE*)decoder->state.context)->pad  = pad;\n    ((BITSTATE*)decoder->state.context)->fill = fill;\n    ((BITSTATE*)decoder->state.context)->sign = sign;\n\n    return (PyObject*) decoder;\n}","23464":"  bool isRoutable() const override { return true; }","23518":"void qxl_spice_update_area(PCIQXLDevice *qxl, uint32_t surface_id,\n                           struct QXLRect *area, struct QXLRect *dirty_rects,\n                           uint32_t num_dirty_rects,\n                           uint32_t clear_dirty_region)\n{\n    qxl->ssd.worker->update_area(qxl->ssd.worker, surface_id, area, dirty_rects,\n                             num_dirty_rects, clear_dirty_region);\n}","23019":"static inline size_t inet6_prefix_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct prefixmsg))\n\t       + nla_total_size(sizeof(struct in6_addr))\n\t       + nla_total_size(sizeof(struct prefix_cacheinfo));\n}","23276":"int BIO_vprintf(BIO *bio, const char *format, va_list args)\n{\n    int ret;\n    size_t retlen;\n    char hugebuf[1024 * 2];     \n    char *hugebufp = hugebuf;\n    size_t hugebufsize = sizeof(hugebuf);\n    char *dynbuf = NULL;\n    int ignored;\n\n    dynbuf = NULL;\n    _dopr(&hugebufp, &dynbuf, &hugebufsize, &retlen, &ignored, format, args);\n    if (dynbuf) {\n        ret = BIO_write(bio, dynbuf, (int)retlen);\n        OPENSSL_free(dynbuf);\n    } else {\n        ret = BIO_write(bio, hugebuf, (int)retlen);\n    }\n    return (ret);\n}","22933":"static ZEND_RESULT_CODE parse_uidn(struct parse_state *state)\n{\n\tchar *host_ptr;\n\tuint16_t *uhost_str, ahost_str[MAXHOSTNAMELEN], *ahost_ptr;\n\tsize_t uhost_len, ahost_len;\n\tUErrorCode error = U_ZERO_ERROR;\n\tTSRMLS_FETCH_FROM_CTX(state->ts);\n\n\tif (state->flags & PHP_HTTP_URL_PARSE_MBUTF8) {\n\t\tif (SUCCESS != to_utf16(parse_mb_utf8, state->url.host, &uhost_str, &uhost_len TSRMLS_CC)) {\n\t\t\treturn FAILURE;\n\t\t}\n#ifdef PHP_HTTP_HAVE_WCHAR\n\t} else if (state->flags & PHP_HTTP_URL_PARSE_MBLOC) {\n\t\tif (SUCCESS != to_utf16(parse_mb_loc, state->url.host, &uhost_str, &uhost_len TSRMLS_CC)) {\n\t\t\treturn FAILURE;\n\t\t}\n#endif\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"STR\");\n\t\treturn FAILURE;\n\t}\n\n\tahost_len = uidna_IDNToASCII(uhost_str, uhost_len, ahost_str, MAXHOSTNAMELEN, 3, NULL, &error);\n\tefree(uhost_str);\n\n\tif (error != U_ZERO_ERROR) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"STR\", error);\n\t\treturn FAILURE;\n\t}\n\n\thost_ptr = state->url.host;\n\tahost_ptr = ahost_str;\n\tPHP_HTTP_DUFF(ahost_len, *host_ptr++ = *ahost_ptr++);\n\n\t*host_ptr = '\\0';\n\tstate->offset += host_ptr - state->url.host;\n\n\treturn SUCCESS;\n}","23452":"static void fdctrl_write_data(FDCtrl *fdctrl, uint32_t value)\n{\n    FDrive *cur_drv;\n    int pos;\n\n    \n    if (!(fdctrl->dor & FD_DOR_nRESET)) {\n        FLOPPY_DPRINTF(\"STR\");\n        return;\n    }\n    if (!(fdctrl->msr & FD_MSR_RQM) || (fdctrl->msr & FD_MSR_DIO)) {\n        FLOPPY_DPRINTF(\"STR\");\n        return;\n    }\n    fdctrl->dsr &= ~FD_DSR_PWRDOWN;\n    \n    if (fdctrl->msr & FD_MSR_NONDMA) {\n        \n        pos = fdctrl->data_pos++;\n        pos %= FD_SECTOR_LEN;\n        fdctrl->fifo[pos] = value;\n        if (pos == FD_SECTOR_LEN - 1 ||\n            fdctrl->data_pos == fdctrl->data_len) {\n            cur_drv = get_cur_drv(fdctrl);\n            if (blk_write(cur_drv->blk, fd_sector(cur_drv), fdctrl->fifo, 1)\n                < 0) {\n                FLOPPY_DPRINTF(\"STR\",\n                               fd_sector(cur_drv));\n                return;\n            }\n            if (!fdctrl_seek_to_next_sect(fdctrl, cur_drv)) {\n                FLOPPY_DPRINTF(\"STR\",\n                               fd_sector(cur_drv));\n                return;\n            }\n        }\n        \n        if (fdctrl->data_pos == fdctrl->data_len)\n            fdctrl_stop_transfer(fdctrl, 0x00, 0x00, 0x00);\n        return;\n    }\n    if (fdctrl->data_pos == 0) {\n        \n        pos = command_to_handler[value & 0xff];\n        FLOPPY_DPRINTF(\"STR\", handlers[pos].name);\n        fdctrl->data_len = handlers[pos].parameters + 1;\n        fdctrl->msr |= FD_MSR_CMDBUSY;\n    }\n\n    FLOPPY_DPRINTF(\"STR\", __func__, value);\n    fdctrl->fifo[fdctrl->data_pos++] = value;\n    if (fdctrl->data_pos == fdctrl->data_len) {\n        \n        if (fdctrl->data_state & FD_STATE_FORMAT) {\n            fdctrl_format_sector(fdctrl);\n            return;\n        }\n\n        pos = command_to_handler[fdctrl->fifo[0] & 0xff];\n        FLOPPY_DPRINTF(\"STR\", handlers[pos].name);\n        (*handlers[pos].handler)(fdctrl, handlers[pos].direction);\n    }\n}","22844":"static int rleCompress(int inLength, const char in[], signed char out[]) {\n  const char *inEnd = in + inLength;\n  const char *runStart = in;\n  const char *runEnd = in + 1;\n  signed char *outWrite = out;\n\n  while (runStart < inEnd) {\n    while (runEnd < inEnd && *runStart == *runEnd &&\n           runEnd - runStart - 1 < MAX_RUN_LENGTH) {\n      ++runEnd;\n    }\n\n    if (runEnd - runStart >= MIN_RUN_LENGTH) {\n      \n      \n      \n\n      *outWrite++ = static_cast<char>(runEnd - runStart) - 1;\n      *outWrite++ = *(reinterpret_cast<const signed char *>(runStart));\n      runStart = runEnd;\n    } else {\n      \n      \n      \n\n      while (runEnd < inEnd &&\n             ((runEnd + 1 >= inEnd || *runEnd != *(runEnd + 1)) ||\n              (runEnd + 2 >= inEnd || *(runEnd + 1) != *(runEnd + 2))) &&\n             runEnd - runStart < MAX_RUN_LENGTH) {\n        ++runEnd;\n      }\n\n      *outWrite++ = static_cast<char>(runStart - runEnd);\n\n      while (runStart < runEnd) {\n        *outWrite++ = *(reinterpret_cast<const signed char *>(runStart++));\n      }\n    }\n\n    ++runEnd;\n  }\n\n  return static_cast<int>(outWrite - out);\n}","23389":"ZEND_VM_HOT_TYPE_SPEC_HANDLER(ZEND_PRE_DEC, (op1_info == MAY_BE_LONG), ZEND_PRE_DEC_LONG, CV, ANY, SPEC(RETVAL))\n{\n\tUSE_OPLINE\n\tzval *var_ptr;\n\n\tvar_ptr = GET_OP1_ZVAL_PTR_PTR_UNDEF(BP_VAR_RW);\n\tfast_long_decrement_function(var_ptr);\n\tif (UNEXPECTED(RETURN_VALUE_USED(opline))) {\n\t\tZVAL_COPY_VALUE(EX_VAR(opline->result.var), var_ptr);\n\t}\n\tZEND_VM_NEXT_OPCODE();\n}","22638":"int base64_encode_block(const char *plaintext_in, int length_in, char *code_out,\n\t\t\tstruct base64_encodestate *state_in)\n{\n\tconst char *plainchar = plaintext_in;\n\tconst char *const plaintextend = plaintext_in + length_in;\n\tchar *codechar = code_out;\n\tchar result;\n\tchar fragment;\n\n\tresult = state_in->result;\n\n\tswitch (state_in->step) {\n\t\twhile (1) {\n\t\t\tcase step_A:\n\t\t\t\tif (plainchar == plaintextend) {\n\t\t\t\t\tstate_in->result = result;\n\t\t\t\t\tstate_in->step = step_A;\n\t\t\t\t\treturn codechar - code_out;\n\t\t\t\t}\n\t\t\t\tfragment = *plainchar++;\n\t\t\t\tresult = (fragment & 0x0fc) >> 2;\n\t\t\t\t*codechar++ = base64_encode_value(result);\n\t\t\t\tresult = (fragment & 0x003) << 4;\n\t\t\t\t\n\t\t\tcase step_B:\n\t\t\t\tif (plainchar == plaintextend) {\n\t\t\t\t\tstate_in->result = result;\n\t\t\t\t\tstate_in->step = step_B;\n\t\t\t\t\treturn codechar - code_out;\n\t\t\t\t}\n\t\t\t\tfragment = *plainchar++;\n\t\t\t\tresult |= (fragment & 0x0f0) >> 4;\n\t\t\t\t*codechar++ = base64_encode_value(result);\n\t\t\t\tresult = (fragment & 0x00f) << 2;\n\t\t\t\t\n\t\t\tcase step_C:\n\t\t\t\tif (plainchar == plaintextend) {\n\t\t\t\t\tstate_in->result = result;\n\t\t\t\t\tstate_in->step = step_C;\n\t\t\t\t\treturn codechar - code_out;\n\t\t\t\t}\n\t\t\t\tfragment = *plainchar++;\n\t\t\t\tresult |= (fragment & 0x0c0) >> 6;\n\t\t\t\t*codechar++ = base64_encode_value(result);\n\t\t\t\tresult  = (fragment & 0x03f) >> 0;\n\t\t\t\t*codechar++ = base64_encode_value(result);\n\n\t\t\t\t++(state_in->stepcount);\n\t\t\t\tif (state_in->stepcount == CHARS_PER_LINE\/4) {\n\t\t\t\t\t*codechar++ = '\\n';\n\t\t\t\t\tstate_in->stepcount = 0;\n\t\t\t\t}\n\t\t}\n\t}\n\t\n\treturn codechar - code_out;\n}","22787":"static inline int fast_to_acquire(struct gfs2_rgrpd *rgd)\n{\n\tstruct gfs2_glock *gl = rgd->rd_gl;\n\n\tif (gl->gl_state != LM_ST_UNLOCKED && list_empty(&gl->gl_holders) &&\n\t    !test_bit(GLF_DEMOTE_IN_PROGRESS, &gl->gl_flags) &&\n\t    !test_bit(GLF_DEMOTE, &gl->gl_flags))\n\t\treturn 1;\n\tif (rgd->rd_flags & GFS2_RDF_PREFERRED)\n\t\treturn 1;\n\treturn 0;\n}","23243":"static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tzend_op *opline = EX(opline);\n\n\tif (ARG_SHOULD_BE_SENT_BY_REF(EX(fbc), opline->extended_value)) {\n\t\t\n\t\tzend_free_op free_op1;\n\t\tzval *property = _get_zval_ptr_cv(&opline->op2, EX(Ts), BP_VAR_R TSRMLS_CC);\n\t\tzval **container = _get_zval_ptr_ptr_var(&opline->op1, EX(Ts), &free_op1 TSRMLS_CC);\n\n\t\tif (0) {\n\t\t\tMAKE_REAL_ZVAL_PTR(property);\n\t\t}\n\t\tif (IS_VAR == IS_VAR && !container) {\n\t\t\tzend_error_noreturn(E_ERROR, \"STR\");\n\t\t}\n\t\tzend_fetch_property_address(&EX_T(opline->result.u.var), container, property, BP_VAR_W TSRMLS_CC);\n\t\tif (0) {\n\t\t\tzval_ptr_dtor(&property);\n\t\t} else {\n\n\t\t}\n\t\tif (IS_VAR == IS_VAR && (free_op1.var != NULL) &&\n\t\t    READY_TO_DESTROY(free_op1.var)) {\n\t\t\tAI_USE_PTR(EX_T(opline->result.u.var).var);\n\t\t\tif (!PZVAL_IS_REF(*EX_T(opline->result.u.var).var.ptr_ptr) &&\n\t\t\t    Z_REFCOUNT_PP(EX_T(opline->result.u.var).var.ptr_ptr) > 2) {\n\t\t\t\tSEPARATE_ZVAL(EX_T(opline->result.u.var).var.ptr_ptr);\n\t\t\t}\n\t\t}\n\t\tif (free_op1.var) {zval_ptr_dtor(&free_op1.var);};\n\t\tZEND_VM_NEXT_OPCODE();\n\t} else {\n\t\treturn zend_fetch_property_address_read_helper_SPEC_VAR_CV(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);\n\t}\n}","23744":"static void sctp_asconf_param_success(struct sctp_association *asoc,\n\t\t\t\t     sctp_addip_param_t *asconf_param)\n{\n\tstruct sctp_af *af;\n\tunion sctp_addr\taddr;\n\tstruct sctp_bind_addr *bp = &asoc->base.bind_addr;\n\tunion sctp_addr_param *addr_param;\n\tstruct sctp_transport *transport;\n\tstruct sctp_sockaddr_entry *saddr;\n\n\taddr_param = (void *)asconf_param + sizeof(sctp_addip_param_t);\n\n\t\n\taf = sctp_get_af_specific(param_type2af(addr_param->p.type));\n\taf->from_addr_param(&addr, addr_param, htons(bp->port), 0);\n\n\tswitch (asconf_param->param_hdr.type) {\n\tcase SCTP_PARAM_ADD_IP:\n\t\t\n\t\tlocal_bh_disable();\n\t\tlist_for_each_entry(saddr, &bp->address_list, list) {\n\t\t\tif (sctp_cmp_addr_exact(&saddr->a, &addr))\n\t\t\t\tsaddr->state = SCTP_ADDR_SRC;\n\t\t}\n\t\tlocal_bh_enable();\n\t\tlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\t\tdst_release(transport->dst);\n\t\t\ttransport->dst = NULL;\n\t\t}\n\t\tbreak;\n\tcase SCTP_PARAM_DEL_IP:\n\t\tlocal_bh_disable();\n\t\tsctp_del_bind_addr(bp, &addr);\n\t\tif (asoc->asconf_addr_del_pending != NULL &&\n\t\t    sctp_cmp_addr_exact(asoc->asconf_addr_del_pending, &addr)) {\n\t\t\tkfree(asoc->asconf_addr_del_pending);\n\t\t\tasoc->asconf_addr_del_pending = NULL;\n\t\t}\n\t\tlocal_bh_enable();\n\t\tlist_for_each_entry(transport, &asoc->peer.transport_addr_list,\n\t\t\t\ttransports) {\n\t\t\tdst_release(transport->dst);\n\t\t\ttransport->dst = NULL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}","23180":"int mnt_fs_is_deleted(struct libmnt_fs *fs)\n{\n\treturn mnt_fs_get_flags(fs) & MNT_FS_DELETED;\n}","23287":"static ssize_t lbs_highrssi_write(struct file *file, const char __user *userbuf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\treturn lbs_threshold_write(TLV_TYPE_RSSI_HIGH, CMD_SUBSCRIBE_RSSI_HIGH,\n\t\t\t\t   file, userbuf, count, ppos);\n}","22977":"int SSL_export_keying_material(SSL *s, unsigned char *out, size_t olen,\n                               const char *label, size_t llen,\n                               const unsigned char *p, size_t plen,\n                               int use_context)\n{\n    if (s->version < TLS1_VERSION)\n        return -1;\n\n    return s->method->ssl3_enc->export_keying_material(s, out, olen, label,\n                                                       llen, p, plen,\n                                                       use_context);\n}","23108":"static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)\n{\n\text4_fsblk_t block = ext4_ext_pblock(ext);\n\tint len = ext4_ext_get_actual_len(ext);\n\text4_lblk_t lblock = le32_to_cpu(ext->ee_block);\n\n\t\n\tif (lblock + len <= lblock)\n\t\treturn 0;\n\treturn ext4_inode_block_valid(inode, block, len);\n}","23372":"static void hci_cc_read_local_commands(struct hci_dev *hdev,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct hci_rp_read_local_commands *rp = (void *) skb->data;\n\n\tBT_DBG(\"STR\", hdev->name, rp->status);\n\n\tif (rp->status)\n\t\treturn;\n\n\tif (hci_dev_test_flag(hdev, HCI_SETUP) ||\n\t    hci_dev_test_flag(hdev, HCI_CONFIG))\n\t\tmemcpy(hdev->commands, rp->commands, sizeof(hdev->commands));\n}","23319":"RPVector *r_bin_wasm_get_tables(RBinWasmObj *bin) {\n\tr_return_val_if_fail (bin && bin->g_sections, NULL);\n\treturn bin->g_tables? bin->g_tables: parse_unique_subsec_vec_by_id (bin, R_BIN_WASM_SECTION_TABLE);\n}","23556":"int tls1_save_sigalgs(SSL *s, PACKET *pkt, int cert)\n{\n    \n    if (!SSL_USE_SIGALGS(s))\n        return 1;\n    \n    if (s->cert == NULL)\n        return 0;\n\n    if (cert)\n        return tls1_save_u16(pkt, &s->s3.tmp.peer_cert_sigalgs,\n                             &s->s3.tmp.peer_cert_sigalgslen);\n    else\n        return tls1_save_u16(pkt, &s->s3.tmp.peer_sigalgs,\n                             &s->s3.tmp.peer_sigalgslen);\n\n}","23472":"int sas_discover_end_dev(struct domain_device *dev)\n{\n\tint res;\n\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\tsas_discover_event(dev->port, DISCE_PROBE);\n\n\treturn 0;\n}","22677":"xmlXPtrGetLastChar(xmlNodePtr *node, int *indx) {\n    xmlNodePtr cur;\n    int pos, len = 0;\n\n    if ((node == NULL) || (indx == NULL))\n\treturn(-1);\n    cur = *node;\n    pos = *indx;\n\n    if (cur == NULL)\n\treturn(-1);\n\n    if ((cur->type == XML_ELEMENT_NODE) ||\n\t(cur->type == XML_DOCUMENT_NODE) ||\n\t(cur->type == XML_HTML_DOCUMENT_NODE)) {\n\tif (pos > 0) {\n\t    cur = xmlXPtrGetNthChild(cur, pos);\n\t}\n    }\n    while (cur != NULL) {\n\tif (cur->last != NULL)\n\t    cur = cur->last;\n\telse if ((cur->type != XML_ELEMENT_NODE) &&\n\t         (cur->content != NULL)) {\n\t    len = xmlStrlen(cur->content);\n\t    break;\n\t} else {\n\t    return(-1);\n\t}\n    }\n    if (cur == NULL)\n\treturn(-1);\n    *node = cur;\n    *indx = len;\n    return(0);\n}","22832":"void CertManager::setPeerX509(X509* x)\n{\n    if (x == 0) return;\n\n    X509_NAME* issuer   = x->GetIssuer();\n    X509_NAME* subject  = x->GetSubject();\n    ASN1_STRING* before = x->GetBefore();\n    ASN1_STRING* after  = x->GetAfter();\n\n    peerX509_ = NEW_YS X509(issuer->GetName(), issuer->GetLength(),\n        subject->GetName(), subject->GetLength(), (const char*) before->data,\n        before->length, (const char*) after->data, after->length);\n}","23232":"static inline bool is_class_loader(const Symbol* class_name,\n                                   const ClassFileParser& parser) {\n  assert(class_name != NULL, \"STR\");\n\n  if (class_name == vmSymbols::java_lang_ClassLoader()) {\n    return true;\n  }\n\n  if (vmClasses::ClassLoader_klass_loaded()) {\n    const Klass* const super_klass = parser.super_klass();\n    if (super_klass != NULL) {\n      if (super_klass->is_subtype_of(vmClasses::ClassLoader_klass())) {\n        return true;\n      }\n    }\n  }\n  return false;\n}","22635":"int format_get_length(const char *str)\n{\n\tGString *tmp;\n\tint len;\n\tgboolean utf8;\n\tint adv = 0;\n\n\tg_return_val_if_fail(str != NULL, 0);\n\n\tutf8 = is_utf8() && g_utf8_validate(str, -1, NULL);\n\n\ttmp = g_string_new(NULL);\n\tlen = 0;\n\twhile (*str != '\\0') {\n\t\tif (*str == '%' && str[1] != '\\0') {\n\t\t\tstr++;\n\t\t\tif (*str != '%') {\n\t\t\t     adv = format_expand_styles(tmp, &str, NULL);\n\t\t\t     str += adv;\n\t\t\t     if (adv)\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t\n\t\t\tif (*str != '%')\n\t\t\t\tlen++;\n\t\t}\n\n\t\tlen += advance(&str, utf8);\n\t}\n\n\tg_string_free(tmp, TRUE);\n\treturn len;\n}","22766":"static void io_wq_exit_workers(struct io_wq *wq)\n{\n\tstruct callback_head *cb;\n\tint node;\n\n\tif (!wq->task)\n\t\treturn;\n\n\twhile ((cb = task_work_cancel_match(wq->task, io_task_work_match, wq)) != NULL) {\n\t\tstruct io_worker *worker;\n\n\t\tworker = container_of(cb, struct io_worker, create_work);\n\t\tatomic_dec(&worker->wqe->acct[worker->create_index].nr_running);\n\t\tio_worker_ref_put(wq);\n\t\tclear_bit_unlock(0, &worker->create_state);\n\t\tio_worker_release(worker);\n\t}\n\n\trcu_read_lock();\n\tfor_each_node(node) {\n\t\tstruct io_wqe *wqe = wq->wqes[node];\n\n\t\tio_wq_for_each_worker(wqe, io_wq_worker_wake, NULL);\n\t}\n\trcu_read_unlock();\n\tio_worker_ref_put(wq);\n\twait_for_completion(&wq->worker_done);\n\n\tfor_each_node(node) {\n\t\tspin_lock_irq(&wq->hash->wait.lock);\n\t\tlist_del_init(&wq->wqes[node]->wait.entry);\n\t\tspin_unlock_irq(&wq->hash->wait.lock);\n\t}\n\tput_task_struct(wq->task);\n\twq->task = NULL;\n}","22682":"query_get (struct query *z, iopause_fd *x, struct taia *stamp)\n{\n    switch (qmerge_get (&z->qm, x, stamp))\n    {\n    case 1:\n        return doit (z, 1);\n    case -1:\n        return doit (z, -1);\n    }\n\n    return 0;\n}","23570":"static int phar_call_openssl_signverify(int is_sign, php_stream *fp, zend_off_t end, char *key, int key_len, char **signature, int *signature_len) \n{\n\tzend_fcall_info fci;\n\tzend_fcall_info_cache fcc;\n\tzval retval, zp[3], openssl;\n\tzend_string *str;\n\n\tZVAL_STRINGL(&openssl, is_sign ? \"STR\")-1);\n\tZVAL_STRINGL(&zp[1], *signature, *signature_len);\n\tZVAL_STRINGL(&zp[2], key, key_len);\n\tphp_stream_rewind(fp);\n\tstr = php_stream_copy_to_mem(fp, (size_t) end, 0);\n\tif (str) {\n\t\tZVAL_STR(&zp[0], str);\n\t} else {\n\t\tZVAL_EMPTY_STRING(&zp[0]);\n\t}\n\n\tif (end != Z_STRLEN(zp[0])) {\n\t\tzval_dtor(&zp[0]);\n\t\tzval_dtor(&zp[1]);\n\t\tzval_dtor(&zp[2]);\n\t\tzval_dtor(&openssl);\n\t\treturn FAILURE;\n\t}\n\n\tif (FAILURE == zend_fcall_info_init(&openssl, 0, &fci, &fcc, NULL, NULL)) {\n\t\tzval_dtor(&zp[0]);\n\t\tzval_dtor(&zp[1]);\n\t\tzval_dtor(&zp[2]);\n\t\tzval_dtor(&openssl);\n\t\treturn FAILURE;\n\t}\n\n\tfci.param_count = 3;\n\tfci.params = zp;\n\tZ_ADDREF(zp[0]);\n\tif (is_sign) {\n\t\tZVAL_NEW_REF(&zp[1], &zp[1]);\n\t} else {\n\t\tZ_ADDREF(zp[1]);\n\t}\n\tZ_ADDREF(zp[2]);\n\n\tfci.retval = &retval;\n\n\tif (FAILURE == zend_call_function(&fci, &fcc)) {\n\t\tzval_dtor(&zp[0]);\n\t\tzval_dtor(&zp[1]);\n\t\tzval_dtor(&zp[2]);\n\t\tzval_dtor(&openssl);\n\t\treturn FAILURE;\n\t}\n\n\tzval_dtor(&openssl);\n\tZ_DELREF(zp[0]);\n\n\tif (is_sign) {\n\t\tZVAL_UNREF(&zp[1]);\n\t} else {\n\t\tZ_DELREF(zp[1]);\n\t}\n\tZ_DELREF(zp[2]);\n\n\tzval_dtor(&zp[0]);\n\tzval_dtor(&zp[2]);\n\n\tswitch (Z_TYPE(retval)) {\n\t\tdefault:\n\t\tcase IS_LONG:\n\t\t\tzval_dtor(&zp[1]);\n\t\t\tif (1 == Z_LVAL(retval)) {\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\tcase IS_TRUE:\n\t\t\t*signature = estrndup(Z_STRVAL(zp[1]), Z_STRLEN(zp[1]));\n\t\t\t*signature_len = Z_STRLEN(zp[1]);\n\t\t\tzval_dtor(&zp[1]);\n\t\t\treturn SUCCESS;\n\t\tcase IS_FALSE:\n\t\t\tzval_dtor(&zp[1]);\n\t\t\treturn FAILURE;\n\t}\n}","23404":"pk_transaction_finish_invalidate_caches (PkTransaction *transaction)\n{\n\tPkTransactionPrivate *priv = transaction->priv;\n\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), FALSE);\n\n\t\n\tif (pk_bitfield_contain (transaction->priv->cached_transaction_flags,\n\t\t\t\t  PK_TRANSACTION_FLAG_ENUM_SIMULATE))\n\t\tgoto out;\n\tif (pk_bitfield_contain (transaction->priv->cached_transaction_flags,\n\t\t\t\t  PK_TRANSACTION_FLAG_ENUM_ONLY_DOWNLOAD))\n\t\tgoto out;\n\tif (priv->role == PK_ROLE_ENUM_UPDATE_PACKAGES ||\n\t    priv->role == PK_ROLE_ENUM_INSTALL_PACKAGES ||\n\t    priv->role == PK_ROLE_ENUM_REMOVE_PACKAGES ||\n\t    priv->role == PK_ROLE_ENUM_REPO_ENABLE ||\n\t    priv->role == PK_ROLE_ENUM_REPO_SET_DATA ||\n\t    priv->role == PK_ROLE_ENUM_REPO_REMOVE ||\n\t    priv->role == PK_ROLE_ENUM_REFRESH_CACHE) {\n\n\t\t\n\t\tpk_backend_updates_changed_delay (priv->backend,\n\t\t\t\t\t\t  PK_TRANSACTION_UPDATES_CHANGED_TIMEOUT);\n\t}\nout:\n\treturn TRUE;\n}","22809":"void APE::Properties::analyzeCurrent()\n{\n  \n  d->file->seek(2, File::Current);\n  ByteVector descriptor = d->file->readBlock(44);\n  uint descriptorBytes = descriptor.mid(0,4).toUInt(false);\n\n  if ((descriptorBytes - 52) > 0)\n    d->file->seek(descriptorBytes - 52, File::Current);\n\n  \n  ByteVector header = d->file->readBlock(24);\n\n  \n  d->channels = header.mid(18, 2).toShort(false);\n  d->sampleRate = header.mid(20, 4).toUInt(false);\n  d->bitsPerSample = header.mid(16, 2).toShort(false);\n  \n\n  uint totalFrames = header.mid(12, 4).toUInt(false);\n  uint blocksPerFrame = header.mid(4, 4).toUInt(false);\n  uint finalFrameBlocks = header.mid(8, 4).toUInt(false);\n  uint totalBlocks = totalFrames > 0 ? (totalFrames -  1) * blocksPerFrame + finalFrameBlocks : 0;\n  d->length = totalBlocks \/ d->sampleRate;\n  d->bitrate = d->length > 0 ? ((d->streamLength * 8L) \/ d->length) \/ 1000 : 0;\n}","23628":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteLocalResponseNormParams*>(node->builtin_data);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  if (output->type == kTfLiteFloat32) {\n\n  tflite::LocalResponseNormalizationParams op_params;                \\\n  op_params.range = params->radius;                                  \\\n  op_params.bias = params->bias;                                     \\\n  op_params.alpha = params->alpha;                                   \\\n  op_params.beta = params->beta;                                     \\\n  type::LocalResponseNormalization(                                  \\\n      op_params, GetTensorShape(input), GetTensorData<float>(input), \\\n      GetTensorShape(output), GetTensorData<float>(output))\n    if (kernel_type == kReference) {\n      TF_LITE_LOCAL_RESPONSE_NORM(reference_ops);\n    }\n    if (kernel_type == kGenericOptimized) {\n      TF_LITE_LOCAL_RESPONSE_NORM(optimized_ops);\n    }\n#undef TF_LITE_LOCAL_RESPONSE_NORM\n  } else {\n    context->ReportError(context, \"STR\",\n                         output->type);\n    return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}","23598":"static void hns_nic_tx_clr_all_bufs(struct hns_nic_ring_data *ring_data)\n{\n\tstruct hnae_ring *ring = ring_data->ring;\n\tstruct net_device *ndev = ring_data->napi.dev;\n\tstruct netdev_queue *dev_queue;\n\tint head;\n\tint bytes, pkts;\n\n\tNETIF_TX_LOCK(ring);\n\n\thead = ring->next_to_use; \n\tbytes = 0;\n\tpkts = 0;\n\twhile (head != ring->next_to_clean)\n\t\thns_nic_reclaim_one_desc(ring, &bytes, &pkts);\n\n\tNETIF_TX_UNLOCK(ring);\n\n\tdev_queue = netdev_get_tx_queue(ndev, ring_data->queue_index);\n\tnetdev_tx_reset_queue(dev_queue);\n}","23147":"\nGF_Err vwid_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tISOM_DECREASE_SIZE(s, 3)\n\tgf_bs_read_int(bs, 2);\n\tptr->min_temporal_id = gf_bs_read_int(bs, 3);\n\tptr->max_temporal_id = gf_bs_read_int(bs, 3);\n\tptr->num_views = gf_bs_read_u16(bs);\n\tif (6 * ptr->num_views > ptr->size)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tptr->views = gf_malloc(sizeof(ViewIDEntry)*ptr->num_views);\n\tmemset(ptr->views, 0, sizeof(ViewIDEntry)*ptr->num_views);\n\tfor (i=0; i<ptr->num_views; i++) {\n\t\tu32 j;\n\t\tISOM_DECREASE_SIZE(s, 6)\n\n\t\tgf_bs_read_int(bs, 6);\n\t\tptr->views[i].view_id = gf_bs_read_int(bs, 10);\n\t\tgf_bs_read_int(bs, 6);\n\t\tptr->views[i].view_order_index = gf_bs_read_int(bs, 10);\n\t\tptr->views[i].texture_in_stream = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].texture_in_track = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].depth_in_stream = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].depth_in_track = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].base_view_type = gf_bs_read_int(bs, 2);\n\t\tptr->views[i].num_ref_views = gf_bs_read_int(bs, 10);\n\n\t\tif (2 * ptr->views[i].num_ref_views > ptr->size)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\n\t\tptr->views[i].view_refs = gf_malloc(sizeof(ViewIDRefViewEntry)*ptr->views[i].num_ref_views);\n\t\tfor (j=0; j<ptr->views[i].num_ref_views; j++) {\n\t\t\tISOM_DECREASE_SIZE(s, 2)\n\t\t\tgf_bs_read_int(bs, 4);\n\t\t\tptr->views[i].view_refs[j].dep_comp_idc = gf_bs_read_int(bs, 2);\n\t\t\tptr->views[i].view_refs[j].ref_view_id = gf_bs_read_int(bs, 10);\n\t\t}\n\t}\n\treturn GF_OK;","23153":"void fmtutil_handle_photoshop_rsrc(deark *c, dbuf *f, i64 pos, i64 len,\n\tunsigned int flags)\n{\n\tfmtutil_handle_photoshop_rsrc2(c, f, pos, len, flags, NULL);\n}","23590":"token_continue(i_ctx_t *i_ctx_p, scanner_state * pstate, bool save)\n{\n    os_ptr op = osp;\n    int code;\n    ref token;\n\n    \n    pop(1);                     \nagain:\n    code = gs_scan_token(i_ctx_p, &token, pstate);\n    op = osp;\n    switch (code) {\n        default:                \n            if (code > 0)       \n                code = gs_note_error(gs_error_syntaxerror);\n            gs_scanner_error_object(i_ctx_p, pstate, &i_ctx_p->error_object);\n            break;\n        case scan_BOS:\n            code = 0;\n        case 0:         \n            push(2);\n            ref_assign(op - 1, &token);\n            make_true(op);\n            break;\n        case scan_EOF:          \n            push(1);\n            make_false(op);\n            code = 0;\n            break;\n        case scan_Refill:       \n            code = gs_scan_handle_refill(i_ctx_p, pstate, save,\n                                      ztoken_continue);\n            switch (code) {\n                case 0: \n                    goto again;\n                case o_push_estack:\n                    return code;\n            }\n            break;              \n    }\n    if (code <= 0 && !save) {   \n        ifree_object(pstate, \"STR\");\n    }\n    return code;\n}","23453":"static inline void openOptimized(sqlite3*& db) {\n  sqlite3_open(\"STR\", &db);\n\n  std::string settings;\n  for (const auto& setting : kMemoryDBSettings) {\n    settings += \"STR\";\n  }\n  sqlite3_exec(db, settings.c_str(), nullptr, nullptr, nullptr);\n\n  \n  registerMathExtensions(db);\n#if !defined(FREEBSD)\n  registerStringExtensions(db);\n#endif\n#if !defined(SKIP_CARVER)\n  registerOperationExtensions(db);\n#endif\n  registerFilesystemExtensions(db);\n  registerHashingExtensions(db);\n  registerEncodingExtensions(db);\n}","23023":"  bool ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t    int protocol, bufferlist& authorizer,\n\t\t\t\t    bufferlist& authorizer_reply,\n\t\t\t\t    bool& isvalid, CryptoKey& session_key) override {\n    \n    isvalid = true;\n    return true;\n  };","23788":"exif_data_option_get_description (ExifDataOption o)\n{\n\tunsigned int i;\n\n\tfor (i = 0; exif_data_option[i].description; i++)\n\t\tif (exif_data_option[i].option == o) \n\t\t\tbreak;\n\treturn _(exif_data_option[i].description);\n}","23572":"qf_find_help_win(void)\n{\n    win_T *wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (bt_help(wp->w_buffer))\n\t    return wp;\n\n    return NULL;\n}","23078":"static unsigned int stack_maxrandom_size(void)\n{\n\tunsigned int max = 0;\n\tif ((current->flags & PF_RANDOMIZE) &&\n\t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\tmax = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;\n\t}\n\n\treturn max;\n}","23093":"static bool tailmatch(const char *little, const char *bigone)\n{\n  size_t littlelen = strlen(little);\n  size_t biglen = strlen(bigone);\n\n  if(littlelen > biglen)\n    return FALSE;\n\n  return Curl_raw_equal(little, bigone+biglen-littlelen) ? TRUE : FALSE;\n}","22871":"void net_enable_timestamp(void)\n{\n#ifdef HAVE_JUMP_LABEL\n\tint deferred = atomic_xchg(&netstamp_needed_deferred, 0);\n\n\tif (deferred) {\n\t\twhile (--deferred)\n\t\t\tstatic_key_slow_dec(&netstamp_needed);\n\t\treturn;\n\t}\n#endif\n\tstatic_key_slow_inc(&netstamp_needed);\n}","23179":"xmlRegexpErrCompile(xmlRegParserCtxtPtr ctxt, const char *extra)\n{\n    const char *regexp = NULL;\n    int idx = 0;\n\n    if (ctxt != NULL) {\n        regexp = (const char *) ctxt->string;\n\tidx = ctxt->cur - ctxt->string;\n\tctxt->error = XML_REGEXP_COMPILE_ERROR;\n    }\n    __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_REGEXP,\n\t\t    XML_REGEXP_COMPILE_ERROR, XML_ERR_FATAL, NULL, 0, extra,\n\t\t    regexp, NULL, idx, 0,\n\t\t    \"STR\", extra);\n}","22966":"si_dbus_read_signals(struct session_info *info)\n{\n    DBusMessage *message = NULL;\n\n    dbus_connection_read_write(info->connection, 0);\n    message = dbus_connection_pop_message(info->connection);\n    while (message != NULL) {\n        const char *member;\n\n        member = dbus_message_get_member (message);\n        if (g_strcmp0(member, SEAT_SIGNAL_ACTIVE_SESSION_CHANGED) == 0) {\n            DBusMessageIter iter;\n            gint type;\n            gchar *session;\n\n            g_clear_pointer(&info->active_session, g_free);\n\n            dbus_message_iter_init(message, &iter);\n            type = dbus_message_iter_get_arg_type(&iter);\n            \n            if (type == DBUS_TYPE_STRING || type == DBUS_TYPE_OBJECT_PATH) {\n                dbus_message_iter_get_basic(&iter, &session);\n                if (session != NULL && session[0] != '\\0') {\n                    info->active_session = g_strdup(session);\n                    si_dbus_match_rule_update(info);\n                } else {\n                    syslog(LOG_WARNING, \"STR\"\n                           \"STR\");\n                }\n            } else {\n                syslog(LOG_ERR,\n                       \"STR\",\n                       type);\n            }\n        } else if (g_strcmp0(member, SESSION_SIGNAL_LOCK) == 0) {\n            info->session_is_locked = TRUE;\n        } else if (g_strcmp0(member, SESSION_SIGNAL_UNLOCK) == 0) {\n            info->session_is_locked = FALSE;\n        } else if (g_strcmp0(member, SESSION_SIGNAL_IDLE_HINT_CHANGED) == 0) {\n            DBusMessageIter iter;\n            gint type;\n            dbus_bool_t idle_hint;\n\n            dbus_message_iter_init(message, &iter);\n            type = dbus_message_iter_get_arg_type(&iter);\n            if (type == DBUS_TYPE_BOOLEAN) {\n                dbus_message_iter_get_basic(&iter, &idle_hint);\n                info->session_idle_hint = (idle_hint);\n            } else {\n                syslog(LOG_ERR,\n                       \"STR\",\n                       type);\n            }\n        } else {\n            if (dbus_message_get_type(message) != DBUS_MESSAGE_TYPE_SIGNAL) {\n                syslog(LOG_WARNING, \"STR\");\n            } else if (info->verbose) {\n                syslog(LOG_DEBUG, \"STR\", member);\n            }\n        }\n\n        dbus_message_unref(message);\n        dbus_connection_read_write(info->connection, 0);\n        message = dbus_connection_pop_message(info->connection);\n    }\n}","23069":"LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n\tif(!file) return 0;\n\tstr = openmpt_module_get_instrument_name(file->mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval>=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n\t}\n\tretval = (int)tmpretval;\n\tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n\t}\n\topenmpt_free_string(str);\n\treturn retval;\n}","23714":"static long __media_device_enum_links(struct media_device *mdev,\n\t\t\t\t      struct media_links_enum *links)\n{\n\tstruct media_entity *entity;\n\n\tentity = find_entity(mdev, links->entity);\n\tif (entity == NULL)\n\t\treturn -EINVAL;\n\n\tif (links->pads) {\n\t\tunsigned int p;\n\n\t\tfor (p = 0; p < entity->num_pads; p++) {\n\t\t\tstruct media_pad_desc pad;\n\t\t\tmedia_device_kpad_to_upad(&entity->pads[p], &pad);\n\t\t\tif (copy_to_user(&links->pads[p], &pad, sizeof(pad)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (links->links) {\n\t\tstruct media_link_desc __user *ulink;\n\t\tunsigned int l;\n\n\t\tfor (l = 0, ulink = links->links; l < entity->num_links; l++) {\n\t\t\tstruct media_link_desc link;\n\n\t\t\t\n\t\t\tif (entity->links[l].source->entity != entity)\n\t\t\t\tcontinue;\n\n\t\t\tmedia_device_kpad_to_upad(entity->links[l].source,\n\t\t\t\t\t\t  &link.source);\n\t\t\tmedia_device_kpad_to_upad(entity->links[l].sink,\n\t\t\t\t\t\t  &link.sink);\n\t\t\tlink.flags = entity->links[l].flags;\n\t\t\tif (copy_to_user(ulink, &link, sizeof(*ulink)))\n\t\t\t\treturn -EFAULT;\n\t\t\tulink++;\n\t\t}\n\t}\n\n\treturn 0;\n}","22650":"static int cmpnbbs(const void *_a, const void *_b) {\n\tconst RzAnalysisFunction *a = _a, *b = _b;\n\tut64 as = rz_list_length(a->bbs);\n\tut64 bs = rz_list_length(b->bbs);\n\treturn (as > bs) ? 1 : (as < bs) ? -1\n\t\t\t\t\t : 0;\n}","23095":"iasecc_sdo_create(struct sc_card *card, struct iasecc_sdo *sdo)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_apdu apdu;\n\tunsigned char *data = NULL, sdo_class = sdo->sdo_class;\n\tstruct iasecc_sdo_update update;\n\tstruct iasecc_extended_tlv *field = NULL;\n\tint rv = SC_ERROR_NOT_SUPPORTED, data_len;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (sdo->magic != SC_CARDCTL_IASECC_SDO_MAGIC)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"STR\");\n\n\tsc_log(ctx, \"STR\", card,\n\t\t\tIASECC_SDO_TAG_HEADER, sdo->sdo_class | 0x80, sdo->sdo_ref);\n\n\tdata_len = iasecc_sdo_encode_create(ctx, sdo, &data);\n\tLOG_TEST_RET(ctx, data_len, \"STR\");\n\tsc_log(ctx, \"STR\", data_len, sc_dump_hex(data, data_len));\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xDB, 0x3F, 0xFF);\n\tapdu.data = data;\n\tapdu.datalen = data_len;\n\tapdu.lc = data_len;\n\tapdu.flags |= SC_APDU_FLAGS_CHAINING;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"STR\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(ctx, rv, \"STR\");\n\n\tmemset(&update, 0, sizeof(update));\n\tupdate.magic = SC_CARDCTL_IASECC_SDO_MAGIC_PUT_DATA;\n\tupdate.sdo_class = sdo->sdo_class;\n\tupdate.sdo_ref = sdo->sdo_ref;\n\n\tif (sdo_class == IASECC_SDO_CLASS_RSA_PRIVATE)   {\n\t\tupdate.fields[0] = sdo->data.prv_key.compulsory;\n\t\tupdate.fields[0].parent_tag = IASECC_SDO_PRVKEY_TAG;\n\t\tfield = &sdo->data.prv_key.compulsory;\n\t}\n\telse if (sdo_class == IASECC_SDO_CLASS_RSA_PUBLIC)   {\n\t\tupdate.fields[0] = sdo->data.pub_key.compulsory;\n\t\tupdate.fields[0].parent_tag = IASECC_SDO_PUBKEY_TAG;\n\t\tfield = &sdo->data.pub_key.compulsory;\n\t}\n\telse if (sdo_class == IASECC_SDO_CLASS_KEYSET)   {\n\t\tupdate.fields[0] = sdo->data.keyset.compulsory;\n\t\tupdate.fields[0].parent_tag = IASECC_SDO_KEYSET_TAG;\n\t\tfield = &sdo->data.keyset.compulsory;\n\t}\n\n\tif (update.fields[0].value && !update.fields[0].on_card)   {\n\t\trv = iasecc_sdo_put_data(card, &update);\n\t\tLOG_TEST_RET(ctx, rv, \"STR\");\n\n\t\tif (field)\n\t\t\tfield->on_card = 1;\n\t}\n\n\tfree(data);\n\tLOG_FUNC_RETURN(ctx, rv);\n}","23459":"int ar6000_remove_ap_interface(struct ar6_softc *ar)\n{\n    if (arApNetDev) {\n        ar6000_stop_ap_interface(ar);\n\n        unregister_netdev(arApNetDev);\n        free_netdev(apApNetDev);\n\n        A_PRINTF(\"STR\");\n    }\n    ar->arApDev = NULL;\n    arApNetDev = NULL;\n\n    \n    return 0;\n}","23262":"static void write_reply_cb(DBusMessage *message, void *user_data)\n{\n\tstruct pending_op *op = user_data;\n\tstruct external_chrc *chrc;\n\tstruct external_desc *desc;\n\tDBusError err;\n\tDBusMessageIter iter;\n\tuint8_t ecode = 0;\n\n\tif (!op->owner_queue) {\n\t\tDBG(\"STR\");\n\t\treturn;\n\t}\n\n\tdbus_error_init(&err);\n\n\tif (dbus_set_error_from_message(&err, message) == TRUE) {\n\t\tDBG(\"STR\", err.name, err.message);\n\t\tecode = dbus_error_to_att_ecode(err.name,\n\t\t\t\t\tBT_ATT_ERROR_WRITE_NOT_PERMITTED);\n\t\tdbus_error_free(&err);\n\t\tgoto done;\n\t}\n\n\tif (op->prep_authorize) {\n\t\tif (op->is_characteristic) {\n\t\t\tchrc = gatt_db_attribute_get_user_data(op->attrib);\n\t\t\tchrc->prep_authorized = true;\n\t\t} else {\n\t\t\tdesc = gatt_db_attribute_get_user_data(op->attrib);\n\t\t\tdesc->prep_authorized = true;\n\t\t}\n\t}\n\n\tdbus_message_iter_init(message, &iter);\n\tif (dbus_message_iter_has_next(&iter)) {\n\t\t\n\t\tecode = BT_ATT_ERROR_REQUEST_NOT_SUPPORTED;\n\t\terror(\"STR\");\n\t}\n\ndone:\n\tgatt_db_attribute_write_result(op->attrib, op->id, ecode);\n}","23156":"cancel_thumbnail_for_file (NautilusDirectory *directory,\n                           NautilusFile      *file)\n{\n    if (directory->details->thumbnail_state != NULL &&\n        directory->details->thumbnail_state->file == file)\n    {\n        thumbnail_cancel (directory);\n    }\n}","22611":"dns_resolver_match(const struct key *key,\n\t\t   const struct key_match_data *match_data)\n{\n\tint slen, dlen, ret = 0;\n\tconst char *src = key->description, *dsp = match_data->raw_data;\n\n\tkenter(\"STR\", src, dsp);\n\n\tif (!src || !dsp)\n\t\tgoto no_match;\n\n\tif (strcasecmp(src, dsp) == 0)\n\t\tgoto matched;\n\n\tslen = strlen(src);\n\tdlen = strlen(dsp);\n\tif (slen <= 0 || dlen <= 0)\n\t\tgoto no_match;\n\tif (src[slen - 1] == '.')\n\t\tslen--;\n\tif (dsp[dlen - 1] == '.')\n\t\tdlen--;\n\tif (slen != dlen || strncasecmp(src, dsp, slen) != 0)\n\t\tgoto no_match;\n\nmatched:\n\tret = 1;\nno_match:\n\tkleave(\"STR\", ret);\n\treturn ret;\n}","23261":"    char* parseKey( char* ptr, FileNode& map_node, FileNode& value_placeholder )\n    {\n        char c;\n        char *endptr = ptr - 1, *saveptr;\n\n        if( *ptr == '-' )\n            CV_PARSE_ERROR_CPP( \"STR\" );\n\n        do c = *++endptr;\n        while( cv_isprint(c) && c != ':' );\n\n        if( c != ':' )\n            CV_PARSE_ERROR_CPP( \"STR\" );\n\n        saveptr = endptr + 1;\n        do c = *--endptr;\n        while( c == ' ' );\n\n        ++endptr;\n        if( endptr == ptr )\n            CV_PARSE_ERROR_CPP( \"STR\" );\n\n        value_placeholder = fs->addNode(map_node, std::string(ptr, endptr - ptr), FileNode::NONE);\n        ptr = saveptr;\n\n        return ptr;\n    }","22898":"static struct page **__atomic_get_pages(void *addr)\n{\n\tstruct dma_pool *pool = &atomic_pool;\n\tstruct page **pages = pool->pages;\n\tint offs = (addr - pool->vaddr) >> PAGE_SHIFT;\n\n\treturn pages + offs;\n}","23175":"static void write_version(\n    FILE       *fp,\n    const char *fname,\n    const char *dirname,\n    xref_t     *xref)\n{\n    long  start;\n    char *c, *new_fname, data;\n    FILE *new_fp;\n    \n    start = ftell(fp);\n\n    \n    if ((c = strstr(fname, \"STR\")))\n      *c = '\\0';\n    new_fname = malloc(strlen(fname) + strlen(dirname) + 16);\n    snprintf(new_fname, strlen(fname) + strlen(dirname) + 16,\n             \"STR\", dirname, fname, xref->version);\n\n    if (!(new_fp = fopen(new_fname, \"STR\")))\n    {\n        ERR(\"STR\", new_fname);\n        fseek(fp, start, SEEK_SET);\n        free(new_fname);\n        return;\n    }\n    \n    \n    fseek(fp, 0, SEEK_SET);\n    while (fread(&data, 1, 1, fp))\n      fwrite(&data, 1, 1, new_fp);\n\n    \n    fprintf(new_fp, \"STR\", xref->start);\n\n    \n    fclose(new_fp);\n    free(new_fname);\n    fseek(fp, start, SEEK_SET);\n}","23160":"static void svm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\ts->base = var->base;\n\ts->limit = var->limit;\n\ts->selector = var->selector;\n\tif (var->unusable)\n\t\ts->attrib = 0;\n\telse {\n\t\ts->attrib = (var->type & SVM_SELECTOR_TYPE_MASK);\n\t\ts->attrib |= (var->s & 1) << SVM_SELECTOR_S_SHIFT;\n\t\ts->attrib |= (var->dpl & 3) << SVM_SELECTOR_DPL_SHIFT;\n\t\ts->attrib |= (var->present & 1) << SVM_SELECTOR_P_SHIFT;\n\t\ts->attrib |= (var->avl & 1) << SVM_SELECTOR_AVL_SHIFT;\n\t\ts->attrib |= (var->l & 1) << SVM_SELECTOR_L_SHIFT;\n\t\ts->attrib |= (var->db & 1) << SVM_SELECTOR_DB_SHIFT;\n\t\ts->attrib |= (var->g & 1) << SVM_SELECTOR_G_SHIFT;\n\t}\n\tif (seg == VCPU_SREG_CS)\n\t\tsvm->vmcb->save.cpl\n\t\t\t= (svm->vmcb->save.cs.attrib\n\t\t\t   >> SVM_SELECTOR_DPL_SHIFT) & 3;\n\n}","23003":"static bool is_legal_file(const std::string &filename)\n{\n\tDBG_FS << \"STR\";\n\n\tif (filename.empty()) {\n\t\tLOG_FS << \"STR\";\n\t\treturn false;\n\t}\n\n\tif (filename.find(\"STR\") != std::string::npos) {\n\t\tERR_FS << \"STR\";\n\t\treturn false;\n\t}\n\n\tif (ends_with(filename, \"STR\")) {\n\t\tERR_FS << \"STR\" << std::endl;\n\t\treturn false;\n\t}\n\n\treturn true;\n}","23083":"ut32 armass_assemble(const char *str, ut64 off, int thumb) {\n\tint i, j;\n\tchar buf[128];\n\tArmOpcode aop = {.off = off};\n\tfor (i = j = 0; i < sizeof (buf) - 1 && str[i]; i++, j++) {\n\t\tif (str[j] == '#') {\n\t\t\ti--; continue;\n\t\t}\n\t\tbuf[i] = tolower ((const ut8)str[j]);\n\t}\n\tbuf[i] = 0;\n\tarm_opcode_parse (&aop, buf);\n\taop.off = off;\n\tif (thumb < 0 || thumb > 1) {\n\t\treturn -1;\n\t}\n\tif (!assemble[thumb] (&aop, off, buf)) {\n\t\t\n\t\treturn -1;\n\t}\n\treturn aop.o;\n}","22782":"ephy_embed_single_set_network_status (EphyEmbedSingle *single,\n                                      gboolean status)\n{\n  if (status != single->priv->online)\n    single->priv->online = status;\n}","23761":"pdf_filter_dquote(fz_context *ctx, pdf_processor *proc, float aw, float ac, char *str, int len)\n{\n\t\n\tpdf_filter_processor *p = (pdf_filter_processor*)proc;\n\tp->gstate->pending.text.word_space = aw;\n\tp->gstate->pending.text.char_space = ac;\n\tpdf_tos_newline(&p->tos, p->gstate->pending.text.leading);\n\t\n\tif (!p->Tm_pending && p->chain->op_Tstar)\n\t\tp->chain->op_Tstar(ctx, p->chain);\n\tfilter_show_string(ctx, p, (unsigned char*)str, len);\n}","23812":"static struct ttf_table *SFDGetTtfTable(FILE *sfd, SplineFont *sf,struct ttf_table *lasttab[2]) {\n    \n    \n    int i,len;\n    int which;\n    struct enc85 dec;\n    struct ttf_table *tab = chunkalloc(sizeof(struct ttf_table));\n\n    memset(&dec,'\\0', sizeof(dec)); dec.pos = -1;\n    dec.sfd = sfd;\n\n    tab->tag = gettag(sfd);\n\n    if ( tab->tag==CHR('f','p','g','m') || tab->tag==CHR('p','r','e','p') ||\n\t    tab->tag==CHR('c','v','t',' ') || tab->tag==CHR('m','a','x','p'))\n\twhich = 0;\n    else\n\twhich = 1;\n\n    getint(sfd,&len);\n    tab->data = malloc(len);\n    tab->len = len;\n    for ( i=0; i<len; ++i )\n\ttab->data[i] = Dec85(&dec);\n\n    if ( lasttab[which]!=NULL )\n\tlasttab[which]->next = tab;\n    else if ( which==0 )\n\tsf->ttf_tables = tab;\n    else\n\tsf->ttf_tab_saved = tab;\n    lasttab[which] = tab;\nreturn( tab );\n}","22830":"static int pkcs7_decrypt_rinfo(unsigned char **pek, int *peklen,\n                               PKCS7_RECIP_INFO *ri, EVP_PKEY *pkey)\n{\n    EVP_PKEY_CTX *pctx = NULL;\n    unsigned char *ek = NULL;\n    size_t eklen;\n\n    int ret = -1;\n\n    pctx = EVP_PKEY_CTX_new(pkey, NULL);\n    if (!pctx)\n        return -1;\n\n    if (EVP_PKEY_decrypt_init(pctx) <= 0)\n        goto err;\n\n    if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_DECRYPT,\n                          EVP_PKEY_CTRL_PKCS7_DECRYPT, 0, ri) <= 0) {\n        PKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, PKCS7_R_CTRL_ERROR);\n        goto err;\n    }\n\n    if (EVP_PKEY_decrypt(pctx, NULL, &eklen,\n                         ri->enc_key->data, ri->enc_key->length) <= 0)\n        goto err;\n\n    ek = OPENSSL_malloc(eklen);\n\n    if (ek == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (EVP_PKEY_decrypt(pctx, ek, &eklen,\n                         ri->enc_key->data, ri->enc_key->length) <= 0) {\n        ret = 0;\n        PKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    ret = 1;\n\n    if (*pek) {\n        OPENSSL_cleanse(*pek, *peklen);\n        OPENSSL_free(*pek);\n    }\n\n    *pek = ek;\n    *peklen = eklen;\n\n err:\n    if (pctx)\n        EVP_PKEY_CTX_free(pctx);\n    if (!ret && ek)\n        OPENSSL_free(ek);\n\n    return ret;\n}","23751":"static void __net_exit packet_net_exit(struct net *net)\n{\n\tremove_proc_entry(\"STR\", net->proc_net);\n}","23801":"static struct sock *x25_make_new(struct sock *osk)\n{\n\tstruct sock *sk = NULL;\n\tstruct x25_sock *x25, *ox25;\n\n\tif (osk->sk_type != SOCK_SEQPACKET)\n\t\tgoto out;\n\n\tif ((sk = x25_alloc_socket(sock_net(osk), 0)) == NULL)\n\t\tgoto out;\n\n\tx25 = x25_sk(sk);\n\n\tsk->sk_type        = osk->sk_type;\n\tsk->sk_priority    = osk->sk_priority;\n\tsk->sk_protocol    = osk->sk_protocol;\n\tsk->sk_rcvbuf      = osk->sk_rcvbuf;\n\tsk->sk_sndbuf      = osk->sk_sndbuf;\n\tsk->sk_state       = TCP_ESTABLISHED;\n\tsk->sk_backlog_rcv = osk->sk_backlog_rcv;\n\tsock_copy_flags(sk, osk);\n\n\tox25 = x25_sk(osk);\n\tx25->t21        = ox25->t21;\n\tx25->t22        = ox25->t22;\n\tx25->t23        = ox25->t23;\n\tx25->t2         = ox25->t2;\n\tx25->flags\t= ox25->flags;\n\tx25->facilities = ox25->facilities;\n\tx25->dte_facilities = ox25->dte_facilities;\n\tx25->cudmatchlength = ox25->cudmatchlength;\n\n\tclear_bit(X25_INTERRUPT_FLAG, &x25->flags);\n\tx25_init_timers(sk);\nout:\n\treturn sk;\n}","22947":"int STDCALL\nmysql_options(MYSQL *mysql,enum mysql_option option, const void *arg)\n{\n  DBUG_ENTER(\"STR\");\n  DBUG_PRINT(\"STR\",(int) option));\n  switch (option) {\n  case MYSQL_OPT_CONNECT_TIMEOUT:\n    mysql->options.connect_timeout= *(uint*) arg;\n    break;\n  case MYSQL_OPT_READ_TIMEOUT:\n    mysql->options.read_timeout= *(uint*) arg;\n    break;\n  case MYSQL_OPT_WRITE_TIMEOUT:\n    mysql->options.write_timeout= *(uint*) arg;\n    break;\n  case MYSQL_OPT_COMPRESS:\n    mysql->options.compress= 1;\t\t\t\n    mysql->options.client_flag|= CLIENT_COMPRESS;\n    break;\n  case MYSQL_OPT_NAMED_PIPE:\t\t\t\n    mysql->options.protocol=MYSQL_PROTOCOL_PIPE; \n    break;\n  case MYSQL_OPT_LOCAL_INFILE:\t\t\t\n    if (!arg || test(*(uint*) arg))\n      mysql->options.client_flag|= CLIENT_LOCAL_FILES;\n    else\n      mysql->options.client_flag&= ~CLIENT_LOCAL_FILES;\n    break;\n  case MYSQL_INIT_COMMAND:\n    add_init_command(&mysql->options,arg);\n    break;\n  case MYSQL_READ_DEFAULT_FILE:\n    my_free(mysql->options.my_cnf_file);\n    mysql->options.my_cnf_file=my_strdup(arg,MYF(MY_WME));\n    break;\n  case MYSQL_READ_DEFAULT_GROUP:\n    my_free(mysql->options.my_cnf_group);\n    mysql->options.my_cnf_group=my_strdup(arg,MYF(MY_WME));\n    break;\n  case MYSQL_SET_CHARSET_DIR:\n    my_free(mysql->options.charset_dir);\n    mysql->options.charset_dir=my_strdup(arg,MYF(MY_WME));\n    break;\n  case MYSQL_SET_CHARSET_NAME:\n    my_free(mysql->options.charset_name);\n    mysql->options.charset_name=my_strdup(arg,MYF(MY_WME));\n    break;\n  case MYSQL_OPT_PROTOCOL:\n    mysql->options.protocol= *(uint*) arg;\n    break;\n  case MYSQL_SHARED_MEMORY_BASE_NAME:\n#ifdef HAVE_SMEM\n    if (mysql->options.shared_memory_base_name != def_shared_memory_base_name)\n      my_free(mysql->options.shared_memory_base_name);\n    mysql->options.shared_memory_base_name=my_strdup(arg,MYF(MY_WME));\n#endif\n    break;\n  case MYSQL_OPT_USE_REMOTE_CONNECTION:\n  case MYSQL_OPT_USE_EMBEDDED_CONNECTION:\n  case MYSQL_OPT_GUESS_CONNECTION:\n    mysql->options.methods_to_use= option;\n    break;\n  case MYSQL_SET_CLIENT_IP:\n    my_free(mysql->options.client_ip);\n    mysql->options.client_ip= my_strdup(arg, MYF(MY_WME));\n    break;\n  case MYSQL_SECURE_AUTH:\n    mysql->options.secure_auth= *(my_bool *) arg;\n    break;\n  case MYSQL_REPORT_DATA_TRUNCATION:\n    mysql->options.report_data_truncation= test(*(my_bool *) arg);\n    break;\n  case MYSQL_OPT_RECONNECT:\n    mysql->reconnect= *(my_bool *) arg;\n    break;\n  case MYSQL_OPT_SSL_VERIFY_SERVER_CERT:\n    if (*(my_bool*) arg)\n      mysql->options.client_flag|= CLIENT_SSL_VERIFY_SERVER_CERT;\n    else\n      mysql->options.client_flag&= ~CLIENT_SSL_VERIFY_SERVER_CERT;\n    break;\n  case MYSQL_PLUGIN_DIR:\n    EXTENSION_SET_STRING(&mysql->options, plugin_dir, arg);\n    break;\n  case MYSQL_DEFAULT_AUTH:\n    EXTENSION_SET_STRING(&mysql->options, default_auth, arg);\n    break;\n  case MYSQL_ENABLE_CLEARTEXT_PLUGIN:\n    ENSURE_EXTENSIONS_PRESENT(&mysql->options);\n    mysql->options.extension->enable_cleartext_plugin= \n      (*(my_bool*) arg) ? TRUE : FALSE;\n    break;\n  default:\n    DBUG_RETURN(1);\n  }\n  DBUG_RETURN(0);","22620":"nfa_t::nfa_t(const RESpec &spec)\n    : max_size(estimate_size(spec.res))\n    , size(0)\n    , states(new nfa_state_t[max_size])\n    , charset(spec.charset)\n    , rules(spec.rules)\n    , tags(spec.tags)\n    , root(NULL)\n    , ncores(0)\n{\n    const size_t nre = spec.res.size();\n\n    if (nre == 0) return;\n\n    for (size_t i = 0; i < nre; ++i) {\n        rtn_ctx_t ctx = {spec.opts, *this, i};\n\n        nfa_state_t *s = &states[size++];\n        s->make_fin(i);\n        s = re_to_nfa(ctx, spec.res[i], s);\n\n        if (root) {\n            nfa_state_t *t = &states[size++];\n            t->make_alt(i, root, s);\n            root = t;\n        } else {\n            root = s;\n        }\n    }\n\n    \n    \n    ncores = stats(root);\n}","22712":"dophn_core(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n    int num, size_t size, off_t fsize, int *flags)\n{\n\tElf32_Phdr ph32;\n\tElf64_Phdr ph64;\n\tsize_t offset, len;\n\tunsigned char nbuf[BUFSIZ];\n\tssize_t bufsize;\n\n\tif (size != xph_sizeof) {\n\t\tif (file_printf(ms, \"STR\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\t\n\tfor ( ; num; num--) {\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) < (ssize_t)xph_sizeof) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toff += size;\n\n\t\tif (fsize != SIZE_UNKNOWN && xph_offset > fsize) {\n\t\t\t\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (xph_type != PT_NOTE)\n\t\t\tcontinue;\n\n\t\t\n\t\tlen = xph_filesz < sizeof(nbuf) ? xph_filesz : sizeof(nbuf);\n\t\tif ((bufsize = pread(fd, nbuf, len, xph_offset)) == -1) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toffset = 0;\n\t\tfor (;;) {\n\t\t\tif (offset >= (size_t)bufsize)\n\t\t\t\tbreak;\n\t\t\toffset = donote(ms, nbuf, offset, (size_t)bufsize,\n\t\t\t    clazz, swap, 4, flags);\n\t\t\tif (offset == 0)\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\treturn 0;\n}","22907":"rehash(table)\n    register st_table *table;\n{\n    register st_table_entry *ptr, *next, **new_bins;\n    int i, old_num_bins = table->num_bins, new_num_bins;\n    unsigned int hash_val;\n\n    new_num_bins = new_size(old_num_bins+1);\n    new_bins = (st_table_entry**)Calloc(new_num_bins, sizeof(st_table_entry*));\n\n    for(i = 0; i < old_num_bins; i++) {\n\tptr = table->bins[i];\n\twhile (ptr != 0) {\n\t    next = ptr->next;\n\t    hash_val = ptr->hash % new_num_bins;\n\t    ptr->next = new_bins[hash_val];\n\t    new_bins[hash_val] = ptr;\n\t    ptr = next;\n\t}\n    }\n    free(table->bins);\n    table->num_bins = new_num_bins;\n    table->bins = new_bins;\n}","23240":"vsay (char const *format, va_list args)\n{\n  vfprintf (stdout, format, args);\n  fflush (stdout);\n}","22989":"void cJSON_AddItemReferenceToArray( cJSON *array, cJSON *item )\n{\n\tcJSON_AddItemToArray( array, create_reference( item ) );\n}","23681":"static void toneport_update_led(struct usb_line6_toneport *toneport)\n{\n\ttoneport_send_cmd(toneport->line6.usbdev,\n\t\t\t  (toneport->leds[0].dev.brightness << 8) | 0x0002,\n\t\t\t  toneport->leds[1].dev.brightness);\n}","23439":"static void cliRefreshPrompt(void) {\n    if (config.eval_ldb) return;\n\n    sds prompt = sdsempty();\n    if (config.hostsocket != NULL) {\n        prompt = sdscatfmt(prompt,\"STR\",config.hostsocket);\n    } else {\n        char addr[256];\n        anetFormatAddr(addr, sizeof(addr), config.hostip, config.hostport);\n        prompt = sdscatlen(prompt,addr,strlen(addr));\n    }\n\n    \n    if (config.dbnum != 0)\n        prompt = sdscatfmt(prompt,\"STR\",config.dbnum);\n\n    \n    prompt = sdscatlen(prompt,\"STR\",2);\n    snprintf(config.prompt,sizeof(config.prompt),\"STR\",prompt);\n    sdsfree(prompt);\n}","22715":"format_cb_pane_tabs(struct format_tree *ft, struct format_entry *fe)\n{\n\tstruct window_pane\t*wp = ft->wp;\n\tstruct evbuffer\t\t*buffer;\n\tu_int\t\t\t i;\n\tint\t\t\t size;\n\n\tif (wp == NULL)\n\t\treturn;\n\n\tbuffer = evbuffer_new();\n\tfor (i = 0; i < wp->base.grid->sx; i++) {\n\t\tif (!bit_test(wp->base.tabs, i))\n\t\t\tcontinue;\n\n\t\tif (EVBUFFER_LENGTH(buffer) > 0)\n\t\t\tevbuffer_add(buffer, \"STR\", 1);\n\t\tevbuffer_add_printf(buffer, \"STR\", i);\n\t}\n\tif ((size = EVBUFFER_LENGTH(buffer)) != 0)\n\t\txasprintf(&fe->value, \"STR\", size, EVBUFFER_DATA(buffer));\n\tevbuffer_free(buffer);\n}","22918":"cgi_set_sid(void)\n{\n  char\t\t\tbuffer[512],\t\n\t\t\tsid[33];\t\n  unsigned char\t\tsum[16];\t\n  const char\t\t*remote_addr,\t\n\t\t\t*server_name,\t\n\t\t\t*server_port;\t\n\n\n  if ((remote_addr = getenv(\"STR\")) == NULL)\n    remote_addr = \"STR\";\n  if ((server_name = getenv(\"STR\")) == NULL)\n    server_name = \"STR\";\n  if ((server_port = getenv(\"STR\")) == NULL)\n    server_port = \"STR\";\n\n  CUPS_SRAND(time(NULL));\n  snprintf(buffer, sizeof(buffer), \"STR\",\n           remote_addr, server_name, server_port,\n\t   (unsigned)CUPS_RAND() & 255, (unsigned)CUPS_RAND() & 255,\n\t   (unsigned)CUPS_RAND() & 255, (unsigned)CUPS_RAND() & 255,\n\t   (unsigned)CUPS_RAND() & 255, (unsigned)CUPS_RAND() & 255,\n\t   (unsigned)CUPS_RAND() & 255, (unsigned)CUPS_RAND() & 255);\n  cupsHashData(\"STR\", (unsigned char *)buffer, strlen(buffer), sum, sizeof(sum));\n\n  cgiSetCookie(CUPS_SID, cupsHashString(sum, sizeof(sum), sid, sizeof(sid)), \"STR\", NULL, 0, 0);\n\n  return (cupsGetOption(CUPS_SID, num_cookies, cookies));\n}","22799":"static u64 sched_slice(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n\tu64 slice = __sched_period(cfs_rq->nr_running);\n\n\tfor_each_sched_entity(se) {\n\t\tcfs_rq = cfs_rq_of(se);\n\n\t\tslice *= se->load.weight;\n\t\tdo_div(slice, cfs_rq->load.weight);\n\t}\n\n\n\treturn slice;\n}","23601":"static int vfio_msi_enable(struct vfio_pci_device *vdev, int nvec, bool msix)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tunsigned int flag = msix ? PCI_IRQ_MSIX : PCI_IRQ_MSI;\n\tint ret;\n\n\tif (!is_irq_none(vdev))\n\t\treturn -EINVAL;\n\n\tvdev->ctx = kzalloc(nvec * sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);\n\tif (!vdev->ctx)\n\t\treturn -ENOMEM;\n\n\t\n\tret = pci_alloc_irq_vectors(pdev, 1, nvec, flag);\n\tif (ret < nvec) {\n\t\tif (ret > 0)\n\t\t\tpci_free_irq_vectors(pdev);\n\t\tkfree(vdev->ctx);\n\t\treturn ret;\n\t}\n\n\tvdev->num_ctx = nvec;\n\tvdev->irq_type = msix ? VFIO_PCI_MSIX_IRQ_INDEX :\n\t\t\t\tVFIO_PCI_MSI_IRQ_INDEX;\n\n\tif (!msix) {\n\t\t\n\t\tvdev->msi_qmax = fls(nvec * 2 - 1) - 1;\n\t}\n\n\treturn 0;\n}","23322":"SYSCALL_DEFINE3(shmctl, int, shmid, int, cmd, struct shmid_ds __user *, buf)\n{\n\tstruct shmid_kernel *shp;\n\tint err, version;\n\tstruct ipc_namespace *ns;\n\n\tif (cmd < 0 || shmid < 0)\n\t\treturn -EINVAL;\n\n\tversion = ipc_parse_version(&cmd);\n\tns = current->nsproxy->ipc_ns;\n\n\tswitch (cmd) {\n\tcase IPC_INFO:\n\tcase SHM_INFO:\n\tcase SHM_STAT:\n\tcase IPC_STAT:\n\t\treturn shmctl_nolock(ns, shmid, cmd, version, buf);\n\tcase IPC_RMID:\n\tcase IPC_SET:\n\t\treturn shmctl_down(ns, shmid, cmd, buf, version);\n\tcase SHM_LOCK:\n\tcase SHM_UNLOCK:\n\t{\n\t\tstruct file *shm_file;\n\n\t\trcu_read_lock();\n\t\tshp = shm_obtain_object_check(ns, shmid);\n\t\tif (IS_ERR(shp)) {\n\t\t\terr = PTR_ERR(shp);\n\t\t\tgoto out_unlock1;\n\t\t}\n\n\t\taudit_ipc_obj(&(shp->shm_perm));\n\t\terr = security_shm_shmctl(shp, cmd);\n\t\tif (err)\n\t\t\tgoto out_unlock1;\n\n\t\tipc_lock_object(&shp->shm_perm);\n\t\tif (!ns_capable(ns->user_ns, CAP_IPC_LOCK)) {\n\t\t\tkuid_t euid = current_euid();\n\t\t\terr = -EPERM;\n\t\t\tif (!uid_eq(euid, shp->shm_perm.uid) &&\n\t\t\t    !uid_eq(euid, shp->shm_perm.cuid))\n\t\t\t\tgoto out_unlock0;\n\t\t\tif (cmd == SHM_LOCK && !rlimit(RLIMIT_MEMLOCK))\n\t\t\t\tgoto out_unlock0;\n\t\t}\n\n\t\tshm_file = shp->shm_file;\n\t\tif (is_file_hugepages(shm_file))\n\t\t\tgoto out_unlock0;\n\n\t\tif (cmd == SHM_LOCK) {\n\t\t\tstruct user_struct *user = current_user();\n\t\t\terr = shmem_lock(shm_file, 1, user);\n\t\t\tif (!err && !(shp->shm_perm.mode & SHM_LOCKED)) {\n\t\t\t\tshp->shm_perm.mode |= SHM_LOCKED;\n\t\t\t\tshp->mlock_user = user;\n\t\t\t}\n\t\t\tgoto out_unlock0;\n\t\t}\n\n\t\t\n\t\tif (!(shp->shm_perm.mode & SHM_LOCKED))\n\t\t\tgoto out_unlock0;\n\t\tshmem_lock(shm_file, 0, shp->mlock_user);\n\t\tshp->shm_perm.mode &= ~SHM_LOCKED;\n\t\tshp->mlock_user = NULL;\n\t\tget_file(shm_file);\n\t\tipc_unlock_object(&shp->shm_perm);\n\t\trcu_read_unlock();\n\t\tshmem_unlock_mapping(shm_file->f_mapping);\n\n\t\tfput(shm_file);\n\t\treturn err;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\nout_unlock0:\n\tipc_unlock_object(&shp->shm_perm);\nout_unlock1:\n\trcu_read_unlock();\n\treturn err;\n}","23441":"close_ccid_reader (int slot)\n{\n  ccid_close_reader (reader_table[slot].ccid.handle);\n  reader_table[slot].used = 0;\n  return 0;\n}","23551":"bitfromint4(PG_FUNCTION_ARGS)\n{\n\tint32\t\ta = PG_GETARG_INT32(0);\n\tint32\t\ttypmod = PG_GETARG_INT32(1);\n\tVarBit\t   *result;\n\tbits8\t   *r;\n\tint\t\t\trlen;\n\tint\t\t\tdestbitsleft,\n\t\t\t\tsrcbitsleft;\n\n\tif (typmod <= 0)\n\t\ttypmod = 1;\t\t\t\t\n\n\trlen = VARBITTOTALLEN(typmod);\n\tresult = (VarBit *) palloc(rlen);\n\tSET_VARSIZE(result, rlen);\n\tVARBITLEN(result) = typmod;\n\n\tr = VARBITS(result);\n\tdestbitsleft = typmod;\n\tsrcbitsleft = 32;\n\t\n\tsrcbitsleft = Min(srcbitsleft, destbitsleft);\n\t\n\twhile (destbitsleft >= srcbitsleft + 8)\n\t{\n\t\t*r++ = (bits8) ((a < 0) ? BITMASK : 0);\n\t\tdestbitsleft -= 8;\n\t}\n\t\n\tif (destbitsleft > srcbitsleft)\n\t{\n\t\tint\t\t\tval = (int) (a >> (destbitsleft - 8));\n\n\t\t\n\t\tif (a < 0)\n\t\t\tval |= (-1) << (srcbitsleft + 8 - destbitsleft);\n\t\t*r++ = (bits8) (val & BITMASK);\n\t\tdestbitsleft -= 8;\n\t}\n\t\n\t\n\twhile (destbitsleft >= 8)\n\t{\n\t\t*r++ = (bits8) ((a >> (destbitsleft - 8)) & BITMASK);\n\t\tdestbitsleft -= 8;\n\t}\n\t\n\tif (destbitsleft > 0)\n\t\t*r = (bits8) ((a << (8 - destbitsleft)) & BITMASK);\n\n\tPG_RETURN_VARBIT_P(result);\n}","22786":"\tswitch (yych) {\n\t\tcase 'a': goto yy20;\n\t\tdefault: goto yy17;\n\t}","22802":"HRESULT Http::HrRequestAuth(const std::string &strMsg)\n{\n\tauto hr = HrResponseHeader(401, \"STR\");\n\tif (hr != hrSuccess)\n\t\treturn hr;\n\treturn HrResponseHeader(\"STR\");\n}","22922":"static long sg_compat_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg)\n{\n\tSg_device *sdp;\n\tSg_fd *sfp;\n\tstruct scsi_device *sdev;\n\n\tif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\n\t\treturn -ENXIO;\n\n\tsdev = sdp->device;\n\tif (sdev->host->hostt->compat_ioctl) {\n\t\tint ret;\n\n\t\tret = sdev->host->hostt->compat_ioctl(sdev, cmd_in, (void __user *)arg);\n\n\t\treturn ret;\n\t}\n\n\treturn -ENOIOCTLCMD;\n}","22765":"int main( int argc, char *argv[] )\n{\n    ((void) argc);\n    ((void) argv);\n\n    printf(\"STR\"\n           \"STR\"\n           \"STR\"\n           \"STR\");\n    return( 0 );\n}","22485":"static void cgroup_pressure_release(struct kernfs_open_file *of)\n{\n\tstruct cgroup_file_ctx *ctx = of->priv;\n\n\tpsi_trigger_replace(&ctx->psi.trigger, NULL);\n}","22625":"void *memslot_get_virt(RedMemSlotInfo *info, QXLPHYSICAL addr, uint32_t add_size,\n                       int group_id)\n{\n    int slot_id;\n    int generation;\n    unsigned long h_virt;\n\n    MemSlot *slot;\n\n    if (group_id > info->num_memslots_groups) {\n        spice_critical(\"STR\");\n        return NULL;\n    }\n\n    slot_id = memslot_get_id(info, addr);\n    if (slot_id > info->num_memslots) {\n        print_memslots(info);\n        spice_critical(\"STR\" PRIx64, slot_id, addr);\n        return NULL;\n    }\n\n    slot = &info->mem_slots[group_id][slot_id];\n\n    generation = memslot_get_generation(info, addr);\n    if (generation != slot->generation) {\n        print_memslots(info);\n        spice_critical(\"STR\"\n                       \"STR\",\n                       group_id, slot_id,\n                       generation, slot->generation);\n        return NULL;\n    }\n\n    h_virt = __get_clean_virt(info, addr);\n    h_virt += slot->address_delta;\n\n    if (!memslot_validate_virt(info, h_virt, slot_id, add_size, group_id)) {\n        return NULL;\n    }\n\n    return (void*)(uintptr_t)h_virt;\n}","23527":"static ssize_t _consolefs_read(oe_fd_t* file_, void* buf, size_t count)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(file_);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_read_ocall(&ret, file->host_fd, buf, count) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}","23109":"static int hidpp10_query_battery_mileage(struct hidpp_device *hidpp)\n{\n\tstruct hidpp_report response;\n\tint ret, status;\n\n\tret = hidpp_send_rap_command_sync(hidpp,\n\t\t\t\t\tREPORT_ID_HIDPP_SHORT,\n\t\t\t\t\tHIDPP_GET_REGISTER,\n\t\t\t\t\tHIDPP_REG_BATTERY_MILEAGE,\n\t\t\t\t\tNULL, 0, &response);\n\tif (ret)\n\t\treturn ret;\n\n\thidpp->battery.capacity = response.rap.params[0];\n\tstatus = hidpp10_battery_mileage_map_status(response.rap.params[2]);\n\thidpp->battery.status = status;\n\t\n\thidpp->battery.online = status == POWER_SUPPLY_STATUS_DISCHARGING ||\n\t\t\t\tstatus == POWER_SUPPLY_STATUS_FULL;\n\n\treturn 0;\n}","23424":"static void verify_event(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t void *event)\n{\n\tstruct buffer_page *page = cpu_buffer->commit_page;\n\tstruct buffer_page *tail_page = READ_ONCE(cpu_buffer->tail_page);\n\tstruct list_head *next;\n\tlong commit, write;\n\tunsigned long addr = (unsigned long)event;\n\tbool done = false;\n\tint stop = 0;\n\n\t\n\tdo {\n\t\tif (page == tail_page || WARN_ON_ONCE(stop++ > 100))\n\t\t\tdone = true;\n\t\tcommit = local_read(&page->page->commit);\n\t\twrite = local_read(&page->write);\n\t\tif (addr >= (unsigned long)&page->page->data[commit] &&\n\t\t    addr < (unsigned long)&page->page->data[write])\n\t\t\treturn;\n\n\t\tnext = rb_list_head(page->list.next);\n\t\tpage = list_entry(next, struct buffer_page, list);\n\t} while (!done);\n\tWARN_ON_ONCE(1);\n}","22934":"static int get_file_caps(struct linux_binprm *bprm)\n{\n\tstruct dentry *dentry;\n\tint rc = 0;\n\tstruct vfs_cap_data vcaps;\n\tstruct inode *inode;\n\n\tif (bprm->file->f_vfsmnt->mnt_flags & MNT_NOSUID) {\n\t\tbprm_clear_caps(bprm);\n\t\treturn 0;\n\t}\n\n\tdentry = dget(bprm->file->f_dentry);\n\tinode = dentry->d_inode;\n\tif (!inode->i_op || !inode->i_op->getxattr)\n\t\tgoto out;\n\n\trc = inode->i_op->getxattr(dentry, XATTR_NAME_CAPS, &vcaps,\n\t\t\t\t   XATTR_CAPS_SZ);\n\tif (rc == -ENODATA || rc == -EOPNOTSUPP) {\n\t\t\n\t\trc = 0;\n\t\tgoto out;\n\t}\n\tif (rc < 0)\n\t\tgoto out;\n\n\trc = cap_from_disk(&vcaps, bprm, rc);\n\tif (rc == -EINVAL)\n\t\tprintk(KERN_NOTICE \"STR\",\n\t\t       __func__, rc, bprm->filename);\n\nout:\n\tdput(dentry);\n\tif (rc)\n\t\tbprm_clear_caps(bprm);\n\n\treturn rc;\n}","22769":"R_API bool r_sys_arch_match(const char *archstr, const char *arch) {\n\tchar *ptr;\n\tif (!archstr || !arch || !*archstr || !*arch) {\n\t\treturn true;\n\t}\n\tif (!strcmp (archstr, \"STR\")) {\n\t\treturn true;\n\t}\n\tif (!strcmp (archstr, arch)) {\n\t\treturn true;\n\t}\n\tif ((ptr = strstr (archstr, arch))) {\n\t\tchar p = ptr[strlen (arch)];\n\t\tif (!p || p==',') {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}","23529":"dirserv_expire_measured_bw_cache(time_t now)\n{\n\n  if (mbw_cache) {\n    \n    DIGESTMAP_FOREACH_MODIFY(mbw_cache, k, mbw_cache_entry_t *, e) {\n      if (now > e->as_of + MAX_MEASUREMENT_AGE) {\n        tor_free(e);\n        MAP_DEL_CURRENT(k);\n      }\n    } DIGESTMAP_FOREACH_END;\n\n    \n    if (digestmap_size(mbw_cache) == 0) {\n      digestmap_free(mbw_cache, tor_free_);\n      mbw_cache = 0;\n    }\n  }\n}","22711":"zdeletefile(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    gs_parsed_file_name_t pname;\n    int code = parse_real_file_name(op, &pname, imemory, \"STR\");\n\n    if (code < 0)\n        return code;\n    if (pname.iodev == iodev_default(imemory)) {\n        if ((code = check_file_permissions(i_ctx_p, pname.fname, pname.len,\n                \"STR\")) < 0 &&\n                 !file_is_tempfile(i_ctx_p, op->value.bytes, r_size(op))) {\n            return code;\n        }\n    }\n    code = (*pname.iodev->procs.delete_file)(pname.iodev, pname.fname);\n    gs_free_file_name(&pname, \"STR\");\n    if (code < 0)\n        return code;\n    pop(1);\n    return 0;\n}","23666":"int sk_receive_skb(struct sock *sk, struct sk_buff *skb, const int nested)\n{\n\tint rc = NET_RX_SUCCESS;\n\n\tif (sk_filter(sk, skb))\n\t\tgoto discard_and_relse;\n\n\tskb->dev = NULL;\n\n\tif (nested)\n\t\tbh_lock_sock_nested(sk);\n\telse\n\t\tbh_lock_sock(sk);\n\tif (!sock_owned_by_user(sk)) {\n\t\t\n\t\tmutex_acquire(&sk->sk_lock.dep_map, 0, 1, _RET_IP_);\n\n\t\trc = sk_backlog_rcv(sk, skb);\n\n\t\tmutex_release(&sk->sk_lock.dep_map, 1, _RET_IP_);\n\t} else if (sk_add_backlog(sk, skb)) {\n\t\tbh_unlock_sock(sk);\n\t\tatomic_inc(&sk->sk_drops);\n\t\tgoto discard_and_relse;\n\t}\n\n\tbh_unlock_sock(sk);\nout:\n\tsock_put(sk);\n\treturn rc;\ndiscard_and_relse:\n\tkfree_skb(skb);\n\tgoto out;\n}","23052":"static int sqfs_get_regfile_info(struct squashfs_reg_inode *reg,\n\t\t\t\t struct squashfs_file_info *finfo,\n\t\t\t\t struct squashfs_fragment_block_entry *fentry,\n\t\t\t\t __le32 blksz)\n{\n\tint datablk_count = 0, ret;\n\n\tfinfo->size = get_unaligned_le32(&reg->file_size);\n\tfinfo->offset = get_unaligned_le32(&reg->offset);\n\tfinfo->start = get_unaligned_le32(&reg->start_block);\n\tfinfo->frag = SQFS_IS_FRAGMENTED(get_unaligned_le32(&reg->fragment));\n\n\tif (finfo->frag && finfo->offset == 0xFFFFFFFF)\n\t\treturn -EINVAL;\n\n\tif (finfo->size < 1 || finfo->start == 0xFFFFFFFF)\n\t\treturn -EINVAL;\n\n\tif (finfo->frag) {\n\t\tdatablk_count = finfo->size \/ le32_to_cpu(blksz);\n\t\tret = sqfs_frag_lookup(get_unaligned_le32(&reg->fragment),\n\t\t\t\t       fentry);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\t\tfinfo->comp = ret;\n\t\tif (fentry->size < 1 || fentry->start == 0x7FFFFFFF)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tdatablk_count = DIV_ROUND_UP(finfo->size, le32_to_cpu(blksz));\n\t}\n\n\tfinfo->blk_sizes = malloc(datablk_count * sizeof(u32));\n\tif (!finfo->blk_sizes)\n\t\treturn -ENOMEM;\n\n\treturn datablk_count;\n}","23165":"static void chap_binaryhex_to_asciihex(char *dst, char *src, int src_len)\n{\n\tint i;\n\n\tfor (i = 0; i < src_len; i++) {\n\t\tsprintf(&dst[i*2], \"STR\", (int) src[i] & 0xff);\n\t}\n}","23345":"long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,\n\t\t      size_t len, unsigned int flags)\n{\n\tstruct splice_desc sd = {\n\t\t.len\t\t= len,\n\t\t.total_len\t= len,\n\t\t.flags\t\t= flags,\n\t\t.pos\t\t= *ppos,\n\t\t.u.file\t\t= out,\n\t};\n\tlong ret;\n\n\tret = splice_direct_to_actor(in, &sd, direct_splice_actor);\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}","22730":"static int rtreeInsertCell(\n  Rtree *pRtree,\n  RtreeNode *pNode,\n  RtreeCell *pCell,\n  int iHeight\n){\n  int rc = SQLITE_OK;\n  if( iHeight>0 ){\n    RtreeNode *pChild = nodeHashLookup(pRtree, pCell->iRowid);\n    if( pChild ){\n      nodeRelease(pRtree, pChild->pParent);\n      nodeReference(pNode);\n      pChild->pParent = pNode;\n    }\n  }\n  if( nodeInsertCell(pRtree, pNode, pCell) ){\n    if( iHeight<=pRtree->iReinsertHeight || pNode->iNode==1){\n      rc = SplitNode(pRtree, pNode, pCell, iHeight);\n    }else{\n      pRtree->iReinsertHeight = iHeight;\n      rc = Reinsert(pRtree, pNode, pCell, iHeight);\n    }\n  }else{\n    rc = AdjustTree(pRtree, pNode, pCell);\n    if( rc==SQLITE_OK ){\n      if( iHeight==0 ){\n        rc = rowidWrite(pRtree, pCell->iRowid, pNode->iNode);\n      }else{\n        rc = parentWrite(pRtree, pCell->iRowid, pNode->iNode);\n      }\n    }\n  }\n  return rc;\n}","22708":"ebb_ews_connect_sync (EBookMetaBackend *meta_backend,\n\t\t      const ENamedParameters *credentials,\n\t\t      ESourceAuthenticationResult *out_auth_result,\n\t\t      gchar **out_certificate_pem,\n\t\t      GTlsCertificateFlags *out_certificate_errors,\n\t\t      GCancellable *cancellable,\n\t\t      GError **error)\n{\n\tEBookBackendEws *bbews;\n\tEBookCache *book_cache;\n\tCamelEwsSettings *ews_settings;\n\tgchar *hosturl;\n\tgboolean success = FALSE;\n\n\tg_return_val_if_fail (E_IS_BOOK_BACKEND_EWS (meta_backend), FALSE);\n\tg_return_val_if_fail (out_auth_result != NULL, FALSE);\n\n\tbbews = E_BOOK_BACKEND_EWS (meta_backend);\n\n\tg_rec_mutex_lock (&bbews->priv->cnc_lock);\n\n\tif (bbews->priv->cnc) {\n\t\tg_rec_mutex_unlock (&bbews->priv->cnc_lock);\n\n\t\t*out_auth_result = E_SOURCE_AUTHENTICATION_ACCEPTED;\n\n\t\treturn TRUE;\n\t}\n\n\tbook_cache = e_book_meta_backend_ref_cache (E_BOOK_META_BACKEND (bbews));\n\tif (book_cache) {\n\t\tECache *cache = E_CACHE (book_cache);\n\t\tgint data_version;\n\n\t\tdata_version = e_cache_get_key_int (cache, EBB_EWS_DATA_VERSION_KEY, NULL);\n\n\t\tif (data_version != EBB_EWS_DATA_VERSION) {\n\t\t\tMigrateData md;\n\n\t\t\te_cache_set_key_int (cache, EBB_EWS_DATA_VERSION_KEY, EBB_EWS_DATA_VERSION, NULL);\n\n\t\t\tmd.data_version = data_version;\n\t\t\tmd.is_gal = ebb_ews_check_is_gal (bbews);\n\n\t\t\tif (e_cache_foreach_update (cache, E_CACHE_INCLUDE_DELETED, NULL, ebb_ews_migrate_data_cb, &md, cancellable, NULL))\n\t\t\t\te_cache_sqlite_exec (cache, \"STR\", cancellable, NULL);\n\t\t}\n\n\t\tg_clear_object (&book_cache);\n\t}\n\n\tews_settings = ebb_ews_get_collection_settings (bbews);\n\thosturl = camel_ews_settings_dup_hosturl (ews_settings);\n\n\tbbews->priv->cnc = e_ews_connection_new_for_backend (E_BACKEND (bbews), e_book_backend_get_registry (E_BOOK_BACKEND (bbews)), hosturl, ews_settings);\n\n\te_binding_bind_property (\n\t\tbbews, \"STR\",\n\t\tbbews->priv->cnc, \"STR\",\n\t\tG_BINDING_SYNC_CREATE);\n\n\t*out_auth_result = e_ews_connection_try_credentials_sync (bbews->priv->cnc, credentials, cancellable, error);\n\n\tif (*out_auth_result == E_SOURCE_AUTHENTICATION_ACCEPTED) {\n\t\tESource *source = e_backend_get_source (E_BACKEND (bbews));\n\t\tESourceEwsFolder *ews_folder;\n\n\t\tews_folder = e_source_get_extension (source, E_SOURCE_EXTENSION_EWS_FOLDER);\n\n\t\tg_free (bbews->priv->folder_id);\n\t\tbbews->priv->folder_id = e_source_ews_folder_dup_id (ews_folder);\n\t\tbbews->priv->is_gal = ebb_ews_check_is_gal (bbews);\n\n\t\tg_signal_connect_swapped (bbews->priv->cnc, \"STR\",\n\t\t\tG_CALLBACK (ebb_ews_server_notification_cb), bbews);\n\n\t\tif (!bbews->priv->is_gal &&\n\t\t    camel_ews_settings_get_listen_notifications (ews_settings) &&\n\t\t    e_ews_connection_satisfies_server_version (bbews->priv->cnc, E_EWS_EXCHANGE_2010_SP1)) {\n\t\t\tGSList *folders = NULL;\n\n\t\t\tfolders = g_slist_prepend (folders, bbews->priv->folder_id);\n\n\t\t\te_ews_connection_enable_notifications_sync (bbews->priv->cnc,\n\t\t\t\tfolders, &bbews->priv->subscription_key);\n\n\t\t\tg_slist_free (folders);\n\t\t}\n\n\t\te_book_backend_set_writable (E_BOOK_BACKEND (bbews), !bbews->priv->is_gal);\n\t\tsuccess = TRUE;\n\t} else {\n\t\tebb_ews_convert_error_to_edb_error (error);\n\t\tg_clear_object (&bbews->priv->cnc);\n\t}\n\n\tg_rec_mutex_unlock (&bbews->priv->cnc_lock);\n\n\tg_free (hosturl);\n\n\treturn success;\n}","23462":"was_router_added_t\nrouter_add_extrainfo_to_routerlist(extrainfo_t *ei, const char **msg,\n                                   int from_cache, int from_fetch)\n{\n  was_router_added_t inserted;\n  (void)from_fetch;\n  if (msg) *msg = NULL;\n  \n\n  inserted = extrainfo_insert(router_get_routerlist(), ei, !from_cache);\n\n  if (WRA_WAS_ADDED(inserted) && !from_cache)\n    signed_desc_append_to_journal(&ei->cache_info,\n                                  &routerlist->extrainfo_store);\n\n  return inserted;","23110":"  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n\n    TensorShape filter_shape;\n    if (takes_shape_) {\n      const Tensor& filter_sizes = context->input(1);\n      OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(\n                                  filter_sizes.vec<int32>(), &filter_shape));\n    } else {\n      filter_shape = context->input(1).shape();\n    }\n\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"STR\"\n                                \"STR\",\n                                input_shape.dim_size(4), \"STR\",\n                                filter_shape.dim_size(3), \"STR\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"STR\"\n                                \"STR\",\n                                out_backprop_shape.dim_size(4),\n                                \"STR\",\n                                filter_shape.dim_size(4), \"STR\"));\n\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context,\n                   ConvBackpropComputeDimensions(\n                       \"STR\", 3,\n                       input_shape, filter_shape, out_backprop_shape, stride_,\n                       padding_, data_format_, &dims));\n\n    Tensor* filter_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, filter_shape, &filter_backprop));\n\n    if (input_shape.num_elements() == 0) {\n      filter_backprop->template flat<T>().setZero();\n      return;\n    }\n\n    functor::CuboidConvolutionBackwardFilter<Device, T>()(\n        context->eigen_device<Device>(),\n        filter_backprop->tensor<T, 5>(),                 \n        input.tensor<T, 5>(),                            \n        out_backprop.tensor<T, 5>(),                     \n        static_cast<int>(dims.spatial_dims[0].stride),   \n        static_cast<int>(dims.spatial_dims[1].stride),   \n        static_cast<int>(dims.spatial_dims[2].stride));  \n  }","23411":"void Type_LUTB2A_Free(struct _cms_typehandler_struct* self, void* Ptr)\n{\n    cmsPipelineFree((cmsPipeline*) Ptr);\n    return;\n\n    cmsUNUSED_PARAMETER(self);\n}","22549":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  \n  \n  \n  \n  \n  \n  \n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 0);\n\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputVariableId);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumElements(input_resource_id_tensor), 1);\n\n  return kTfLiteOk;\n}","23496":"static NETJOIN_REC *netjoin_find(IRC_SERVER_REC *server, const char *nick)\n{\n\tNETJOIN_SERVER_REC *srec;\n\tGSList *tmp;\n\n\tg_return_val_if_fail(server != NULL, NULL);\n\tg_return_val_if_fail(nick != NULL, NULL);\n\n\tsrec = netjoin_find_server(server);\n        if (srec == NULL) return NULL;\n\n\tfor (tmp = srec->netjoins; tmp != NULL; tmp = tmp->next) {\n\t\tNETJOIN_REC *rec = tmp->data;\n\n\t\tif (g_ascii_strcasecmp(rec->nick, nick) == 0)\n\t\t\treturn rec;\n\t}\n\n\treturn NULL;\n}","23163":"psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t\tcount ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.write (ptr, bytes*items, psf->vio_user_data) \/ bytes ;\n\n\titems *= bytes ;\n\n\t\n\tif (items <= 0)\n\t\treturn 0 ;\n\n\twhile (items > 0)\n\t{\t\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;\n\n\t\tcount = write (psf->file.filedes, ((const char*) ptr) + total, count) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0)\n\t\t\tbreak ;\n\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\n\treturn total \/ bytes ;\n} ","22853":"static inline void ModulateLCHab(const double percent_luma,\n  const double percent_chroma,const double percent_hue,double *red,\n  double *green,double *blue)\n{\n  double\n    hue,\n    luma,\n    chroma;\n\n  \n  ConvertRGBToLCHab(*red,*green,*blue,&luma,&chroma,&hue);\n  luma*=0.01*percent_luma;\n  chroma*=0.01*percent_chroma;\n  hue+=0.5*(0.01*percent_hue-1.0);\n  while (hue < 0.0)\n    hue+=1.0;\n  while (hue >= 1.0)\n    hue-=1.0;\n  ConvertLCHabToRGB(luma,chroma,hue,red,green,blue);\n}","23669":"      static double mp_vminabs(_cimg_math_parser& mp) {\n        _cimg_mp_vfunc(res = vec.minabs());\n      }","22519":"TPM_ECC_CURVE_Unmarshal(TPM_ECC_CURVE *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = UINT16_Unmarshal(target, buffer, size);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n\t  case TPM_ECC_NONE:\n\t  case TPM_ECC_NIST_P192:\n\t  case TPM_ECC_NIST_P224:\n\t  case TPM_ECC_NIST_P256:\n\t  case TPM_ECC_NIST_P384:\n\t  case TPM_ECC_NIST_P521:\n\t  case TPM_ECC_BN_P256:\n\t  case TPM_ECC_BN_P638:\n\t  case TPM_ECC_SM2_P256:\n\t    break;\n\t  default:\n\t    rc = TPM_RC_CURVE;\n\t}\n    }\n    return rc;\n}","22754":"static void attach_entity_cfs_rq(struct sched_entity *se)\n{\n\tstruct cfs_rq *cfs_rq = cfs_rq_of(se);\n\n#ifdef CONFIG_FAIR_GROUP_SCHED\n\t\n\tse->depth = se->parent ? se->parent->depth + 1 : 0;\n#endif\n\n\t\n\tupdate_load_avg(cfs_rq, se, sched_feat(ATTACH_AGE_LOAD) ? 0 : SKIP_AGE_LOAD);\n\tattach_entity_load_avg(cfs_rq, se, 0);\n\tupdate_tg_load_avg(cfs_rq, false);\n\tpropagate_entity_cfs_rq(se);\n}","22674":"static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"STR\", ret);\n\t\tgoto exit;\n\t}\n\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"STR\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = 0;\n\nexit:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret <= 0 ? ret : -EIO;\n}","23145":"vrrp_tfile_weight_handler(vector_t *strvec)\n{\n\tint weight;\n\tvrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);\n\n\tif (vector_size(strvec) < 2) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"STR\", tfile->fname);\n\t\treturn;\n\t}\n\tif (tfile->weight != 1) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"STR\", tfile->fname, FMT_STR_VSLOT(strvec, 1));\n\t\treturn;\n\t}\n\n\tif (!read_int_strvec(strvec, 1, &weight, -254, 254, true)) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"STR\"\n\t\t\t\t \"STR\", FMT_STR_VSLOT(strvec, 1), tfile->fname);\n\t\tweight = 1;\n\t}\n\n\ttfile->weight = weight;\n}","22653":"static int cirrus_bitblt_solidfill(CirrusVGAState *s, int blt_rop)\n{\n    cirrus_fill_t rop_func;\n\n    if (blit_is_unsafe(s, true)) {\n        return 0;\n    }\n    rop_func = cirrus_fill[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];\n    rop_func(s, s->vga.vram_ptr + s->cirrus_blt_dstaddr,\n             s->cirrus_blt_dstpitch,\n             s->cirrus_blt_width, s->cirrus_blt_height);\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t     s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t     s->cirrus_blt_height);\n    cirrus_bitblt_reset(s);\n    return 1;\n}","23049":"_copyTruncateStmt(const TruncateStmt *from)\n{\n\tTruncateStmt *newnode = makeNode(TruncateStmt);\n\n\tCOPY_NODE_FIELD(relations);\n\tCOPY_SCALAR_FIELD(restart_seqs);\n\tCOPY_SCALAR_FIELD(behavior);\n\n\treturn newnode;\n}","23725":"static void binder_deferred_release(struct binder_proc *proc)\n{\n\tstruct binder_context *context = proc->context;\n\tstruct rb_node *n;\n\tint threads, nodes, incoming_refs, outgoing_refs, active_transactions;\n\n\tmutex_lock(&binder_procs_lock);\n\thlist_del(&proc->proc_node);\n\tmutex_unlock(&binder_procs_lock);\n\n\tmutex_lock(&context->context_mgr_node_lock);\n\tif (context->binder_context_mgr_node &&\n\t    context->binder_context_mgr_node->proc == proc) {\n\t\tbinder_debug(BINDER_DEBUG_DEAD_BINDER,\n\t\t\t     \"STR\",\n\t\t\t     __func__, proc->pid);\n\t\tcontext->binder_context_mgr_node = NULL;\n\t}\n\tmutex_unlock(&context->context_mgr_node_lock);\n\tbinder_inner_proc_lock(proc);\n\t\n\tproc->tmp_ref++;\n\n\tproc->is_dead = true;\n\tthreads = 0;\n\tactive_transactions = 0;\n\twhile ((n = rb_first(&proc->threads))) {\n\t\tstruct binder_thread *thread;\n\n\t\tthread = rb_entry(n, struct binder_thread, rb_node);\n\t\tbinder_inner_proc_unlock(proc);\n\t\tthreads++;\n\t\tactive_transactions += binder_thread_release(proc, thread);\n\t\tbinder_inner_proc_lock(proc);\n\t}\n\n\tnodes = 0;\n\tincoming_refs = 0;\n\twhile ((n = rb_first(&proc->nodes))) {\n\t\tstruct binder_node *node;\n\n\t\tnode = rb_entry(n, struct binder_node, rb_node);\n\t\tnodes++;\n\t\t\n\t\tbinder_inc_node_tmpref_ilocked(node);\n\t\trb_erase(&node->rb_node, &proc->nodes);\n\t\tbinder_inner_proc_unlock(proc);\n\t\tincoming_refs = binder_node_release(node, incoming_refs);\n\t\tbinder_inner_proc_lock(proc);\n\t}\n\tbinder_inner_proc_unlock(proc);\n\n\toutgoing_refs = 0;\n\tbinder_proc_lock(proc);\n\twhile ((n = rb_first(&proc->refs_by_desc))) {\n\t\tstruct binder_ref *ref;\n\n\t\tref = rb_entry(n, struct binder_ref, rb_node_desc);\n\t\toutgoing_refs++;\n\t\tbinder_cleanup_ref_olocked(ref);\n\t\tbinder_proc_unlock(proc);\n\t\tbinder_free_ref(ref);\n\t\tbinder_proc_lock(proc);\n\t}\n\tbinder_proc_unlock(proc);\n\n\tbinder_release_work(proc, &proc->todo);\n\tbinder_release_work(proc, &proc->delivered_death);\n\n\tbinder_debug(BINDER_DEBUG_OPEN_CLOSE,\n\t\t     \"STR\",\n\t\t     __func__, proc->pid, threads, nodes, incoming_refs,\n\t\t     outgoing_refs, active_transactions);\n\n\tbinder_proc_dec_tmpref(proc);\n}","22694":"tc_dump_action(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nlmsghdr *nlh;\n\tunsigned char *b = skb->tail;\n\tstruct rtattr *x;\n\tstruct tc_action_ops *a_o;\n\tstruct tc_action a;\n\tint ret = 0;\n\tstruct tcamsg *t = (struct tcamsg *) NLMSG_DATA(cb->nlh);\n\tchar *kind = find_dump_kind(cb->nlh);\n\n\tif (kind == NULL) {\n\t\tprintk(\"STR\");\n\t\treturn 0;\n\t}\n\n\ta_o = tc_lookup_action_n(kind);\n\tif (a_o == NULL) {\n\t\tprintk(\"STR\", kind);\n\t\treturn 0;\n\t}\n\n\tmemset(&a, 0, sizeof(struct tc_action));\n\ta.ops = a_o;\n\n\tif (a_o->walk == NULL) {\n\t\tprintk(\"STR\", kind);\n\t\tgoto rtattr_failure;\n\t}\n\n\tnlh = NLMSG_PUT(skb, NETLINK_CB(cb->skb).pid, cb->nlh->nlmsg_seq,\n\t                cb->nlh->nlmsg_type, sizeof(*t));\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\n\tx = (struct rtattr *) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\n\tret = a_o->walk(skb, cb, RTM_GETACTION, &a);\n\tif (ret < 0)\n\t\tgoto rtattr_failure;\n\n\tif (ret > 0) {\n\t\tx->rta_len = skb->tail - (u8 *) x;\n\t\tret = skb->len;\n\t} else\n\t\tskb_trim(skb, (u8*)x - skb->data);\n\n\tnlh->nlmsg_len = skb->tail - b;\n\tif (NETLINK_CB(cb->skb).pid && ret)\n\t\tnlh->nlmsg_flags |= NLM_F_MULTI;\n\tmodule_put(a_o->owner);\n\treturn skb->len;\n\nrtattr_failure:\nnlmsg_failure:\n\tmodule_put(a_o->owner);\n\tskb_trim(skb, b - skb->data);\n\treturn skb->len;\n}","22716":"static int64 xattr_lookup_hash(const item_list *xalp)\n{\n\tconst rsync_xa *rxas = xalp->items;\n\tsize_t i;\n\tint64 key = hashlittle(&xalp->count, sizeof xalp->count);\n\n\tfor (i = 0; i < xalp->count; i++) {\n\t\tkey += hashlittle(rxas[i].name, rxas[i].name_len);\n\t\tif (rxas[i].datum_len > MAX_FULL_DATUM)\n\t\t\tkey += hashlittle(rxas[i].datum, MAX_DIGEST_LEN);\n\t\telse\n\t\t\tkey += hashlittle(rxas[i].datum, rxas[i].datum_len);\n\t}\n\n\tif (key == 0) {\n\t\t\n\t\treturn 1;\n\t}\n\n\treturn key;\n}","23353":"xmlGcMemGet(xmlFreeFunc *freeFunc, xmlMallocFunc *mallocFunc,\n            xmlMallocFunc *mallocAtomicFunc, xmlReallocFunc *reallocFunc,\n\t    xmlStrdupFunc *strdupFunc) {\n    if (freeFunc != NULL) *freeFunc = xmlFree;\n    if (mallocFunc != NULL) *mallocFunc = xmlMalloc;\n    if (mallocAtomicFunc != NULL) *mallocAtomicFunc = xmlMallocAtomic;\n    if (reallocFunc != NULL) *reallocFunc = xmlRealloc;\n    if (strdupFunc != NULL) *strdupFunc = xmlMemStrdup;\n    return(0);\n}","22504":"void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n\tgdImageJpegCtx (im, out, quality);\n\trv = gdDPExtractData (out, size);\n\tout->gd_free (out);\n\n\treturn rv;\n}","23548":"Value ExpressionMeta::evaluate(const Document& root, Variables* variables) const {\n    const auto& metadata = root.metadata();\n    switch (_metaType) {\n        case MetaType::kTextScore:\n            return metadata.hasTextScore() ? Value(metadata.getTextScore()) : Value();\n        case MetaType::kRandVal:\n            return metadata.hasRandVal() ? Value(metadata.getRandVal()) : Value();\n        case MetaType::kSearchScore:\n            return metadata.hasSearchScore() ? Value(metadata.getSearchScore()) : Value();\n        case MetaType::kSearchHighlights:\n            return metadata.hasSearchHighlights() ? Value(metadata.getSearchHighlights()) : Value();\n        case MetaType::kGeoNearDist:\n            return metadata.hasGeoNearDistance() ? Value(metadata.getGeoNearDistance()) : Value();\n        case MetaType::kGeoNearPoint:\n            return metadata.hasGeoNearPoint() ? Value(metadata.getGeoNearPoint()) : Value();\n        case MetaType::kRecordId:\n            \n            static_assert(RecordId::kMinRepr >= std::numeric_limits<long long>::min());\n            static_assert(RecordId::kMaxRepr <= std::numeric_limits<long long>::max());\n            return metadata.hasRecordId()\n                ? Value{static_cast<long long>(metadata.getRecordId().repr())}\n                : Value();\n        case MetaType::kIndexKey:\n            return metadata.hasIndexKey() ? Value(metadata.getIndexKey()) : Value();\n        case MetaType::kSortKey:\n            return metadata.hasSortKey()\n                ? Value(DocumentMetadataFields::serializeSortKey(metadata.isSingleElementKey(),\n                                                                 metadata.getSortKey()))\n                : Value();\n        default:\n            MONGO_UNREACHABLE;\n    }\n    MONGO_UNREACHABLE;\n}","23326":"struct tcp_sock_t *tcp_open(uint16_t port)\n{\n\tstruct tcp_sock_t *this = calloc(1, sizeof *this);\n\tif (this == NULL) {\n\t\tERR(\"STR\");\n\t\tgoto error;\n\t}\n\n\t\n\tthis->sd = -1;\n\tthis->sd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (this->sd < 0) {\n\t\tERR(\"STR\");\n\t\tgoto error;\n\t}\n\n\t\n\tstruct sockaddr_in addr;\n\tmemset(&addr, 0, sizeof addr);\n\taddr.sin_family = AF_INET;\n\taddr.sin_port = htons(port);\n\taddr.sin_addr.s_addr = htonl(0x7F000001);\n\n\t\n\tif (bind(this->sd,\n\t        (struct sockaddr *)&addr,\n\t        sizeof addr) < 0) {\n\t\tif (g_options.only_desired_port == 1)\n\t\t\tERR(\"STR\"\n\t\t\t    \"STR\");\n\t\tgoto error;\n\t}\n\n\t\n\tif (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {\n\t\tERR(\"STR\");\n\t\tgoto error;\n\t}\n\n\treturn this;\n\nerror:\n\tif (this != NULL) {\n\t\tif (this->sd != -1) {\n\t\t\tclose(this->sd);\n\t\t}\n\t\tfree(this);\n\t}\n\treturn NULL;\n}","22938":"int uwsgi_num2str2(int num, char *ptr) {\n\n\treturn snprintf(ptr, 11, \"STR\", num);\n}","23581":"static int cmm_timeout_handler(struct ctl_table *ctl, int write,\n\t\t\t       void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tchar buf[64], *p;\n\tlong nr, seconds;\n\tunsigned int len;\n\n\tif (!*lenp || (*ppos && !write)) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\tif (write) {\n\t\tlen = *lenp;\n\t\tif (copy_from_user(buf, buffer,\n\t\t\t\t   len > sizeof(buf) ? sizeof(buf) : len))\n\t\t\treturn -EFAULT;\n\t\tbuf[sizeof(buf) - 1] = '\\0';\n\t\tcmm_skip_blanks(buf, &p);\n\t\tnr = simple_strtoul(p, &p, 0);\n\t\tcmm_skip_blanks(p, &p);\n\t\tseconds = simple_strtoul(p, &p, 0);\n\t\tcmm_set_timeout(nr, seconds);\n\t} else {\n\t\tlen = sprintf(buf, \"STR\",\n\t\t\t      cmm_timeout_pages, cmm_timeout_seconds);\n\t\tif (len > *lenp)\n\t\t\tlen = *lenp;\n\t\tif (copy_to_user(buffer, buf, len))\n\t\t\treturn -EFAULT;\n\t}\n\t*lenp = len;\n\t*ppos += len;\n\treturn 0;\n}","23417":"static int page_not_mapped(struct page *page)\n{\n\treturn !page_mapped(page);\n};","23541":"int install_thread_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tkeyring = keyring_alloc(\"STR\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->thread_keyring = keyring;\n\treturn 0;\n}","22499":"asmlinkage void do_notify_resume(struct pt_regs *regs, u32 thread_info_flags)\n{\n\t\n\tif (thread_info_flags & _TIF_SINGLESTEP) {\n#ifndef CONFIG_MN10300_USING_JTAG\n\t\tregs->epsw |= EPSW_T;\n\t\tclear_thread_flag(TIF_SINGLESTEP);\n#else\n\t\tBUG(); \n#endif\n\t}\n\n\t\n\tif (thread_info_flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))\n\t\tdo_signal(regs);\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(__frame);\n\t}\n}","23763":"BitStream::skipToNextByte()\n{\n    if (bit_offset != 7)\n    {\n\tunsigned int bits_to_skip = bit_offset + 1;\n\tif (bits_available < bits_to_skip)\n\t{\n\t    throw std::logic_error(\n\t\t\"STR\");\n\t}\n\tbit_offset = 7;\n\t++p;\n\tbits_available -= bits_to_skip;\n    }\n}","23552":"WORD_LIST *\nexpand_word (word, quoted)\n     WORD_DESC *word;\n     int quoted;\n{\n  WORD_LIST *result, *tresult;\n\n  tresult = call_expand_word_internal (word, quoted, 0, (int *)NULL, (int *)NULL);\n  result = word_list_split (tresult);\n  dispose_words (tresult);\n  return (result ? dequote_list (result) : result);","22910":"bool ActiveStreamDecoderFilter::complete() { return parent_.state_.remote_decode_complete_; }","23367":"static opj_bool pi_next_lrcp(opj_pi_iterator_t * pi)\n{\n    opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        res = &comp->resolutions[pi->resno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n\n    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n        for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1;\n                pi->resno++) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                if (pi->resno >= comp->numresolutions) {\n                    continue;\n                }\n                res = &comp->resolutions[pi->resno];\n                if (!pi->tp_on) {\n                    pi->poc.precno1 = res->pw * res->ph;\n                }\n                for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n                    index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                            pi->step_c + pi->precno * pi->step_p;\n                    \n                    if (index >= pi->include_size) {\n                        opj_pi_emit_error(pi, \"STR\");\n                        return OPJ_FALSE;\n                    }\n                    if (!pi->include[index]) {\n                        pi->include[index] = 1;\n                        return OPJ_TRUE;\n                    }\nLABEL_SKIP:\n                    ;\n                }\n            }\n        }\n    }\n\n    return OPJ_FALSE;\n}","23754":"     (CirrusVGAState *s,\n      uint8_t *dst, int dst_pitch,\n      int width, int height)\n{\n    uint8_t *d, *d1;\n    uint32_t col;\n    int x, y;\n\n    col = s->cirrus_blt_fgcol;\n\n    d1 = dst;\n    for(y = 0; y < height; y++) {\n        d = d1;\n        for(x = 0; x < width; x += (DEPTH \/ 8)) {\n            PUTPIXEL();\n            d += (DEPTH \/ 8);\n        }\n        d1 += dst_pitch;\n    }\n}","23309":"acquire_caps (uid_t uid)\n{\n  struct __user_cap_header_struct hdr;\n  struct __user_cap_data_struct data;\n\n  \n  if (prctl (PR_SET_KEEPCAPS, 1, 0, 0, 0) < 0)\n    g_error (\"STR\");\n\n  \n  if (setuid (uid) < 0)\n    g_error (\"STR\");\n\n  memset (&hdr, 0, sizeof(hdr));\n  hdr.version = _LINUX_CAPABILITY_VERSION;\n\n  \n  data.effective = REQUIRED_CAPS;\n  data.permitted = REQUIRED_CAPS;\n  data.inheritable = 0;\n  if (capset (&hdr, &data) < 0)\n    g_error (\"STR\");\n}","23460":"GF_Err tkhd_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TrackHeaderBox *ptr = (GF_TrackHeaderBox *)s;\n\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tif (ptr->version == 1) {\n\t\tgf_bs_write_u64(bs, ptr->creationTime);\n\t\tgf_bs_write_u64(bs, ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->trackID);\n\t\tgf_bs_write_u32(bs, ptr->reserved1);\n\t\tgf_bs_write_u64(bs, ptr->duration);\n\t} else {\n\t\tgf_bs_write_u32(bs, (u32) ptr->creationTime);\n\t\tgf_bs_write_u32(bs, (u32) ptr->modificationTime);\n\t\tgf_bs_write_u32(bs, ptr->trackID);\n\t\tgf_bs_write_u32(bs, ptr->reserved1);\n\t\tgf_bs_write_u32(bs, (u32) ptr->duration);\n\t}\n\tgf_bs_write_u32(bs, ptr->reserved2[0]);\n\tgf_bs_write_u32(bs, ptr->reserved2[1]);\n\tgf_bs_write_u16(bs, ptr->layer);\n\tgf_bs_write_u16(bs, ptr->alternate_group);\n\tgf_bs_write_u16(bs, ptr->volume);\n\tgf_bs_write_u16(bs, ptr->reserved3);\n\tgf_bs_write_u32(bs, ptr->matrix[0]);\n\tgf_bs_write_u32(bs, ptr->matrix[1]);\n\tgf_bs_write_u32(bs, ptr->matrix[2]);\n\tgf_bs_write_u32(bs, ptr->matrix[3]);\n\tgf_bs_write_u32(bs, ptr->matrix[4]);\n\tgf_bs_write_u32(bs, ptr->matrix[5]);\n\tgf_bs_write_u32(bs, ptr->matrix[6]);\n\tgf_bs_write_u32(bs, ptr->matrix[7]);\n\tgf_bs_write_u32(bs, ptr->matrix[8]);\n\tgf_bs_write_u32(bs, ptr->width);\n\tgf_bs_write_u32(bs, ptr->height);\n\treturn GF_OK;\n}","23248":"call_refresh(struct rpc_task *task)\n{\n\tdprint_status(task);\n\n\ttask->tk_action = call_refreshresult;\n\ttask->tk_status = 0;\n\ttask->tk_client->cl_stats->rpcauthrefresh++;\n\trpcauth_refreshcred(task);\n}","22835":"pblock_analytics_destroy(Slapi_PBlock *pb)\n{\n    \n    if (pb->analytics_init != ANALYTICS_MAGIC) {\n        return;\n    }\n    \n    PL_HashTableDestroy(pb->analytics);\n    pb->analytics_init = 0;\n}","22729":"PHP_FUNCTION(xsl_xsltprocessor_get_parameter)\n{\n\tzval *id;\n\tint name_len = 0, namespace_len = 0;\n\tchar *name, *namespace;\n\tzval **value;\n\txsl_object *intern;\n\n\tDOM_GET_THIS(id);\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"STR\", &namespace, &namespace_len, &name, &name_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tintern = (xsl_object *)zend_object_store_get_object(id TSRMLS_CC);\n\tif ( zend_hash_find(intern->parameter, name, name_len + 1,  (void**) &value) == SUCCESS) {\n\t\tconvert_to_string_ex(value);\n\t\tRETVAL_STRING(Z_STRVAL_PP(value),1);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}","23196":"int i2d_PrivateKey_bio(BIO *bp, EVP_PKEY *pkey)\n\t{\n\treturn ASN1_i2d_bio_of(EVP_PKEY,i2d_PrivateKey,bp,pkey);\n\t}","22878":"static char *stibp_state(void)\n{\n\tif (spectre_v2_enabled == SPECTRE_V2_IBRS_ENHANCED)\n\t\treturn \"\";\n\n\tswitch (spectre_v2_user) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\treturn \"STR\";\n\tcase SPECTRE_V2_USER_STRICT:\n\t\treturn \"STR\";\n\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n\t\treturn \"STR\";\n\tcase SPECTRE_V2_USER_PRCTL:\n\tcase SPECTRE_V2_USER_SECCOMP:\n\t\tif (static_key_enabled(&switch_to_cond_stibp))\n\t\t\treturn \"STR\";\n\t}\n\treturn \"\";\n}","23687":"\tDlfcnModule(void* m)\n\t\t: module(m)\n\t{}","22917":"rsvg_marker_parse (const RsvgDefs * defs, const char *str)\n{\n    char *name;\n\n    name = rsvg_get_url_string (str);\n    if (name) {\n        RsvgNode *val;\n        val = rsvg_defs_lookup (defs, name);\n        g_free (name);\n\n        if (val && (!strcmp (val->type->str, \"STR\")))\n            return val;\n    }\n    return NULL;\n}","23605":"rpc_restart_call(struct rpc_task *task)\n{\n\tif (RPC_ASSASSINATED(task))\n\t\treturn 0;\n\ttask->tk_action = call_start;\n\treturn 1;\n}","22475":"main (int argc, char *const *argv)\n{\n  unsigned int errorCount = 0;\n  (void) argc; (void) argv;  \n\n  errorCount += test_multipart_splits ();\n  errorCount += test_multipart_garbage ();\n  errorCount += test_urlencoding ();\n  errorCount += test_multipart ();\n  errorCount += test_nested_multipart ();\n  errorCount += test_empty_value ();\n  if (errorCount != 0)\n    fprintf (stderr, \"STR\", errorCount);\n  return errorCount != 0;       \n}","22821":"bool AuthUnknownAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n\t\t\t\t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t\t\t\t EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,\nuint64_t *auid)\n{\n  \n\n  return true;\n}","23463":"htmlParseErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,\n             const char *msg, const xmlChar *str1, const xmlChar *str2)\n{\n    if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&\n        (ctxt->instate == XML_PARSER_EOF))\n\treturn;\n    if (ctxt != NULL)\n\tctxt->errNo = error;\n    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_HTML, error,\n                    XML_ERR_ERROR, NULL, 0,\n\t\t    (const char *) str1, (const char *) str2,\n\t\t    NULL, 0, 0,\n\t\t    msg, str1, str2);\n    if (ctxt != NULL)\n\tctxt->wellFormed = 0;\n}","23510":"R_API ut8 *r_bin_java_get_attr_buf(RBinJavaObj *bin, ut64 sz, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tut8 *attr_buf = NULL;\n\tint pending = len - offset;\n\tconst ut8 *a_buf = offset + buf;\n\tattr_buf = (ut8 *) calloc (pending + 1, 1);\n\tif (!attr_buf) {\n\t\teprintf (\"STR\"PFMT64x\n\t\t\t\"STR\", sz);\n\t\treturn attr_buf;\n\t}\n\tmemcpy (attr_buf, a_buf, pending); \n\treturn attr_buf;\n}","23659":"INT64 LibRaw::x3f_thumb_size()\n{\n\ttry {\n\t\tx3f_t *x3f = (x3f_t*)_x3f_data;\n\t\tif (!x3f) return -1; \n\t\tx3f_directory_entry_t *DE = x3f_get_thumb_jpeg(x3f);\n\t\tif (!DE)\n\t\t\tDE = x3f_get_thumb_plain(x3f);\n\t\tif (!DE)\n\t\t\treturn -1;\n\t\tint64_t p = x3f_load_data_size(x3f, DE);\n\t\tif (p < 0 || p > 0xffffffff)\n\t\t\treturn -1;\n\t\treturn p;\n\t}\n\tcatch (...)\n\t{\n\t\treturn -1;\n\t}\n}","22937":"int unit_coldplug(Unit *u) {\n        int r = 0, q;\n        char **i;\n\n        assert(u);\n\n        \n        if (u->coldplugged)\n                return 0;\n\n        u->coldplugged = true;\n\n        STRV_FOREACH(i, u->deserialized_refs) {\n                q = bus_unit_track_add_name(u, *i);\n                if (q < 0 && r >= 0)\n                        r = q;\n        }\n        u->deserialized_refs = strv_free(u->deserialized_refs);\n\n        if (UNIT_VTABLE(u)->coldplug) {\n                q = UNIT_VTABLE(u)->coldplug(u);\n                if (q < 0 && r >= 0)\n                        r = q;\n        }\n\n        if (u->job) {\n                q = job_coldplug(u->job);\n                if (q < 0 && r >= 0)\n                        r = q;\n        }\n\n        return r;\n}","22660":"static int __net_init tcp4_proc_init_net(struct net *net)\n{\n\treturn tcp_proc_register(net, &tcp4_seq_afinfo);\n}","23259":"get_cmdline_type(void)\n{\n    cmdline_info_T *p = get_ccline_ptr();\n\n    if (p == NULL)\n\treturn NUL;\n    if (p->cmdfirstc == NUL)\n\treturn\n# ifdef FEAT_EVAL\n\t    (p->input_fn) ? '@' :\n# endif\n\t    '-';\n    return p->cmdfirstc;\n}","23768":"int enc_untrusted_unlink(const char *pathname) {\n  return EnsureInitializedAndDispatchSyscall(asylo::system_call::kSYS_unlink,\n                                             pathname);\n}","22774":"PixarLogSetupDecode(TIFF* tif)\n{\n\tstatic const char module[] = \"STR\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tPixarLogState* sp = DecoderState(tif);\n\ttmsize_t tbuf_size;\n\n\tassert(sp != NULL);\n\n\t\n\ttif->tif_postdecode = _TIFFNoPostDecode;  \n\n\t\n\n\tsp->stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ?\n\t    td->td_samplesperpixel : 1);\n\ttbuf_size = multiply_ms(multiply_ms(multiply_ms(sp->stride, td->td_imagewidth),\n\t\t\t\t      td->td_rowsperstrip), sizeof(uint16));\n\t\n\ttbuf_size = add_ms(tbuf_size, sizeof(uint16) * sp->stride);\n\tif (tbuf_size == 0)\n\t\treturn (0);   \n\tsp->tbuf = (uint16 *) _TIFFmalloc(tbuf_size);\n\tif (sp->tbuf == NULL)\n\t\treturn (0);\n\tif (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN)\n\t\tsp->user_datafmt = PixarLogGuessDataFmt(td);\n\tif (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"STR\", \n\t\t\ttd->td_bitspersample);\n\t\treturn (0);\n\t}\n\n\tif (inflateInit(&sp->stream) != Z_OK) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"STR\");\n\t\treturn (0);\n\t} else {\n\t\tsp->state |= PLSTATE_INIT;\n\t\treturn (1);\n\t}\n}","23708":"NO_INLINE JsVar *__jspeAssignmentExpression(JsVar *lhs) {\n  if (lex->tk=='=' || lex->tk==LEX_PLUSEQUAL || lex->tk==LEX_MINUSEQUAL ||\n      lex->tk==LEX_MULEQUAL || lex->tk==LEX_DIVEQUAL || lex->tk==LEX_MODEQUAL ||\n      lex->tk==LEX_ANDEQUAL || lex->tk==LEX_OREQUAL ||\n      lex->tk==LEX_XOREQUAL || lex->tk==LEX_RSHIFTEQUAL ||\n      lex->tk==LEX_LSHIFTEQUAL || lex->tk==LEX_RSHIFTUNSIGNEDEQUAL) {\n    JsVar *rhs;\n\n    int op = lex->tk;\n    JSP_ASSERT_MATCH(op);\n    rhs = jspeAssignmentExpression();\n    rhs = jsvSkipNameAndUnLock(rhs); \n\n    if (JSP_SHOULD_EXECUTE && lhs) {\n      if (op=='=') {\n        \n        if (!jsvGetRefs(lhs) && jsvIsName(lhs)) {\n          if (!jsvIsArrayBufferName(lhs) && !jsvIsNewChild(lhs))\n            jsvAddName(execInfo.root, lhs);\n        }\n        jspReplaceWith(lhs, rhs);\n      } else {\n        if (op==LEX_PLUSEQUAL) op='+';\n        else if (op==LEX_MINUSEQUAL) op='-';\n        else if (op==LEX_MULEQUAL) op='*';\n        else if (op==LEX_DIVEQUAL) op='\/';\n        else if (op==LEX_MODEQUAL) op='%';\n        else if (op==LEX_ANDEQUAL) op='&';\n        else if (op==LEX_OREQUAL) op='|';\n        else if (op==LEX_XOREQUAL) op='^';\n        else if (op==LEX_RSHIFTEQUAL) op=LEX_RSHIFT;\n        else if (op==LEX_LSHIFTEQUAL) op=LEX_LSHIFT;\n        else if (op==LEX_RSHIFTUNSIGNEDEQUAL) op=LEX_RSHIFTUNSIGNED;\n        if (op=='+' && jsvIsName(lhs)) {\n          JsVar *currentValue = jsvSkipName(lhs);\n          if (jsvIsString(currentValue) && !jsvIsFlatString(currentValue) && jsvGetRefs(currentValue)==1 && rhs!=currentValue) {\n            \n            JsVar *str = jsvAsString(rhs, false);\n            jsvAppendStringVarComplete(currentValue, str);\n            jsvUnLock(str);\n            op = 0;\n          }\n          jsvUnLock(currentValue);\n        }\n        if (op) {\n          \n          JsVar *res = jsvMathsOpSkipNames(lhs,rhs,op);\n          jspReplaceWith(lhs, res);\n          jsvUnLock(res);\n        }\n      }\n    }\n    jsvUnLock(rhs);\n  }\n  return lhs;\n}","22911":"void usb_sg_cancel(struct usb_sg_request *io)\n{\n\tunsigned long flags;\n\tint i, retval;\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status) {\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\treturn;\n\t}\n\t\n\tio->status = -ECONNRESET;\n\tspin_unlock_irqrestore(&io->lock, flags);\n\n\tfor (i = io->entries - 1; i >= 0; --i) {\n\t\tusb_block_urb(io->urbs[i]);\n\n\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\tif (retval != -EINPROGRESS\n\t\t    && retval != -ENODEV\n\t\t    && retval != -EBUSY\n\t\t    && retval != -EIDRM)\n\t\t\tdev_warn(&io->dev->dev, \"STR\",\n\t\t\t\t __func__, retval);\n\t}\n}","22900":"int32_t ClockMath::floorDivide(int32_t numerator, int32_t denominator) {\n    return (numerator >= 0) ?\n        numerator \/ denominator : ((numerator + 1) \/ denominator) - 1;\n}","22663":"NOEXPORT void print_ssl_options(void) {\n    SSL_OPTION *option;\n\n    s_log(LOG_NOTICE, \"STR\");\n    s_log(LOG_NOTICE, \"STR\");\n    for(option=(SSL_OPTION *)ssl_opts; option->name; ++option)\n        s_log(LOG_NOTICE, \"STR\", option->name);\n}","22641":"static void tcp_sum_lost(struct tcp_sock *tp, struct sk_buff *skb)\n{\n\t__u8 sacked = TCP_SKB_CB(skb)->sacked;\n\n\tif (!(sacked & TCPCB_LOST) ||\n\t    ((sacked & TCPCB_LOST) && (sacked & TCPCB_SACKED_RETRANS)))\n\t\ttp->lost += tcp_skb_pcount(skb);\n}","22564":"int ssl3_setup_buffers(SSL *s)\n\t{\n\tunsigned char *p;\n\tsize_t len,align=0;\n\n#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0\n\talign = (-SSL3_RT_HEADER_LENGTH)&(SSL3_ALIGN_PAYLOAD-1);\n#endif\n\n\tif (s->s3->rbuf.buf == NULL)\n\t\t{\n\t\tlen = SSL3_RT_MAX_PLAIN_LENGTH\n\t\t\t+ SSL3_RT_MAX_ENCRYPTED_OVERHEAD\n\t\t\t+ SSL3_RT_HEADER_LENGTH + align;\n\t\tif (s->options & SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER)\n\t\t\t{\n\t\t\ts->s3->init_extra = 1;\n\t\t\tlen += SSL3_RT_MAX_EXTRA;\n\t\t\t}\n#ifndef OPENSSL_NO_COMP\n\t\tif (!(s->options & SSL_OP_NO_COMPRESSION))\n\t\t\tlen += SSL3_RT_MAX_COMPRESSED_OVERHEAD;\n#endif\n\t\tif ((p=OPENSSL_malloc(len)) == NULL)\n\t\t\tgoto err;\n\t\ts->s3->rbuf.buf = p;\n\t\ts->s3->rbuf.len = len;\n\t\t}\n\n\tif (s->s3->wbuf.buf == NULL)\n\t\t{\n\t\tlen = s->max_send_fragment\n\t\t\t+ SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD\n\t\t\t+ SSL3_RT_HEADER_LENGTH + align;\n#ifndef OPENSSL_NO_COMP\n\t\tif (!(s->options & SSL_OP_NO_COMPRESSION))\n\t\t\tlen += SSL3_RT_MAX_COMPRESSED_OVERHEAD;\n#endif\n\t\tif (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS))\n\t\t\tlen += SSL3_RT_HEADER_LENGTH + align\n\t\t\t\t+ SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD;\n\t\tif ((p=OPENSSL_malloc(len)) == NULL)\n\t\t\tgoto err;\n\t\ts->s3->wbuf.buf = p;\n\t\ts->s3->wbuf.len = len;\n\t\t}\n\ts->packet= &(s->s3->rbuf.buf[0]);\n\treturn(1);\nerr:\n\tSSLerr(SSL_F_SSL3_SETUP_BUFFERS,ERR_R_MALLOC_FAILURE);\n\treturn(0);\n\t}","22777":"int Field_temporal_with_date::store(const char *from, size_t len, CHARSET_INFO *cs)\n{\n  MYSQL_TIME ltime;\n  MYSQL_TIME_STATUS status;\n  THD *thd= get_thd();\n  ErrConvString str(from, len, cs);\n  bool func_res= !str_to_datetime(cs, from, len, &ltime,\n                                  sql_mode_for_dates(thd),\n                                  &status);\n  return store_TIME_with_warning(&ltime, &str, status.warnings, func_res);\n}","23604":"static int dxtory_decode_v1_444(AVCodecContext *avctx, AVFrame *pic,\n                                const uint8_t *src, int src_size)\n{\n    int h, w;\n    uint8_t *Y, *U, *V;\n    int ret;\n\n    if (src_size < avctx->width * avctx->height * 3) {\n        av_log(avctx, AV_LOG_ERROR, \"STR\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV444P;\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n        return ret;\n\n    Y = pic->data[0];\n    U = pic->data[1];\n    V = pic->data[2];\n    for (h = 0; h < avctx->height; h++) {\n        for (w = 0; w < avctx->width; w++) {\n            Y[w] = *src++;\n            U[w] = *src++ ^ 0x80;\n            V[w] = *src++ ^ 0x80;\n        }\n        Y += pic->linesize[0];\n        U += pic->linesize[1];\n        V += pic->linesize[2];\n    }\n\n    return 0;\n}","22696":"static bool write_log_changed_partitions(ALTER_PARTITION_PARAM_TYPE *lpt,\n                                         uint *next_entry, const char *path)\n{\n  DDL_LOG_ENTRY ddl_log_entry;\n  partition_info *part_info= lpt->part_info;\n  DDL_LOG_MEMORY_ENTRY *log_entry;\n  char tmp_path[FN_REFLEN];\n  char normal_path[FN_REFLEN];\n  List_iterator<partition_element> part_it(part_info->partitions);\n  uint temp_partitions= part_info->temp_partitions.elements;\n  uint num_elements= part_info->partitions.elements;\n  uint i= 0;\n  DBUG_ENTER(\"STR\");\n\n  do\n  {\n    partition_element *part_elem= part_it++;\n    if (part_elem->part_state == PART_IS_CHANGED ||\n        (part_elem->part_state == PART_IS_ADDED && temp_partitions))\n    {\n      if (part_info->is_sub_partitioned())\n      {\n        List_iterator<partition_element> sub_it(part_elem->subpartitions);\n        uint num_subparts= part_info->num_subparts;\n        uint j= 0;\n        do\n        {\n          partition_element *sub_elem= sub_it++;\n          ddl_log_entry.next_entry= *next_entry;\n          ddl_log_entry.handler_name=\n               ha_resolve_storage_engine_name(sub_elem->engine_type);\n          create_subpartition_name(tmp_path, path,\n                                   part_elem->partition_name,\n                                   sub_elem->partition_name,\n                                   TEMP_PART_NAME);\n          create_subpartition_name(normal_path, path,\n                                   part_elem->partition_name,\n                                   sub_elem->partition_name,\n                                   NORMAL_PART_NAME);\n          ddl_log_entry.name= normal_path;\n          ddl_log_entry.from_name= tmp_path;\n          if (part_elem->part_state == PART_IS_CHANGED)\n            ddl_log_entry.action_type= DDL_LOG_REPLACE_ACTION;\n          else\n            ddl_log_entry.action_type= DDL_LOG_RENAME_ACTION;\n          if (write_ddl_log_entry(&ddl_log_entry, &log_entry))\n          {\n            DBUG_RETURN(TRUE);\n          }\n          *next_entry= log_entry->entry_pos;\n          sub_elem->log_entry= log_entry;\n          insert_part_info_log_entry_list(part_info, log_entry);\n        } while (++j < num_subparts);\n      }\n      else\n      {\n        ddl_log_entry.next_entry= *next_entry;\n        ddl_log_entry.handler_name=\n               ha_resolve_storage_engine_name(part_elem->engine_type);\n        create_partition_name(tmp_path, path,\n                              part_elem->partition_name,\n                              TEMP_PART_NAME, TRUE);\n        create_partition_name(normal_path, path,\n                              part_elem->partition_name,\n                              NORMAL_PART_NAME, TRUE);\n        ddl_log_entry.name= normal_path;\n        ddl_log_entry.from_name= tmp_path;\n        if (part_elem->part_state == PART_IS_CHANGED)\n          ddl_log_entry.action_type= DDL_LOG_REPLACE_ACTION;\n        else\n          ddl_log_entry.action_type= DDL_LOG_RENAME_ACTION;\n        if (write_ddl_log_entry(&ddl_log_entry, &log_entry))\n        {\n          DBUG_RETURN(TRUE);\n        }\n        *next_entry= log_entry->entry_pos;\n        part_elem->log_entry= log_entry;\n        insert_part_info_log_entry_list(part_info, log_entry);\n      }\n    }\n  } while (++i < num_elements);\n  DBUG_RETURN(FALSE);\n}","23039":"static void megasas_scsi_reset(DeviceState *dev)\n{\n    MegasasState *s = MEGASAS(dev);\n\n    megasas_soft_reset(s);\n}","23139":"callbacks_get_selected_row_index (void)\n{\n\tGtkTreeSelection *selection;\n\tGtkTreeIter       iter;\n\tGtkListStore *list_store = (GtkListStore *) gtk_tree_view_get_model\n\t\t\t((GtkTreeView *) screen.win.layerTree);\n\tgint index=-1,i=0;\n\n\t\n\tselection = gtk_tree_view_get_selection((GtkTreeView *) screen.win.layerTree);\n\tif (gtk_tree_selection_get_selected(selection, NULL, &iter)) {\n\t\twhile (gtk_tree_model_iter_nth_child ((GtkTreeModel *)list_store,\n\t\t\t\t&iter, NULL, i)){\n\t\t\tif (gtk_tree_selection_iter_is_selected (selection, &iter)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\ti++;\n     \t\t}\n\t}\n\treturn index;\n}","23044":"void dvb_usb_device_exit(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *name = \"STR\";\n\n\tusb_set_intfdata(intf, NULL);\n\tif (d != NULL && d->desc != NULL) {\n\t\tname = d->desc->name;\n\t\tdvb_usb_exit(d);\n\t}\n\tinfo(\"STR\", name);\n\n}","23654":"static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,\n                struct vmsvga_cursor_definition_s *c)\n{\n    QEMUCursor *qc;\n    int i, pixels;\n\n    qc = cursor_alloc(c->width, c->height);\n    qc->hot_x = c->hot_x;\n    qc->hot_y = c->hot_y;\n    switch (c->bpp) {\n    case 1:\n        cursor_set_mono(qc, 0xffffff, 0x000000, (void *)c->image,\n                        1, (void *)c->mask);\n#ifdef DEBUG\n        cursor_print_ascii_art(qc, \"STR\");\n#endif\n        break;\n    case 32:\n        \n        cursor_set_mono(qc, 0x000000, 0x000000, (void *)c->mask,\n                        1, (void *)c->mask);\n        \n        pixels = c->width * c->height;\n        for (i = 0; i < pixels; i++) {\n            qc->data[i] |= c->image[i] & 0xffffff;\n        }\n#ifdef DEBUG\n        cursor_print_ascii_art(qc, \"STR\");\n#endif\n        break;\n    default:\n        fprintf(stderr, \"STR\",\n                __func__, c->bpp);\n        cursor_put(qc);\n        qc = cursor_builtin_left_ptr();\n    }\n\n    dpy_cursor_define(s->vga.con, qc);\n    cursor_put(qc);\n}","23059":"uint8_t smb2cli_session_security_mode(struct smbXcli_session *session)\n{\n\tstruct smbXcli_conn *conn = session->conn;\n\tuint8_t security_mode = 0;\n\n\tif (conn == NULL) {\n\t\treturn security_mode;\n\t}\n\n\tsecurity_mode = SMB2_NEGOTIATE_SIGNING_ENABLED;\n\tif (conn->mandatory_signing) {\n\t\tsecurity_mode |= SMB2_NEGOTIATE_SIGNING_REQUIRED;\n\t}\n\n\treturn security_mode;\n}","23007":"void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"STR\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\"STR\");\n\tcmdline.append(utils::replace_all(file,\"STR\"));\n\tcmdline.append(\"STR\");\n\tstfl::reset();\n\tutils::run_interactively(cmdline, \"STR\");\n}","23783":"static void ms_adpcm_run_pull (_AFmoduleinst *module)\n{\n\tms_adpcm_data\t*d = (ms_adpcm_data *) module->modspec;\n\tAFframecount\tframes2read = module->outc->nframes;\n\tAFframecount\tnframes = 0;\n\tint\t\ti, framesPerBlock, blockCount;\n\tssize_t\t\tblocksRead, bytesDecoded;\n\n\tframesPerBlock = d->samplesPerBlock \/ d->track->f.channelCount;\n\tassert(module->outc->nframes % framesPerBlock == 0);\n\tblockCount = module->outc->nframes \/ framesPerBlock;\n\n\t\n\tblocksRead = af_fread(module->inc->buf, d->blockAlign, blockCount, d->fh);\n\n\t\n\tfor (i=0; i<blockCount; i++)\n\t{\n\t\tbytesDecoded = ms_adpcm_decode_block(d,\n\t\t\t(uint8_t *) module->inc->buf + i * d->blockAlign,\n\t\t\t(int16_t *) module->outc->buf + i * d->samplesPerBlock);\n\n\t\tnframes += framesPerBlock;\n\t}\n\n\td->track->nextfframe += nframes;\n\n\tif (blocksRead > 0)\n\t\td->track->fpos_next_frame += blocksRead * d->blockAlign;\n\n\tassert(af_ftell(d->fh) == d->track->fpos_next_frame);\n\n\t\n\n\tif (d->track->totalfframes != -1 && nframes != frames2read)\n\t{\n\t\t\n\t\tif (d->track->filemodhappy)\n\t\t{\n\t\t\t_af_error(AF_BAD_READ,\n\t\t\t\t\"STR\",\n\t\t\t\td->track->nextfframe,\n\t\t\t\td->track->totalfframes);\n\t\t\td->track->filemodhappy = AF_FALSE;\n\t\t}\n\t}\n\n\tmodule->outc->nframes = nframes;\n}","23415":"apr_byte_t oidc_cache_set(request_rec *r, const char *section, const char *key,\n\t\tconst char *value, apr_time_t expiry) {\n\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\tint encrypted = oidc_cfg_cache_encrypt(r);\n\tchar *encoded = NULL;\n\tapr_byte_t rc = FALSE;\n\tchar *msg = NULL;\n\n\toidc_debug(r,\n\t\t\t\"STR\",\n\t\t\tkey, section, value ? (int )strlen(value) : 0, encrypted,\n\t\t\t\t\tapr_time_sec(expiry - apr_time_now()), cfg->cache->name);\n\n\t\n\tif (encrypted == 1) {\n\n\t\tkey = oidc_cache_get_hashed_key(r, cfg->crypto_passphrase, key);\n\t\tif (key == NULL)\n\t\t\tgoto out;\n\n\t\tif (value != NULL) {\n\t\t\tif (oidc_cache_crypto_encrypt(r, value,\n\t\t\t\t\toidc_cache_hash_passphrase(r, cfg->crypto_passphrase),\n\t\t\t\t\t&encoded) <= 0)\n\t\t\t\tgoto out;\n\t\t\tvalue = encoded;\n\t\t}\n\t}\n\n\t\n\trc = cfg->cache->set(r, section, key, value, expiry);\n\nout:\n\t\n\tmsg = apr_psprintf(r->pool, \"STR\",\n\t\t\t(value ? (int) strlen(value) : 0),\n\t\t\t(cfg->cache->name ? cfg->cache->name : \"\"),\n\t\t\t(encrypted ? \"STR\"));\n\tif (rc == TRUE)\n\t\toidc_debug(r, \"STR\", msg);\n\telse\n\t\toidc_warn(r, \"STR\", msg);\n\n\treturn rc;\n}","23573":"int sas_discover_sata(struct domain_device *dev)\n{\n\tint res;\n\n\tif (dev->dev_type == SAS_SATA_PM)\n\t\treturn -ENODEV;\n\n\tdev->sata_dev.class = sas_get_ata_command_set(dev);\n\tsas_fill_in_rphy(dev, dev->rphy);\n\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\n\tsas_discover_event(dev->port, DISCE_PROBE);\n\treturn 0;\n}","23719":"static void virtio_scsi_save(QEMUFile *f, void *opaque)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(opaque);\n    virtio_save(vdev, f);\n}","22842":"njs_generate_switch_case_end(njs_vm_t *vm, njs_generator_t *generator,\n    njs_parser_node_t *swtch)\n{\n    njs_int_t                   ret;\n    njs_parser_node_t           *branch;\n    njs_generator_switch_ctx_t  *ctx;\n\n    ctx = generator->context;\n\n    \n    ret = njs_generate_index_release(vm, generator, ctx->index);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    njs_generate_code_jump(generator, ctx->jump,\n                           offsetof(njs_vmcode_jump_t, offset));\n\n    ctx->jump_offset = njs_code_offset(generator, ctx->jump);\n\n    branch = swtch->right;\n\n    if (branch != NULL) {\n        njs_generator_next(generator, njs_generate_switch_default, branch);\n\n        return njs_generator_after(vm, generator,\n                                   njs_queue_first(&generator->stack), swtch,\n                                   njs_generate_switch_end, ctx, 0);\n    }\n\n    return njs_generate_switch_end(vm, generator, swtch);\n}","23656":"misdn_sock_init(u_int *deb)\n{\n\tint err;\n\n\tdebug = deb;\n\terr = sock_register(&mISDN_sock_family_ops);\n\tif (err)\n\t\tprintk(KERN_ERR \"STR\", __func__, err);\n\treturn err;\n}","22847":"static int cms_RecipientInfo_ktri_decrypt(CMS_ContentInfo *cms,\n                                          CMS_RecipientInfo *ri)\n{\n    CMS_KeyTransRecipientInfo *ktri = ri->d.ktri;\n    EVP_PKEY *pkey = ktri->pkey;\n    unsigned char *ek = NULL;\n    size_t eklen;\n    int ret = 0;\n    CMS_EncryptedContentInfo *ec;\n    ec = cms->d.envelopedData->encryptedContentInfo;\n\n    if (ktri->pkey == NULL) {\n        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_NO_PRIVATE_KEY);\n        return 0;\n    }\n\n    ktri->pctx = EVP_PKEY_CTX_new(pkey, NULL);\n    if (!ktri->pctx)\n        return 0;\n\n    if (EVP_PKEY_decrypt_init(ktri->pctx) <= 0)\n        goto err;\n\n    if (!cms_env_asn1_ctrl(ri, 1))\n        goto err;\n\n    if (EVP_PKEY_CTX_ctrl(ktri->pctx, -1, EVP_PKEY_OP_DECRYPT,\n                          EVP_PKEY_CTRL_CMS_DECRYPT, 0, ri) <= 0) {\n        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_CTRL_ERROR);\n        goto err;\n    }\n\n    if (EVP_PKEY_decrypt(ktri->pctx, NULL, &eklen,\n                         ktri->encryptedKey->data,\n                         ktri->encryptedKey->length) <= 0)\n        goto err;\n\n    ek = OPENSSL_malloc(eklen);\n\n    if (ek == NULL) {\n        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (EVP_PKEY_decrypt(ktri->pctx, ek, &eklen,\n                         ktri->encryptedKey->data,\n                         ktri->encryptedKey->length) <= 0) {\n        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_CMS_LIB);\n        goto err;\n    }\n\n    ret = 1;\n\n    if (ec->key) {\n        OPENSSL_cleanse(ec->key, ec->keylen);\n        OPENSSL_free(ec->key);\n    }\n\n    ec->key = ek;\n    ec->keylen = eklen;\n\n err:\n    if (ktri->pctx) {\n        EVP_PKEY_CTX_free(ktri->pctx);\n        ktri->pctx = NULL;\n    }\n    if (!ret && ek)\n        OPENSSL_free(ek);\n\n    return ret;\n}","22783":"static void *freelist_extract(SSL_CTX *ctx, int for_read, int sz)\n{\n    SSL3_BUF_FREELIST *list;\n    SSL3_BUF_FREELIST_ENTRY *ent = NULL;\n    void *result = NULL;\n\n    CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);\n    list = for_read ? ctx->rbuf_freelist : ctx->wbuf_freelist;\n    if (list != NULL && sz == (int)list->chunklen)\n        ent = list->head;\n    if (ent != NULL) {\n        list->head = ent->next;\n        result = ent;\n        if (--list->len == 0)\n            list->chunklen = 0;\n    }\n    CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);\n    if (!result)\n        result = OPENSSL_malloc(sz);\n    return result;\n}","22736":"void Magick::Image::colorMatrix(const size_t order_,\n  const double *color_matrix_)\n{\n  KernelInfo\n    *kernel_info;\n\n  GetPPException;\n  kernel_info=AcquireKernelInfo((const char *) NULL,exceptionInfo);\n  if (kernel_info != (KernelInfo *) NULL)\n    {\n      kernel_info->width=order_;\n      kernel_info->height=order_;\n      kernel_info->values=(MagickRealType *) AcquireAlignedMemory(order_,\n        order_*sizeof(*kernel_info->values));\n      if (kernel_info->values != (MagickRealType *) NULL)\n        {\n          MagickCore::Image\n            *newImage;\n\n          for (ssize_t i=0; i < (ssize_t) (order_*order_); i++)\n            kernel_info->values[i]=color_matrix_[i];\n          newImage=ColorMatrixImage(image(),kernel_info,exceptionInfo);\n          replaceImage(newImage);\n        }\n      kernel_info=DestroyKernelInfo(kernel_info);\n    }\n  ThrowImageException;\n}","23170":"create_read_object (LoadData        *load_data,\n\t\t    struct archive **a)\n{\n\t*a = archive_read_new ();\n\tarchive_read_support_filter_all (*a);\n\tarchive_read_support_format_all (*a);\n\n\tarchive_read_set_open_callback (*a, load_data_open);\n\tarchive_read_set_read_callback (*a, load_data_read);\n\tarchive_read_set_close_callback (*a, load_data_close);\n\tarchive_read_set_seek_callback (*a, load_data_seek);\n\tarchive_read_set_skip_callback (*a, load_data_skip);\n\tarchive_read_set_callback_data (*a, load_data);\n\n\treturn archive_read_open1 (*a);\n}","23425":"EncryptedPreMasterSecret::EncryptedPreMasterSecret()\n    : secret_(0), length_(0)\n{}","22636":"void ServerSecurityFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {\n  options->addOption(\"STR\",\n                     \"STR\"\n                     \"STR\",\n                     new BooleanParameter(&_hardenedRestApi))\n                     .setIntroducedIn(30500);\n\n  options->addOption(\"STR\",\n                     new BooleanParameter(&_enableFoxxApi),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n  options->addOption(\"STR\",\n                     new BooleanParameter(&_enableFoxxStore),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n\n}","23154":"alist_clear(alist_T *al)\n{\n    if (check_arglist_locked() == FAIL)\n\treturn;\n    while (--al->al_ga.ga_len >= 0)\n\tvim_free(AARGLIST(al)[al->al_ga.ga_len].ae_fname);\n    ga_clear(&al->al_ga);\n}","22718":"g_tls_connection_base_dtls_handshake_finish (GDtlsConnection  *conn,\n                                             GAsyncResult     *result,\n                                             GError          **error)\n{\n  return g_tls_connection_base_handshake_finish (G_TLS_CONNECTION (conn),\n                                                 result, error);\n}","22675":"GF_Err ctts_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tu32 sampleCount;\n\tGF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s;\n\n\tptr->nb_entries = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\n\tif (ptr->nb_entries > ptr->size \/ 8) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"STR\", ptr->nb_entries));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\tptr->alloc_size = ptr->nb_entries;\n\tptr->entries = (GF_DttsEntry *)gf_malloc(sizeof(GF_DttsEntry)*ptr->alloc_size);\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\tsampleCount = 0;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tptr->entries[i].sampleCount = gf_bs_read_u32(bs);\n\t\tif (ptr->version)\n\t\t\tptr->entries[i].decodingOffset = gf_bs_read_int(bs, 32);\n\t\telse\n\t\t\tptr->entries[i].decodingOffset = (s32) gf_bs_read_u32(bs);\n\t\tsampleCount += ptr->entries[i].sampleCount;\n\t}\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tptr->w_LastSampleNumber = sampleCount;\n#endif\n\treturn GF_OK;\n}","22789":"mswin_handle_fopen(gx_io_device * iodev, const char *fname, const char *access,\n                   gp_file ** pfile, char *rfname, uint rnamelen, gs_memory_t *mem)\n{\n    int fd;\n    long hfile;\t\n    gs_lib_ctx_t *ctx = mem->gs_lib_ctx;\n    gs_fs_list_t *fs = ctx->core->fs;\n\n    if (gp_validate_path(mem, fname, access) != 0)\n        return gs_error_invalidfileaccess;\n\n    \n    \n    *pfile = NULL;\n    for (fs = ctx->core->fs; fs != NULL && fs->next != NULL; fs = fs->next)\n    {\n        int code = 0;\n        if (fs->fs.open_handle)\n            code = fs->fs.open_handle(mem, fs->secret, fname, access, pfile);\n        if (code < 0)\n            return code;\n        if (*pfile != NULL)\n            return code;\n    }\n\n    \n    errno = 0;\n    *pfile = gp_file_FILE_alloc(mem);\n    if (*pfile == NULL) {\n        return gs_error_VMerror;\n    }\n\n    if ((hfile = get_os_handle(fname)) == (long)INVALID_HANDLE_VALUE) {\n        gp_file_dealloc(*pfile);\n        return_error(gs_fopen_errno_to_code(EBADF));\n    }\n\n    \n    fd = _open_osfhandle((long)hfile, 0);\n    if (fd == -1) {\n        gp_file_dealloc(*pfile);\n        return_error(gs_fopen_errno_to_code(EBADF));\n    }\n\n    \n    if (gp_file_FILE_set(*pfile, fdopen(fd, (char *)access), NULL)) {\n        *pfile = NULL;\n        return_error(gs_fopen_errno_to_code(errno));\n    }\n\n    if (rfname != NULL)\n        strcpy(rfname, fname);\n\n    return 0;\n}","23493":"STACK_OF(SSL_CIPHER) *ssl_bytes_to_cipher_list(SSL *s,unsigned char *p,int num,\n\t\t\t\t\t       STACK_OF(SSL_CIPHER) **skp)\n\t{\n\tconst SSL_CIPHER *c;\n\tSTACK_OF(SSL_CIPHER) *sk;\n\tint i,n;\n\tif (s->s3)\n\t\ts->s3->send_connection_binding = 0;\n\n\tn=ssl_put_cipher_by_char(s,NULL,NULL);\n\tif ((num%n) != 0)\n\t\t{\n\t\tSSLerr(SSL_F_SSL_BYTES_TO_CIPHER_LIST,SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST);\n\t\treturn(NULL);\n\t\t}\n\tif ((skp == NULL) || (*skp == NULL))\n\t\tsk=sk_SSL_CIPHER_new_null(); \n\telse\n\t\t{\n\t\tsk= *skp;\n\t\tsk_SSL_CIPHER_zero(sk);\n\t\t}\n\n\tfor (i=0; i<num; i+=n)\n\t\t{\n\t\t\n\t\tif (s->s3 && (n != 3 || !p[0]) &&\n\t\t\t(p[n-2] == ((SSL3_CK_SCSV >> 8) & 0xff)) &&\n\t\t\t(p[n-1] == (SSL3_CK_SCSV & 0xff)))\n\t\t\t{\n\t\t\t\n\t\t\tif (s->renegotiate)\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL_BYTES_TO_CIPHER_LIST,SSL_R_SCSV_RECEIVED_WHEN_RENEGOTIATING);\n\t\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,SSL_AD_HANDSHAKE_FAILURE); \n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\ts->s3->send_connection_binding = 1;\n\t\t\tp += n;\n#ifdef OPENSSL_RI_DEBUG\n\t\t\tfprintf(stderr, \"STR\");\n#endif\n\t\t\tcontinue;\n\t\t\t}\n\n\t\tc=ssl_get_cipher_by_char(s,p);\n\t\tp+=n;\n\t\tif (c != NULL)\n\t\t\t{\n\t\t\tif (!sk_SSL_CIPHER_push(sk,c))\n\t\t\t\t{\n\t\t\t\tSSLerr(SSL_F_SSL_BYTES_TO_CIPHER_LIST,ERR_R_MALLOC_FAILURE);\n\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tif (skp != NULL)\n\t\t*skp=sk;\n\treturn(sk);\nerr:\n\tif ((skp == NULL) || (*skp == NULL))\n\t\tsk_SSL_CIPHER_free(sk);\n\treturn(NULL);\n\t}","23578":"TEST_P(Security, BuiltinAuthenticationAndAccessAndCryptoPlugin_PermissionsEnableDiscoveryEnableAccessNone_validation_ok_enable_discovery_enable_access_encrypt)\n\n{\n    PubSubReader<HelloWorldType> reader(TEST_TOPIC_NAME);\n    PubSubWriter<HelloWorldType> writer(TEST_TOPIC_NAME);\n    std::string governance_file(\"STR\");\n\n    BuiltinAuthenticationAndAccessAndCryptoPlugin_Permissions_validation_ok_common(reader, writer, governance_file);\n}","23616":"static ssize_t _hostsock_readv(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n\n    if (!sock || (!iov && iovcnt) || iovcnt < 0 || iovcnt > OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    \n    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    \n    if (oe_syscall_recvv_ocall(&ret, sock->host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    \n    if (ret > 0)\n    {\n        if (oe_iov_sync(iov, iovcnt, buf, buf_size) != 0)\n            OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}","22767":"static void __nfs4_close(struct path *path, struct nfs4_state *state, mode_t mode, int wait)\n{\n\tstruct nfs4_state_owner *owner = state->owner;\n\tint call_close = 0;\n\tint newstate;\n\n\tatomic_inc(&owner->so_count);\n\t\n\tspin_lock(&owner->so_lock);\n\tswitch (mode & (FMODE_READ | FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly--;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly--;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr--;\n\t}\n\tnewstate = FMODE_READ|FMODE_WRITE;\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tnewstate &= ~FMODE_READ;\n\t\t\tcall_close |= test_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tnewstate &= ~FMODE_WRITE;\n\t\t\tcall_close |= test_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (newstate == 0)\n\t\t\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tnfs4_state_set_mode_locked(state, newstate);\n\tspin_unlock(&owner->so_lock);\n\n\tif (!call_close) {\n\t\tnfs4_put_open_state(state);\n\t\tnfs4_put_state_owner(owner);\n\t} else\n\t\tnfs4_do_close(path, state, wait);\n}","23234":"static int cbs_av1_read_ns(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                           uint32_t n, const char *name,\n                           const int *subscripts, uint32_t *write_to)\n{\n    uint32_t w, m, v, extra_bit, value;\n    int position;\n\n    av_assert0(n > 0);\n\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    w = av_log2(n) + 1;\n    m = (1 << w) - n;\n\n    if (get_bits_left(gbc) < w) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"STR\"\n               \"STR\", name);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (w - 1 > 0)\n        v = get_bits(gbc, w - 1);\n    else\n        v = 0;\n\n    if (v < m) {\n        value = v;\n    } else {\n        extra_bit = get_bits1(gbc);\n        value = (v << 1) - m + extra_bit;\n    }\n\n    if (ctx->trace_enable) {\n        char bits[33];\n        int i;\n        for (i = 0; i < w - 1; i++)\n            bits[i] = (v >> i & 1) ? '1' : '0';\n        if (v >= m)\n            bits[i++] = extra_bit ? '1' : '0';\n        bits[i] = 0;\n\n        ff_cbs_trace_syntax_element(ctx, position,\n                                    name, subscripts, bits, value);\n    }\n\n    *write_to = value;\n    return 0;\n}","23310":"static int intf_next_seq(struct ipmi_smi      *intf,\n\t\t\t struct ipmi_recv_msg *recv_msg,\n\t\t\t unsigned long        timeout,\n\t\t\t int                  retries,\n\t\t\t int                  broadcast,\n\t\t\t unsigned char        *seq,\n\t\t\t long                 *seqid)\n{\n\tint          rv = 0;\n\tunsigned int i;\n\n\tif (timeout == 0)\n\t\ttimeout = default_retry_ms;\n\tif (retries < 0)\n\t\tretries = default_max_retries;\n\n\tfor (i = intf->curr_seq; (i+1)%IPMI_IPMB_NUM_SEQ != intf->curr_seq;\n\t\t\t\t\ti = (i+1)%IPMI_IPMB_NUM_SEQ) {\n\t\tif (!intf->seq_table[i].inuse)\n\t\t\tbreak;\n\t}\n\n\tif (!intf->seq_table[i].inuse) {\n\t\tintf->seq_table[i].recv_msg = recv_msg;\n\n\t\t\n\t\tintf->seq_table[i].timeout = MAX_MSG_TIMEOUT;\n\t\tintf->seq_table[i].orig_timeout = timeout;\n\t\tintf->seq_table[i].retries_left = retries;\n\t\tintf->seq_table[i].broadcast = broadcast;\n\t\tintf->seq_table[i].inuse = 1;\n\t\tintf->seq_table[i].seqid = NEXT_SEQID(intf->seq_table[i].seqid);\n\t\t*seq = i;\n\t\t*seqid = intf->seq_table[i].seqid;\n\t\tintf->curr_seq = (i+1)%IPMI_IPMB_NUM_SEQ;\n\t\tneed_waiter(intf);\n\t} else {\n\t\trv = -EAGAIN;\n\t}\n\n\treturn rv;\n}","22647":"static void sdhci_send_command(SDHCIState *s)\n{\n    SDRequest request;\n    uint8_t response[16];\n    int rlen;\n\n    s->errintsts = 0;\n    s->acmd12errsts = 0;\n    request.cmd = s->cmdreg >> 8;\n    request.arg = s->argument;\n\n    trace_sdhci_send_command(request.cmd, request.arg);\n    rlen = sdbus_do_command(&s->sdbus, &request, response);\n\n    if (s->cmdreg & SDHC_CMD_RESPONSE) {\n        if (rlen == 4) {\n            s->rspreg[0] = ldl_be_p(response);\n            s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0;\n            trace_sdhci_response4(s->rspreg[0]);\n        } else if (rlen == 16) {\n            s->rspreg[0] = ldl_be_p(&response[11]);\n            s->rspreg[1] = ldl_be_p(&response[7]);\n            s->rspreg[2] = ldl_be_p(&response[3]);\n            s->rspreg[3] = (response[0] << 16) | (response[1] << 8) |\n                            response[2];\n            trace_sdhci_response16(s->rspreg[3], s->rspreg[2],\n                                   s->rspreg[1], s->rspreg[0]);\n        } else {\n            trace_sdhci_error(\"STR\");\n            if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) {\n                s->errintsts |= SDHC_EIS_CMDTIMEOUT;\n                s->norintsts |= SDHC_NIS_ERR;\n            }\n        }\n\n        if (!(s->quirks & SDHCI_QUIRK_NO_BUSY_IRQ) &&\n            (s->norintstsen & SDHC_NISEN_TRSCMP) &&\n            (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {\n            s->norintsts |= SDHC_NIS_TRSCMP;\n        }\n    }\n\n    if (s->norintstsen & SDHC_NISEN_CMDCMP) {\n        s->norintsts |= SDHC_NIS_CMDCMP;\n    }\n\n    sdhci_update_irq(s);\n\n    if (s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) {\n        s->data_count = 0;\n        sdhci_data_transfer(s);\n    }\n}","23786":"static apr_status_t buffer_output(request_rec *r,\n                                  const char *str, apr_size_t len)\n{\n    conn_rec *c = r->connection;\n    ap_filter_t *f;\n    old_write_filter_ctx *ctx;\n\n    if (len == 0)\n        return APR_SUCCESS;\n\n    f = insert_old_write_filter(r);\n    ctx = f->ctx;\n\n    \n    if (f != r->output_filters) {\n        apr_status_t rv;\n        apr_bucket *b = apr_bucket_transient_create(str, len, c->bucket_alloc);\n        APR_BRIGADE_INSERT_TAIL(ctx->tmpbb, b);\n\n        rv = ap_pass_brigade(r->output_filters, ctx->tmpbb);\n        apr_brigade_cleanup(ctx->tmpbb);\n        return rv;\n    }\n\n    if (ctx->bb == NULL) {\n        ctx->bb = apr_brigade_create(r->pool, c->bucket_alloc);\n    }\n\n    return ap_fwrite(f->next, ctx->bb, str, len);\n}","23736":"void buffer_free(Buffer *buffer)\n{\n    g_free(buffer->buffer);\n    buffer->offset = 0;\n    buffer->capacity = 0;\n    buffer->buffer = NULL;\n}","23420":"int ext4_dio_get_block(struct inode *inode, sector_t iblock,\n\t\t       struct buffer_head *bh, int create)\n{\n\t\n\tWARN_ON_ONCE(ext4_journal_current_handle());\n\n\tif (!create)\n\t\treturn _ext4_get_block(inode, iblock, bh, 0);\n\treturn ext4_get_block_trans(inode, iblock, bh, EXT4_GET_BLOCKS_CREATE);\n}","22818":"_TIFFSwab32BitData(TIFF* tif, uint8* buf, tmsize_t cc)\n{\n    (void) tif;\n    assert((cc & 3) == 0);\n    TIFFSwabArrayOfLong((uint32*) buf, cc\/4);\n}","23368":"void set_ndpi_malloc(void *(*__ndpi_malloc)(size_t size)) {\n  _ndpi_malloc = __ndpi_malloc;\n}","23770":"snmpCreateOid(int length,...)\n{\n    va_list args;\n    oid *new_oid;\n    int loop;\n    va_start(args, length);\n\n    new_oid = (oid *)xmalloc(sizeof(oid) * length);\n\n    if (length > 0) {\n        for (loop = 0; loop < length; ++loop) {\n            new_oid[loop] = va_arg(args, int);\n        }\n    }\n\n    va_end(args);\n    return (new_oid);\n}","23299":"char *theme_format_expand_get(THEME_REC *theme, const char **format)\n{\n\tGString *str;\n\tchar *ret, dummy;\n\tint braces = 1; \n\n\tstr = g_string_new(NULL);\n\twhile (**format != '\\0' && braces != 0) {\n\t\tif (**format == '{')\n\t\t\tbraces++;\n\t\telse if (**format == '}')\n\t\t\tbraces--;\n\t\telse {\n\t\t\ttheme_format_append_next(theme, str, format,\n\t\t\t\t\t\t 'n', 'n',\n\t\t\t\t\t\t &dummy, &dummy, 0);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (braces == 0) {\n\t\t\t(*format)++;\n\t\t\tbreak;\n\t\t}\n\n\t\tg_string_append_c(str, **format);\n\t\t(*format)++;\n\t}\n\n\tret = str->str;\n        g_string_free(str, FALSE);\n        return ret;\n}","23636":"url_to_charset(const char *url, const ParsedURL *base, wc_ces doc_charset)\n{\n    const ParsedURL *pu;\n    ParsedURL pu_buf;\n    const wc_ces *csptr;\n\n    if (url && *url && *url != '#') {\n\tparseURL2((char *)url, &pu_buf, (ParsedURL *)base);\n\tpu = &pu_buf;\n    } else {\n\tpu = base;\n    }\n    if (pu && (pu->scheme == SCM_LOCAL || pu->scheme == SCM_LOCAL_CGI))\n\treturn SystemCharset;\n    csptr = query_SCONF_URL_CHARSET(pu);\n    return (csptr && *csptr) ? *csptr :\n\tdoc_charset ? doc_charset : DocumentCharset;\n}","22594":"static int rds_iw_laddr_check(__be32 addr)\n{\n\tint ret;\n\tstruct rdma_cm_id *cm_id;\n\tstruct sockaddr_in sin;\n\n\t\n\tcm_id = rdma_create_id(NULL, NULL, RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(cm_id))\n\t\treturn PTR_ERR(cm_id);\n\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n\tsin.sin_addr.s_addr = addr;\n\n\t\n\tret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);\n\t\n\tif (ret || cm_id->device->node_type != RDMA_NODE_RNIC)\n\t\tret = -EADDRNOTAVAIL;\n\n\trdsdebug(\"STR\",\n\t\t&addr, ret,\n\t\tcm_id->device ? cm_id->device->node_type : -1);\n\n\trdma_destroy_id(cm_id);\n\n\treturn ret;\n}","22885":"inline static Int32 indexIntoF ( Int32 indx, Int32 *cftab )\n{\n   Int32 nb, na, mid;\n   nb = 0;\n   na = 256;\n   do {\n      mid = (nb + na) >> 1;\n      if (indx >= cftab[mid]) nb = mid; else na = mid;\n   }\n   while (na - nb != 1);\n   return nb;\n}","23501":"TfLiteRegistration* Register_SLICE_REF() {\n  static TfLiteRegistration r = {nullptr, nullptr, slice::Prepare,\n                                 slice::Eval<slice::kReference>};\n  return &r;\n}","23336":"static void xudc_set_clear_feature(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0\t= &udc->ep[0];\n\tstruct xusb_req *req\t= udc->req;\n\tstruct xusb_ep *target_ep;\n\tu8 endpoint;\n\tu8 outinbit;\n\tu32 epcfgreg;\n\tint flag = (udc->setup.bRequest == USB_REQ_SET_FEATURE ? 1 : 0);\n\tint ret;\n\n\tswitch (udc->setup.bRequestType) {\n\tcase USB_RECIP_DEVICE:\n\t\tswitch (udc->setup.wValue) {\n\t\tcase USB_DEVICE_TEST_MODE:\n\t\t\t\n\t\t\tbreak;\n\t\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\t\tif (flag)\n\t\t\t\tudc->remote_wkp = 1;\n\t\t\telse\n\t\t\t\tudc->remote_wkp = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txudc_ep0_stall(udc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tif (!udc->setup.wValue) {\n\t\t\tendpoint = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\t\tif (endpoint >= XUSB_MAX_ENDPOINTS) {\n\t\t\t\txudc_ep0_stall(udc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttarget_ep = &udc->ep[endpoint];\n\t\t\toutinbit = udc->setup.wIndex & USB_ENDPOINT_DIR_MASK;\n\t\t\toutinbit = outinbit >> 7;\n\n\t\t\t\n\t\t\tif (outinbit != target_ep->is_in) {\n\t\t\t\txudc_ep0_stall(udc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tepcfgreg = udc->read_fn(udc->addr + target_ep->offset);\n\t\t\tif (!endpoint) {\n\t\t\t\t\n\t\t\t\tepcfgreg &= ~XUSB_EP_CFG_STALL_MASK;\n\t\t\t\tudc->write_fn(udc->addr,\n\t\t\t\t\t      target_ep->offset, epcfgreg);\n\t\t\t} else {\n\t\t\t\tif (flag) {\n\t\t\t\t\tepcfgreg |= XUSB_EP_CFG_STALL_MASK;\n\t\t\t\t\tudc->write_fn(udc->addr,\n\t\t\t\t\t\t      target_ep->offset,\n\t\t\t\t\t\t      epcfgreg);\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tepcfgreg &= ~(XUSB_EP_CFG_STALL_MASK |\n\t\t\t\t\t\tXUSB_EP_CFG_DATA_TOGGLE_MASK);\n\t\t\t\t\tudc->write_fn(udc->addr,\n\t\t\t\t\t\t      target_ep->offset,\n\t\t\t\t\t\t      epcfgreg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\txudc_ep0_stall(udc);\n\t\treturn;\n\t}\n\n\treq->usb_req.length = 0;\n\tret = __xudc_ep0_queue(ep0, req);\n\tif (ret == 0)\n\t\treturn;\n\n\tdev_err(udc->dev, \"STR\");\n\txudc_ep0_stall(udc);\n}","23537":"setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType)\n{\n  DTD * const dtd = parser->m_dtd;  \n  const XML_Char *name;\n  for (name = elementType->name; *name; name++) {\n    if (*name == XML_T(ASCII_COLON)) {\n      PREFIX *prefix;\n      const XML_Char *s;\n      for (s = elementType->name; s != name; s++) {\n        if (!poolAppendChar(&dtd->pool, *s))\n          return 0;\n      }\n      if (!poolAppendChar(&dtd->pool, XML_T('\\0')))\n        return 0;\n      prefix = (PREFIX *)lookup(parser, &dtd->prefixes, poolStart(&dtd->pool),\n                                sizeof(PREFIX));\n      if (!prefix)\n        return 0;\n      if (prefix->name == poolStart(&dtd->pool))\n        poolFinish(&dtd->pool);\n      else\n        poolDiscard(&dtd->pool);\n      elementType->prefix = prefix;\n\n    }\n  }\n  return 1;\n}","22719":"void sort_extable(struct exception_table_entry *start,\n\t\t  struct exception_table_entry *finish)\n{\n\tstruct exception_table_entry *p;\n\tint i;\n\n\t\n\ti = 0;\n\tfor (p = start; p < finish; p++) {\n\t\tp->insn += i;\n\t\ti += 4;\n\t\tp->fixup += i;\n\t\ti += 4;\n\t}\n\n\tsort(start, finish - start, sizeof(struct exception_table_entry),\n\t     cmp_ex, NULL);\n\n\t\n\ti = 0;\n\tfor (p = start; p < finish; p++) {\n\t\tp->insn -= i;\n\t\ti += 4;\n\t\tp->fixup -= i;\n\t\ti += 4;\n\t}\n}","22699":"int read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\n\tunsigned char header[18];\n\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"STR\");\n\t\treturn -1;\n\t}\n\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"STR\", tga->bits);\n\tprintf(\"STR\", tga->fliph, tga->flipv);\n\tprintf(\"STR\", tga->alphabits);\n\tprintf(\"STR\", tga->width, tga->height);\n#endif\n\n\tif (!((tga->bits == TGA_BPP_24 && tga->alphabits == 0)\n\t\t|| (tga->bits == TGA_BPP_32 && tga->alphabits == 8)))\n\t{\n\t\tgd_error_ex(GD_WARNING, \"STR\",\n\t\t\ttga->bits, tga->alphabits);\n\t\treturn -1;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\n\treturn 1;\n}","23257":"unpack_vcol_info_from_frm(THD *thd, MEM_ROOT *mem_root, TABLE *table,\n                          String *expr_str, Virtual_column_info **vcol_ptr,\n                          bool *error_reported)\n{\n  Create_field vcol_storage; \n  Parser_state parser_state;\n  Virtual_column_info *vcol= *vcol_ptr, *vcol_info= 0;\n  LEX *old_lex= thd->lex;\n  LEX lex;\n  bool error;\n  DBUG_ENTER(\"STR\");\n\n  DBUG_ASSERT(vcol->expr == NULL);\n  \n  if (parser_state.init(thd, expr_str->c_ptr_safe(), expr_str->length()))\n    goto end;\n\n  if (init_lex_with_single_table(thd, table, &lex))\n    goto end;\n\n  lex.parse_vcol_expr= true;\n  lex.last_field= &vcol_storage;\n\n  error= parse_sql(thd, &parser_state, NULL);\n  if (unlikely(error))\n    goto end;\n\n  if (lex.current_select->table_list.first[0].next_global)\n  {\n    \n    TABLE_LIST *sequence= lex.current_select->table_list.first[0].next_global;\n    sequence->next_global= table->internal_tables;\n    table->internal_tables= sequence;\n  }\n\n  vcol_storage.vcol_info->set_vcol_type(vcol->get_vcol_type());\n  vcol_storage.vcol_info->stored_in_db=      vcol->stored_in_db;\n  vcol_storage.vcol_info->name=              vcol->name;\n  vcol_storage.vcol_info->utf8=              vcol->utf8;\n  if (!fix_and_check_vcol_expr(thd, table, vcol_storage.vcol_info))\n  {\n    *vcol_ptr= vcol_info= vcol_storage.vcol_info;   \n    DBUG_ASSERT(vcol_info->expr);\n    goto end;\n  }\n  *error_reported= TRUE;\n\nend:\n  end_lex_with_single_table(thd, table, old_lex);\n\n  DBUG_RETURN(vcol_info);\n}","23158":"ly_register_exts(struct lyext_plugin_list *plugin, const char *log_name)\n{\n    FUN_IN;\n\n    struct lyext_plugin_list *p;\n    struct lyext_plugin_complex *pluginc;\n    uint32_t u, v;\n\n    for (u = 0; plugin[u].name; u++) {\n        \n        for (v = 0; v < ext_plugins_count; v++) {\n            if (!strcmp(plugin[u].name, ext_plugins[v].name) &&\n                    !strcmp(plugin[u].module, ext_plugins[v].module) &&\n                    (!plugin[u].revision || !ext_plugins[v].revision || !strcmp(plugin[u].revision, ext_plugins[v].revision))) {\n                LOGERR(NULL, LY_ESYS, \"STR\"\n                        \"STR\",\n                        log_name, plugin[u].name, plugin[u].module, plugin[u].revision ? \"STR\",\n                        plugin[u].revision ? plugin[u].revision : \"\");\n                return 1;\n            }\n        }\n\n        \n        if (plugin[u].plugin->type == LYEXT_COMPLEX && ((struct lyext_plugin_complex *)plugin[u].plugin)->substmt) {\n            pluginc = (struct lyext_plugin_complex *)plugin[u].plugin;\n            for (v = 0; pluginc->substmt[v].stmt; v++) {\n                if (pluginc->substmt[v].stmt >= LY_STMT_SUBMODULE ||\n                        pluginc->substmt[v].stmt == LY_STMT_VERSION ||\n                        pluginc->substmt[v].stmt == LY_STMT_YINELEM) {\n                    LOGERR(NULL, LY_EINVAL,\n                            \"STR\",\n                            log_name, plugin[u].name, ly_stmt_str[pluginc->substmt[v].stmt]);\n                    return 1;\n                }\n                if (pluginc->substmt[v].cardinality > LY_STMT_CARD_MAND &&\n                        pluginc->substmt[v].stmt >= LY_STMT_MODIFIER &&\n                        pluginc->substmt[v].stmt <= LY_STMT_STATUS) {\n                    LOGERR(NULL, LY_EINVAL, \"STR\"\n                           \"STR\",\n                           log_name, plugin[u].name, ly_stmt_str[pluginc->substmt[v].stmt]);\n                    return 1;\n                }\n            }\n        }\n    }\n\n    \n    p = realloc(ext_plugins, (ext_plugins_count + u) * sizeof *ext_plugins);\n    if (!p) {\n        LOGMEM(NULL);\n        return -1;\n    }\n    ext_plugins = p;\n    for (; u; u--) {\n        memcpy(&ext_plugins[ext_plugins_count], &plugin[u - 1], sizeof *plugin);\n        ext_plugins_count++;\n    }\n\n    return 0;\n}","22639":"void arch_pick_mmap_layout(struct mm_struct *mm)\n{\n\tunsigned long random_factor = 0UL;\n\tunsigned long gap;\n\n\tif (current->flags & PF_RANDOMIZE) {\n\t\trandom_factor = get_random_int();\n\t\tif (test_thread_flag(TIF_32BIT))\n\t\t\trandom_factor &= ((1 * 1024 * 1024) - 1);\n\t\telse\n\t\t\trandom_factor = ((random_factor << PAGE_SHIFT) &\n\t\t\t\t\t 0xffffffffUL);\n\t}\n\n\t\n\tgap = rlimit(RLIMIT_STACK);\n\tif (!test_thread_flag(TIF_32BIT) ||\n\t    (current->personality & ADDR_COMPAT_LAYOUT) ||\n\t    gap == RLIM_INFINITY ||\n\t    sysctl_legacy_va_layout) {\n\t\tmm->mmap_base = TASK_UNMAPPED_BASE + random_factor;\n\t\tmm->get_unmapped_area = arch_get_unmapped_area;\n\t\tmm->unmap_area = arch_unmap_area;\n\t} else {\n\t\t\n\t\tunsigned long task_size = STACK_TOP32;\n\n\t\tif (gap < 128 * 1024 * 1024)\n\t\t\tgap = 128 * 1024 * 1024;\n\t\tif (gap > (task_size \/ 6 * 5))\n\t\t\tgap = (task_size \/ 6 * 5);\n\n\t\tmm->mmap_base = PAGE_ALIGN(task_size - gap - random_factor);\n\t\tmm->get_unmapped_area = arch_get_unmapped_area_topdown;\n\t\tmm->unmap_area = arch_unmap_area_topdown;\n\t}\n}","23813":"static int pipe_to_sendpage(struct pipe_inode_info *pipe,\n\t\t\t    struct pipe_buffer *buf, struct splice_desc *sd)\n{\n\tstruct file *file = sd->file;\n\tloff_t pos = sd->pos;\n\tint ret, more;\n\n\tret = buf->ops->pin(pipe, buf);\n\tif (!ret) {\n\t\tmore = (sd->flags & SPLICE_F_MORE) || sd->len < sd->total_len;\n\n\t\tret = file->f_op->sendpage(file, buf->page, buf->offset,\n\t\t\t\t\t   sd->len, &pos, more);\n\t}\n\n\treturn ret;\n}","23296":"CollectionOptions _makeCollectionOptionsWithUuid() {\n    CollectionOptions options;\n    options.uuid = UUID::gen();\n    return options;\n}","23711":"std::string GetTempFileName() {\n#if !defined _MSC_VER && !defined __MINGW32__\n  std::string temp_file_name_template_str =\n      std::string(std::getenv(\"STR\") :\n                                               \"STR\") +\n      \"STR\";\n  char* temp_file_name_template =\n      new char[temp_file_name_template_str.length() + 1];\n  memset(temp_file_name_template, 0, temp_file_name_template_str.length() + 1);\n  temp_file_name_template_str.copy(temp_file_name_template,\n                                   temp_file_name_template_str.length(), 0);\n  int fd = mkstemp(temp_file_name_template);\n  std::string temp_file_name =\n      (fd != -1) ? std::string(temp_file_name_template) : std::string();\n  delete[] temp_file_name_template;\n  if (fd != -1) {\n    close(fd);\n  }\n  return temp_file_name;\n#else\n  char tmp_file_name[_MAX_PATH];\n#if defined _MSC_VER || defined MINGW_HAS_SECURE_API\n  errno_t err = tmpnam_s(tmp_file_name);\n#else\n  char* fname_pointer = tmpnam(tmp_file_name);\n  errno_t err = (fname_pointer == &tmp_file_name[0]) ? 0 : -1;\n#endif\n  if (err == 0) {\n    return std::string(tmp_file_name);\n  }\n  return std::string();\n#endif\n}","23407":"static inline unsigned int ScaleQuantumToLong(const Quantum quantum)\n{\n  return((unsigned int) (quantum\/4294967297.0+0.5));\n}","22890":"static int hash_df(DRBG_CTX *dctx, unsigned char *out,\n\t\t\tconst unsigned char *in1, size_t in1len,\n\t\t\tconst unsigned char *in2, size_t in2len,\n\t\t\tconst unsigned char *in3, size_t in3len)\n\t{\n\tDRBG_EC_CTX *ectx = &dctx->d.ec;\n\tEVP_MD_CTX *mctx = &ectx->mctx;\n\tunsigned char *vtmp = ectx->vtmp;\n\tunsigned char tmp[6];\n\tsize_t mdlen = M_EVP_MD_size(ectx->md);\n\t\n\tsize_t outlen = dctx->seedlen;\n\tsize_t nbits = (outlen << 3) - ectx->exbits;\n\ttmp[0] = 1;\n\ttmp[1] = (nbits >> 24) & 0xff;\n\ttmp[2] = (nbits >> 16) & 0xff;\n\ttmp[3] = (nbits >> 8) & 0xff;\n\ttmp[4] = nbits & 0xff;\n\tif (!in1)\n\t\t{\n\t\ttmp[5] = (unsigned char)in1len;\n\t\tin1 = tmp + 5;\n\t\tin1len = 1;\n\t\t}\n\tfor (;;)\n\t\t{\n\t\tif (!FIPS_digestinit(mctx, ectx->md))\n\t\t\treturn 0;\n\t\tif (!FIPS_digestupdate(mctx, tmp, 5))\n\t\t\treturn 0;\n\t\tif (in1 && !FIPS_digestupdate(mctx, in1, in1len))\n\t\t\treturn 0;\n\t\tif (in2 && !FIPS_digestupdate(mctx, in2, in2len))\n\t\t\treturn 0;\n\t\tif (in3 && !FIPS_digestupdate(mctx, in3, in3len))\n\t\t\treturn 0;\n\t\tif (outlen < mdlen)\n\t\t\t{\n\t\t\tif (!FIPS_digestfinal(mctx, vtmp, NULL))\n\t\t\t\treturn 0;\n\t\t\tmemcpy(out, vtmp, outlen);\n\t\t\tOPENSSL_cleanse(vtmp, mdlen);\n\t\t\treturn 1;\n\t\t\t}\n\t\telse if(!FIPS_digestfinal(mctx, out, NULL))\n\t\t\treturn 0;\n\n\t\toutlen -= mdlen;\n\t\tif (outlen == 0)\n\t\t\treturn 1;\n\t\ttmp[0]++;\n\t\tout += mdlen;\n\t\t}\n\t}","23364":"static const char *escape_identifier(const char *identifier)\n{\n\tsize_t pos = strcspn(identifier, \"STR\");\n\tif (pos < strlen(identifier)) {\n\t\t\n\t\tstring_t *new_id = t_str_new(strlen(identifier));\n\t\t\n\t\tstr_append_data(new_id, identifier, pos);\n\n\t\tfor (const char *c = identifier+pos; *c != '\\0'; c++) {\n\t\t\tswitch (*c) {\n\t\t\tcase '.':\n\t\t\t\tstr_append(new_id, \"STR\");\n\t\t\t\tbreak;\n\t\t\tcase '\/':\n\t\t\t\tstr_append(new_id, \"STR\");\n\t\t\t\tbreak;\n\t\t\tcase '%':\n\t\t\t\tstr_append(new_id, \"STR\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstr_append_c(new_id, *c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn str_c(new_id);\n\t}\n\treturn identifier;\n}","23208":"bool st_select_lex::add_window_spec(THD *thd, \n                                    LEX_STRING *win_ref,\n                                    SQL_I_List<ORDER> win_partition_list,\n                                    SQL_I_List<ORDER> win_order_list,\n                                    Window_frame *win_frame)\n{\n  SQL_I_List<ORDER> *win_part_list_ptr=\n    new (thd->mem_root) SQL_I_List<ORDER> (win_partition_list);\n  SQL_I_List<ORDER> *win_order_list_ptr=\n    new (thd->mem_root) SQL_I_List<ORDER> (win_order_list);\n  if (!(win_part_list_ptr && win_order_list_ptr))\n    return true;\n  Window_spec *win_spec= new (thd->mem_root) Window_spec(win_ref,\n                                                         win_part_list_ptr,\n                                                         win_order_list_ptr,\n                                                         win_frame);\n  group_list= thd->lex->save_group_list;\n  order_list= thd->lex->save_order_list;\n  if (parsing_place != SELECT_LIST)\n  {\n    fields_in_window_functions+= win_part_list_ptr->elements +\n                                 win_order_list_ptr->elements;\n  }\n  thd->lex->win_spec= win_spec;\n  return (win_spec == NULL || window_specs.push_back(win_spec));\n}","22951":"DEFUN(closeT, CLOSE_TAB, \"STR\")\n{\n    TabBuffer *tab;\n\n    if (nTab <= 1)\n\treturn;\n    if (prec_num)\n\ttab = numTab(PREC_NUM);\n    else\n\ttab = CurrentTab;\n    if (tab)\n\tdeleteTab(tab);\n    displayBuffer(Currentbuf, B_REDRAW_IMAGE);\n}","23015":"void Utf8DecoderBase::WriteUtf16Slow(const uint8_t* stream,\n                                     uint16_t* data,\n                                     unsigned data_length) {\n  while (data_length != 0) {\n    unsigned cursor = 0;\n    uint32_t character = Utf8::ValueOf(stream, Utf8::kMaxEncodedSize, &cursor);\n    \n    \n    stream += cursor;\n    if (character > unibrow::Utf16::kMaxNonSurrogateCharCode) {\n      *data++ = Utf16::LeadSurrogate(character);\n      *data++ = Utf16::TrailSurrogate(character);\n      DCHECK(data_length > 1);\n      data_length -= 2;\n    } else {\n      *data++ = character;\n      data_length -= 1;\n    }\n  }\n}","22664":"mbfl_strwidth(mbfl_string *string)\n{\n\tint len, n;\n\tunsigned char *p;\n\tmbfl_convert_filter *filter;\n\n\tlen = 0;\n\tif (string->len > 0 && string->val != NULL) {\n\t\t\n\t\tfilter = mbfl_convert_filter_new(\n\t\t    string->no_encoding,\n\t\t    mbfl_no_encoding_wchar,\n\t\t    filter_count_width, 0, &len);\n\t\tif (filter == NULL) {\n\t\t\tmbfl_convert_filter_delete(filter);\n\t\t\treturn -1;\n\t\t}\n\n\t\t\n\t\tp = string->val;\n\t\tn = string->len;\n\t\twhile (n > 0) {\n\t\t\t(*filter->filter_function)(*p++, filter);\n\t\t\tn--;\n\t\t}\n\n\t\tmbfl_convert_filter_flush(filter);\n\t\tmbfl_convert_filter_delete(filter);\n\t}\n\n\treturn len;\n}","23201":"transformTableConstraint(CreateStmtContext *cxt, Constraint *constraint)\n{\n\tswitch (constraint->contype)\n\t{\n\t\tcase CONSTR_PRIMARY:\n\t\t\tif (cxt->isforeign)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"STR\"),\n\t\t\t\t\t\t parser_errposition(cxt->pstate,\n\t\t\t\t\t\t\t\t\t\t\tconstraint->location)));\n\t\t\tcxt->ixconstraints = lappend(cxt->ixconstraints, constraint);\n\t\t\tbreak;\n\n\t\tcase CONSTR_UNIQUE:\n\t\t\tif (cxt->isforeign)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"STR\"),\n\t\t\t\t\t\t parser_errposition(cxt->pstate,\n\t\t\t\t\t\t\t\t\t\t\tconstraint->location)));\n\t\t\tcxt->ixconstraints = lappend(cxt->ixconstraints, constraint);\n\t\t\tbreak;\n\n\t\tcase CONSTR_EXCLUSION:\n\t\t\tif (cxt->isforeign)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"STR\"),\n\t\t\t\t\t\t parser_errposition(cxt->pstate,\n\t\t\t\t\t\t\t\t\t\t\tconstraint->location)));\n\t\t\tif (cxt->ispartitioned)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"STR\"),\n\t\t\t\t\t\t parser_errposition(cxt->pstate,\n\t\t\t\t\t\t\t\t\t\t\tconstraint->location)));\n\t\t\tcxt->ixconstraints = lappend(cxt->ixconstraints, constraint);\n\t\t\tbreak;\n\n\t\tcase CONSTR_CHECK:\n\t\t\tcxt->ckconstraints = lappend(cxt->ckconstraints, constraint);\n\t\t\tbreak;\n\n\t\tcase CONSTR_FOREIGN:\n\t\t\tif (cxt->isforeign)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t errmsg(\"STR\"),\n\t\t\t\t\t\t parser_errposition(cxt->pstate,\n\t\t\t\t\t\t\t\t\t\t\tconstraint->location)));\n\t\t\tcxt->fkconstraints = lappend(cxt->fkconstraints, constraint);\n\t\t\tbreak;\n\n\t\tcase CONSTR_NULL:\n\t\tcase CONSTR_NOTNULL:\n\t\tcase CONSTR_DEFAULT:\n\t\tcase CONSTR_ATTR_DEFERRABLE:\n\t\tcase CONSTR_ATTR_NOT_DEFERRABLE:\n\t\tcase CONSTR_ATTR_DEFERRED:\n\t\tcase CONSTR_ATTR_IMMEDIATE:\n\t\t\telog(ERROR, \"STR\",\n\t\t\t\t constraint->contype);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"STR\",\n\t\t\t\t constraint->contype);\n\t\t\tbreak;\n\t}\n}","23528":"LEX_USER *create_definer(THD *thd, LEX_CSTRING *user_name,\n                         LEX_CSTRING *host_name)\n{\n  LEX_USER *definer;\n\n  \n\n  if (unlikely(!(definer= (LEX_USER*) thd->alloc(sizeof(LEX_USER)))))\n    return 0;\n\n  definer->user= *user_name;\n  definer->host= *host_name;\n  definer->auth= NULL;\n\n  return definer;\n}","23358":"static vm_fault_t vhost_vdpa_fault(struct vm_fault *vmf)\n{\n\tstruct vhost_vdpa *v = vmf->vma->vm_file->private_data;\n\tstruct vdpa_device *vdpa = v->vdpa;\n\tconst struct vdpa_config_ops *ops = vdpa->config;\n\tstruct vdpa_notification_area notify;\n\tstruct vm_area_struct *vma = vmf->vma;\n\tu16 index = vma->vm_pgoff;\n\n\tnotify = ops->get_vq_notification(vdpa, index);\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tif (remap_pfn_range(vma, vmf->address & PAGE_MASK,\n\t\t\t    notify.addr >> PAGE_SHIFT, PAGE_SIZE,\n\t\t\t    vma->vm_page_prot))\n\t\treturn VM_FAULT_SIGBUS;\n\n\treturn VM_FAULT_NOPAGE;\n}","23314":"  RGWOpType get_type() override { return RGW_OP_STAT_BUCKET; }","22758":"vg_resource_attach_backing(VuGpu *g,\n                           struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_simple_resource *res;\n    struct virtio_gpu_resource_attach_backing ab;\n    int ret;\n\n    VUGPU_FILL_CMD(ab);\n    virtio_gpu_bswap_32(&ab, sizeof(ab));\n\n    res = virtio_gpu_find_resource(g, ab.resource_id);\n    if (!res) {\n        g_critical(\"STR\",\n                   __func__, ab.resource_id);\n        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;\n        return;\n    }\n\n    ret = vg_create_mapping_iov(g, &ab, cmd, &res->iov);\n    if (ret != 0) {\n        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n        return;\n    }\n\n    res->iov_cnt = ab.nr_entries;\n}","23731":"static char *mongo_ns_to_cmd_db( const char *ns ) {\n    char *current = NULL;\n    char *cmd_db_name = NULL;\n    int len = 0;\n\n    for( current = (char *)ns; *current != '.'; current++ ) {\n        len++;\n    }\n\n    cmd_db_name = (char *)bson_malloc( len + 6 );\n    strncpy( cmd_db_name, ns, len );\n    strncpy( cmd_db_name + len, \"STR\", 6 );\n\n    return cmd_db_name;\n}","23269":"dtls1_process_out_of_seq_message(SSL *s, struct hm_header_st* msg_hdr, int *ok)\n{\n\tint i=-1;\n\thm_fragment *frag = NULL;\n\tpitem *item = NULL;\n\tunsigned char seq64be[8];\n\tunsigned long frag_len = msg_hdr->frag_len;\n\n\tif ((msg_hdr->frag_off+frag_len) > msg_hdr->msg_len)\n\t\tgoto err;\n\n\t\n\tmemset(seq64be,0,sizeof(seq64be));\n\tseq64be[6] = (unsigned char) (msg_hdr->seq>>8);\n\tseq64be[7] = (unsigned char) msg_hdr->seq;\n\titem = pqueue_find(s->d1->buffered_messages, seq64be);\n\t\n\t\n\tif (msg_hdr->seq <= s->d1->handshake_read_seq ||\n\t\tmsg_hdr->seq > s->d1->handshake_read_seq + 10 || item != NULL ||\n\t\t(s->d1->handshake_read_seq == 0 && msg_hdr->type == SSL3_MT_FINISHED))\n\t\t{\n\t\tunsigned char devnull [256];\n\n\t\twhile (frag_len)\n\t\t\t{\n\t\t\ti = s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,\n\t\t\t\tdevnull,\n\t\t\t\tfrag_len>sizeof(devnull)?sizeof(devnull):frag_len,0);\n\t\t\tif (i<=0) goto err;\n\t\t\tfrag_len -= i;\n\t\t\t}\n\t\t}\n\n\tif (frag_len)\n\t\t{\n\t\tfrag = dtls1_hm_fragment_new(frag_len);\n\t\tif ( frag == NULL)\n\t\t\tgoto err;\n\n\t\tmemcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));\n\n\t\t\n\t\ti = s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,\n\t\t\tfrag->fragment,frag_len,0);\n\t\tif (i<=0 || (unsigned long)i!=frag_len)\n\t\t\tgoto err;\n\n\t\tmemset(seq64be,0,sizeof(seq64be));\n\t\tseq64be[6] = (unsigned char)(msg_hdr->seq>>8);\n\t\tseq64be[7] = (unsigned char)(msg_hdr->seq);\n\n\t\titem = pitem_new(seq64be, frag);\n\t\tif ( item == NULL)\n\t\t\tgoto err;\n\n\t\tpqueue_insert(s->d1->buffered_messages, item);\n\t\t}\n\n\treturn DTLS1_HM_FRAGMENT_RETRY;\n\nerr:\n\tif ( frag != NULL) dtls1_hm_fragment_free(frag);\n\tif ( item != NULL) OPENSSL_free(item);\n\t*ok = 0;\n\treturn i;\n\t}","22581":"int X509_aux_print(BIO *out, X509 *x, int indent)\n{\n    char oidstr[80], first;\n    STACK_OF(ASN1_OBJECT) *trust, *reject;\n    const unsigned char *alias, *keyid;\n    int keyidlen;\n    int i;\n    if (X509_trusted(x) == 0)\n        return 1;\n    trust = X509_get0_trust_objects(x);\n    reject = X509_get0_reject_objects(x);\n    if (trust) {\n        first = 1;\n        BIO_printf(out, \"STR\");\n        for (i = 0; i < sk_ASN1_OBJECT_num(trust); i++) {\n            if (!first)\n                BIO_puts(out, \"STR\");\n            else\n                first = 0;\n            OBJ_obj2txt(oidstr, sizeof(oidstr),\n                        sk_ASN1_OBJECT_value(trust, i), 0);\n            BIO_puts(out, oidstr);\n        }\n        BIO_puts(out, \"STR\");\n    } else\n        BIO_printf(out, \"STR\");\n    if (reject) {\n        first = 1;\n        BIO_printf(out, \"STR\");\n        for (i = 0; i < sk_ASN1_OBJECT_num(reject); i++) {\n            if (!first)\n                BIO_puts(out, \"STR\");\n            else\n                first = 0;\n            OBJ_obj2txt(oidstr, sizeof(oidstr),\n                        sk_ASN1_OBJECT_value(reject, i), 0);\n            BIO_puts(out, oidstr);\n        }\n        BIO_puts(out, \"STR\");\n    } else\n        BIO_printf(out, \"STR\");\n    alias = X509_alias_get0(x, NULL);\n    if (alias)\n        BIO_printf(out, \"STR\", alias);\n    keyid = X509_keyid_get0(x, &keyidlen);\n    if (keyid) {\n        BIO_printf(out, \"STR\");\n        for (i = 0; i < keyidlen; i++)\n            BIO_printf(out, \"STR\", keyid[i]);\n        BIO_write(out, \"STR\", 1);\n    }\n    return 1;\n}","23699":"  Field *get_tmp_table_field() { return 0; }","23612":"int unit_write_drop_in_private_format(Unit *u, UnitSetPropertiesMode mode, const char *name, const char *format, ...) {\n        _cleanup_free_ char *p = NULL;\n        va_list ap;\n        int r;\n\n        assert(u);\n        assert(name);\n        assert(format);\n\n        if (!(mode & (UNIT_PERSISTENT|UNIT_RUNTIME)))\n                return 0;\n\n        va_start(ap, format);\n        r = vasprintf(&p, format, ap);\n        va_end(ap);\n\n        if (r < 0)\n                return -ENOMEM;\n\n        return unit_write_drop_in_private(u, mode, name, p);\n}","23098":"TEE_Result syscall_cipher_init(unsigned long state, const void *iv,\n\t\t\tsize_t iv_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key1;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_CIPHER)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) iv, iv_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey1 = o->attr;\n\n\tif (tee_obj_get(utc, cs->key2, &o) == TEE_SUCCESS) {\n\t\tstruct tee_cryp_obj_secret *key2 = o->attr;\n\n\t\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t (uint8_t *)(key2 + 1), key2->key_size,\n\t\t\t\t\t iv, iv_len);\n\t} else {\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t NULL, 0, iv, iv_len);\n\t}\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tcs->ctx_finalize = crypto_cipher_final;\n\treturn TEE_SUCCESS;\n}","23422":"mrb_proc_new(mrb_state *mrb, const mrb_irep *irep)\n{\n  struct RProc *p;\n  mrb_callinfo *ci = mrb->c->ci;\n\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb->proc_class);\n  if (ci) {\n    struct RClass *tc = NULL;\n\n    if (ci->proc) {\n      if (ci->proc->color != MRB_GC_RED) {\n        tc = MRB_PROC_TARGET_CLASS(ci->proc);\n      }\n      else {\n        tc = mrb_vm_ci_target_class(ci);\n        if (tc && tc->tt == MRB_TT_ICLASS) {\n          tc = tc->c;\n        }\n      }\n    }\n    if (tc == NULL) {\n      tc = mrb_vm_ci_target_class(ci);\n    }\n    p->upper = ci->proc;\n    p->e.target_class = tc;\n  }\n  p->body.irep = irep;\n  if (irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)irep);\n  }\n\n  return p;\n}","23634":"decompilePUSH (SWF_ACTION *act)\n{\n\tint i;\n\tOUT_BEGIN(SWF_ACTIONPUSH);\n\n\tSanityCheck(SWF_PUSH,\n\t\tact->SWF_ACTIONRECORD.ActionCode == SWFACTION_PUSH,\n\t\t\"STR\")\n\n\tfor(i=0;i<sact->NumParam;i++)\n\t\tpush(&(sact->Params[i]));\n}","23328":"void HeaderMapImpl::appendToHeader(HeaderString& header, absl::string_view data) {\n  if (data.empty()) {\n    return;\n  }\n  if (!header.empty()) {\n    header.append(\"STR\", 1);\n  }\n  header.append(data.data(), data.size());\n}","22962":"static int gg_session_init_ssl(struct gg_session *gs)\n{\n#ifdef GG_CONFIG_HAVE_GNUTLS\n\tgg_session_gnutls_t *tmp;\n\n\ttmp = (gg_session_gnutls_t*) gs->ssl;\n\n\tif (tmp == NULL) {\n\t\ttmp = malloc(sizeof(gg_session_gnutls_t));\n\n\t\tif (tmp == NULL) {\n\t\t\tgg_debug(GG_DEBUG_MISC, \"STR\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemset(tmp, 0, sizeof(gg_session_gnutls_t));\n\n\t\tgs->ssl = tmp;\n\n\t\tgnutls_global_init();\n\t\tgnutls_certificate_allocate_credentials(&tmp->xcred);\n\t} else {\n\t\tgnutls_deinit(tmp->session);\n\t}\n\n\tgnutls_init(&tmp->session, GNUTLS_CLIENT);\n\tgnutls_set_default_priority(tmp->session);\n\tgnutls_credentials_set(tmp->session, GNUTLS_CRD_CERTIFICATE, tmp->xcred);\n\tgnutls_transport_set_ptr(tmp->session, (gnutls_transport_ptr_t) (long) gs->fd);\n#endif\n\n#ifdef GG_CONFIG_HAVE_OPENSSL\n\tchar buf[1024];\n\n\tOpenSSL_add_ssl_algorithms();\n\n\tif (!RAND_status()) {\n\t\tchar rdata[1024];\n\t\tstruct {\n\t\t\ttime_t time;\n\t\t\tvoid *ptr;\n\t\t} rstruct;\n\n\t\ttime(&rstruct.time);\n\t\trstruct.ptr = (void *) &rstruct;\n\n\t\tRAND_seed((void *) rdata, sizeof(rdata));\n\t\tRAND_seed((void *) &rstruct, sizeof(rstruct));\n\t}\n\n\tif (gs->ssl_ctx == NULL) {\n\t\tgs->ssl_ctx = SSL_CTX_new(SSLv3_client_method());\n\n\t\tif (gs->ssl_ctx == NULL) {\n\t\t\tERR_error_string_n(ERR_get_error(), buf, sizeof(buf));\n\t\t\tgg_debug(GG_DEBUG_MISC, \"STR\", buf);\n\t\t\treturn -1;\n\t\t}\n\n\t\tSSL_CTX_set_verify(gs->ssl_ctx, SSL_VERIFY_NONE, NULL);\n\t}\n\n\tif (gs->ssl != NULL)\n\t\tSSL_free(gs->ssl);\n\n\tgs->ssl = SSL_new(gs->ssl_ctx);\n\n\tif (gs->ssl == NULL) {\n\t\tERR_error_string_n(ERR_get_error(), buf, sizeof(buf));\n\t\tgg_debug(GG_DEBUG_MISC, \"STR\", buf);\n\t\treturn -1;\n\t}\n\n\tSSL_set_fd(gs->ssl, gs->fd);\n#endif\n\n\treturn 0;\n}","23065":"void ZrtpQueue::setUserCallback(ZrtpUserCallback* ucb) {\n    zrtpUserCallback = ucb;\n}","22814":"static ZIPARCHIVE_METHOD(extractTo)\n{\n\tstruct zip *intern;\n\n\tzval *this = getThis();\n\tzval *zval_files = NULL;\n\tzval **zval_file = NULL;\n\tphp_stream_statbuf ssb;\n\tchar *pathto;\n\tint pathto_len;\n\tint ret, i;\n\n\tint nelems;\n\n\tif (!this) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"STR\", &pathto, &pathto_len, &zval_files) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (pathto_len < 1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (php_stream_stat_path(pathto, &ssb) < 0) {\n\t\tret = php_stream_mkdir(pathto, 0777,  PHP_STREAM_MKDIR_RECURSIVE, NULL);\n\t\tif (!ret) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\tZIP_FROM_OBJECT(intern, this);\n\tif (zval_files && (Z_TYPE_P(zval_files) != IS_NULL)) {\n\t\tswitch (Z_TYPE_P(zval_files)) {\n\t\t\tcase IS_STRING:\n\t\t\t\tif (!php_zip_extract_file(intern, pathto, Z_STRVAL_P(zval_files), Z_STRLEN_P(zval_files) TSRMLS_CC)) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase IS_ARRAY:\n\t\t\t\tnelems = zend_hash_num_elements(Z_ARRVAL_P(zval_files));\n\t\t\t\tif (nelems == 0 ) {\n\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < nelems; i++) {\n\t\t\t\t\tif (zend_hash_index_find(Z_ARRVAL_P(zval_files), i, (void **) &zval_file) == SUCCESS) {\n\t\t\t\t\t\tswitch (Z_TYPE_PP(zval_file)) {\n\t\t\t\t\t\t\tcase IS_LONG:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase IS_STRING:\n\t\t\t\t\t\t\t\tif (!php_zip_extract_file(intern, pathto, Z_STRVAL_PP(zval_file), Z_STRLEN_PP(zval_file) TSRMLS_CC)) {\n\t\t\t\t\t\t\t\t\tRETURN_FALSE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase IS_LONG:\n\t\t\tdefault:\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"STR\");\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n        \n        int filecount = zip_get_num_files(intern);\n\n        if (filecount == -1) {\n            php_error_docref(NULL TSRMLS_CC, E_WARNING, \"STR\");\n            RETURN_FALSE;\n        }\n\n        for (i = 0; i < filecount; i++) {\n\t\t\tchar *file = (char*)zip_get_name(intern, i, ZIP_FL_UNCHANGED);\n            if (!php_zip_extract_file(intern, pathto, file, strlen(file) TSRMLS_CC)) {\n                RETURN_FALSE;\n            }\n        }\n    }\n\tRETURN_TRUE;\n}","23136":"GF_Err gf_isom_text_set_box(GF_TextSample *samp, s16 top, s16 left, s16 bottom, s16 right)\n{\n\tif (!samp) return GF_BAD_PARAM;\n\tif (!samp->box) {\n\t\tsamp->box = (GF_TextBoxBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_TBOX);\n\t\tif (!samp->box) return GF_OUT_OF_MEM;\n\t}\n\tsamp->box->box.top = top;\n\tsamp->box->box.left = left;\n\tsamp->box->box.bottom = bottom;\n\tsamp->box->box.right = right;\n\treturn GF_OK;\n}","23244":"glue(cirrus_bitblt_rop_fwd_, ROP_NAME)(CirrusVGAState *s,\n                             uint8_t *dst,const uint8_t *src,\n                             int dstpitch,int srcpitch,\n                             int bltwidth,int bltheight)\n{\n    int x,y;\n    dstpitch -= bltwidth;\n    srcpitch -= bltwidth;\n    for (y = 0; y < bltheight; y++) {\n        for (x = 0; x < bltwidth; x++) {\n            ROP_OP(*dst, *src);\n            dst++;\n            src++;\n        }\n        dst += dstpitch;\n        src += srcpitch;\n    }\n}","22659":"static inline double DecodeGamma(const double x)\n{\n  div_t\n    quotient;\n\n  double\n    p,\n    term[9];\n\n  int\n    exponent;\n\n  static const double coefficient[] =  \n  {\n    1.7917488588043277509,\n    0.82045614371976854984,\n    0.027694100686325412819,\n    -0.00094244335181762134018,\n    0.000064355540911469709545,\n    -5.7224404636060757485e-06,\n    5.8767669437311184313e-07,\n    -6.6139920053589721168e-08,\n    7.9323242696227458163e-09\n  };\n\n  static const double powers_of_two[] =  \n  {\n    1.0,\n    2.6390158215457883983,\n    6.9644045063689921093,\n    1.8379173679952558018e+01,\n    4.8502930128332728543e+01\n  };\n\n  \n  term[0]=1.0;\n  term[1]=4.0*frexp(x,&exponent)-3.0;\n  term[2]=2.0*term[1]*term[1]-term[0];\n  term[3]=2.0*term[1]*term[2]-term[1];\n  term[4]=2.0*term[1]*term[3]-term[2];\n  term[5]=2.0*term[1]*term[4]-term[3];\n  term[6]=2.0*term[1]*term[5]-term[4];\n  term[7]=2.0*term[1]*term[6]-term[5];\n  term[8]=2.0*term[1]*term[7]-term[6];\n  p=coefficient[0]*term[0]+coefficient[1]*term[1]+coefficient[2]*term[2]+\n    coefficient[3]*term[3]+coefficient[4]*term[4]+coefficient[5]*term[5]+\n    coefficient[6]*term[6]+coefficient[7]*term[7]+coefficient[8]*term[8];\n  quotient=div(exponent-1,5);\n  if (quotient.rem < 0)\n    {\n      quotient.quot-=1;\n      quotient.rem+=5;\n    }\n  return(x*ldexp(powers_of_two[quotient.rem]*p,7*quotient.quot));\n}","22791":"static int nfsd_inetaddr_event(struct notifier_block *this, unsigned long event,\n\tvoid *ptr)\n{\n\tstruct in_ifaddr *ifa = (struct in_ifaddr *)ptr;\n\tstruct net_device *dev = ifa->ifa_dev->dev;\n\tstruct net *net = dev_net(dev);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct sockaddr_in sin;\n\n\tif (event != NETDEV_DOWN)\n\t\tgoto out;\n\n\tif (nn->nfsd_serv) {\n\t\tdprintk(\"STR\", &ifa->ifa_local);\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_addr.s_addr = ifa->ifa_local;\n\t\tsvc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin);\n\t}\n\nout:\n\treturn NOTIFY_DONE;\n}","22507":"_rl_get_string_variable_value (name)\n     const char *name;\n{\n  static char numbuf[32];\n  char *ret;\n\n  if (_rl_stricmp (name, \"STR\") == 0)\n    {\n      switch (_rl_bell_preference)\n\t{\n\t  case NO_BELL:\n\t    return \"STR\";\n\t  case VISIBLE_BELL:\n\t    return \"STR\";\n\t  case AUDIBLE_BELL:\n\t  default:\n\t    return \"STR\";\n\t}\n    }\n  else if (_rl_stricmp (name, \"STR\") == 0)\n    return (_rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);\n  else if (_rl_stricmp (name, \"STR\") == 0)\n    {\n      sprintf (numbuf, \"STR\", _rl_completion_columns);\n      return (numbuf);\n    }\n  else if (_rl_stricmp (name, \"STR\") == 0)\n    {\n      sprintf (numbuf, \"STR\", _rl_completion_prefix_display_length);\n      return (numbuf);\n    }\n  else if (_rl_stricmp (name, \"STR\") == 0)\n    {\n      sprintf (numbuf, \"STR\", rl_completion_query_items);\n      return (numbuf);\n    }\n  else if (_rl_stricmp (name, \"STR\") == 0)\n    return (rl_get_keymap_name_from_edit_mode ());\n  else if (_rl_stricmp (name, \"STR\") == 0)\n    {\n      sprintf (numbuf, \"STR\", history_is_stifled() ? history_max_entries : 0);\n      return (numbuf);\n    }\n  else if (_rl_stricmp (name, \"STR\") == 0)\n    {\n      if (_rl_isearch_terminators == 0)\n\treturn 0;\n      ret = _rl_untranslate_macro_value (_rl_isearch_terminators, 0);\n      if (ret)\n\t{\n\t  strncpy (numbuf, ret, sizeof (numbuf) - 1);\n\t  xfree (ret);\n\t  numbuf[sizeof(numbuf) - 1] = '\\0';\n\t}\n      else\n\tnumbuf[0] = '\\0';\n      return numbuf;\n    }\n  else if (_rl_stricmp (name, \"STR\") == 0)\n    {\n      ret = rl_get_keymap_name (_rl_keymap);\n      if (ret == 0)\n\tret = rl_get_keymap_name_from_edit_mode ();\n      return (ret ? ret : \"STR\");\n    }\n  else if (_rl_stricmp (name, \"STR\") == 0)\n    {\n      sprintf (numbuf, \"STR\", _rl_keyseq_timeout);    \n      return (numbuf);\n    }\n  else if (_rl_stricmp (name, \"STR\") == 0)\n    return (_rl_emacs_mode_str ? _rl_emacs_mode_str : RL_EMACS_MODESTR_DEFAULT);\n  else if (_rl_stricmp (name, \"STR\") == 0)\n    return (_rl_emacs_mode_str ? _rl_emacs_mode_str : RL_VI_CMD_MODESTR_DEFAULT);\n  else if (_rl_stricmp (name, \"STR\") == 0)\n    return (_rl_emacs_mode_str ? _rl_emacs_mode_str : RL_VI_INS_MODESTR_DEFAULT);\n  else\n    return (0);\n}","23631":"ews_backend_delete_resource_sync (ECollectionBackend *backend,\n                                  ESource *source,\n                                  GCancellable *cancellable,\n                                  GError **error)\n{\n\tEEwsConnection *connection;\n\tESourceEwsFolder *extension;\n\tconst gchar *extension_name;\n\tgboolean success = FALSE;\n\n\tconnection = e_ews_backend_ref_connection_sync (E_EWS_BACKEND (backend), NULL, cancellable, error);\n\tif (connection == NULL)\n\t\treturn FALSE;\n\n\textension_name = E_SOURCE_EXTENSION_EWS_FOLDER;\n\tif (!e_source_has_extension (source, extension_name)) {\n\t\tg_set_error (\n\t\t\terror, G_IO_ERROR,\n\t\t\tG_IO_ERROR_INVALID_ARGUMENT,\n\t\t\t_(\"STR\"\n\t\t\t\"STR\"),\n\t\t\te_source_get_display_name (source));\n\t\tgoto exit;\n\t}\n\textension = e_source_get_extension (source, extension_name);\n\n\tif (e_source_ews_folder_get_foreign (extension) ||\n\t    e_source_ews_folder_get_public (extension)) {\n\t\t\n\t\tsuccess = TRUE;\n\t} else {\n\t\tgchar *folder_id;\n\n\t\tfolder_id = e_source_ews_folder_dup_id (extension);\n\n\t\tsuccess = e_ews_connection_delete_folder_sync (\n\t\t\tconnection, EWS_PRIORITY_MEDIUM, folder_id,\n\t\t\tFALSE, \"STR\", cancellable, error);\n\n\t\tg_free (folder_id);\n\t}\n\n\tif (success)\n\t\tsuccess = e_source_remove_sync (source, cancellable, error);\n\nexit:\n\tg_object_unref (connection);\n\n\treturn success;\n}","23599":"static int decode_imm(struct x86_emulate_ctxt *ctxt, struct operand *op,\n\t\t      unsigned size, bool sign_extension)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\top->type = OP_IMM;\n\top->bytes = size;\n\top->addr.mem.ea = ctxt->_eip;\n\t\n\tswitch (op->bytes) {\n\tcase 1:\n\t\top->val = insn_fetch(s8, ctxt);\n\t\tbreak;\n\tcase 2:\n\t\top->val = insn_fetch(s16, ctxt);\n\t\tbreak;\n\tcase 4:\n\t\top->val = insn_fetch(s32, ctxt);\n\t\tbreak;\n\tcase 8:\n\t\top->val = insn_fetch(s64, ctxt);\n\t\tbreak;\n\t}\n\tif (!sign_extension) {\n\t\tswitch (op->bytes) {\n\t\tcase 1:\n\t\t\top->val &= 0xff;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\top->val &= 0xffff;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\top->val &= 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\treturn rc;\n}","23443":"time_delta_should_use_heuristics(const congestion_control_t *cc)\n{\n\n  \n  if (!cc->in_slow_start) {\n    return true;\n  }\n\n  \n  if (cc->bdp[BDP_ALG_SENDME_RATE]) {\n    return true;\n  }\n\n  \n  return false;\n}","22877":"PMatch(control, string)\nregister char *control;\nregister char *string;\n{\n    while (*string && *control)\n    {\n    \tif (!MatchClass(*control, *string))\n    \t{\n    \t    return(0);\n    \t}\n\n    \tstring++;\n    \tcontrol++;\n    }\n\n    if (*string || *control)\n    {\n    \treturn(0);\n    }\n\n    return(1);\n}","23121":"void RegexMatchExpression::serializeToBSONTypeRegex(BSONObjBuilder* out) const {\n    out->appendRegex(path(), _regex, _flags);\n}","22634":"psutil_virtual_mem(PyObject *self, PyObject *args) {\n    int      mib[2];\n    uint64_t total;\n    size_t   len = sizeof(total);\n    vm_statistics_data_t vm;\n    int pagesize = getpagesize();\n    \n    mib[0] = CTL_HW;\n    mib[1] = HW_MEMSIZE;\n\n    \n    if (sysctl(mib, 2, &total, &len, NULL, 0)) {\n        if (errno != 0)\n            PyErr_SetFromErrno(PyExc_OSError);\n        else\n            PyErr_Format(\n                PyExc_RuntimeError, \"STR\");\n        return NULL;\n    }\n\n    \n    if (!psutil_sys_vminfo(&vm))\n        return NULL;\n\n    return Py_BuildValue(\n        \"STR\",\n        total,\n        (unsigned long long) vm.active_count * pagesize,  \n        (unsigned long long) vm.inactive_count * pagesize,  \n        (unsigned long long) vm.wire_count * pagesize,  \n        (unsigned long long) vm.free_count * pagesize,  \n        (unsigned long long) vm.speculative_count * pagesize  \n    );\n}","23166":"static irqreturn_t _vop_virtio_intr_handler(int irq, void *data)\n{\n\tstruct vop_vdev *vdev = data;\n\tstruct vop_device *vpdev = vdev->vpdev;\n\n\tvpdev->hw_ops->ack_interrupt(vpdev, vdev->virtio_db);\n\tschedule_work(&vdev->virtio_bh_work);\n\treturn IRQ_HANDLED;\n}","22740":"static int vapic_enter(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct page *page;\n\n\tif (!apic || !apic->vapic_addr)\n\t\treturn 0;\n\n\tpage = gfn_to_page(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn -EFAULT;\n\n\tvcpu->arch.apic->vapic_page = page;\n\treturn 0;\n}","23661":"static void *ocfs2_acl_to_xattr(const struct posix_acl *acl, size_t *size)\n{\n\tstruct ocfs2_acl_entry *entry = NULL;\n\tchar *ocfs2_acl;\n\tsize_t n;\n\n\t*size = acl->a_count * sizeof(struct posix_acl_entry);\n\n\tocfs2_acl = kmalloc(*size, GFP_NOFS);\n\tif (!ocfs2_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tentry = (struct ocfs2_acl_entry *)ocfs2_acl;\n\tfor (n = 0; n < acl->a_count; n++, entry++) {\n\t\tentry->e_tag  = cpu_to_le16(acl->a_entries[n].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[n].e_perm);\n\t\tswitch(acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns,\n\t\t\t\t\t  acl->a_entries[n].e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns,\n\t\t\t\t\t  acl->a_entries[n].e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tentry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ocfs2_acl;\n}","23307":"int TABLE::verify_constraints(bool ignore_failure)\n{\n  \n  if (in_use->is_error())\n    return (VIEW_CHECK_ERROR);\n\n  \n  if (check_constraints &&\n      !(in_use->variables.option_bits & OPTION_NO_CHECK_CONSTRAINT_CHECKS))\n  {\n    if (versioned() && !vers_end_field()->is_max())\n      return VIEW_CHECK_OK;\n    for (Virtual_column_info **chk= check_constraints ; *chk ; chk++)\n    {\n      \n      if (((*chk)->expr->val_int() == 0 && !(*chk)->expr->null_value) ||\n          in_use->is_error())\n      {\n        StringBuffer<MAX_FIELD_WIDTH> field_error(system_charset_info);\n        enum_vcol_info_type vcol_type= (*chk)->get_vcol_type();\n        DBUG_ASSERT(vcol_type == VCOL_CHECK_TABLE ||\n                    vcol_type == VCOL_CHECK_FIELD);\n        if (vcol_type == VCOL_CHECK_FIELD)\n        {\n          field_error.append(s->table_name.str);\n          field_error.append(\"STR\");\n        }\n        field_error.append((*chk)->name.str);\n        my_error(ER_CONSTRAINT_FAILED,\n                 MYF(ignore_failure ? ME_JUST_WARNING : 0), field_error.c_ptr(),\n                 s->db.str, s->table_name.str);\n        return ignore_failure ? VIEW_CHECK_SKIP : VIEW_CHECK_ERROR;\n      }\n    }\n  }\n  \n  return(!in_use->is_error() ? VIEW_CHECK_OK : VIEW_CHECK_ERROR);\n}","22739":"static void qxl_create_guest_primary(PCIQXLDevice *qxl, int loadvm)\n{\n    QXLDevSurfaceCreate surface;\n    QXLSurfaceCreate *sc = &qxl->guest_primary.surface;\n\n    assert(qxl->mode != QXL_MODE_NATIVE);\n    qxl_exit_vga_mode(qxl);\n\n    dprint(qxl, 1, \"STR\", __FUNCTION__,\n           le32_to_cpu(sc->width), le32_to_cpu(sc->height));\n\n    surface.format     = le32_to_cpu(sc->format);\n    surface.height     = le32_to_cpu(sc->height);\n    surface.mem        = le64_to_cpu(sc->mem);\n    surface.position   = le32_to_cpu(sc->position);\n    surface.stride     = le32_to_cpu(sc->stride);\n    surface.width      = le32_to_cpu(sc->width);\n    surface.type       = le32_to_cpu(sc->type);\n    surface.flags      = le32_to_cpu(sc->flags);\n\n    surface.mouse_mode = true;\n    surface.group_id   = MEMSLOT_GROUP_GUEST;\n    if (loadvm) {\n        surface.flags |= QXL_SURF_FLAG_KEEP_DATA;\n    }\n\n    qxl->mode = QXL_MODE_NATIVE;\n    qxl->cmdflags = 0;\n    qemu_spice_create_primary_surface(&qxl->ssd, 0, &surface);\n\n    \n    qxl_render_resize(qxl);\n}","22733":"TEST_P(SdsDynamicDownstreamCertValidationContextTest, CombinedValidationContextWithSharedSecret) {\n  enableCombinedValidationContext(true);\n  shareValidationSecret(true);\n  on_server_init_function_ = [this]() {\n    createSdsStream(*(fake_upstreams_[1]));\n    sendSdsResponse(getCvcSecretWithOnlyTrustedCa());\n  };\n  initialize();\n\n  \n  \n  test_server_->waitForCounterGe(\n      \"STR\", 1);\n  test_server_->waitForCounterGe(\n      listenerStatPrefix(\"STR\"), 1);\n\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection();\n  };\n  testRouterHeaderOnlyRequestAndResponse(&creator);\n}","22950":"file_printable(char *buf, size_t bufsiz, const char *str)\n{\n\tchar *ptr, *eptr;\n\tconst unsigned char *s = (const unsigned char *)str;\n\n\tfor (ptr = buf, eptr = ptr + bufsiz - 1; ptr < eptr && *s; s++) {\n\t\tif (isprint(*s)) {\n\t\t\t*ptr++ = *s;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr >= eptr + 4)\n\t\t\tbreak;\n\t\t*ptr++ = '\\\\';\n\t\t*ptr++ = ((*s >> 6) & 7) + '0';\n\t\t*ptr++ = ((*s >> 3) & 7) + '0';\n\t\t*ptr++ = ((*s >> 0) & 7) + '0';\n\t}\n\t*ptr = '\\0';\n\treturn buf;\n}","22939":"static bool prep_compound_gigantic_page_for_demote(struct page *page,\n\t\t\t\t\t\t\tunsigned int order)\n{\n\treturn __prep_compound_gigantic_page(page, order, true);\n}","22574":"int igmp6_event_report(struct sk_buff *skb)\n{\n\tstruct inet6_dev *idev = __in6_dev_get(skb->dev);\n\n\tif (!idev)\n\t\treturn -EINVAL;\n\n\tif (idev->dead) {\n\t\tkfree_skb(skb);\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_bh(&idev->mc_report_lock);\n\tif (skb_queue_len(&idev->mc_report_queue) < MLD_MAX_SKBS) {\n\t\t__skb_queue_tail(&idev->mc_report_queue, skb);\n\t\tif (!mod_delayed_work(mld_wq, &idev->mc_report_work, 0))\n\t\t\tin6_dev_hold(idev);\n\t}\n\tspin_unlock_bh(&idev->mc_report_lock);\n\n\treturn 0;\n}","23238":"static void xmlGROW (xmlParserCtxtPtr ctxt) {\n    unsigned long curEnd = ctxt->input->end - ctxt->input->cur;\n    unsigned long curBase = ctxt->input->cur - ctxt->input->base;\n\n    if (((curEnd > (unsigned long) XML_MAX_LOOKUP_LIMIT) ||\n         (curBase > (unsigned long) XML_MAX_LOOKUP_LIMIT)) &&\n         ((ctxt->input->buf) && (ctxt->input->buf->readcallback != (xmlInputReadCallback) xmlNop)) &&\n        ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, \"STR\");\n        xmlHaltParser(ctxt);\n\treturn;\n    }\n    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n    if ((ctxt->input->cur > ctxt->input->end) ||\n        (ctxt->input->cur < ctxt->input->base)) {\n        xmlHaltParser(ctxt);\n        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, \"STR\");\n\treturn;\n    }\n    if ((ctxt->input->cur != NULL) && (*ctxt->input->cur == 0))\n        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n}","22649":"int join_namespace(pid_t pid, char *type) {\n\tchar *path;\n\tif (asprintf(&path, \"STR\", pid, type) == -1)\n\t\terrExit(\"STR\");\n\n\tint fd = open(path, O_RDONLY);\n\tif (fd < 0)\n\t\tgoto errout;\n\n\tif (syscall(__NR_setns, fd, 0) < 0) {\n\t\tclose(fd);\n\t\tgoto errout;\n\t}\n\n\tclose(fd);\n\tfree(path);\n\treturn 0;\n\nerrout:\n\tfree(path);\n\tfprintf(stderr, \"STR\", type);\n\treturn -1;\n\n}","22646":"static int verify_auth_trunc(struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_ALG_AUTH_TRUNC];\n\tstruct xfrm_algo_auth *algp;\n\n\tif (!rt)\n\t\treturn 0;\n\n\talgp = nla_data(rt);\n\tif (nla_len(rt) < xfrm_alg_auth_len(algp))\n\t\treturn -EINVAL;\n\n\talgp->alg_name[CRYPTO_MAX_ALG_NAME - 1] = '\\0';\n\treturn 0;\n}","22882":"InputFile::InputFile (InputPartData* part) :\n    _data (new Data (part->numThreads))\n{\n    _data->_deleteStream=false;\n    multiPartInitialize (part);\n}","23207":"xmlXPathNodeSetAddNs(xmlNodeSetPtr cur, xmlNodePtr node, xmlNsPtr ns) {\n    int i;\n\n\n    if ((cur == NULL) || (ns == NULL) || (node == NULL) ||\n        (ns->type != XML_NAMESPACE_DECL) ||\n\t(node->type != XML_ELEMENT_NODE))\n\treturn;\n\n    \n    \n    for (i = 0;i < cur->nodeNr;i++) {\n        if ((cur->nodeTab[i] != NULL) &&\n\t    (cur->nodeTab[i]->type == XML_NAMESPACE_DECL) &&\n\t    (((xmlNsPtr)cur->nodeTab[i])->next == (xmlNsPtr) node) &&\n\t    (xmlStrEqual(ns->prefix, ((xmlNsPtr)cur->nodeTab[i])->prefix)))\n\t    return;\n    }\n\n    \n    if (cur->nodeMax == 0) {\n        cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *\n\t\t\t\t\t     sizeof(xmlNodePtr));\n\tif (cur->nodeTab == NULL) {\n\t    xmlXPathErrMemory(NULL, \"STR\");\n\t    return;\n\t}\n\tmemset(cur->nodeTab, 0 ,\n\t       XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n        cur->nodeMax = XML_NODESET_DEFAULT;\n    } else if (cur->nodeNr == cur->nodeMax) {\n        xmlNodePtr *temp;\n\n        cur->nodeMax *= 2;\n\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *\n\t\t\t\t      sizeof(xmlNodePtr));\n\tif (temp == NULL) {\n\t    xmlXPathErrMemory(NULL, \"STR\");\n\t    return;\n\t}\n\tcur->nodeTab = temp;\n    }\n    cur->nodeTab[cur->nodeNr++] = xmlXPathNodeSetDupNs(node, ns);\n}","23209":"  Statement_Ptr Expand::operator()(Debug_Ptr d)\n  {\n    \n    d->perform(&eval);\n    return 0;\n  }","22775":"static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n{\n\tfreerdp_peer* client = (freerdp_peer*) extra;\n\trdpRdp* rdp = client->context->rdp;\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_INITIAL:\n\t\t\tif (!rdp_server_accept_nego(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tif (rdp->nego->selected_protocol & PROTOCOL_NLA)\n\t\t\t{\n\t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n\t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, FALSE);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_NEGO:\n\t\t\tif (!rdp_server_accept_mcs_connect_initial(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CONNECT:\n\t\t\tif (!rdp_server_accept_mcs_erect_domain_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ERECT_DOMAIN:\n\t\t\tif (!rdp_server_accept_mcs_attach_user_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!rdp_server_accept_mcs_channel_join_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CHANNEL_JOIN:\n\t\t\tif (rdp->settings->DisableEncryption)\n\t\t\t{\n\t\t\t\tif (!rdp_server_accept_client_keys(rdp, s))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trdp->state = CONNECTION_STATE_ESTABLISH_KEYS;\n\t\t\t\n\n\t\tcase CONNECTION_STATE_ESTABLISH_KEYS:\n\t\t\tif (!rdp_server_accept_client_info(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tIFCALL(client->Capabilities, client);\n\n\t\t\tif (!rdp_send_demand_active(rdp))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_LICENSE:\n\t\t\tif (!rdp_server_accept_confirm_active(rdp, s))\n\t\t\t{\n\t\t\t\t\n\t\t\t\tStream_SetPosition(s, 0);\n\t\t\t\treturn peer_recv_pdu(client, s);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"STR\", rdp->state);\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}","23102":"uint32_t smb2cli_tcon_current_id(struct smbXcli_tcon *tcon)\n{\n\treturn tcon->smb2.tcon_id;\n}","23305":"rfbSendSetColourMapEntries(rfbClientPtr cl,\n                           int firstColour,\n                           int nColours)\n{\n    char buf[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];\n    char *wbuf = buf;\n    rfbSetColourMapEntriesMsg *scme;\n    uint16_t *rgb;\n    rfbColourMap* cm = &cl->screen->colourMap;\n    int i, len;\n\n    if (nColours > 256) {\n\t\n    \twbuf = (char *) malloc(sz_rfbSetColourMapEntriesMsg + nColours * 3 * 2);\n    }\n\n    scme = (rfbSetColourMapEntriesMsg *)wbuf;\n    rgb = (uint16_t *)(&wbuf[sz_rfbSetColourMapEntriesMsg]);\n\n    scme->type = rfbSetColourMapEntries;\n\n    scme->firstColour = Swap16IfLE(firstColour);\n    scme->nColours = Swap16IfLE(nColours);\n\n    len = sz_rfbSetColourMapEntriesMsg;\n\n    for (i = 0; i < nColours; i++) {\n      if(i<(int)cm->count) {\n\tif(cm->is16) {\n\t  rgb[i*3] = Swap16IfLE(cm->data.shorts[i*3]);\n\t  rgb[i*3+1] = Swap16IfLE(cm->data.shorts[i*3+1]);\n\t  rgb[i*3+2] = Swap16IfLE(cm->data.shorts[i*3+2]);\n\t} else {\n\t  rgb[i*3] = Swap16IfLE((unsigned short)cm->data.bytes[i*3]);\n\t  rgb[i*3+1] = Swap16IfLE((unsigned short)cm->data.bytes[i*3+1]);\n\t  rgb[i*3+2] = Swap16IfLE((unsigned short)cm->data.bytes[i*3+2]);\n\t}\n      }\n    }\n\n    len += nColours * 3 * 2;\n\n    if (rfbWriteExact(cl, wbuf, len) < 0) {\n\trfbLogPerror(\"STR\");\n\trfbCloseClient(cl);\n        if (wbuf != buf) free(wbuf);\n\treturn FALSE;\n    }\n\n    rfbStatRecordMessageSent(cl, rfbSetColourMapEntries, len, len);\n    if (wbuf != buf) free(wbuf);\n    return TRUE;\n}","22763":"    inline int mod(const unsigned char x, const unsigned char m) {\n      if (!m) throw CImgArgumentException(\"STR\");\n      return x%m;\n    }","23067":"static void store_pending_adv_report(struct hci_dev *hdev, bdaddr_t *bdaddr,\n\t\t\t\t     u8 bdaddr_type, s8 rssi, u32 flags,\n\t\t\t\t     u8 *data, u8 len)\n{\n\tstruct discovery_state *d = &hdev->discovery;\n\n\tbacpy(&d->last_adv_addr, bdaddr);\n\td->last_adv_addr_type = bdaddr_type;\n\td->last_adv_rssi = rssi;\n\td->last_adv_flags = flags;\n\tmemcpy(d->last_adv_data, data, len);\n\td->last_adv_data_len = len;\n}","23553":"char* dd_load_text_ext(const struct dump_dir *dd, const char *name, unsigned flags)\n{\n\n\n\n    \n    if (strcmp(name, \"STR\") == 0)\n        name = FILENAME_OS_RELEASE;\n\n    char *full_path = concat_path_file(dd->dd_dirname, name);\n    char *ret = load_text_file(full_path, flags);\n    free(full_path);\n\n    return ret;\n}","22905":"  Item *get_copy(THD *thd)\n  { return get_item_copy<Item_time_literal>(thd, this); }","23042":"static MagickBooleanType WriteCIPImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent];\n\n  const char\n    *value;\n\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  unsigned char\n    byte;\n\n  \n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"STR\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) WriteBlobString(image,\"STR\");\n  value=GetImageProperty(image,\"STR\",exception);\n  if (value != (const char *) NULL)\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"STR\",value);\n  else\n    {\n      char\n        basename[MagickPathExtent];\n\n      GetPathComponent(image->filename,BasePath,basename);\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"STR\",\n        basename);\n    }\n  (void) WriteBlobString(image,buffer);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\n    \"STR\",(double) image->page.x);\n  (void) WriteBlobString(image,buffer);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\n    \"STR\",(double) image->page.y);\n  (void) WriteBlobString(image,buffer);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"STR\",\n    (double) (image->columns+(image->columns % 2)));\n  (void) WriteBlobString(image,buffer);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"STR\",\n    (double) image->rows);\n  (void) WriteBlobString(image,buffer);\n  (void) FormatLocaleString(buffer,MagickPathExtent,\"STR\");\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"STR\");\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < ((ssize_t) image->columns-3); x+=4)\n    {\n      byte=(unsigned char)\n        ((((size_t) (3*ClampToQuantum(GetPixelLuma(image,p+3*GetPixelChannels(image)))\/QuantumRange) & 0x03) << 6) |\n         (((size_t) (3*ClampToQuantum(GetPixelLuma(image,p+2*GetPixelChannels(image)))\/QuantumRange) & 0x03) << 4) |\n         (((size_t) (3*ClampToQuantum(GetPixelLuma(image,p+1*GetPixelChannels(image)))\/QuantumRange) & 0x03) << 2) |\n         (((size_t) (3*ClampToQuantum(GetPixelLuma(image,p+0*GetPixelChannels(image)))\/QuantumRange) & 0x03) << 0));\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"STR\",byte);\n      (void) WriteBlobString(image,buffer);\n      p+=GetPixelChannels(image);\n    }\n    if ((image->columns % 4) != 0)\n      {\n        i=(ssize_t) image->columns % 4;\n        byte=(unsigned char)\n          ((((size_t) (3*ClampToQuantum(GetPixelLuma(image,p+MagickMin(i,3)*GetPixelChannels(image)))\/QuantumRange) & 0x03) << 6) |\n           (((size_t) (3*ClampToQuantum(GetPixelLuma(image,p+MagickMin(i,2)*GetPixelChannels(image)))\/QuantumRange) & 0x03) << 4) |\n           (((size_t) (3*ClampToQuantum(GetPixelLuma(image,p+MagickMin(i,1)*GetPixelChannels(image)))\/QuantumRange) & 0x03) << 2) |\n           (((size_t) (3*ClampToQuantum(GetPixelLuma(image,p+MagickMin(i,0)*GetPixelChannels(image)))\/QuantumRange) & 0x03) << 0));\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"STR\",~byte);\n        (void) WriteBlobString(image,buffer);\n      }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  (void) WriteBlobString(image,\"STR\");\n  (void) WriteBlobString(image,\"STR\");\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}","22698":"static ut32 alias_hashfn(const void *k_in) {\n\t\n\tut32 hash = 5381;\n\tut8 c;\n\tconst char *k = k_in;\n\n\twhile (*k) {\n\t\tc = *k++;\n\t\t\n\t\thash += (hash << 5) + c;\n\t}\n\n\treturn hash;\n}","23036":"ip_printts(netdissect_options *ndo,\n           register const u_char *cp, u_int length)\n{\n\tregister u_int ptr;\n\tregister u_int len;\n\tint hoplen;\n\tconst char *type;\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"STR\", length));\n\t\treturn;\n\t}\n\tND_PRINT((ndo, \"STR\"));\n\thoplen = ((cp[3]&0xF) != IPOPT_TS_TSONLY) ? 8 : 4;\n\tif ((length - 4) & (hoplen-1))\n\t\tND_PRINT((ndo, \"STR\", length));\n\tptr = cp[2] - 1;\n\tlen = 0;\n\tif (ptr < 4 || ((ptr - 4) & (hoplen-1)) || ptr > length + 1)\n\t\tND_PRINT((ndo, \"STR\", cp[2]));\n\tswitch (cp[3]&0xF) {\n\tcase IPOPT_TS_TSONLY:\n\t\tND_PRINT((ndo, \"STR\"));\n\t\tbreak;\n\tcase IPOPT_TS_TSANDADDR:\n\t\tND_PRINT((ndo, \"STR\"));\n\t\tbreak;\n\t\n\n\tcase 2:\n\t\tND_PRINT((ndo, \"STR\"));\n\t\tbreak;\n\tcase 3:\t\t\t\n\t\tND_PRINT((ndo, \"STR\"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"STR\", cp[3]&0xF));\n\t\tgoto done;\n\t}\n\n\ttype = \"STR\";\n\tfor (len = 4; len < length; len += hoplen) {\n\t\tif (ptr == len)\n\t\t\ttype = \"STR\";\n\t\tND_PRINT((ndo, \"STR\", type, EXTRACT_32BITS(&cp[len+hoplen-4]),\n\t\t       hoplen!=8 ? \"\" : ipaddr_string(ndo, &cp[len])));\n\t\ttype = \"STR\";\n\t}\n\ndone:\n\tND_PRINT((ndo, \"STR\"));\n\n\tif (cp[3]>>4)\n\t\tND_PRINT((ndo, \"STR\", cp[3]>>4));\n\telse\n\t\tND_PRINT((ndo, \"STR\"));\n}","22559":"ReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n\n    \n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    reason = malloc((uint64_t)reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"STR\",reason);\n    free(reason);\n}","23767":"static bool deadtime_fn(const struct timeval *now, void *private_data)\n{\n\tstruct smbd_server_connection *sconn = smbd_server_conn;\n\tif ((conn_num_open(sconn) == 0)\n\t    || (conn_idle_all(sconn, now->tv_sec))) {\n\t\tDEBUG( 2, ( \"STR\" ) );\n\t\tmessaging_send(smbd_messaging_context(), procid_self(),\n\t\t\t       MSG_SHUTDOWN, &data_blob_null);\n\t\treturn False;\n\t}\n\n\treturn True;\n}","23311":"static int nested_svm_exit_handled_msr(struct vcpu_svm *svm)\n{\n\tu32 offset, msr, value;\n\tint write, mask;\n\n\tif (!(vmcb_is_intercept(&svm->nested.ctl, INTERCEPT_MSR_PROT)))\n\t\treturn NESTED_EXIT_HOST;\n\n\tmsr    = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\toffset = svm_msrpm_offset(msr);\n\twrite  = svm->vmcb->control.exit_info_1 & 1;\n\tmask   = 1 << ((2 * (msr & 0xf)) + write);\n\n\tif (offset == MSR_INVALID)\n\t\treturn NESTED_EXIT_DONE;\n\n\t\n\toffset *= 4;\n\n\tif (kvm_vcpu_read_guest(&svm->vcpu, svm->nested.ctl.msrpm_base_pa + offset, &value, 4))\n\t\treturn NESTED_EXIT_DONE;\n\n\treturn (value & mask) ? NESTED_EXIT_DONE : NESTED_EXIT_HOST;\n}","23647":"PixarLogClose(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\n\t\n\ttd->td_bitspersample = 8;\n\ttd->td_sampleformat = SAMPLEFORMAT_UINT;\n}","23511":"static void __exit xfrm6_tunnel_fini(void)\n{\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\n\txfrm6_tunnel_spi_fini();\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\n}","23450":"ssize_t v9fs_list_xattr(FsContext *ctx, const char *path,\n                        void *value, size_t vsize)\n{\n    ssize_t size = 0;\n    void *ovalue = value;\n    XattrOperations *xops;\n    char *orig_value, *orig_value_start;\n    ssize_t xattr_len, parsed_len = 0, attr_len;\n    char *dirpath, *name;\n    int dirfd;\n\n    \n    dirpath = g_path_get_dirname(path);\n    dirfd = local_opendir_nofollow(ctx, dirpath);\n    g_free(dirpath);\n    if (dirfd == -1) {\n        return -1;\n    }\n\n    name = g_path_get_basename(path);\n    xattr_len = flistxattrat_nofollow(dirfd, name, value, 0);\n    if (xattr_len <= 0) {\n        g_free(name);\n        close_preserve_errno(dirfd);\n        return xattr_len;\n    }\n\n    \n    orig_value = g_malloc(xattr_len);\n    xattr_len = flistxattrat_nofollow(dirfd, name, orig_value, xattr_len);\n    g_free(name);\n    close_preserve_errno(dirfd);\n    if (xattr_len < 0) {\n        return -1;\n    }\n\n    \n    orig_value_start = orig_value;\n    while (xattr_len > parsed_len) {\n        xops = get_xattr_operations(ctx->xops, orig_value);\n        if (!xops) {\n            goto next_entry;\n        }\n\n        if (!value) {\n            size += xops->listxattr(ctx, path, orig_value, value, vsize);\n        } else {\n            size = xops->listxattr(ctx, path, orig_value, value, vsize);\n            if (size < 0) {\n                goto err_out;\n            }\n            value += size;\n            vsize -= size;\n        }\nnext_entry:\n        \n        attr_len = strlen(orig_value) + 1;\n        parsed_len += attr_len;\n        orig_value += attr_len;\n    }\n    if (value) {\n        size = value - ovalue;\n    }\n\nerr_out:\n    g_free(orig_value_start);\n    return size;\n}","23271":"char *xid_to_str(char *buf, const XID &xid)\n{\n  int i;\n  char *s=buf;\n  *s++='\\'';\n  for (i= 0; i < xid.gtrid_length + xid.bqual_length; i++)\n  {\n    uchar c= (uchar) xid.data[i];\n    \n    bool is_next_dig= FALSE;\n    if (i < XIDDATASIZE)\n    {\n      char ch= xid.data[i + 1];\n      is_next_dig= (ch >= '0' && ch <='9');\n    }\n    if (i == xid.gtrid_length)\n    {\n      *s++='\\'';\n      if (xid.bqual_length)\n      {\n        *s++='.';\n        *s++='\\'';\n      }\n    }\n    if (c < 32 || c > 126)\n    {\n      *s++='\\\\';\n      \n      if (c > 077 || is_next_dig)\n        *s++=_dig_vec_lower[c >> 6];\n      if (c > 007 || is_next_dig)\n        *s++=_dig_vec_lower[(c >> 3) & 7];\n      *s++=_dig_vec_lower[c & 7];\n    }\n    else\n    {\n      if (c == '\\'' || c == '\\\\')\n        *s++='\\\\';\n      *s++=c;\n    }\n  }\n  *s++='\\'';\n  *s=0;\n  return buf;\n}","23266":"InsStr(NCURSES_SP_DCLx NCURSES_CH_T *line, int count)\n{\n    TR(TRACE_UPDATE, (\"STR\",\n\t\t      (void *) SP_PARM,\n\t\t      (void *) line, count));\n\n    \n    \n    if (parm_ich) {\n\tTPUTS_TRACE(\"STR\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_1(parm_ich, count),\n\t\t\t\t1,\n\t\t\t\tNCURSES_SP_NAME(_nc_outch));\n\twhile (count > 0) {\n\t    PutAttrChar(NCURSES_SP_ARGx CHREF(*line));\n\t    line++;\n\t    count--;\n\t}\n    } else if (enter_insert_mode && exit_insert_mode) {\n\tNCURSES_PUTP2(\"STR\", enter_insert_mode);\n\twhile (count > 0) {\n\t    PutAttrChar(NCURSES_SP_ARGx CHREF(*line));\n\t    if (insert_padding) {\n\t\tNCURSES_PUTP2(\"STR\", insert_padding);\n\t    }\n\t    line++;\n\t    count--;\n\t}\n\tNCURSES_PUTP2(\"STR\", exit_insert_mode);\n    } else {\n\twhile (count > 0) {\n\t    NCURSES_PUTP2(\"STR\", insert_character);\n\t    PutAttrChar(NCURSES_SP_ARGx CHREF(*line));\n\t    if (insert_padding) {\n\t\tNCURSES_PUTP2(\"STR\", insert_padding);\n\t    }\n\t    line++;\n\t    count--;\n\t}\n    }\n    position_check(NCURSES_SP_ARGx\n\t\t   SP_PARM->_cursrow,\n\t\t   SP_PARM->_curscol, \"STR\");\n}","22992":"static void of_unittest_overlay_i2c_14(void)\n{\n}","23489":"MONGO_EXPORT int bson_append_long( bson *b, const char *name, const int64_t i ) {\n    if ( bson_append_estart( b , BSON_LONG, name, 8 ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append64( b , &i );\n    return BSON_OK;\n}","22540":"void X509Certificate::ToLegacy(const FunctionCallbackInfo<Value>& args) {\n  Environment* env = Environment::GetCurrent(args);\n  X509Certificate* cert;\n  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());\n  Local<Value> ret;\n  if (X509ToObject(env, cert->get()).ToLocal(&ret))\n    args.GetReturnValue().Set(ret);\n}","23697":"void nghttp2_option_set_max_reserved_remote_streams(nghttp2_option *option,\n                                                    uint32_t val) {\n  option->opt_set_mask |= NGHTTP2_OPT_MAX_RESERVED_REMOTE_STREAMS;\n  option->max_reserved_remote_streams = val;\n}","23505":"qboolean FS_IsExt(const char *filename, const char *ext, int namelen)\n{\n\tint extlen;\n\n\textlen = strlen(ext);\n\n\tif(extlen > namelen)\n\t\treturn qfalse;\n\n\tfilename += namelen - extlen;\n\n\treturn !Q_stricmp(filename, ext);\n}","22529":"static int eb_copy_relocations(const struct i915_execbuffer *eb)\n{\n\tconst unsigned int count = eb->buffer_count;\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < count; i++) {\n\t\tconst unsigned int nreloc = eb->exec[i].relocation_count;\n\t\tstruct drm_i915_gem_relocation_entry __user *urelocs;\n\t\tstruct drm_i915_gem_relocation_entry *relocs;\n\t\tunsigned long size;\n\t\tunsigned long copied;\n\n\t\tif (nreloc == 0)\n\t\t\tcontinue;\n\n\t\terr = check_relocations(&eb->exec[i]);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\turelocs = u64_to_user_ptr(eb->exec[i].relocs_ptr);\n\t\tsize = nreloc * sizeof(*relocs);\n\n\t\trelocs = kvmalloc_array(size, 1, GFP_KERNEL);\n\t\tif (!relocs) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\t\n\t\tcopied = 0;\n\t\tdo {\n\t\t\tunsigned int len =\n\t\t\t\tmin_t(u64, BIT_ULL(31), size - copied);\n\n\t\t\tif (__copy_from_user((char *)relocs + copied,\n\t\t\t\t\t     (char __user *)urelocs + copied,\n\t\t\t\t\t     len)) {\nend_user:\n\t\t\t\tuser_access_end();\n\t\t\t\tkvfree(relocs);\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tcopied += len;\n\t\t} while (copied < size);\n\n\t\t\n\t\tuser_access_begin();\n\t\tfor (copied = 0; copied < nreloc; copied++)\n\t\t\tunsafe_put_user(-1,\n\t\t\t\t\t&urelocs[copied].presumed_offset,\n\t\t\t\t\tend_user);\n\t\tuser_access_end();\n\n\t\teb->exec[i].relocs_ptr = (uintptr_t)relocs;\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (i--) {\n\t\tstruct drm_i915_gem_relocation_entry *relocs =\n\t\t\tu64_to_ptr(typeof(*relocs), eb->exec[i].relocs_ptr);\n\t\tif (eb->exec[i].relocation_count)\n\t\t\tkvfree(relocs);\n\t}\n\treturn err;\n}","23698":"static void checkPageContents(QPDFObjectHandle page,\n                              std::string const& wanted_string)\n{\n    std::string contents = getPageContents(page);\n    if (contents.find(wanted_string) == std::string::npos)\n    {\n        std::cout << \"STR\"\n                  << contents << std::endl;\n    }\n}","23001":"static void *show_partition_start(struct seq_file *seqf, loff_t *pos)\n{\n\tvoid *p;\n\n\tp = disk_seqf_start(seqf, pos);\n\tif (!IS_ERR_OR_NULL(p) && !*pos)\n\t\tseq_puts(seqf, \"STR\");\n\treturn p;\n}","23242":"flow_wc_map(const struct flow *flow, struct flowmap *map)\n{\n    \n    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 36);\n\n    flowmap_init(map);\n\n    if (flow_tnl_dst_is_set(&flow->tunnel)) {\n        FLOWMAP_SET__(map, tunnel, offsetof(struct flow_tnl, metadata));\n        if (!(flow->tunnel.flags & FLOW_TNL_F_UDPIF)) {\n            if (flow->tunnel.metadata.present.map) {\n                FLOWMAP_SET(map, tunnel.metadata);\n            }\n        } else {\n            FLOWMAP_SET(map, tunnel.metadata.present.len);\n            FLOWMAP_SET__(map, tunnel.metadata.opts.gnv,\n                          flow->tunnel.metadata.present.len);\n        }\n    }\n\n    \n    FLOWMAP_SET(map, skb_priority);\n    FLOWMAP_SET(map, pkt_mark);\n    FLOWMAP_SET(map, recirc_id);\n    FLOWMAP_SET(map, dp_hash);\n    FLOWMAP_SET(map, in_port);\n    FLOWMAP_SET(map, dl_dst);\n    FLOWMAP_SET(map, dl_src);\n    FLOWMAP_SET(map, dl_type);\n    FLOWMAP_SET(map, vlan_tci);\n    FLOWMAP_SET(map, ct_state);\n    FLOWMAP_SET(map, ct_zone);\n    FLOWMAP_SET(map, ct_mark);\n    FLOWMAP_SET(map, ct_label);\n\n    \n    if (OVS_LIKELY(flow->dl_type == htons(ETH_TYPE_IP))) {\n        FLOWMAP_SET(map, nw_src);\n        FLOWMAP_SET(map, nw_dst);\n        FLOWMAP_SET(map, nw_proto);\n        FLOWMAP_SET(map, nw_frag);\n        FLOWMAP_SET(map, nw_tos);\n        FLOWMAP_SET(map, nw_ttl);\n        FLOWMAP_SET(map, tp_src);\n        FLOWMAP_SET(map, tp_dst);\n\n        if (OVS_UNLIKELY(flow->nw_proto == IPPROTO_IGMP)) {\n            FLOWMAP_SET(map, igmp_group_ip4);\n        } else {\n            FLOWMAP_SET(map, tcp_flags);\n        }\n    } else if (flow->dl_type == htons(ETH_TYPE_IPV6)) {\n        FLOWMAP_SET(map, ipv6_src);\n        FLOWMAP_SET(map, ipv6_dst);\n        FLOWMAP_SET(map, ipv6_label);\n        FLOWMAP_SET(map, nw_proto);\n        FLOWMAP_SET(map, nw_frag);\n        FLOWMAP_SET(map, nw_tos);\n        FLOWMAP_SET(map, nw_ttl);\n        FLOWMAP_SET(map, tp_src);\n        FLOWMAP_SET(map, tp_dst);\n\n        if (OVS_UNLIKELY(flow->nw_proto == IPPROTO_ICMPV6)) {\n            FLOWMAP_SET(map, nd_target);\n            FLOWMAP_SET(map, arp_sha);\n            FLOWMAP_SET(map, arp_tha);\n        } else {\n            FLOWMAP_SET(map, tcp_flags);\n        }\n    } else if (eth_type_mpls(flow->dl_type)) {\n        FLOWMAP_SET(map, mpls_lse);\n    } else if (flow->dl_type == htons(ETH_TYPE_ARP) ||\n               flow->dl_type == htons(ETH_TYPE_RARP)) {\n        FLOWMAP_SET(map, nw_src);\n        FLOWMAP_SET(map, nw_dst);\n        FLOWMAP_SET(map, nw_proto);\n        FLOWMAP_SET(map, arp_sha);\n        FLOWMAP_SET(map, arp_tha);\n    }\n}","22693":"u_clearline(void)\n{\n    if (curbuf->b_u_line_ptr != NULL)\n    {\n\tvim_free(curbuf->b_u_line_ptr);\n\tcurbuf->b_u_line_ptr = NULL;\n\tcurbuf->b_u_line_lnum = 0;\n    }\n}","23373":"export_ini_file (int                 parent_fd,\n                 const char         *name,\n                 ExportedIniFileType ini_type,\n                 struct stat        *stat_buf,\n                 char              **target,\n                 GCancellable       *cancellable,\n                 GError            **error)\n{\n  glnx_autofd int desktop_fd = -1;\n  g_autofree char *tmpfile_name = g_strdup_printf (\"STR\");\n\n  g_autoptr(GOutputStream) out_stream = NULL;\n  g_autofree gchar *data = NULL;\n  gsize data_len;\n  g_autofree gchar *new_data = NULL;\n  gsize new_data_len;\n  g_autoptr(GKeyFile) keyfile = NULL;\n\n  if (!flatpak_openat_noatime (parent_fd, name, &desktop_fd, cancellable, error) ||\n      !read_fd (desktop_fd, stat_buf, &data, &data_len, error))\n    return FALSE;\n\n  keyfile = g_key_file_new ();\n  if (!g_key_file_load_from_data (keyfile, data, data_len, G_KEY_FILE_KEEP_TRANSLATIONS, error))\n    return FALSE;\n\n  if (ini_type == INI_FILE_TYPE_SEARCH_PROVIDER)\n    g_key_file_set_boolean (keyfile, \"STR\", TRUE);\n\n  new_data = g_key_file_to_data (keyfile, &new_data_len, error);\n  if (new_data == NULL)\n    return FALSE;\n\n  if (!flatpak_open_in_tmpdir_at (parent_fd, 0755, tmpfile_name, &out_stream, cancellable, error) ||\n      !g_output_stream_write_all (out_stream, new_data, new_data_len, NULL, cancellable, error) ||\n      !g_output_stream_close (out_stream, cancellable, error))\n    return FALSE;\n\n  if (target)\n    *target = g_steal_pointer (&tmpfile_name);\n\n  return TRUE;\n}","23157":"unsigned long round_jiffies_up_relative(unsigned long j)\n{\n\treturn __round_jiffies_up_relative(j, raw_smp_processor_id());\n}","23137":"briopt_check(win_T *wp)\n{\n    char_u\t*p;\n    int\t\tbri_shift = 0;\n    long\tbri_min = 20;\n    int\t\tbri_sbr = FALSE;\n    int\t\tbri_list = 0;\n    int\t\tbri_vcol = 0;\n\n    p = wp->w_p_briopt;\n    while (*p != NUL)\n    {\n\tif (STRNCMP(p, \"STR\", 6) == 0\n\t\t && ((p[6] == '-' && VIM_ISDIGIT(p[7])) || VIM_ISDIGIT(p[6])))\n\t{\n\t    p += 6;\n\t    bri_shift = getdigits(&p);\n\t}\n\telse if (STRNCMP(p, \"STR\", 4) == 0 && VIM_ISDIGIT(p[4]))\n\t{\n\t    p += 4;\n\t    bri_min = getdigits(&p);\n\t}\n\telse if (STRNCMP(p, \"STR\", 3) == 0)\n\t{\n\t    p += 3;\n\t    bri_sbr = TRUE;\n\t}\n\telse if (STRNCMP(p, \"STR\", 5) == 0)\n\t{\n\t    p += 5;\n\t    bri_list = getdigits(&p);\n\t}\n\telse if (STRNCMP(p, \"STR\", 7) == 0)\n\t{\n\t    p += 7;\n\t    bri_vcol = getdigits(&p);\n\t}\n\tif (*p != ',' && *p != NUL)\n\t    return FAIL;\n\tif (*p == ',')\n\t    ++p;\n    }\n\n    wp->w_briopt_shift = bri_shift;\n    wp->w_briopt_min   = bri_min;\n    wp->w_briopt_sbr   = bri_sbr;\n    wp->w_briopt_list  = bri_list;\n    wp->w_briopt_vcol  = bri_vcol;\n\n    return OK;\n}","23388":"int sqlite3WhereIsDistinct(WhereInfo *pWInfo){\n  return pWInfo->eDistinct;\n}","22566":"zzip_mem_disk_entry_to_data(ZZIP_MEM_DISK* dir, ZZIP_DISK_ENTRY* entry) {\n    return zzip_disk_entry_to_data(dir->disk, entry); }","23106":"int main( int argc, char *argv[] )\n{\n    ((void) argc);\n    ((void) argv);\n\n    printf(\"STR\"\n           \"STR\"\n           \"STR\"\n           \"STR\");\n    return( 0 );\n}","22637":"static int handle_preemption_timer(struct kvm_vcpu *vcpu)\n{\n\tkvm_lapic_expired_hv_timer(vcpu);\n\treturn 1;\n}","23675":"int sftp_closedir(sftp_dir dir){\n  int err = SSH_NO_ERROR;\n\n  SAFE_FREE(dir->name);\n  if (dir->handle) {\n    err = sftp_handle_close(dir->sftp, dir->handle);\n    ssh_string_free(dir->handle);\n  }\n  \n  ssh_buffer_free(dir->buffer);\n  SAFE_FREE(dir);\n\n  return err;\n}","22861":"archive_string_append_from_wcs(struct archive_string *as,\n    const wchar_t *w, size_t len)\n{\n\t(void)as;\n\t(void)w;\n\t(void)len;\n\terrno = ENOSYS;\n\treturn (-1);\n}","22480":"TPM2B_ENCRYPTED_SECRET_Marshal(TPM2B_ENCRYPTED_SECRET *source, BYTE **buffer, INT32 *size)\n{\n    UINT16 written = 0;\n    written += TPM2B_Marshal(&source->b, buffer, size);\n    return written;\n}","23054":"isdn_net_force_dial_lp(isdn_net_local *lp)\n{\n\tif ((!(lp->flags & ISDN_NET_CONNECTED)) && !lp->dialstate) {\n\t\tint chi;\n\t\tif (lp->phone[1]) {\n\t\t\tulong flags;\n\n\t\t\t\n\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\tif ((chi = isdn_get_free_channel(\n\t\t\t\t     ISDN_USAGE_NET,\n\t\t\t\t     lp->l2_proto,\n\t\t\t\t     lp->l3_proto,\n\t\t\t\t     lp->pre_device,\n\t\t\t\t     lp->pre_channel,\n\t\t\t\t     lp->msn)) < 0) {\n\t\t\t\tprintk(KERN_WARNING \"STR\",\n\t\t\t\t       lp->netdev->dev->name);\n\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t\tlp->dialstate = 1;\n\t\t\t\n\t\t\tisdn_net_bind_channel(lp, chi);\n#ifdef CONFIG_ISDN_PPP\n\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\n\t\t\t\tif (isdn_ppp_bind(lp) < 0) {\n\t\t\t\t\tisdn_net_unbind_channel(lp);\n\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\treturn -EAGAIN;\n\t\t\t\t}\n#endif\n\t\t\t\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\tisdn_net_dial();\n\t\t\treturn 0;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t} else\n\t\treturn -EBUSY;\n}","23275":"ipcp_decision_stage (class ipa_topo_info *topo)\n{\n  int i;\n\n  if (dump_file)\n    fprintf (dump_file, \"STR\");\n\n  for (i = topo->nnodes - 1; i >= 0; i--)\n    {\n      struct cgraph_node *node = topo->order[i];\n      bool change = false, iterate = true;\n\n      while (iterate)\n\t{\n\t  struct cgraph_node *v;\n\t  iterate = false;\n\t  for (v = node; v; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n\t    if (v->has_gimple_body_p ()\n\t\t&& ipcp_versionable_function_p (v))\n\t      iterate |= decide_whether_version_node (v);\n\n\t  change |= iterate;\n\t}\n      if (change)\n\tidentify_dead_nodes (node);\n    }\n}","23497":"  DeletionConfirmationDlg(QWidget *parent, const int &size, const QString &name, bool defaultDeleteFiles): QDialog(parent) {\n    setupUi(this);\n    if (size == 1)\n      label->setText(tr(\"STR\").arg(name));\n    else\n      label->setText(tr(\"STR\").arg(QString::number(size)));\n    \n    lbl_warn->setPixmap(GuiIconProvider::instance()->getIcon(\"STR\").pixmap(lbl_warn->height()));\n    lbl_warn->setFixedWidth(lbl_warn->height());\n    rememberBtn->setIcon(GuiIconProvider::instance()->getIcon(\"STR\"));\n\n    move(Utils::Misc::screenCenter(this));\n    checkPermDelete->setChecked(defaultDeleteFiles || Preferences::instance()->deleteTorrentFilesAsDefault());\n    connect(checkPermDelete, SIGNAL(clicked()), this, SLOT(updateRememberButtonState()));\n    buttonBox->button(QDialogButtonBox::Cancel)->setFocus();\n  }","23149":"static void print_qualifiers(BIO *out, STACK_OF(POLICYQUALINFO) *quals,\n                             int indent)\n{\n    POLICYQUALINFO *qualinfo;\n    int i;\n    for (i = 0; i < sk_POLICYQUALINFO_num(quals); i++) {\n        qualinfo = sk_POLICYQUALINFO_value(quals, i);\n        switch (OBJ_obj2nid(qualinfo->pqualid)) {\n        case NID_id_qt_cps:\n            BIO_printf(out, \"STR\",\n                       qualinfo->d.cpsuri->data);\n            break;\n\n        case NID_id_qt_unotice:\n            BIO_printf(out, \"STR\");\n            print_notice(out, qualinfo->d.usernotice, indent + 2);\n            break;\n\n        default:\n            BIO_printf(out, \"STR\");\n\n            i2a_ASN1_OBJECT(out, qualinfo->pqualid);\n            BIO_puts(out, \"STR\");\n            break;\n        }\n    }\n}","23822":"xmlXPathOrderDocElems(xmlDocPtr doc) {\n    long count = 0;\n    xmlNodePtr cur;\n\n    if (doc == NULL)\n\treturn(-1);\n    cur = doc->children;\n    while (cur != NULL) {\n\tif (cur->type == XML_ELEMENT_NODE) {\n\t    cur->content = (void *) (-(++count));\n\t    if (cur->children != NULL) {\n\t\tcur = cur->children;\n\t\tcontinue;\n\t    }\n\t}\n\tif (cur->next != NULL) {\n\t    cur = cur->next;\n\t    continue;\n\t}\n\tdo {\n\t    cur = cur->parent;\n\t    if (cur == NULL)\n\t\tbreak;\n\t    if (cur == (xmlNodePtr) doc) {\n\t\tcur = NULL;\n\t\tbreak;\n\t    }\n\t    if (cur->next != NULL) {\n\t\tcur = cur->next;\n\t\tbreak;\n\t    }\n\t} while (cur != NULL);\n    }\n    return(count);\n}","23668":"xmlBufGrowInternal(xmlBufPtr buf, size_t len) {\n    size_t size;\n    xmlChar *newbuf;\n\n    if ((buf == NULL) || (buf->error != 0)) return(0);\n    CHECK_COMPAT(buf)\n\n    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return(0);\n    if (buf->use + len < buf->size)\n        return(buf->size - buf->use);\n\n    \n#if 1\n    if (buf->size > (size_t) len)\n        size = buf->size * 2;\n    else\n        size = buf->use + len + 100;\n#else\n    size = buf->use + len + 100;\n#endif\n\n    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {\n        \n        if ((buf->use + len >= XML_MAX_TEXT_LENGTH) ||\n\t    (buf->size >= XML_MAX_TEXT_LENGTH)) {\n\t    xmlBufMemoryError(buf, \"STR\");\n\t    return(0);\n\t}\n\tif (size >= XML_MAX_TEXT_LENGTH)\n\t    size = XML_MAX_TEXT_LENGTH;\n    }\n    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {\n        size_t start_buf = buf->content - buf->contentIO;\n\n\tnewbuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + size);\n\tif (newbuf == NULL) {\n\t    xmlBufMemoryError(buf, \"STR\");\n\t    return(0);\n\t}\n\tbuf->contentIO = newbuf;\n\tbuf->content = newbuf + start_buf;\n    } else {\n\tnewbuf = (xmlChar *) xmlRealloc(buf->content, size);\n\tif (newbuf == NULL) {\n\t    xmlBufMemoryError(buf, \"STR\");\n\t    return(0);\n\t}\n\tbuf->content = newbuf;\n    }\n    buf->size = size;\n    UPDATE_COMPAT(buf)\n    return(buf->size - buf->use);\n}","23431":"take_offline(NCR_Instance inst)\n{\n  inst->opmode = MD_OFFLINE;\n  if (inst->timer_running) {\n    SCH_RemoveTimeout(inst->timeout_id);\n    inst->timer_running = 0;\n  }\n\n  \n  SRC_ResetReachability(inst->source);\n\n  \n  SRC_UnsetActive(inst->source);\n\n  close_client_socket(inst);\n\n  NCR_ResetInstance(inst);\n}","23002":"static PHP_FUNCTION(xmlwriter_end_pi)\n{\n\tphp_xmlwriter_end(INTERNAL_FUNCTION_PARAM_PASSTHRU, xmlTextWriterEndPI);\n}","23533":"static int ath6kl_wmi_ratemask_reply_rx(struct wmi *wmi, u8 *datap, int len)\n{\n\tif (len < sizeof(struct wmi_fix_rates_reply))\n\t\treturn -EINVAL;\n\n\tath6kl_wakeup_event(wmi->parent_dev);\n\n\treturn 0;\n}","23694":"static bool check_args_pair_invalid(enum bpf_arg_type arg_curr,\n\t\t\t\t    enum bpf_arg_type arg_next)\n{\n\treturn (arg_type_is_mem_ptr(arg_curr) &&\n\t        !arg_type_is_mem_size(arg_next)) ||\n\t       (!arg_type_is_mem_ptr(arg_curr) &&\n\t\targ_type_is_mem_size(arg_next));\n}","23549":"static int fake_magic_space(const char *, int)\n#endif\n{\n  rl_insert(1, ' ');\n  return 0;\n}","23619":"void rose_start_idletimer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tdel_timer(&rose->idletimer);\n\n\tif (rose->idle > 0) {\n\t\trose->idletimer.function = rose_idletimer_expiry;\n\t\trose->idletimer.expires  = jiffies + rose->idle;\n\n\t\tadd_timer(&rose->idletimer);\n\t}\n}","23117":"QList<QPair<unsigned int, QString> > ServerDB::getLog(int server_id, unsigned int offs_min, unsigned int offs_max) {\n\tTransactionHolder th;\n\tQSqlQuery &query = *th.qsqQuery;\n\n\tSQLPREP(\"STR\");\n\tquery.addBindValue(server_id);\n\tquery.addBindValue(offs_min);\n\tquery.addBindValue(offs_max);\n\tSQLEXEC();\n\n\tQList<QPair<unsigned int, QString> > ql;\n\twhile (query.next()) {\n\t\tQDateTime qdt = query.value(0).toDateTime();\n\t\tQString msg = query.value(1).toString();\n\t\tql << QPair<unsigned int, QString>(qdt.toLocalTime().toTime_t(), msg);\n\t}\n\treturn ql;\n}","22909":"static inline bool tcp_ack_update_rtt(struct sock *sk, const int flag,\n\t\t\t\t      s32 seq_rtt, s32 sack_rtt)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\n\t\n\tif (flag & FLAG_RETRANS_DATA_ACKED)\n\t\tseq_rtt = -1;\n\n\tif (seq_rtt < 0)\n\t\tseq_rtt = sack_rtt;\n\n\t\n\tif (seq_rtt < 0 && tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr &&\n\t    flag & FLAG_ACKED)\n\t\tseq_rtt = tcp_time_stamp - tp->rx_opt.rcv_tsecr;\n\n\tif (seq_rtt < 0)\n\t\treturn false;\n\n\ttcp_rtt_estimator(sk, seq_rtt);\n\ttcp_set_rto(sk);\n\n\t\n\tinet_csk(sk)->icsk_backoff = 0;\n\treturn true;\n}","22803":"int ConnectionImpl::onHeadersCompleteBase() {\n  ENVOY_CONN_LOG(trace, \"STR\", connection_);\n  completeLastHeader();\n  \n  \n  ASSERT(current_header_map_->byteSize().has_value() &&\n         current_header_map_->byteSize() == current_header_map_->byteSizeInternal());\n  if (!(parser_.http_major == 1 && parser_.http_minor == 1)) {\n    \n    \n    protocol_ = Protocol::Http10;\n  }\n  if (Utility::isUpgrade(*current_header_map_)) {\n    \n    \n    if (current_header_map_->Upgrade() &&\n        absl::EqualsIgnoreCase(current_header_map_->Upgrade()->value().getStringView(),\n                               Http::Headers::get().UpgradeValues.H2c)) {\n      ENVOY_CONN_LOG(trace, \"STR\", connection_);\n      current_header_map_->removeUpgrade();\n      if (current_header_map_->Connection()) {\n        const auto& tokens_to_remove = caseUnorderdSetContainingUpgradeAndHttp2Settings();\n        std::string new_value = StringUtil::removeTokens(\n            current_header_map_->Connection()->value().getStringView(), \"STR\");\n        if (new_value.empty()) {\n          current_header_map_->removeConnection();\n        } else {\n          current_header_map_->Connection()->value(new_value);\n        }\n      }\n      current_header_map_->remove(Headers::get().Http2Settings);\n    } else {\n      ENVOY_CONN_LOG(trace, \"STR\", connection_);\n      handling_upgrade_ = true;\n    }\n  }\n\n  int rc = onHeadersComplete(std::move(current_header_map_));\n  current_header_map_.reset();\n  header_parsing_state_ = HeaderParsingState::Done;\n\n  \n  return handling_upgrade_ ? 2 : rc;\n}","22864":"static void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tif (ctx->might_cancel) {\n\t\tctx->might_cancel = false;\n\t\tspin_lock(&cancel_lock);\n\t\tlist_del_rcu(&ctx->clist);\n\t\tspin_unlock(&cancel_lock);\n\t}\n}","22531":"int ClientHandler::read_clear() {\n  rb_.ensure_chunk();\n  for (;;) {\n    if (rb_.rleft() && on_read() != 0) {\n      return -1;\n    }\n    if (rb_.rleft() == 0) {\n      rb_.reset();\n    } else if (rb_.wleft() == 0) {\n      conn_.rlimit.stopw();\n      return 0;\n    }\n\n    if (!ev_is_active(&conn_.rev)) {\n      return 0;\n    }\n\n    auto nread = conn_.read_clear(rb_.last(), rb_.wleft());\n\n    if (nread == 0) {\n      if (rb_.rleft() == 0) {\n        rb_.release_chunk();\n      }\n      return 0;\n    }\n\n    if (nread < 0) {\n      return -1;\n    }\n\n    rb_.write(nread);\n  }\n}","23523":"GC_API GC_ATTR_MALLOC void * GC_CALL GC_malloc_many(size_t lb)\n{\n    void *result;\n\n    GC_generic_malloc_many(ROUNDUP_GRANULE_SIZE(lb + EXTRA_BYTES),\n                           NORMAL, &result);\n    return result;\n}","22643":"http_rxchunk(struct http *hp)\n{\n\tchar *q;\n\tint l, i;\n\n\tl = hp->prxbuf;\n\tdo\n\t\t(void)http_rxchar(hp, 1, 0);\n\twhile (hp->rxbuf[hp->prxbuf - 1] != '\\n');\n\tvtc_dump(hp->vl, 4, \"STR\", hp->rxbuf + l, -1);\n\ti = strtoul(hp->rxbuf + l, &q, 16);\n\tbprintf(hp->chunklen, \"STR\", i);\n\tif ((q == hp->rxbuf + l) ||\n\t\t(*q != '\\0' && !vct_islws(*q))) {\n\t\tvtc_log(hp->vl, hp->fatal, \"STR\",\n\t\t    *q, q - (hp->rxbuf + l));\n\t}\n\tassert(q != hp->rxbuf + l);\n\tassert(*q == '\\0' || vct_islws(*q));\n\thp->prxbuf = l;\n\tif (i > 0) {\n\t\t(void)http_rxchar(hp, i, 0);\n\t\tvtc_dump(hp->vl, 4, \"STR\",\n\t\t    hp->rxbuf + l, i);\n\t}\n\tl = hp->prxbuf;\n\t(void)http_rxchar(hp, 2, 0);\n\tif(!vct_iscrlf(hp->rxbuf[l]))\n\t\tvtc_log(hp->vl, hp->fatal,\n\t\t    \"STR\",\n\t\t    hp->rxbuf[l] & 0xff);\n\tif(!vct_iscrlf(hp->rxbuf[l + 1]))\n\t\tvtc_log(hp->vl, hp->fatal,\n\t\t    \"STR\",\n\t\t    hp->rxbuf[l + 1] & 0xff);\n\thp->prxbuf = l;\n\thp->rxbuf[l] = '\\0';\n\treturn (i);\n}","23644":"FILE *open_dumpfile(SRC_Instance inst, const char *mode)\n{\n  FILE *f;\n  char filename[PATH_MAX], *dumpdir;\n\n  dumpdir = CNF_GetDumpDir();\n  if (dumpdir[0] == '\\0') {\n    LOG(LOGS_WARN, \"STR\");\n    return NULL;\n  }\n\n  \n  if ((inst->type == SRC_NTP &&\n       snprintf(filename, sizeof (filename), \"STR\", dumpdir,\n                source_to_string(inst)) >= sizeof (filename)) ||\n      (inst->type != SRC_NTP &&\n       snprintf(filename, sizeof (filename), \"STR\",\n                dumpdir, inst->ref_id) >= sizeof (filename))) {\n    LOG(LOGS_WARN, \"STR\");\n    return NULL;\n  }\n\n  f = fopen(filename, mode);\n  if (!f && mode[0] != 'r')\n    LOG(LOGS_WARN, \"STR\",\n        source_to_string(inst));\n\n  return f;\n}","23347":"void mnt_pin(struct vfsmount *mnt)\n{\n\tlock_mount_hash();\n\treal_mount(mnt)->mnt_pinned++;\n\tunlock_mount_hash();\n}","22595":"Pl_AES_PDF::setIV(unsigned char const* iv, size_t bytes)\n{\n    if (bytes != this->buf_size)\n    {\n        throw std::logic_error(\n            \"STR\"\n            \"STR\" + QUtil::int_to_string(bytes));\n    }\n    this->use_specified_iv = true;\n    memcpy(this->specified_iv, iv, bytes);\n}","23764":"allocsymkey(\n\tsymkey **\tbucket,\n\tkeyid_t\t\tid,\n\tu_short\t\tflags,\n\tu_short\t\ttype,\n\tu_long\t\tlifetime,\n\tu_short\t\tsecretsize,\n\tu_char *\tsecret\n\t)\n{\n\tsymkey *\tsk;\n\n\tif (authnumfreekeys < 1)\n\t\tauth_moremem(-1);\n\tUNLINK_HEAD_SLIST(sk, authfreekeys, llink.f);\n\tDEBUG_ENSURE(sk != NULL);\n\tsk->keyid = id;\n\tsk->flags = flags;\n\tsk->type = type;\n\tsk->secretsize = secretsize;\n\tsk->secret = secret;\n\tsk->lifetime = lifetime;\n\tLINK_SLIST(*bucket, sk, hlink);\n\tLINK_TAIL_DLIST(key_listhead, sk, llink);\n\tauthnumfreekeys--;\n\tauthnumkeys++;\n}","23602":"Item_sp::execute_impl(THD *thd, Item **args, uint arg_count)\n{\n  Sub_statement_state statement_state;\n  Security_context *save_security_ctx= thd->security_ctx;\n  enum enum_sp_data_access access=\n    (m_sp->daccess() == SP_DEFAULT_ACCESS) ?\n     SP_DEFAULT_ACCESS_MAPPING : m_sp->daccess();\n\n  DBUG_ENTER(\"STR\");\n\n  if (context->security_ctx)\n  {\n    \n    thd->security_ctx= context->security_ctx;\n  }\n\n  if (unlikely(sp_check_access(thd)))\n  {\n    thd->security_ctx= save_security_ctx;\n    DBUG_RETURN(TRUE);\n  }\n\n  \n\n  if (unlikely(!m_sp->detistic() && !trust_function_creators &&\n               (access == SP_CONTAINS_SQL || access == SP_MODIFIES_SQL_DATA) &&\n               (mysql_bin_log.is_open() &&\n                thd->variables.binlog_format == BINLOG_FORMAT_STMT)))\n  {\n    my_error(ER_BINLOG_UNSAFE_ROUTINE, MYF(0));\n    thd->security_ctx= save_security_ctx;\n    DBUG_RETURN(TRUE);\n  }\n\n  \n  thd->reset_sub_statement_state(&statement_state, SUB_STMT_FUNCTION);\n\n  \n  m_sp->agg_type();\n  DBUG_ASSERT(m_sp->agg_type() == GROUP_AGGREGATE ||\n              (m_sp->agg_type() == NOT_AGGREGATE && !func_ctx));\n  if (!func_ctx)\n  {\n    init_sql_alloc(&sp_mem_root, \"STR\", MEM_ROOT_BLOCK_SIZE, 0, MYF(0));\n    *sp_query_arena= Query_arena(&sp_mem_root,\n                                 Query_arena::STMT_INITIALIZED_FOR_SP);\n  }\n\n  bool err_status= m_sp->execute_function(thd, args, arg_count,\n                                          sp_result_field, &func_ctx,\n                                          sp_query_arena);\n  \n  if (err_status || func_ctx->quit_func)\n  {\n    \n    delete func_ctx;\n    func_ctx= NULL;\n    sp_query_arena->free_items();\n    free_root(&sp_mem_root, MYF(0));\n    memset(&sp_mem_root, 0, sizeof(sp_mem_root));\n  }\n  thd->restore_sub_statement_state(&statement_state);\n\n  thd->security_ctx= save_security_ctx;\n  DBUG_RETURN(err_status);\n}","23797":"static void restore_time_zone(FILE *sql_file,\n                              const char *delimiter)\n{\n  fprintf(sql_file,\n          \"STR\",\n          (const char *) delimiter);\n}","23338":"slapi_pblock_set_pwdpolicy(Slapi_PBlock *pb, passwdPolicy *pwdpolicy)\n{\n#ifdef PBLOCK_ANALYTICS\n    pblock_analytics_record(pb, SLAPI_PWDPOLICY);\n#endif\n    _pblock_assert_pb_intop(pb);\n    pb->pb_intop->pwdpolicy = pwdpolicy;\n}","22761":"static ssize_t hid_debug_events_read(struct file *file, char __user *buffer,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hid_debug_list *list = file->private_data;\n\tint ret = 0, len;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tmutex_lock(&list->read_mutex);\n\twhile (ret == 0) {\n\t\tif (list->head == list->tail) {\n\t\t\tadd_wait_queue(&list->hdev->debug_wait, &wait);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\t\twhile (list->head == list->tail) {\n\t\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\t\tret = -EAGAIN;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (signal_pending(current)) {\n\t\t\t\t\tret = -ERESTARTSYS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!list->hdev || !list->hdev->debug) {\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tmutex_unlock(&list->read_mutex);\n\t\t\t\tschedule();\n\t\t\t\tmutex_lock(&list->read_mutex);\n\t\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\t}\n\n\t\t\tset_current_state(TASK_RUNNING);\n\t\t\tremove_wait_queue(&list->hdev->debug_wait, &wait);\n\t\t}\n\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t\ncopy_rest:\n\t\tif (list->tail == list->head)\n\t\t\tgoto out;\n\t\tif (list->tail > list->head) {\n\t\t\tlen = list->tail - list->head;\n\t\t\tif (len > count)\n\t\t\t\tlen = count;\n\n\t\t\tif (copy_to_user(buffer + ret, &list->hid_debug_buf[list->head], len)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret += len;\n\t\t\tlist->head += len;\n\t\t} else {\n\t\t\tlen = HID_DEBUG_BUFSIZE - list->head;\n\t\t\tif (len > count)\n\t\t\t\tlen = count;\n\n\t\t\tif (copy_to_user(buffer, &list->hid_debug_buf[list->head], len)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlist->head = 0;\n\t\t\tret += len;\n\t\t\tcount -= len;\n\t\t\tif (count > 0)\n\t\t\t\tgoto copy_rest;\n\t\t}\n\n\t}\nout:\n\tmutex_unlock(&list->read_mutex);\n\treturn ret;\n}","23062":"static const char *next_u64(const char *s, uint64_t *num, int *rc)\n{\n\tchar *end = NULL;\n\n\tif (!s || !*s)\n\t\treturn s;\n\n\terrno = 0;\n\t*rc = -EINVAL;\n\t*num = (uint64_t) strtoumax(s, &end, 10);\n\tif (end == NULL || s == end)\n\t       return s;\n\tif (errno == 0 && (*end == ' ' || *end == '\\t' || *end == '\\0'))\n\t\t*rc = 0;\n\treturn end;\n}","22491":"printer_open(struct inode *inode, struct file *fd)\n{\n\tstruct printer_dev\t*dev;\n\tunsigned long\t\tflags;\n\tint\t\t\tret = -EBUSY;\n\n\tdev = container_of(inode->i_cdev, struct printer_dev, printer_cdev);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tif (dev->interface < 0) {\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!dev->printer_cdev_open) {\n\t\tdev->printer_cdev_open = 1;\n\t\tfd->private_data = dev;\n\t\tret = 0;\n\t\t\n\t\tdev->printer_status |= PRINTER_SELECTED;\n\t}\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tDBG(dev, \"STR\", ret);\n\treturn ret;\n}","22863":"static struct urb *uas_alloc_cmd_urb(struct uas_dev_info *devinfo, gfp_t gfp,\n\t\t\t\t\tstruct scsi_cmnd *cmnd)\n{\n\tstruct usb_device *udev = devinfo->udev;\n\tstruct scsi_device *sdev = cmnd->device;\n\tstruct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n\tstruct urb *urb = usb_alloc_urb(0, gfp);\n\tstruct command_iu *iu;\n\tint len;\n\n\tif (!urb)\n\t\tgoto out;\n\n\tlen = cmnd->cmd_len - 16;\n\tif (len < 0)\n\t\tlen = 0;\n\tlen = ALIGN(len, 4);\n\tiu = kzalloc(sizeof(*iu) + len, gfp);\n\tif (!iu)\n\t\tgoto free;\n\n\tiu->iu_id = IU_ID_COMMAND;\n\tiu->tag = cpu_to_be16(cmdinfo->uas_tag);\n\tiu->prio_attr = UAS_SIMPLE_TAG;\n\tiu->len = len;\n\tint_to_scsilun(sdev->lun, &iu->lun);\n\tmemcpy(iu->cdb, cmnd->cmnd, cmnd->cmd_len);\n\n\tusb_fill_bulk_urb(urb, udev, devinfo->cmd_pipe, iu, sizeof(*iu) + len,\n\t\t\t\t\t\t\tuas_cmd_cmplt, NULL);\n\turb->transfer_flags |= URB_FREE_BUFFER;\n out:\n\treturn urb;\n free:\n\tusb_free_urb(urb);\n\treturn NULL;\n}","23140":"static int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\n\treturn r;\n}","22623":"static UINT drdynvc_virtual_channel_event_data_received(drdynvcPlugin* drdynvc,\n        void* pData, UINT32 dataLength, UINT32 totalLength, UINT32 dataFlags)\n{\n\twStream* data_in;\n\n\tif ((dataFlags & CHANNEL_FLAG_SUSPEND) || (dataFlags & CHANNEL_FLAG_RESUME))\n\t{\n\t\treturn CHANNEL_RC_OK;\n\t}\n\n\tif (dataFlags & CHANNEL_FLAG_FIRST)\n\t{\n\t\tif (drdynvc->data_in)\n\t\t\tStream_Free(drdynvc->data_in, TRUE);\n\n\t\tdrdynvc->data_in = Stream_New(NULL, totalLength);\n\t}\n\n\tif (!(data_in = drdynvc->data_in))\n\t{\n\t\tWLog_Print(drdynvc->log, WLOG_ERROR, \"STR\");\n\t\treturn CHANNEL_RC_NO_MEMORY;\n\t}\n\n\tif (!Stream_EnsureRemainingCapacity(data_in, (int) dataLength))\n\t{\n\t\tWLog_Print(drdynvc->log, WLOG_ERROR, \"STR\");\n\t\tStream_Free(drdynvc->data_in, TRUE);\n\t\tdrdynvc->data_in = NULL;\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\tStream_Write(data_in, pData, dataLength);\n\n\tif (dataFlags & CHANNEL_FLAG_LAST)\n\t{\n\t\tif (Stream_Capacity(data_in) != Stream_GetPosition(data_in))\n\t\t{\n\t\t\tWLog_Print(drdynvc->log, WLOG_ERROR, \"STR\");\n\t\t\treturn ERROR_INVALID_DATA;\n\t\t}\n\n\t\tdrdynvc->data_in = NULL;\n\t\tStream_SealLength(data_in);\n\t\tStream_SetPosition(data_in, 0);\n\n\t\tif (!MessageQueue_Post(drdynvc->queue, NULL, 0, (void*) data_in, NULL))\n\t\t{\n\t\t\tWLog_Print(drdynvc->log, WLOG_ERROR, \"STR\");\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\t\t}\n\t}\n\n\treturn CHANNEL_RC_OK;\n}","23722":"void *Type_NamedColor_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n\n    cmsUInt32Number      vendorFlag;     \n    cmsUInt32Number      count;          \n    cmsUInt32Number      nDeviceCoords;  \n    char                 prefix[32];     \n    char                 suffix[32];     \n    cmsNAMEDCOLORLIST*  v;\n    cmsUInt32Number i;\n\n\n    *nItems = 0;\n    if (!_cmsReadUInt32Number(io, &vendorFlag)) return NULL;\n    if (!_cmsReadUInt32Number(io, &count)) return NULL;\n    if (!_cmsReadUInt32Number(io, &nDeviceCoords)) return NULL;\n\n    if (io -> Read(io, prefix, 32, 1) != 1) return NULL;\n    if (io -> Read(io, suffix, 32, 1) != 1) return NULL;\n\n    prefix[31] = suffix[31] = 0;\n\n    v = cmsAllocNamedColorList(self ->ContextID, count, nDeviceCoords, prefix, suffix);\n    if (v == NULL) {\n        cmsSignalError(self->ContextID, cmsERROR_RANGE, \"STR\", count);\n        return NULL;\n    }\n\n    if (nDeviceCoords > cmsMAXCHANNELS) {\n        cmsSignalError(self->ContextID, cmsERROR_RANGE, \"STR\", nDeviceCoords);\n        return 0;\n    }\n    for (i=0; i < count; i++) {\n\n        cmsUInt16Number PCS[3];\n        cmsUInt16Number Colorant[cmsMAXCHANNELS];\n        char Root[33];\n\n        memset(Colorant, 0, sizeof(Colorant));\n        if (io -> Read(io, Root, 32, 1) != 1) return NULL;\n        if (!_cmsReadUInt16Array(io, 3, PCS)) goto Error;\n        if (!_cmsReadUInt16Array(io, nDeviceCoords, Colorant)) goto Error;\n\n        if (!cmsAppendNamedColor(v, Root, PCS, Colorant)) goto Error;\n    }\n\n    *nItems = 1;\n    return (void*) v ;\n\nError:\n    cmsFreeNamedColorList(v);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}","22665":"static void tw5864_frame_interval_set(struct tw5864_input *input)\n{\n\t\n\tstruct tw5864_dev *dev = input->root;\n\tu32 unary_framerate = 0;\n\tint shift = 0;\n\tint std_max_fps = input->std == STD_NTSC ? 30 : 25;\n\n\tfor (shift = 0; shift < std_max_fps; shift += input->frame_interval)\n\t\tunary_framerate |= 0x00000001 << shift;\n\n\ttw_writel(TW5864_H264EN_RATE_CNTL_LO_WORD(input->nr, 0),\n\t\t  unary_framerate >> 16);\n\ttw_writel(TW5864_H264EN_RATE_CNTL_HI_WORD(input->nr, 0),\n\t\t  unary_framerate & 0xffff);\n}","23012":"nfs4_xdr_dec_getacl(struct rpc_rqst *rqstp, __be32 *p, size_t *acl_len)\n{\n\tstruct xdr_stream xdr;\n\tstruct compound_hdr hdr;\n\tint status;\n\n\txdr_init_decode(&xdr, &rqstp->rq_rcv_buf, p);\n\tstatus = decode_compound_hdr(&xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(&xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getacl(&xdr, rqstp, acl_len);\n\nout:\n\treturn status;\n}","23610":"static inline int forced_push(struct tcp_sock *tp)\n{\n\treturn after(tp->write_seq, tp->pushed_seq + (tp->max_window >> 1));\n}","22661":"_my_socket_unref (int lnr, my_socket_t so,\n                  void (*preclose)(void*), void *preclosearg)\n{\n  if (so)\n    {\n      so->refcount--;\n      if (opt_debug > 1)\n        log_debug (\"STR\",\n                   lnr, so, (int)so->fd, so->refcount);\n\n      if (!so->refcount)\n        {\n          if (preclose)\n            preclose (preclosearg);\n          assuan_sock_close (so->fd);\n          xfree (so);\n        }\n    }\n}","22991":"static inline bool sched_debug(void)\n{\n\treturn false;\n}","22944":"TEST_F(RenameCollectionTest, RenameDifferentDatabaseStayTempTrue) {\n    _testRenameCollectionStayTemp(_opCtx.get(), _sourceNss, _targetNssDifferentDb, true, true);\n}","22776":"static struct hlist_nulls_node *ct_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct hlist_nulls_node *head = ct_get_first(seq);\n\n\tif (head)\n\t\twhile (pos && (head = ct_get_next(seq, head)))\n\t\t\tpos--;\n\treturn pos ? NULL : head;\n}","23575":"static void huffman_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,\n                               int bits, int row, int offset, int *minimum)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_huffman_t *HUF = ID->huffman;\n\n  int16_t c[3] = {(int16_t)offset, (int16_t)offset, (int16_t)offset};\n  int col;\n  bit_state_t BS;\n\n  set_bit_state(&BS, (uint8_t *)ID->data + HUF->row_offsets.element[row]);\n\n  for (col = 0; col < ID->columns; col++)\n  {\n    int color;\n\n    for (color = 0; color < 3; color++)\n    {\n      uint16_t c_fix;\n\n      c[color] += get_huffman_diff(&BS, &HUF->tree);\n      if (c[color] < 0)\n      {\n        c_fix = 0;\n        if (c[color] < *minimum)\n          *minimum = c[color];\n      }\n      else\n      {\n        c_fix = c[color];\n      }\n\n      switch (ID->type_format)\n      {\n      case X3F_IMAGE_RAW_HUFFMAN_X530:\n      case X3F_IMAGE_RAW_HUFFMAN_10BIT:\n        HUF->x3rgb16.data[3 * (row * ID->columns + col) + color] =\n            (uint16_t)c_fix;\n        break;\n      case X3F_IMAGE_THUMB_HUFFMAN:\n        HUF->rgb8.data[3 * (row * ID->columns + col) + color] = (uint8_t)c_fix;\n        break;\n      default:\n        \n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      }\n    }\n  }\n}","23658":"ut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin) {\n\tut64 addr = 0LL;\n\tstruct symbol_t *symbols;\n\tint i;\n\n\tif (!(symbols = MACH0_(get_symbols) (bin))) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; !symbols[i].last; i++) {\n\t\tif (!strcmp (symbols[i].name, \"STR\")) {\n\t\t\taddr = symbols[i].addr;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree (symbols);\n\n\tif (!addr && bin->main_cmd.cmd == LC_MAIN) {\n\t\taddr = bin->entry + bin->baddr;\n\t}\n\n\tif (!addr) {\n\t\tut8 b[128];\n\t\tut64 entry = addr_to_offset(bin, bin->entry);\n\t\t\n\t\tif (entry > bin->size || entry + sizeof (b) > bin->size)\n\t\t\treturn 0;\n\t\ti = r_buf_read_at (bin->b, entry, b, sizeof (b));\n\t\tif (i < 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tif (b[i] == 0xe8 && !b[i+3] && !b[i+4]) {\n\t\t\t\tint delta = b[i+1] | (b[i+2] << 8) | (b[i+3] << 16) | (b[i+4] << 24);\n\t\t\t\treturn bin->entry + i + 5 + delta;\n\n\t\t\t}\n\t\t}\n\t}\n\treturn addr;\n}","23348":"    CiffComponent* CiffDirectory::doFindComponent(uint16_t crwTagId,\n                                                  uint16_t crwDir) const\n    {\n        CiffComponent* cc = NULL;\n        const Components::const_iterator b = components_.begin();\n        const Components::const_iterator e = components_.end();\n        for (Components::const_iterator i = b; i != e; ++i) {\n            cc = (*i)->findComponent(crwTagId, crwDir);\n            if (cc) return cc;\n        }\n        return 0;\n    } ","23071":"auth_generate_key(struct sc_card *card, int use_sm,\n\t\tstruct sc_cardctl_oberthur_genkey_info *data)\n{\n\tstruct sc_apdu apdu;\n\tunsigned char sbuf[SC_MAX_APDU_BUFFER_SIZE];\n\tstruct sc_path tmp_path;\n\tint rv = 0;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (data->key_bits < 512 || data->key_bits > 2048 ||\n\t\t\t(data->key_bits%0x20)!=0)   {\n\t\tLOG_TEST_RET(card->ctx, SC_ERROR_INVALID_ARGUMENTS, \"STR\");\n\t}\n\n\tsbuf[0] = (data->id_pub >> 8) & 0xFF;\n\tsbuf[1] = data->id_pub & 0xFF;\n\tsbuf[2] = (data->id_prv >> 8) & 0xFF;\n\tsbuf[3] = data->id_prv & 0xFF;\n\tif (data->exponent != 0x10001)   {\n\t\trv = auth_encode_exponent(data->exponent, &sbuf[5],SC_MAX_APDU_BUFFER_SIZE-6);\n\t\tLOG_TEST_RET(card->ctx, rv, \"STR\");\n\n\t\tsbuf[4] = rv;\n\t\trv++;\n\t}\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0x46, 0x00, 0x00);\n\tapdu.resp = calloc(1, data->key_bits\/8+8);\n\tif (!apdu.resp)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tapdu.resplen = data->key_bits\/8+8;\n\tapdu.lc = rv + 4;\n\tapdu.le = data->key_bits\/8;\n\tapdu.data = sbuf;\n\tapdu.datalen = rv + 4;\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, rv, \"STR\");\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, rv, \"STR\");\n\n\tmemset(&tmp_path, 0, sizeof(struct sc_path));\n\ttmp_path.type = SC_PATH_TYPE_FILE_ID;\n\ttmp_path.len = 2;\n\tmemcpy(tmp_path.value, sbuf, 2);\n\n\trv = auth_select_file(card, &tmp_path, NULL);\n\tLOG_TEST_RET(card->ctx, rv, \"STR\");\n\n\trv = auth_read_component(card, SC_CARDCTL_OBERTHUR_KEY_RSA_PUBLIC,\n\t\t\t1, apdu.resp, data->key_bits\/8);\n\tLOG_TEST_RET(card->ctx, rv, \"STR\");\n\n\tapdu.resplen = rv;\n\n\tif (data->pubkey)   {\n\t\tif (data->pubkey_len < apdu.resplen)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\n\t\tmemcpy(data->pubkey,apdu.resp,apdu.resplen);\n\t}\n\n\tdata->pubkey_len = apdu.resplen;\n\tfree(apdu.resp);\n\n\tsc_log(card->ctx, \"STR\",\n\t       apdu.resplen);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}","23641":"DecimalQuantity::DecimalQuantity(DecimalQuantity&& src) U_NOEXCEPT {\n    *this = std::move(src);\n}","22833":"Status AuthorizationManager::getBSONForRole(RoleGraph* graph,\n                                            const RoleName& roleName,\n                                            mutablebson::Element result) {\n    if (!graph->roleExists(roleName)) {\n        return Status(ErrorCodes::RoleNotFound,\n                      mongoutils::str::stream() << roleName.getFullName()\n                                                << \"STR\");\n    }\n    std::string id = mongoutils::str::stream() << roleName.getDB() << \"STR\" << roleName.getRole();\n    result.appendString(\"STR\", id).transitional_ignore();\n    result.appendString(ROLE_NAME_FIELD_NAME, roleName.getRole()).transitional_ignore();\n    result.appendString(ROLE_DB_FIELD_NAME, roleName.getDB()).transitional_ignore();\n\n    \n    mutablebson::Element privilegesArrayElement =\n        result.getDocument().makeElementArray(\"STR\");\n    result.pushBack(privilegesArrayElement).transitional_ignore();\n    const PrivilegeVector& privileges = graph->getDirectPrivileges(roleName);\n    Status status = getBSONForPrivileges(privileges, privilegesArrayElement);\n    if (!status.isOK()) {\n        return status;\n    }\n\n    \n    mutablebson::Element rolesArrayElement = result.getDocument().makeElementArray(\"STR\");\n    result.pushBack(rolesArrayElement).transitional_ignore();\n    for (RoleNameIterator roles = graph->getDirectSubordinates(roleName); roles.more();\n         roles.next()) {\n        const RoleName& subRole = roles.get();\n        mutablebson::Element roleObj = result.getDocument().makeElementObject(\"\");\n        roleObj.appendString(ROLE_NAME_FIELD_NAME, subRole.getRole()).transitional_ignore();\n        roleObj.appendString(ROLE_DB_FIELD_NAME, subRole.getDB()).transitional_ignore();\n        rolesArrayElement.pushBack(roleObj).transitional_ignore();\n    }\n\n    return Status::OK();\n}","23772":"void dd_close(struct dump_dir *dd)\n{\n    if (!dd)\n        return;\n\n    dd_unlock(dd);\n    if (dd->next_dir)\n    {\n        closedir(dd->next_dir);\n        \n    }\n\n    free(dd->dd_type);\n    free(dd->dd_dirname);\n    free(dd);\n}","22838":"static void svcxdr_init_encode_from_buffer(struct xdr_stream *xdr,\n\t\t\t\tstruct xdr_buf *buf, __be32 *p, int bytes)\n{\n\txdr->scratch.iov_len = 0;\n\tmemset(buf, 0, sizeof(struct xdr_buf));\n\tbuf->head[0].iov_base = p;\n\tbuf->head[0].iov_len = 0;\n\tbuf->len = 0;\n\txdr->buf = buf;\n\txdr->iov = buf->head;\n\txdr->p = p;\n\txdr->end = (void *)p + bytes;\n\tbuf->buflen = bytes;\n}","22476":"check_mountpoint(const char *progname, char *mountpoint)\n{\n\tint err;\n\tstruct stat statbuf;\n\n\t\n\terr = stat(mountpoint, &statbuf);\n\tif (err) {\n\t\tfprintf(stderr, \"STR\", progname,\n\t\t\t\tmountpoint, strerror(errno));\n\t\treturn EX_USAGE;\n\t}\n\n\tif (!S_ISDIR(statbuf.st_mode)) {\n\t\tfprintf(stderr, \"STR\", progname,\n\t\t\t\tmountpoint);\n\t\treturn EX_USAGE;\n\t}\n\n#if CIFS_LEGACY_SETUID_CHECK\n\t\n\tif (!getuid() || geteuid())\n\t\treturn 0;\n\n\tif (statbuf.st_uid != getuid()) {\n\t\tfprintf(stderr, \"STR\", progname,\n\t\t\tmountpoint);\n\t\treturn EX_USAGE;\n\t}\n\n\tif ((statbuf.st_mode & S_IRWXU) != S_IRWXU) {\n\t\tfprintf(stderr, \"STR\", progname,\n\t\t\tmountpoint);\n\t\treturn EX_USAGE;\n\t}\n#endif \n\n\treturn 0;\n}","23032":"static int ext4_get_block_write(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create)\n{\n\thandle_t *handle = NULL;\n\tint ret = 0;\n\tunsigned max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint dio_credits;\n\n\text4_debug(\"STR\",\n\t\t   inode->i_ino, create);\n\t\n\tcreate = EXT4_GET_BLOCKS_IO_CREATE_EXT;\n\n\tif (max_blocks > DIO_MAX_BLOCKS)\n\t\tmax_blocks = DIO_MAX_BLOCKS;\n\tdio_credits = ext4_chunk_trans_blocks(inode, max_blocks);\n\thandle = ext4_journal_start(inode, dio_credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\tret = ext4_get_blocks(handle, inode, iblock, max_blocks, bh_result,\n\t\t\t      create);\n\tif (ret > 0) {\n\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tret = 0;\n\t}\n\text4_journal_stop(handle);\nout:\n\treturn ret;\n}","23773":"static inline int try_force_unload(unsigned int flags)\n{\n\tint ret = (flags & O_TRUNC);\n\tif (ret)\n\t\tadd_taint(TAINT_FORCED_RMMOD, LOCKDEP_NOW_UNRELIABLE);\n\treturn ret;\n}","22846":"static size_t trhash_compare(void *k1, size_t k1_len, void *k2, size_t k2_len)\n{\n  (void)k1_len;\n  (void)k2_len;\n\n  return *(struct Curl_easy **)k1 == *(struct Curl_easy **)k2;\n}","23131":"static struct tcf_proto *tcf_chain_tp_prev(struct tcf_chain *chain,\n\t\t\t\t\t   struct tcf_chain_info *chain_info)\n{\n\treturn tcf_chain_dereference(*chain_info->pprev, chain);\n}","22710":"jas_matrix_t *jas_matrix_create(int numrows, int numcols)\n{\n\tjas_matrix_t *matrix;\n\tint i;\n\n\tif (numrows < 0 || numcols < 0) {\n\t\treturn 0;\n\t}\n\n\tif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\n\t\treturn 0;\n\t}\n\tmatrix->flags_ = 0;\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\tmatrix->rows_ = 0;\n\tmatrix->maxrows_ = numrows;\n\tmatrix->data_ = 0;\n\tmatrix->datasize_ = numrows * numcols;\n\n\tif (matrix->maxrows_ > 0) {\n\t\tif (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,\n\t\t  sizeof(jas_seqent_t *)))) {\n\t\t\tjas_matrix_destroy(matrix);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (matrix->datasize_ > 0) {\n\t\tif (!(matrix->data_ = jas_alloc2(matrix->datasize_,\n\t\t  sizeof(jas_seqent_t)))) {\n\t\t\tjas_matrix_destroy(matrix);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < numrows; ++i) {\n\t\tmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];\n\t}\n\n\tfor (i = 0; i < matrix->datasize_; ++i) {\n\t\tmatrix->data_[i] = 0;\n\t}\n\n\tmatrix->xstart_ = 0;\n\tmatrix->ystart_ = 0;\n\tmatrix->xend_ = matrix->numcols_;\n\tmatrix->yend_ = matrix->numrows_;\n\n\treturn matrix;\n}","23546":"MagickPrivate void SetPixelCacheMethods(Cache cache,CacheMethods *cache_methods)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  GetOneAuthenticPixelFromHandler\n    get_one_authentic_pixel_from_handler;\n\n  GetOneVirtualPixelFromHandler\n    get_one_virtual_pixel_from_handler;\n\n  \n  assert(cache != (Cache) NULL);\n  assert(cache_methods != (CacheMethods *) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"STR\",\n      cache_info->filename);\n  if (cache_methods->get_virtual_pixel_handler != (GetVirtualPixelHandler) NULL)\n    cache_info->methods.get_virtual_pixel_handler=\n      cache_methods->get_virtual_pixel_handler;\n  if (cache_methods->destroy_pixel_handler != (DestroyPixelHandler) NULL)\n    cache_info->methods.destroy_pixel_handler=\n      cache_methods->destroy_pixel_handler;\n  if (cache_methods->get_virtual_metacontent_from_handler !=\n      (GetVirtualMetacontentFromHandler) NULL)\n    cache_info->methods.get_virtual_metacontent_from_handler=\n      cache_methods->get_virtual_metacontent_from_handler;\n  if (cache_methods->get_authentic_pixels_handler !=\n      (GetAuthenticPixelsHandler) NULL)\n    cache_info->methods.get_authentic_pixels_handler=\n      cache_methods->get_authentic_pixels_handler;\n  if (cache_methods->queue_authentic_pixels_handler !=\n      (QueueAuthenticPixelsHandler) NULL)\n    cache_info->methods.queue_authentic_pixels_handler=\n      cache_methods->queue_authentic_pixels_handler;\n  if (cache_methods->sync_authentic_pixels_handler !=\n      (SyncAuthenticPixelsHandler) NULL)\n    cache_info->methods.sync_authentic_pixels_handler=\n      cache_methods->sync_authentic_pixels_handler;\n  if (cache_methods->get_authentic_pixels_from_handler !=\n      (GetAuthenticPixelsFromHandler) NULL)\n    cache_info->methods.get_authentic_pixels_from_handler=\n      cache_methods->get_authentic_pixels_from_handler;\n  if (cache_methods->get_authentic_metacontent_from_handler !=\n      (GetAuthenticMetacontentFromHandler) NULL)\n    cache_info->methods.get_authentic_metacontent_from_handler=\n      cache_methods->get_authentic_metacontent_from_handler;\n  get_one_virtual_pixel_from_handler=\n    cache_info->methods.get_one_virtual_pixel_from_handler;\n  if (get_one_virtual_pixel_from_handler !=\n      (GetOneVirtualPixelFromHandler) NULL)\n    cache_info->methods.get_one_virtual_pixel_from_handler=\n      cache_methods->get_one_virtual_pixel_from_handler;\n  get_one_authentic_pixel_from_handler=\n    cache_methods->get_one_authentic_pixel_from_handler;\n  if (get_one_authentic_pixel_from_handler !=\n      (GetOneAuthenticPixelFromHandler) NULL)\n    cache_info->methods.get_one_authentic_pixel_from_handler=\n      cache_methods->get_one_authentic_pixel_from_handler;\n}","23278":"static inline void security_req_classify_flow(const struct request_sock *req, struct flowi *fl)\n{\n}","22819":"syslog_connect(void)\n{\n#ifdef SUNOS_5\n  return -1;\n#else\n  int fd;\n  char *s;\n  struct sockaddr_un addr;\n\n  if ((fd = socket(AF_UNIX,SOCK_DGRAM,0)) < 0)\n    return -1;\n  addr.sun_family = AF_UNIX;\n#ifdef _PATH_LOG\n\n#else\n\n#endif\n  s = str_append(addr.sun_path,sizeof(addr.sun_path),SYSLOG_SOCKET_PATH);\n#undef SYSLOG_SOCKET_PATH\n  *s = '\\0';\n  if (connect(fd,(struct sockaddr *)&addr,sizeof(addr)) < 0)\n    {\n      close(fd);\n      return -1;\n    }\n  return fd;\n#endif\n}","23538":"psutil_per_cpu_times(PyObject *self, PyObject *args) {\n    natural_t cpu_count;\n    natural_t i;\n    processor_info_array_t info_array;\n    mach_msg_type_number_t info_count;\n    kern_return_t error;\n    processor_cpu_load_info_data_t *cpu_load_info = NULL;\n    int ret;\n    PyObject *py_retlist = PyList_New(0);\n    PyObject *py_cputime = NULL;\n\n    if (py_retlist == NULL)\n        return NULL;\n\n    mach_port_t host_port = mach_host_self();\n    error = host_processor_info(host_port, PROCESSOR_CPU_LOAD_INFO,\n                                &cpu_count, &info_array, &info_count);\n    if (error != KERN_SUCCESS) {\n        PyErr_Format(\n            PyExc_RuntimeError,\n            \"STR\",\n             mach_error_string(error));\n        goto error;\n    }\n    mach_port_deallocate(mach_task_self(), host_port);\n\n    cpu_load_info = (processor_cpu_load_info_data_t *) info_array;\n\n    for (i = 0; i < cpu_count; i++) {\n        py_cputime = Py_BuildValue(\n            \"STR\",\n            (double)cpu_load_info[i].cpu_ticks[CPU_STATE_USER] \/ CLK_TCK,\n            (double)cpu_load_info[i].cpu_ticks[CPU_STATE_NICE] \/ CLK_TCK,\n            (double)cpu_load_info[i].cpu_ticks[CPU_STATE_SYSTEM] \/ CLK_TCK,\n            (double)cpu_load_info[i].cpu_ticks[CPU_STATE_IDLE] \/ CLK_TCK\n        );\n        if (!py_cputime)\n            goto error;\n        if (PyList_Append(py_retlist, py_cputime))\n            goto error;\n        Py_DECREF(py_cputime);\n    }\n\n    ret = vm_deallocate(mach_task_self(), (vm_address_t)info_array,\n                        info_count * sizeof(int));\n    if (ret != KERN_SUCCESS)\n        PyErr_WarnEx(PyExc_RuntimeWarning, \"STR\", 2);\n    return py_retlist;\n\nerror:\n    Py_XDECREF(py_cputime);\n    Py_DECREF(py_retlist);\n    if (cpu_load_info != NULL) {\n        ret = vm_deallocate(mach_task_self(), (vm_address_t)info_array,\n                            info_count * sizeof(int));\n        if (ret != KERN_SUCCESS)\n            PyErr_WarnEx(PyExc_RuntimeWarning, \"STR\", 2);\n    }\n    return NULL;\n}","23084":"gxps_archive_read_entry (GXPSArchive *archive,\n\t\t\t const gchar *path,\n\t\t\t guchar     **buffer,\n\t\t\t gsize       *bytes_read,\n\t\t\t GError     **error)\n{\n\tGInputStream *stream;\n\tgssize        entry_size;\n\tgboolean      retval;\n\n\tstream = gxps_archive_open (archive, path);\n\tif (!stream)\n\t\t\n\t\treturn FALSE;\n\n\tentry_size = archive_entry_size (GXPS_ARCHIVE_INPUT_STREAM (stream)->entry);\n\tif (entry_size <= 0) {\n\t\tgssize bytes;\n\t\tguchar buf[BUFFER_SIZE];\n\t\tguint  buffer_size = BUFFER_SIZE * 4;\n\n\t\t\n\t\t*bytes_read = 0;\n\t\t*buffer = g_malloc (buffer_size);\n\t\tdo {\n\t\t\tbytes = g_input_stream_read (stream, &buf, BUFFER_SIZE, NULL, error);\n\t\t\tif (*error != NULL) {\n\t\t\t\tg_free (*buffer);\n\t\t\t\tg_object_unref (stream);\n\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tif (*bytes_read + bytes > buffer_size) {\n\t\t\t\tbuffer_size += BUFFER_SIZE * 4;\n\t\t\t\t*buffer = g_realloc (*buffer, buffer_size);\n\t\t\t}\n\t\t\tmemcpy (*buffer + *bytes_read, buf, bytes);\n\t\t\t*bytes_read += bytes;\n\t\t} while (bytes > 0);\n\n\t\tg_object_unref (stream);\n\n\t\tif (*bytes_read == 0) {\n\t\t\t\n\t\t\tg_free (*buffer);\n\t\t\treturn FALSE;\n\t\t}\n\n\t\treturn TRUE;\n\t}\n\n\t*buffer = g_malloc (entry_size);\n\tretval = g_input_stream_read_all (stream,\n\t\t\t\t\t  *buffer, entry_size,\n\t\t\t\t\t  bytes_read, NULL,\n\t\t\t\t\t  error);\n\tif (!retval)\n\t\tg_free (*buffer);\n\n\tg_object_unref (stream);\n\n\treturn retval;\n}","23760":"static void k_shift(struct vc_data *vc, unsigned char value, char up_flag)\n{\n\tint old_state = shift_state;\n\n\tif (rep)\n\t\treturn;\n\t\n\tif (value == KVAL(K_CAPSSHIFT)) {\n\t\tvalue = KVAL(K_SHIFT);\n\t\tif (!up_flag)\n\t\t\tclr_vc_kbd_led(kbd, VC_CAPSLOCK);\n\t}\n\n\tif (up_flag) {\n\t\t\n\t\tif (shift_down[value])\n\t\t\tshift_down[value]--;\n\t} else\n\t\tshift_down[value]++;\n\n\tif (shift_down[value])\n\t\tshift_state |= (1 << value);\n\telse\n\t\tshift_state &= ~(1 << value);\n\n\t\n\tif (up_flag && shift_state != old_state && npadch != -1) {\n\t\tif (kbd->kbdmode == VC_UNICODE)\n\t\t\tto_utf8(vc, npadch);\n\t\telse\n\t\t\tput_queue(vc, npadch & 0xff);\n\t\tnpadch = -1;\n\t}\n}","23707":"se::DeviceMemory<Scalar> AsDeviceMemory(const Scalar* gpu_memory) {\n  se::DeviceMemoryBase wrapped(const_cast<Scalar*>(gpu_memory));\n  se::DeviceMemory<Scalar> typed(wrapped);\n  return typed;\n}","22975":"decodenetnum(\n\tconst char *num,\n\tsockaddr_u *netnum\n\t)\n{\n\tstruct addrinfo hints, *ai = NULL;\n\tint err;\n\tu_short port;\n\tconst char *cp;\n\tconst char *port_str;\n\tchar *pp;\n\tchar *np;\n\tchar name[80];\n\n\tREQUIRE(num != NULL);\n\tREQUIRE(strlen(num) < sizeof(name));\n\n\tport_str = NULL;\n\tif ('[' != num[0]) {\n\t\t\n\t\tpp = strchr(num, ':');\n\t\tif (NULL == pp)\n\t\t\tcp = num;\t\n\t\telse if (NULL != strchr(pp + 1, ':'))\n\t\t\tcp = num;\t\n\t\telse {\t\t\t\n\t\t\tstrlcpy(name, num, sizeof(name));\n\t\t\tcp = name;\n\t\t\tpp = strchr(cp, ':');\n\t\t\t*pp = '\\0';\n\t\t\tport_str = pp + 1;\n\t\t}\n\t} else {\n\t\tcp = num + 1;\n\t\tnp = name; \n\t\twhile (*cp && ']' != *cp)\n\t\t\t*np++ = *cp++;\n\t\t*np = 0;\n\t\tif (']' == cp[0] && ':' == cp[1] && '\\0' != cp[2])\n\t\t\tport_str = &cp[2];\n\t\tcp = name; \n\t}\n\tZERO(hints);\n\thints.ai_flags = Z_AI_NUMERICHOST;\n\terr = getaddrinfo(cp, \"STR\", &hints, &ai);\n\tif (err != 0)\n\t\treturn 0;\n\tINSIST(ai->ai_addrlen <= sizeof(*netnum));\n\tZERO(*netnum);\n\tmemcpy(netnum, ai->ai_addr, ai->ai_addrlen);\n\tfreeaddrinfo(ai);\n\tif (NULL == port_str || 1 != sscanf(port_str, \"STR\", &port))\n\t\tport = NTP_PORT;\n\tSET_PORT(netnum, port);\n\treturn 1;\n}","23321":"static int process_head_file_extra(struct archive_read* a,\n    struct archive_entry* e, struct rar5* rar, ssize_t extra_data_size)\n{\n\tsize_t extra_field_size;\n\tsize_t extra_field_id = 0;\n\tint ret = ARCHIVE_FATAL;\n\tsize_t var_size;\n\n\twhile(extra_data_size > 0) {\n\t\tif(!read_var_sized(a, &extra_field_size, &var_size))\n\t\t\treturn ARCHIVE_EOF;\n\n\t\textra_data_size -= var_size;\n\t\tif(ARCHIVE_OK != consume(a, var_size)) {\n\t\t\treturn ARCHIVE_EOF;\n\t\t}\n\n\t\tif(!read_var_sized(a, &extra_field_id, &var_size))\n\t\t\treturn ARCHIVE_EOF;\n\n\t\textra_data_size -= var_size;\n\t\tif(ARCHIVE_OK != consume(a, var_size)) {\n\t\t\treturn ARCHIVE_EOF;\n\t\t}\n\n\t\tswitch(extra_field_id) {\n\t\t\tcase EX_HASH:\n\t\t\t\tret = parse_file_extra_hash(a, rar,\n\t\t\t\t    &extra_data_size);\n\t\t\t\tbreak;\n\t\t\tcase EX_HTIME:\n\t\t\t\tret = parse_file_extra_htime(a, e, rar,\n\t\t\t\t    &extra_data_size);\n\t\t\t\tbreak;\n\t\t\tcase EX_REDIR:\n\t\t\t\tret = parse_file_extra_redir(a, e, rar,\n\t\t\t\t    &extra_data_size);\n\t\t\t\tbreak;\n\t\t\tcase EX_UOWNER:\n\t\t\t\tret = parse_file_extra_owner(a, e,\n\t\t\t\t    &extra_data_size);\n\t\t\t\tbreak;\n\t\t\tcase EX_VERSION:\n\t\t\t\tret = parse_file_extra_version(a, e,\n\t\t\t\t    &extra_data_size);\n\t\t\t\tbreak;\n\t\t\tcase EX_CRYPT:\n\t\t\t\t\n\t\t\tcase EX_SUBDATA:\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\t\n\t\t\t\treturn consume(a, extra_data_size);\n\t\t}\n\t}\n\n\tif(ret != ARCHIVE_OK) {\n\t\t\n\t\treturn ret;\n\t}\n\n\treturn ARCHIVE_OK;\n}","23301":"ZEND_API int ZEND_FASTCALL string_compare_function(zval *op1, zval *op2) \n{\n\tif (EXPECTED(Z_TYPE_P(op1) == IS_STRING) &&\n\t    EXPECTED(Z_TYPE_P(op2) == IS_STRING)) {\n\t\tif (Z_STR_P(op1) == Z_STR_P(op2)) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn zend_binary_strcmp(Z_STRVAL_P(op1), Z_STRLEN_P(op1), Z_STRVAL_P(op2), Z_STRLEN_P(op2));\n\t\t}\n\t} else {\n\t\tzend_string *tmp_str1, *tmp_str2;\n\t\tzend_string *str1 = zval_get_tmp_string(op1, &tmp_str1);\n\t\tzend_string *str2 = zval_get_tmp_string(op2, &tmp_str2);\n\t\tint ret = zend_binary_strcmp(ZSTR_VAL(str1), ZSTR_LEN(str1), ZSTR_VAL(str2), ZSTR_LEN(str2));\n\n\t\tzend_tmp_string_release(tmp_str1);\n\t\tzend_tmp_string_release(tmp_str2);\n\t\treturn ret;\n\t}\n}","23215":"input_csi_dispatch_sm(struct input_ctx *ictx)\n{\n\tu_int\ti;\n\n\tfor (i = 0; i < ictx->param_list_len; i++) {\n\t\tswitch (input_get(ictx, i, 0, -1)) {\n\t\tcase -1:\n\t\t\tbreak;\n\t\tcase 4:\t\t\n\t\t\tscreen_write_mode_set(&ictx->ctx, MODE_INSERT);\n\t\t\tbreak;\n\t\tcase 34:\n\t\t\tscreen_write_mode_clear(&ictx->ctx, MODE_BLINKING);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlog_debug(\"STR\", __func__, ictx->ch);\n\t\t\tbreak;\n\t\t}\n\t}\n}","23614":"static void iscsi_transport_release(struct device *dev)\n{\n\tstruct iscsi_internal *priv = dev_to_iscsi_internal(dev);\n\tkfree(priv);\n}","22688":"static void print_word(BIO *bp,BN_ULONG w)\n\t{\n#ifdef SIXTY_FOUR_BIT\n\tif (sizeof(w) > sizeof(unsigned long))\n\t\t{\n\t\tunsigned long\th=(unsigned long)(w>>32),\n\t\t\t\tl=(unsigned long)(w);\n\n\t\tif (h)\tBIO_printf(bp,\"STR\",h,l);\n\t\telse\tBIO_printf(bp,\"STR\",l);\n\t\treturn;\n\t\t}\n#endif\n\tBIO_printf(bp,BN_HEX_FMT1,w);\n\t}","22681":"static void voutf(struct GlobalConfig *config,\n                  const char *prefix,\n                  const char *fmt,\n                  va_list ap)\n{\n  size_t width = (79 - strlen(prefix));\n  if(!config->mute) {\n    size_t len;\n    char *ptr;\n    char print_buffer[256];\n\n    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);\n\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(prefix, config->errors);\n\n      if(len > width) {\n        size_t cut = width-1;\n\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n        if(0 == cut)\n          \n          cut = width-1;\n\n        (void)fwrite(ptr, cut + 1, 1, config->errors);\n        fputs(\"STR\", config->errors);\n        ptr += cut + 1; \n        len -= cut;\n      }\n      else {\n        fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n  }\n}","22678":"\nstatic enum gro_result dev_gro_receive(struct napi_struct *napi, struct sk_buff *skb)\n{\n\tstruct sk_buff **pp = NULL;\n\tstruct packet_offload *ptype;\n\t__be16 type = skb->protocol;\n\tstruct list_head *head = &offload_base;\n\tint same_flow;\n\tenum gro_result ret;\n\tint grow;\n\n\tif (!(skb->dev->features & NETIF_F_GRO))\n\t\tgoto normal;\n\n\tif (skb_is_gso(skb) || skb_has_frag_list(skb) || skb->csum_bad)\n\t\tgoto normal;\n\n\tgro_list_prepare(napi, skb);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ptype, head, list) {\n\t\tif (ptype->type != type || !ptype->callbacks.gro_receive)\n\t\t\tcontinue;\n\n\t\tskb_set_network_header(skb, skb_gro_offset(skb));\n\t\tskb_reset_mac_len(skb);\n\t\tNAPI_GRO_CB(skb)->same_flow = 0;\n\t\tNAPI_GRO_CB(skb)->flush = 0;\n\t\tNAPI_GRO_CB(skb)->free = 0;\n\t\tNAPI_GRO_CB(skb)->udp_mark = 0;\n\t\tNAPI_GRO_CB(skb)->gro_remcsum_start = 0;\n\n\t\t\n\t\tswitch (skb->ip_summed) {\n\t\tcase CHECKSUM_COMPLETE:\n\t\t\tNAPI_GRO_CB(skb)->csum = skb->csum;\n\t\t\tNAPI_GRO_CB(skb)->csum_valid = 1;\n\t\t\tNAPI_GRO_CB(skb)->csum_cnt = 0;\n\t\t\tbreak;\n\t\tcase CHECKSUM_UNNECESSARY:\n\t\t\tNAPI_GRO_CB(skb)->csum_cnt = skb->csum_level + 1;\n\t\t\tNAPI_GRO_CB(skb)->csum_valid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNAPI_GRO_CB(skb)->csum_cnt = 0;\n\t\t\tNAPI_GRO_CB(skb)->csum_valid = 0;\n\t\t}\n\n\t\tpp = ptype->callbacks.gro_receive(&napi->gro_list, skb);\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\tif (&ptype->list == head)\n\t\tgoto normal;\n\n\tsame_flow = NAPI_GRO_CB(skb)->same_flow;\n\tret = NAPI_GRO_CB(skb)->free ? GRO_MERGED_FREE : GRO_MERGED;\n\n\tif (pp) {\n\t\tstruct sk_buff *nskb = *pp;\n\n\t\t*pp = nskb->next;\n\t\tnskb->next = NULL;\n\t\tnapi_gro_complete(nskb);\n\t\tnapi->gro_count--;\n\t}\n\n\tif (same_flow)\n\t\tgoto ok;\n\n\tif (NAPI_GRO_CB(skb)->flush)\n\t\tgoto normal;\n\n\tif (unlikely(napi->gro_count >= MAX_GRO_SKBS)) {\n\t\tstruct sk_buff *nskb = napi->gro_list;\n\n\t\t\n\t\twhile (nskb->next) {\n\t\t\tpp = &nskb->next;\n\t\t\tnskb = *pp;\n\t\t}\n\t\t*pp = NULL;\n\t\tnskb->next = NULL;\n\t\tnapi_gro_complete(nskb);\n\t} else {\n\t\tnapi->gro_count++;\n\t}\n\tNAPI_GRO_CB(skb)->count = 1;\n\tNAPI_GRO_CB(skb)->age = jiffies;\n\tNAPI_GRO_CB(skb)->last = skb;\n\tskb_shinfo(skb)->gso_size = skb_gro_len(skb);\n\tskb->next = napi->gro_list;\n\tnapi->gro_list = skb;\n\tret = GRO_HELD;\n\npull:\n\tgrow = skb_gro_offset(skb) - skb_headlen(skb);\n\tif (grow > 0)\n\t\tgro_pull_from_frag0(skb, grow);\nok:\n\treturn ret;\n\nnormal:\n\tret = GRO_NORMAL;\n\tgoto pull;","23494":"server_client_unref(struct client *c)\n{\n\tlog_debug(\"STR\", c, c->references);\n\n\tc->references--;\n\tif (c->references == 0)\n\t\tevent_once(-1, EV_TIMEOUT, server_client_free, c, NULL);\n}","22751":"NTSTATUS dcerpc_server_lsa_init(TALLOC_CTX *ctx)\n{\n\tNTSTATUS ret;\n\n\tret = dcerpc_server_dssetup_init(ctx);\n\tif (!NT_STATUS_IS_OK(ret)) {\n\t\treturn ret;\n\t}\n\tret = dcerpc_server_lsarpc_init(ctx);\n\tif (!NT_STATUS_IS_OK(ret)) {\n\t\treturn ret;\n\t}\n\treturn ret;\n}","22642":"void Huff_Compress(msg_t *mbuf, int offset) {\n\tint\t\t\ti, ch, size;\n\tbyte\t\tseq[65536];\n\tbyte*\t\tbuffer;\n\thuff_t\t\thuff;\n\n\tsize = mbuf->cursize - offset;\n\tbuffer = mbuf->data+ + offset;\n\n\tif (size<=0) {\n\t\treturn;\n\t}\n\n\tCom_Memset(&huff, 0, sizeof(huff_t));\n\t\n\thuff.tree = huff.lhead = huff.loc[NYT] =  &(huff.nodeList[huff.blocNode++]);\n\thuff.tree->symbol = NYT;\n\thuff.tree->weight = 0;\n\thuff.lhead->next = huff.lhead->prev = NULL;\n\thuff.tree->parent = huff.tree->left = huff.tree->right = NULL;\n\n\tseq[0] = (size>>8);\n\tseq[1] = size&0xff;\n\n\tbloc = 16;\n\n\tfor (i=0; i<size; i++ ) {\n\t\tch = buffer[i];\n\t\tHuff_transmit(&huff, ch, seq);\t\t\t\t\t\t\n\t\tHuff_addRef(&huff, (byte)ch);\t\t\t\t\t\t\t\t\n\t}\n\n\tbloc += 8;\t\t\t\t\t\t\t\t\t\t\t\t\n\n\tmbuf->cursize = (bloc>>3) + offset;\n\tCom_Memcpy(mbuf->data+offset, seq, (bloc>>3));\n}","22753":"static bool checkreturn pb_decode_varint32_eof(pb_istream_t *stream, uint32_t *dest, bool *eof)\n{\n    pb_byte_t byte;\n    uint32_t result;\n    \n    if (!pb_readbyte(stream, &byte))\n    {\n        if (stream->bytes_left == 0)\n        {\n            if (eof)\n            {\n                *eof = true;\n            }\n        }\n\n        return false;\n    }\n    \n    if ((byte & 0x80) == 0)\n    {\n        \n        result = byte;\n    }\n    else\n    {\n        \n        uint_fast8_t bitpos = 7;\n        result = byte & 0x7F;\n        \n        do\n        {\n            if (!pb_readbyte(stream, &byte))\n                return false;\n            \n            if (bitpos >= 32)\n            {\n                \n                pb_byte_t sign_extension = (bitpos < 63) ? 0xFF : 0x01;\n                bool valid_extension = ((byte & 0x7F) == 0x00 ||\n                         ((result >> 31) != 0 && byte == sign_extension));\n\n                if (bitpos >= 64 || !valid_extension)\n                {\n                    PB_RETURN_ERROR(stream, \"STR\");\n                }\n            }\n            else\n            {\n                result |= (uint32_t)(byte & 0x7F) << bitpos;\n            }\n            bitpos = (uint_fast8_t)(bitpos + 7);\n        } while (byte & 0x80);\n        \n        if (bitpos == 35 && (byte & 0x70) != 0)\n        {\n            \n            PB_RETURN_ERROR(stream, \"STR\");\n        }\n   }\n   \n   *dest = result;\n   return true;\n}","22972":"TEST_P(Security, BuiltinAuthenticationAndCryptoPlugin_besteffort_rtps_ok)\n{\n    PubSubReader<HelloWorldType> reader(TEST_TOPIC_NAME);\n    PubSubWriter<HelloWorldType> writer(TEST_TOPIC_NAME);\n\n    PropertyPolicy pub_property_policy, sub_property_policy;\n\n    sub_property_policy.properties().emplace_back(Property(\"STR\",\n            \"STR\"));\n    sub_property_policy.properties().emplace_back(Property(\"STR\",\n            \"STR\"));\n    sub_property_policy.properties().emplace_back(Property(\"STR\",\n            \"STR\"));\n    sub_property_policy.properties().emplace_back(Property(\"STR\",\n            \"STR\"));\n    sub_property_policy.properties().emplace_back(Property(\"STR\",\n            \"STR\"));\n    sub_property_policy.properties().emplace_back(\"STR\");\n\n    reader.history_depth(10).\n            property_policy(sub_property_policy).init();\n\n    ASSERT_TRUE(reader.isInitialized());\n\n    pub_property_policy.properties().emplace_back(Property(\"STR\",\n            \"STR\"));\n    pub_property_policy.properties().emplace_back(Property(\"STR\",\n            \"STR\"));\n    pub_property_policy.properties().emplace_back(Property(\"STR\",\n            \"STR\"));\n    pub_property_policy.properties().emplace_back(Property(\"STR\",\n            \"STR\"));\n    pub_property_policy.properties().emplace_back(Property(\"STR\",\n            \"STR\"));\n    pub_property_policy.properties().emplace_back(\"STR\");\n\n    writer.history_depth(10).\n            reliability(eprosima::fastrtps::BEST_EFFORT_RELIABILITY_QOS).\n            property_policy(pub_property_policy).init();\n\n    ASSERT_TRUE(writer.isInitialized());\n\n    \n    reader.waitAuthorized();\n    writer.waitAuthorized();\n\n    \n    writer.wait_discovery();\n    reader.wait_discovery();\n\n    auto data = default_helloworld_data_generator();\n\n    reader.startReception(data);\n\n    \n    writer.send(data);\n    \n    ASSERT_TRUE(data.empty());\n    \n    reader.block_for_at_least(2);\n}","23356":"static bool extract_sections_symbols(pyc_object *obj, RList *sections, RList *symbols, RList *cobjs, char *prefix) {\n\tpyc_code_object *cobj = NULL;\n\tRBinSection *section = NULL;\n\tRBinSymbol *symbol = NULL;\n\tRListIter *i = NULL;\n\n\t\n\tif_true_return (!obj || (obj->type != TYPE_CODE_v1 && obj->type != TYPE_CODE_v0), false);\n\n\tcobj = obj->data;\n\n\tif_true_return (!cobj || !cobj->name, false);\n\tif_true_return (cobj->name->type != TYPE_ASCII && cobj->name->type != TYPE_STRING && cobj->name->type != TYPE_INTERNED, false);\n\tif_true_return (!cobj->name->data, false);\n\tif_true_return (!cobj->consts, false);\n\n\t\n\tif (!r_list_append (cobjs, cobj)) {\n\t\tgoto fail;\n\t}\n\tsection = R_NEW0 (RBinSection);\n\tsymbol = R_NEW0 (RBinSymbol);\n\tprefix = r_str_newf (\"STR\", r_str_get (prefix),\n\t\tprefix? \"STR\", (const char *)cobj->name->data);\n\tif (!prefix || !section || !symbol) {\n\t\tgoto fail;\n\t}\n\tsection->name = strdup (prefix);\n\tif (!section->name) {\n\t\tgoto fail;\n\t}\n\tsection->paddr = cobj->start_offset;\n\tsection->vaddr = cobj->start_offset;\n\tsection->size = cobj->end_offset - cobj->start_offset;\n\tsection->vsize = cobj->end_offset - cobj->start_offset;\n\tif (!r_list_append (sections, section)) {\n\t\tgoto fail;\n\t}\n\t\n\tsymbol->name = strdup (prefix);\n\t\n\tsymbol->type = R_BIN_TYPE_FUNC_STR;\n\tsymbol->size = cobj->end_offset - cobj->start_offset;\n\tsymbol->vaddr = cobj->start_offset;\n\tsymbol->paddr = cobj->start_offset;\n\tsymbol->ordinal = symbols_ordinal++;\n\tif (cobj->consts->type != TYPE_TUPLE && cobj->consts->type != TYPE_SMALL_TUPLE) {\n\t\tgoto fail;\n\t}\n\tif (!r_list_append (symbols, symbol)) {\n\t\tgoto fail;\n\t}\n\tr_list_foreach (((RList *)(cobj->consts->data)), i, obj) {\n\t\textract_sections_symbols (obj, sections, symbols, cobjs, prefix);\n\t}\n\tfree (prefix);\n\treturn true;\nfail:\n\n\tfree (section);\n\tfree (prefix);\n\tfree (symbol);\n\treturn false;\n}","23315":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TfLiteTensor* hits = GetOutput(context, node, 1);\n  const TfLiteTensor* lookup = GetInput(context, node, 0);\n  const TfLiteTensor* key = GetInput(context, node, 1);\n  const TfLiteTensor* value = GetInput(context, node, 2);\n\n  const int num_rows = SizeOfDimension(value, 0);\n  const int row_bytes = value->bytes \/ num_rows;\n  void* pointer = nullptr;\n  DynamicBuffer buf;\n\n  for (int i = 0; i < SizeOfDimension(lookup, 0); i++) {\n    int idx = -1;\n    pointer = bsearch(&(lookup->data.i32[i]), key->data.i32, num_rows,\n                      sizeof(int32_t), greater);\n    if (pointer != nullptr) {\n      idx = (reinterpret_cast<char*>(pointer) - (key->data.raw)) \/\n            sizeof(int32_t);\n    }\n\n    if (idx >= num_rows || idx < 0) {\n      if (output->type == kTfLiteString) {\n        buf.AddString(nullptr, 0);\n      } else {\n        memset(output->data.raw + i * row_bytes, 0, row_bytes);\n      }\n      hits->data.uint8[i] = 0;\n    } else {\n      if (output->type == kTfLiteString) {\n        buf.AddString(GetString(value, idx));\n      } else {\n        memcpy(output->data.raw + i * row_bytes,\n               value->data.raw + idx * row_bytes, row_bytes);\n      }\n      hits->data.uint8[i] = 1;\n    }\n  }\n  if (output->type == kTfLiteString) {\n    buf.WriteToTensorAsVector(output);\n  }\n\n  return kTfLiteOk;\n}","23337":"void SSL_CTX_sess_set_new_cb(SSL_CTX *ctx,\n\tint (*cb)(struct ssl_st *ssl,SSL_SESSION *sess))\n\t{\n\tctx->new_session_cb=cb;\n\t}","23376":"int v9fs_refresh_inode(struct p9_fid *fid, struct inode *inode)\n{\n\tint umode;\n\tdev_t rdev;\n\tloff_t i_size;\n\tstruct p9_wstat *st;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tst = p9_client_stat(fid);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\t\n\tumode = p9mode2unixmode(v9ses, st, &rdev);\n\tif ((inode->i_mode & S_IFMT) != (umode & S_IFMT))\n\t\tgoto out;\n\n\tspin_lock(&inode->i_lock);\n\t\n\ti_size = inode->i_size;\n\tv9fs_stat2inode(st, inode, inode->i_sb);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tinode->i_size = i_size;\n\tspin_unlock(&inode->i_lock);\nout:\n\tp9stat_free(st);\n\tkfree(st);\n\treturn 0;\n}","22988":"const char *StreamTcpStateAsString(const enum TcpState state)\n{\n    const char *tcp_state = NULL;\n    switch (state) {\n        case TCP_NONE:\n            tcp_state = \"STR\";\n            break;\n        case TCP_LISTEN:\n            tcp_state = \"STR\";\n            break;\n        case TCP_SYN_SENT:\n            tcp_state = \"STR\";\n            break;\n        case TCP_SYN_RECV:\n            tcp_state = \"STR\";\n            break;\n        case TCP_ESTABLISHED:\n            tcp_state = \"STR\";\n            break;\n        case TCP_FIN_WAIT1:\n            tcp_state = \"STR\";\n            break;\n        case TCP_FIN_WAIT2:\n            tcp_state = \"STR\";\n            break;\n        case TCP_TIME_WAIT:\n            tcp_state = \"STR\";\n            break;\n        case TCP_LAST_ACK:\n            tcp_state = \"STR\";\n            break;\n        case TCP_CLOSE_WAIT:\n            tcp_state = \"STR\";\n            break;\n        case TCP_CLOSING:\n            tcp_state = \"STR\";\n            break;\n        case TCP_CLOSED:\n            tcp_state = \"STR\";\n            break;\n    }\n    return tcp_state;\n}","23260":"bool LibuvStreamWrap::IsIPCPipe() {\n  return is_named_pipe_ipc();\n}","23706":"bool Create_field::vers_check_bigint(const Lex_table_name &table_name) const\n{\n  if (is_some_bigint() && flags & UNSIGNED_FLAG &&\n      length == MY_INT64_NUM_DECIMAL_DIGITS - 1)\n    return false;\n\n  my_error(ER_VERS_FIELD_WRONG_TYPE, MYF(0), field_name.str,\n           \"STR\", table_name.str);\n  return true;\n}","22829":"activate_desktop_file (ActivateParameters *parameters,\n                       NautilusFile       *file)\n{\n    ActivateParametersDesktop *parameters_desktop;\n    char *primary, *secondary, *display_name;\n    GtkWidget *dialog;\n    GdkScreen *screen;\n    char *uri;\n\n    screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n\n    if (!nautilus_file_is_trusted_link (file))\n    {\n        \n        parameters_desktop = g_new0 (ActivateParametersDesktop, 1);\n        if (parameters->parent_window)\n        {\n            parameters_desktop->parent_window = parameters->parent_window;\n            g_object_add_weak_pointer (G_OBJECT (parameters_desktop->parent_window), (gpointer *) &parameters_desktop->parent_window);\n        }\n        parameters_desktop->file = nautilus_file_ref (file);\n\n        primary = _(\"STR\");\n        display_name = nautilus_file_get_display_name (file);\n        secondary =\n            g_strdup_printf (_(\"STR\"\n                               \"STR\"\n                               ),\n                             display_name);\n\n        dialog = gtk_message_dialog_new (parameters->parent_window,\n                                         0,\n                                         GTK_MESSAGE_WARNING,\n                                         GTK_BUTTONS_NONE,\n                                         NULL);\n        g_object_set (dialog,\n                      \"STR\", primary,\n                      \"STR\", secondary,\n                      NULL);\n        gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"STR\"), RESPONSE_RUN);\n        if (nautilus_file_can_set_permissions (file))\n        {\n            gtk_dialog_add_button (GTK_DIALOG (dialog),\n                                   _(\"STR\"), RESPONSE_MARK_TRUSTED);\n        }\n        gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"STR\"), GTK_RESPONSE_CANCEL);\n        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);\n\n        g_signal_connect (dialog, \"STR\",\n                          G_CALLBACK (untrusted_launcher_response_callback),\n                          parameters_desktop);\n        gtk_widget_show (dialog);\n\n        g_free (display_name);\n        g_free (secondary);\n        return;\n    }\n\n    uri = nautilus_file_get_uri (file);\n    DEBUG (\"STR\", uri);\n    nautilus_launch_desktop_file (screen, uri, NULL,\n                                  parameters->parent_window);\n    g_free (uri);\n}","23401":"static int handle_triple_fault(struct kvm_vcpu *vcpu)\n{\n\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\treturn 0;\n}","22794":"static HRESULT STDMETHODCALLTYPE CliprdrDataObject_QueryInterface(IDataObject* This, REFIID riid,\n                                                                  void** ppvObject)\n{\n\t(void)This;\n\n\tif (!ppvObject)\n\t\treturn E_INVALIDARG;\n\n\tif (IsEqualIID(riid, &IID_IDataObject) || IsEqualIID(riid, &IID_IUnknown))\n\t{\n\t\tIDataObject_AddRef(This);\n\t\t*ppvObject = This;\n\t\treturn S_OK;\n\t}\n\telse\n\t{\n\t\t*ppvObject = 0;\n\t\treturn E_NOINTERFACE;\n\t}\n}","22984":"static struct dst_entry *geneve_get_v6_dst(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *dev,\n\t\t\t\t\t   struct geneve_sock *gs6,\n\t\t\t\t\t   struct flowi6 *fl6,\n\t\t\t\t\t   const struct ip_tunnel_info *info)\n{\n\tbool use_cache = ip_tunnel_dst_cache_usable(skb, info);\n\tstruct geneve_dev *geneve = netdev_priv(dev);\n\tstruct dst_entry *dst = NULL;\n\tstruct dst_cache *dst_cache;\n\t__u8 prio;\n\n\tif (!gs6)\n\t\treturn ERR_PTR(-EIO);\n\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_mark = skb->mark;\n\tfl6->flowi6_proto = IPPROTO_UDP;\n\tfl6->daddr = info->key.u.ipv6.dst;\n\tfl6->saddr = info->key.u.ipv6.src;\n\tprio = info->key.tos;\n\tif ((prio == 1) && !geneve->collect_md) {\n\t\tprio = ip_tunnel_get_dsfield(ip_hdr(skb), skb);\n\t\tuse_cache = false;\n\t}\n\n\tfl6->flowlabel = ip6_make_flowinfo(RT_TOS(prio),\n\t\t\t\t\t   info->key.label);\n\tdst_cache = (struct dst_cache *)&info->dst_cache;\n\tif (use_cache) {\n\t\tdst = dst_cache_get_ip6(dst_cache, &fl6->saddr);\n\t\tif (dst)\n\t\t\treturn dst;\n\t}\n\tif (ipv6_stub->ipv6_dst_lookup(geneve->net, gs6->sock->sk, &dst, fl6)) {\n\t\tnetdev_dbg(dev, \"STR\", &fl6->daddr);\n\t\treturn ERR_PTR(-ENETUNREACH);\n\t}\n\tif (dst->dev == dev) { \n\t\tnetdev_dbg(dev, \"STR\", &fl6->daddr);\n\t\tdst_release(dst);\n\t\treturn ERR_PTR(-ELOOP);\n\t}\n\n\tif (use_cache)\n\t\tdst_cache_set_ip6(dst_cache, dst, &fl6->saddr);\n\treturn dst;\n}","22994":"void Gfx::opSetFillColorSpace(Object args[], int numArgs) {\n  Object obj;\n  GfxColorSpace *colorSpace;\n  GfxColor color;\n\n  res->lookupColorSpace(args[0].getName(), &obj);\n  if (obj.isNull()) {\n    colorSpace = GfxColorSpace::parse(&args[0], this);\n  } else {\n    colorSpace = GfxColorSpace::parse(&obj, this);\n  }\n  obj.free();\n  if (colorSpace) {\n    if (textHaveCSPattern && drawText) {\n      GBool needFill = out->deviceHasTextClip(state);\n      out->endTextObject(state);\n      if (needFill) {\n        doPatternFill(gTrue);\n      }\n      out->restoreState(state);\n    }\n    state->setFillPattern(NULL);\n    state->setFillColorSpace(colorSpace);\n    out->updateFillColorSpace(state);\n    colorSpace->getDefaultColor(&color);\n    state->setFillColor(&color);\n    out->updateFillColor(state);\n    if (textHaveCSPattern) {\n      out->beginTextObject(state);\n      out->updateRender(state);\n      out->updateTextMat(state);\n      out->updateTextPos(state);\n      textHaveCSPattern = colorSpace->getMode() == csPattern;\n    } else if (drawText && out->supportTextCSPattern(state)) {\n      out->beginTextObject(state);\n      textHaveCSPattern = gTrue;\n    }\n  } else {\n    error(getPos(), \"STR\");\n  }\n}","23214":"static int jpc_dec_tilefini(jpc_dec_t *dec, jpc_dec_tile_t *tile)\n{\n\tjpc_dec_tcomp_t *tcomp;\n\tint compno;\n\tint bandno;\n\tint rlvlno;\n\tjpc_dec_band_t *band;\n\tjpc_dec_rlvl_t *rlvl;\n\tint prcno;\n\tjpc_dec_prc_t *prc;\n\tjpc_dec_seg_t *seg;\n\tjpc_dec_cblk_t *cblk;\n\tint cblkno;\n\n\tif (tile->tcomps) {\n\n\t\tfor (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps;\n\t\t  ++compno, ++tcomp) {\n\t\t\tfor (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;\n\t\t\t  ++rlvlno, ++rlvl) {\n\t\t\t\tif (!rlvl->bands) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t\t\t  ++bandno, ++band) {\n\t\t\t\t\tif (band->prcs) {\n\t\t\t\t\t\tfor (prcno = 0, prc = band->prcs; prcno <\n\t\t\t\t\t\t  rlvl->numprcs; ++prcno, ++prc) {\n\t\t\t\t\t\t\tif (!prc->cblks) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno <\n\t\t\t\t\t\t\t  prc->numcblks; ++cblkno, ++cblk) {\n\n\t\t\t\t\t\t\t\twhile (cblk->segs.head) {\n\t\t\t\t\t\t\t\t\tseg = cblk->segs.head;\n\t\t\t\t\t\t\t\t\tjpc_seglist_remove(&cblk->segs, seg);\n\t\t\t\t\t\t\t\t\tjpc_seg_destroy(seg);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tjas_matrix_destroy(cblk->data);\n\t\t\t\t\t\t\t\tif (cblk->mqdec) {\n\t\t\t\t\t\t\t\t\tjpc_mqdec_destroy(cblk->mqdec);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (cblk->nulldec) {\n\t\t\t\t\t\t\t\t\tjpc_bitstream_close(cblk->nulldec);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (cblk->flags) {\n\t\t\t\t\t\t\t\t\tjas_matrix_destroy(cblk->flags);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->incltagtree) {\n\t\t\t\t\t\t\t\tjpc_tagtree_destroy(prc->incltagtree);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->numimsbstagtree) {\n\t\t\t\t\t\t\t\tjpc_tagtree_destroy(prc->numimsbstagtree);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (prc->cblks) {\n\t\t\t\t\t\t\t\tjas_free(prc->cblks);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (band->data) {\n\t\t\t\t\t\tjas_matrix_destroy(band->data);\n\t\t\t\t\t}\n\t\t\t\t\tif (band->prcs) {\n\t\t\t\t\t\tjas_free(band->prcs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rlvl->bands) {\n\t\t\t\t\tjas_free(rlvl->bands);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tcomp->rlvls) {\n\t\t\t\tjas_free(tcomp->rlvls);\n\t\t\t}\n\t\t\tif (tcomp->data) {\n\t\t\t\tjas_matrix_destroy(tcomp->data);\n\t\t\t}\n\t\t\tif (tcomp->tsfb) {\n\t\t\t\tjpc_tsfb_destroy(tcomp->tsfb);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (tile->cp) {\n\t\tjpc_dec_cp_destroy(tile->cp);\n\t\ttile->cp = 0;\n\t}\n\tif (tile->tcomps) {\n\t\tjas_free(tile->tcomps);\n\t\ttile->tcomps = 0;\n\t}\n\tif (tile->pi) {\n\t\tjpc_pi_destroy(tile->pi);\n\t\ttile->pi = 0;\n\t}\n\tif (tile->pkthdrstream) {\n\t\tjas_stream_close(tile->pkthdrstream);\n\t\ttile->pkthdrstream = 0;\n\t}\n\tif (tile->pptstab) {\n\t\tjpc_ppxstab_destroy(tile->pptstab);\n\t\ttile->pptstab = 0;\n\t}\n\n\ttile->state = JPC_TILE_DONE;\n\n\treturn 0;\n}","23396":"enum nss_status _nss_mymachines_getpwnam_r(\n                const char *name,\n                struct passwd *pwd,\n                char *buffer, size_t buflen,\n                int *errnop) {\n\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        const char *p, *e, *machine;\n        uint32_t mapped;\n        uid_t uid;\n        size_t l;\n        int r;\n\n        assert(name);\n        assert(pwd);\n\n        p = startswith(name, \"STR\");\n        if (!p)\n                goto not_found;\n\n        e = strrchr(p, '-');\n        if (!e || e == p)\n                goto not_found;\n\n        r = parse_uid(e + 1, &uid);\n        if (r < 0)\n                goto not_found;\n\n        machine = strndupa(p, e - p);\n        if (!machine_name_is_valid(machine))\n                goto not_found;\n\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_call_method(bus,\n                               \"STR\",\n                               \"STR\",\n                               \"STR\",\n                               \"STR\",\n                               &error,\n                               &reply,\n                               \"STR\",\n                               machine, (uint32_t) uid);\n        if (r < 0) {\n                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_USER_MAPPING))\n                        goto not_found;\n\n                goto fail;\n        }\n\n        r = sd_bus_message_read(reply, \"STR\", &mapped);\n        if (r < 0)\n                goto fail;\n\n        l = strlen(name);\n        if (buflen < l+1) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n\n        memcpy(buffer, name, l+1);\n\n        pwd->pw_name = buffer;\n        pwd->pw_uid = mapped;\n        pwd->pw_gid = 65534; \n        pwd->pw_gecos = buffer;\n        pwd->pw_passwd = (char*) \"STR\"; \n        pwd->pw_dir = (char*) \"STR\";\n        pwd->pw_shell = (char*) \"STR\";\n\n        *errnop = 0;\n        return NSS_STATUS_SUCCESS;\n\nnot_found:\n        *errnop = 0;\n        return NSS_STATUS_NOTFOUND;\n\nfail:\n        *errnop = -r;\n        return NSS_STATUS_UNAVAIL;\n}","23031":"megasas_read_fw_status_reg_xscale(struct megasas_instance *instance)\n{\n\treturn readl(&instance->reg_set->outbound_msg_0);\n}","23130":"static void xenvif_fatal_tx_err(struct xenvif *vif)\n{\n\tnetdev_err(vif->dev, \"STR\");\n\txenvif_carrier_off(vif);\n}","22606":"struct inode *fuse_iget(struct super_block *sb, u64 nodeid,\n\t\t\tint generation, struct fuse_attr *attr,\n\t\t\tu64 attr_valid, u64 attr_version)\n{\n\tstruct inode *inode;\n\tstruct fuse_inode *fi;\n\tstruct fuse_conn *fc = get_fuse_conn_super(sb);\n\n\t\n\tif (fc->auto_submounts && (attr->flags & FUSE_ATTR_SUBMOUNT) &&\n\t    S_ISDIR(attr->mode)) {\n\t\tinode = new_inode(sb);\n\t\tif (!inode)\n\t\t\treturn NULL;\n\n\t\tfuse_init_inode(inode, attr);\n\t\tget_fuse_inode(inode)->nodeid = nodeid;\n\t\tinode->i_flags |= S_AUTOMOUNT;\n\t\tgoto done;\n\t}\n\nretry:\n\tinode = iget5_locked(sb, nodeid, fuse_inode_eq, fuse_inode_set, &nodeid);\n\tif (!inode)\n\t\treturn NULL;\n\n\tif ((inode->i_state & I_NEW)) {\n\t\tinode->i_flags |= S_NOATIME;\n\t\tif (!fc->writeback_cache || !S_ISREG(attr->mode))\n\t\t\tinode->i_flags |= S_NOCMTIME;\n\t\tinode->i_generation = generation;\n\t\tfuse_init_inode(inode, attr);\n\t\tunlock_new_inode(inode);\n\t} else if ((inode->i_mode ^ attr->mode) & S_IFMT) {\n\t\t\n\t\tmake_bad_inode(inode);\n\t\tiput(inode);\n\t\tgoto retry;\n\t}\ndone:\n\tfi = get_fuse_inode(inode);\n\tspin_lock(&fi->lock);\n\tfi->nlookup++;\n\tspin_unlock(&fi->lock);\n\tfuse_change_attributes(inode, attr, attr_valid, attr_version);\n\n\treturn inode;\n}","23000":"static void __exit af_unix_exit(void)\n{\n\tsock_unregister(PF_UNIX);\n\tunix_sysctl_unregister();\n\tproc_net_remove(\"STR\");\n\tproto_unregister(&unix_proto);\n}","22720":"static int dn_nl_deladdr(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *tb[IFA_MAX+1];\n\tstruct dn_dev *dn_db;\n\tstruct ifaddrmsg *ifm;\n\tstruct dn_ifaddr *ifa;\n\tstruct dn_ifaddr __rcu **ifap;\n\tint err = -EINVAL;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!net_eq(net, &init_net))\n\t\tgoto errout;\n\n\terr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, dn_ifa_policy);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = -ENODEV;\n\tifm = nlmsg_data(nlh);\n\tif ((dn_db = dn_dev_by_index(ifm->ifa_index)) == NULL)\n\t\tgoto errout;\n\n\terr = -EADDRNOTAVAIL;\n\tfor (ifap = &dn_db->ifa_list;\n\t     (ifa = rtnl_dereference(*ifap)) != NULL;\n\t     ifap = &ifa->ifa_next) {\n\t\tif (tb[IFA_LOCAL] &&\n\t\t    nla_memcmp(tb[IFA_LOCAL], &ifa->ifa_local, 2))\n\t\t\tcontinue;\n\n\t\tif (tb[IFA_LABEL] && nla_strcmp(tb[IFA_LABEL], ifa->ifa_label))\n\t\t\tcontinue;\n\n\t\tdn_dev_del_ifa(dn_db, ifap, 1);\n\t\treturn 0;\n\t}\n\nerrout:\n\treturn err;\n}","23297":"bool TABLE_SHARE::wait_for_old_version(THD *thd, struct timespec *abstime,\n                                       uint deadlock_weight)\n{\n  MDL_context *mdl_context= &thd->mdl_context;\n  Wait_for_flush ticket(mdl_context, this, deadlock_weight);\n  MDL_wait::enum_wait_status wait_status;\n\n  mysql_mutex_assert_owner(&tdc->LOCK_table_share);\n  DBUG_ASSERT(tdc->flushed);\n\n  tdc->m_flush_tickets.push_front(&ticket);\n\n  mdl_context->m_wait.reset_status();\n\n  mysql_mutex_unlock(&tdc->LOCK_table_share);\n\n  mdl_context->will_wait_for(&ticket);\n\n  mdl_context->find_deadlock();\n\n  wait_status= mdl_context->m_wait.timed_wait(thd, abstime, TRUE,\n                                              &stage_waiting_for_table_flush);\n\n  mdl_context->done_waiting_for();\n\n  mysql_mutex_lock(&tdc->LOCK_table_share);\n  tdc->m_flush_tickets.remove(&ticket);\n  mysql_cond_broadcast(&tdc->COND_release);\n  mysql_mutex_unlock(&tdc->LOCK_table_share);\n\n\n  \n  switch (wait_status)\n  {\n  case MDL_wait::GRANTED:\n    return FALSE;\n  case MDL_wait::VICTIM:\n    my_error(ER_LOCK_DEADLOCK, MYF(0));\n    return TRUE;\n  case MDL_wait::TIMEOUT:\n    my_error(ER_LOCK_WAIT_TIMEOUT, MYF(0));\n    return TRUE;\n  case MDL_wait::KILLED:\n    return TRUE;\n  default:\n    DBUG_ASSERT(0);\n    return TRUE;\n  }\n}","22815":"static void rbd_dev_destroy(struct rbd_device *rbd_dev)\n{\n\tif (rbd_dev)\n\t\tput_device(&rbd_dev->dev);\n}","23771":"void hns_roce_exit(struct hns_roce_dev *hr_dev)\n{\n\thns_roce_unregister_device(hr_dev);\n\tif (hr_dev->hw->hw_exit)\n\t\thr_dev->hw->hw_exit(hr_dev);\n\thns_roce_cleanup_bitmap(hr_dev);\n\thns_roce_cleanup_hem(hr_dev);\n\n\tif (hr_dev->cmd_mod)\n\t\thns_roce_cmd_use_polling(hr_dev);\n\n\thr_dev->hw->cleanup_eq(hr_dev);\n\thns_roce_cmd_cleanup(hr_dev);\n\tif (hr_dev->hw->cmq_exit)\n\t\thr_dev->hw->cmq_exit(hr_dev);\n\tif (hr_dev->hw->reset)\n\t\thr_dev->hw->reset(hr_dev, false);\n}","23490":"static int check_pad_bytes(struct kmem_cache *s, struct page *page, u8 *p)\n{\n\tunsigned long off = s->inuse;\t\n\n\tif (s->offset)\n\t\t\n\t\toff += sizeof(void *);\n\n\tif (s->flags & SLAB_STORE_USER)\n\t\t\n\t\toff += 2 * sizeof(struct track);\n\n\toff += kasan_metadata_size(s);\n\n\tif (size_from_object(s) == off)\n\t\treturn 1;\n\n\treturn check_bytes_and_report(s, page, p, \"STR\",\n\t\t\tp + off, POISON_INUSE, size_from_object(s) - off);\n}","23363":"PHP_MINIT_FUNCTION(dir)\n{\n\tstatic char dirsep_str[2], pathsep_str[2];\n\tzend_class_entry dir_class_entry;\n\n\tINIT_CLASS_ENTRY(dir_class_entry, \"STR\", php_dir_class_functions);\n\tdir_class_entry_ptr = zend_register_internal_class(&dir_class_entry TSRMLS_CC);\n\n#ifdef ZTS\n\tts_allocate_id(&dir_globals_id, sizeof(php_dir_globals), NULL, NULL);\n#endif\n\n\tdirsep_str[0] = DEFAULT_SLASH;\n\tdirsep_str[1] = '\\0';\n\tREGISTER_STRING_CONSTANT(\"STR\", dirsep_str, CONST_CS|CONST_PERSISTENT);\n\n\tpathsep_str[0] = ZEND_PATHS_SEPARATOR;\n\tpathsep_str[1] = '\\0';\n\tREGISTER_STRING_CONSTANT(\"STR\", pathsep_str, CONST_CS|CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"STR\",  PHP_SCANDIR_SORT_ASCENDING,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STR\", PHP_SCANDIR_SORT_DESCENDING, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STR\",       PHP_SCANDIR_SORT_NONE,       CONST_CS | CONST_PERSISTENT);\n\n#ifdef HAVE_GLOB\n\n#ifdef GLOB_BRACE\n\tREGISTER_LONG_CONSTANT(\"STR\", GLOB_BRACE, CONST_CS | CONST_PERSISTENT);\n#else\n# define GLOB_BRACE 0\n#endif\n\n#ifdef GLOB_MARK\n\tREGISTER_LONG_CONSTANT(\"STR\", GLOB_MARK, CONST_CS | CONST_PERSISTENT);\n#else\n# define GLOB_MARK 0\n#endif\n\n#ifdef GLOB_NOSORT\n\tREGISTER_LONG_CONSTANT(\"STR\", GLOB_NOSORT, CONST_CS | CONST_PERSISTENT);\n#else \n# define GLOB_NOSORT 0\n#endif\n\n#ifdef GLOB_NOCHECK\n\tREGISTER_LONG_CONSTANT(\"STR\", GLOB_NOCHECK, CONST_CS | CONST_PERSISTENT);\n#else \n# define GLOB_NOCHECK 0\n#endif\n\n#ifdef GLOB_NOESCAPE\n\tREGISTER_LONG_CONSTANT(\"STR\", GLOB_NOESCAPE, CONST_CS | CONST_PERSISTENT);\n#else \n# define GLOB_NOESCAPE 0\n#endif\n\n#ifdef GLOB_ERR\n\tREGISTER_LONG_CONSTANT(\"STR\", GLOB_ERR, CONST_CS | CONST_PERSISTENT);\n#else \n# define GLOB_ERR 0\n#endif\n\n#ifndef GLOB_ONLYDIR\n# define GLOB_ONLYDIR (1<<30)\n# define GLOB_EMULATE_ONLYDIR\n# define GLOB_FLAGMASK (~GLOB_ONLYDIR)\n#else\n# define GLOB_FLAGMASK (~0)\n#endif\n\n\n\n\n\tREGISTER_LONG_CONSTANT(\"STR\", GLOB_ONLYDIR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STR\", GLOB_AVAILABLE_FLAGS, CONST_CS | CONST_PERSISTENT);\n\n#endif \n\n\treturn SUCCESS;\n}","23778":"static void convert(float y, float u, float v,\n                    float *b, float *g, float *r)\n{\n    *r = y               + 1.5747f * v;\n    *g = y - 0.1873f * u - 0.4682f * v;\n    *b = y + 1.8556f * u;\n}","23092":"cgiSetVariable(const char *name,\t\n               const char *value)\t\n{\n  int\t\ti;\t\t\t\n  _cgi_var_t\t*var;\t\t\t\n\n\n  if (name == NULL || value == NULL)\n    return;\n\n  fprintf(stderr, \"STR\", name, value);\n\n  if ((var = cgi_find_variable(name)) == NULL)\n  {\n    cgi_add_variable(name, 0, value);\n    cgi_sort_variables();\n  }\n  else\n  {\n    for (i = 0; i < var->nvalues; i ++)\n      if (var->values[i])\n        _cupsStrFree((char *)var->values[i]);\n\n    var->values[0] = _cupsStrAlloc(value);\n    var->nvalues   = 1;\n  }\n}","23306":"TIFFScanlineSize(TIFF* tif)\n{\n\tstatic const char module[] = \"STR\";\n\tuint64 m;\n\ttmsize_t n;\n\tm=TIFFScanlineSize64(tif);\n\tn=(tmsize_t)m;\n\tif ((uint64)n!=m) {\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\"STR\");\n\t\tn=0;\n\t}\n\treturn(n);\n}","23637":"std::string t_go_generator::publicize(const std::string& value, bool is_args_or_result) const {\n  if (value.size() <= 0) {\n    return value;\n  }\n\n  std::string value2(value), prefix;\n\n  string::size_type dot_pos = value.rfind('.');\n  if (dot_pos != string::npos) {\n    prefix = value.substr(0, dot_pos + 1) + prefix;\n    value2 = value.substr(dot_pos + 1);\n  }\n\n  if (!isupper(value2[0])) {\n    value2[0] = toupper(value2[0]);\n  }\n\n  value2 = camelcase(value2);\n\n  \n  size_t len_before = value2.length();\n\n  \n  \n  if ((len_before >= 3) && (value2.substr(0, 3) == \"STR\")) {\n    value2 += '_';\n  }\n\n  \n  \n  \n  \n  if (!is_args_or_result) {\n    bool ends_with_args = (len_before >= 4) && (value2.substr(len_before - 4, 4) == \"STR\");\n    bool ends_with_rslt = (len_before >= 6) && (value2.substr(len_before - 6, 6) == \"STR\");\n    if (ends_with_args || ends_with_rslt) {\n      value2 += '_';\n    }\n  }\n\n  \n  if (is_args_or_result) {\n    prefix += publicize(service_name_);\n  }\n\n  return prefix + value2;\n}","23171":"static void function_drop(\n\t\tstruct config_group *group,\n\t\tstruct config_item *item)\n{\n\tstruct usb_function_instance *fi = to_usb_function_instance(item);\n\tstruct gadget_info *gi;\n\n\tgi = container_of(group, struct gadget_info, functions_group);\n\n\tmutex_lock(&gi->lock);\n\tlist_del(&fi->cfs_list);\n\tmutex_unlock(&gi->lock);\n\tconfig_item_put(item);\n}","23222":"String *Item_func_sha2::val_str_ascii(String *str)\n{\n  DBUG_ASSERT(fixed == 1);\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  unsigned char digest_buf[SHA512_DIGEST_LENGTH];\n  String *input_string;\n  unsigned char *input_ptr;\n  size_t input_len;\n  uint digest_length= 0;\n\n  input_string= args[0]->val_str(str);\n  str->set_charset(&my_charset_bin);\n\n  if (input_string == NULL)\n  {\n    null_value= TRUE;\n    return (String *) NULL;\n  }\n\n  null_value= args[0]->null_value;\n  if (null_value)\n    return (String *) NULL;\n\n  input_ptr= (unsigned char *) input_string->ptr();\n  input_len= input_string->length();\n\n  switch ((uint) args[1]->val_int()) {\n#ifndef OPENSSL_NO_SHA512\n  case 512:\n    digest_length= SHA512_DIGEST_LENGTH;\n    (void) SHA512(input_ptr, input_len, digest_buf);\n    break;\n  case 384:\n    digest_length= SHA384_DIGEST_LENGTH;\n    (void) SHA384(input_ptr, input_len, digest_buf);\n    break;\n#endif\n#ifndef OPENSSL_NO_SHA256\n  case 224:\n    digest_length= SHA224_DIGEST_LENGTH;\n    (void) SHA224(input_ptr, input_len, digest_buf);\n    break;\n  case 256:\n  case 0: \n    digest_length= SHA256_DIGEST_LENGTH;\n    (void) SHA256(input_ptr, input_len, digest_buf);\n    break;\n#endif\n  default:\n    if (!args[1]->const_item())\n      push_warning_printf(current_thd,\n        Sql_condition::WARN_LEVEL_WARN,\n        ER_WRONG_PARAMETERS_TO_NATIVE_FCT,\n        ER(ER_WRONG_PARAMETERS_TO_NATIVE_FCT), \"STR\");\n    null_value= TRUE;\n    return NULL;\n  }\n\n  \n  str->realloc((uint) digest_length*2 + 1); \n\n  \n  array_to_hex((char *) str->ptr(), digest_buf, digest_length);\n\n  \n  str->length((uint) digest_length*2); \n\n  null_value= FALSE;\n  return str;\n\n#else\n  push_warning_printf(current_thd,\n    Sql_condition::WARN_LEVEL_WARN,\n    ER_FEATURE_DISABLED,\n    ER(ER_FEATURE_DISABLED),\n    \"STR\");\n  null_value= TRUE;\n  return (String *) NULL;\n#endif \n}","22895":"      static double mp_lowercase(_cimg_math_parser& mp) {\n        return cimg::lowercase(_mp_arg(2));\n      }","23653":"rsvg_new_group (void)\n{\n    RsvgNodeGroup *group;\n    group = g_new (RsvgNodeGroup, 1);\n    _rsvg_node_init (&group->super);\n    group->super.draw = _rsvg_node_draw_children;\n    group->super.set_atts = rsvg_node_group_set_atts;\n    return &group->super;\n}","23263":"void vterm_state_reset(VTermState *state, int hard)\n{\n  VTermEncoding *default_enc;\n\n  state->scrollregion_top = 0;\n  state->scrollregion_bottom = -1;\n  state->scrollregion_left = 0;\n  state->scrollregion_right = -1;\n\n  state->mode.keypad          = 0;\n  state->mode.cursor          = 0;\n  state->mode.autowrap        = 1;\n  state->mode.insert          = 0;\n  state->mode.newline         = 0;\n  state->mode.alt_screen      = 0;\n  state->mode.origin          = 0;\n  state->mode.leftrightmargin = 0;\n  state->mode.bracketpaste    = 0;\n  state->mode.report_focus    = 0;\n\n  state->vt->mode.ctrl8bit   = 0;\n\n  {\n    int col;\n    for(col = 0; col < state->cols; col++)\n      if(col % 8 == 0)\n\tset_col_tabstop(state, col);\n      else\n\tclear_col_tabstop(state, col);\n  }\n\n  {\n    int row;\n    for(row = 0; row < state->rows; row++)\n      set_lineinfo(state, row, FORCE, DWL_OFF, DHL_OFF);\n  }\n\n  if(state->callbacks && state->callbacks->initpen)\n    (*state->callbacks->initpen)(state->cbdata);\n\n  vterm_state_resetpen(state);\n\n  default_enc = state->vt->mode.utf8 ?\n      vterm_lookup_encoding(ENC_UTF8,      'u') :\n      vterm_lookup_encoding(ENC_SINGLE_94, 'B');\n\n  {\n    int i;\n    for(i = 0; i < 4; i++) {\n      state->encoding[i].enc = default_enc;\n      if(default_enc->init)\n\t(*default_enc->init)(default_enc, state->encoding[i].data);\n    }\n  }\n\n  state->gl_set = 0;\n  state->gr_set = 1;\n  state->gsingle_set = 0;\n\n  state->protected_cell = 0;\n\n  \n  settermprop_bool(state, VTERM_PROP_CURSORVISIBLE, 1);\n  settermprop_bool(state, VTERM_PROP_CURSORBLINK,   1);\n  settermprop_int (state, VTERM_PROP_CURSORSHAPE,   VTERM_PROP_CURSORSHAPE_BLOCK);\n\n  if(hard) {\n    VTermRect rect = { 0, 0, 0, 0 };\n\n    state->pos.row = 0;\n    state->pos.col = 0;\n    state->at_phantom = 0;\n\n    rect.end_row = state->rows;\n    rect.end_col =  state->cols;\n    erase(state, rect, 0);\n  }\n}","22999":"njs_object_property_key_set(njs_lvlhsh_query_t *lhq, const njs_value_t *key,\n    uint32_t hash)\n{\n    if (njs_is_symbol(key)) {\n\n        lhq->key.length = 0;\n        lhq->key.start = NULL;\n        lhq->key_hash = njs_symbol_key(key);\n\n    } else {\n\n        \n\n        njs_string_get(key, &lhq->key);\n\n        if (hash == 0) {\n            lhq->key_hash = njs_djb_hash(lhq->key.start, lhq->key.length);\n\n        } else {\n            lhq->key_hash = hash;\n        }\n    }\n}","23040":"static int ath6kl_wmi_pstream_timeout_event_rx(struct wmi *wmi, u8 *datap,\n\t\t\t\t\t       int len)\n{\n\tstruct wmi_pstream_timeout_event *ev;\n\n\tif (len < sizeof(struct wmi_pstream_timeout_event))\n\t\treturn -EINVAL;\n\n\tev = (struct wmi_pstream_timeout_event *) datap;\n\n\t\n\tspin_lock_bh(&wmi->lock);\n\twmi->stream_exist_for_ac[ev->traffic_class] = 0;\n\twmi->fat_pipe_exist &= ~(1 << ev->traffic_class);\n\tspin_unlock_bh(&wmi->lock);\n\n\t\n\tath6kl_indicate_tx_activity(wmi->parent_dev, ev->traffic_class, false);\n\n\treturn 0;\n}","23146":"static int pcan_usb_pro_encode_msg(struct peak_usb_device *dev,\n\t\t\t\t   struct sk_buff *skb, u8 *obuf, size_t *size)\n{\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tu8 data_type, len, flags;\n\tstruct pcan_usb_pro_msg usb_msg;\n\n\tpcan_msg_init_empty(&usb_msg, obuf, *size);\n\n\tif ((cf->can_id & CAN_RTR_FLAG) || (cf->can_dlc == 0))\n\t\tdata_type = PCAN_USBPRO_TXMSG0;\n\telse if (cf->can_dlc <= 4)\n\t\tdata_type = PCAN_USBPRO_TXMSG4;\n\telse\n\t\tdata_type = PCAN_USBPRO_TXMSG8;\n\n\tlen = (dev->ctrl_idx << 4) | (cf->can_dlc & 0x0f);\n\n\tflags = 0;\n\tif (cf->can_id & CAN_EFF_FLAG)\n\t\tflags |= 0x02;\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tflags |= 0x01;\n\n\tpcan_msg_add_rec(&usb_msg, data_type, 0, flags, len, cf->can_id,\n\t\t\t cf->data);\n\n\t*size = usb_msg.rec_buffer_len;\n\n\treturn 0;\n}","22902":"static void input_device_enter_reconnect_mode(struct input_device *idev)\n{\n\tDBG(\"STR\", idev->path,\n\t\t\t\treconnect_mode_to_string(idev->reconnect_mode));\n\n\t\n\tif (idev->reconnect_mode != RECONNECT_ANY &&\n\t\t\t\tidev->reconnect_mode != RECONNECT_HOST)\n\t\treturn;\n\n\t\n\tif (device_is_temporary(idev->device) ||\n\t\t\t\t\tbtd_device_is_connected(idev->device))\n\t\treturn;\n\n\tif (idev->reconnect_timer > 0)\n\t\tg_source_remove(idev->reconnect_timer);\n\n\tDBG(\"STR\");\n\tidev->reconnect_attempt = 0;\n\tidev->reconnect_timer = g_timeout_add_seconds(30,\n\t\t\t\t\tinput_device_auto_reconnect, idev);\n\n}","23729":"process_extended_posix_rename(u_int32_t id)\n{\n\tchar *oldpath, *newpath;\n\tint r, status;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &oldpath, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(iqueue, &newpath, NULL)) != 0)\n\t\tfatal(\"STR\", __func__, ssh_err(r));\n\n\tdebug3(\"STR\", id);\n\tlogit(\"STR\", oldpath, newpath);\n\tr = rename(oldpath, newpath);\n\tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n\tsend_status(id, status);\n\tfree(oldpath);\n\tfree(newpath);\n}","23580":"int dsdb_wellknown_dn(struct ldb_context *samdb, TALLOC_CTX *mem_ctx,\n\t\t      struct ldb_dn *nc_root, const char *wk_guid,\n\t\t      struct ldb_dn **wkguid_dn)\n{\n\tTALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);\n\tconst char *attrs[] = { NULL };\n\tint ret;\n\tstruct ldb_dn *dn;\n\tstruct ldb_result *res = NULL;\n\n\t\n\tdn = ldb_dn_new_fmt(tmp_ctx, samdb, \"STR\",\n\t\t\t    wk_guid, ldb_dn_get_linearized(nc_root));\n\tif (!wkguid_dn) {\n\t\ttalloc_free(tmp_ctx);\n\t\treturn ldb_operr(samdb);\n\t}\n\n\tret = dsdb_search_dn(samdb, tmp_ctx, &res, dn, attrs,\n\t\t\t     DSDB_SEARCH_SHOW_DELETED |\n\t\t\t     DSDB_SEARCH_SHOW_RECYCLED);\n\tif (ret != LDB_SUCCESS) {\n\t\ttalloc_free(tmp_ctx);\n\t\treturn ret;\n\t}\n\t\n\tif (res == NULL){\n\t\ttalloc_free(tmp_ctx);\n\t\treturn LDB_ERR_OTHER;\n\t}\n\n\t(*wkguid_dn) = talloc_steal(mem_ctx, res->msgs[0]->dn);\n\ttalloc_free(tmp_ctx);\n\treturn LDB_SUCCESS;\n}","22744":"  void set_active() {\n    active = true;\n  };","23223":"gint vdagent_connection_get_peer_pid(VDAgentConnection *self,\n                                     GError           **err)\n{\n    VDAgentConnectionPrivate *priv = vdagent_connection_get_instance_private(self);\n    GSocket *sock;\n    GCredentials *cred;\n    gint pid = -1;\n\n    g_return_val_if_fail(G_IS_SOCKET_CONNECTION(priv->io_stream), pid);\n\n    sock = g_socket_connection_get_socket(G_SOCKET_CONNECTION(priv->io_stream));\n    cred = g_socket_get_credentials(sock, err);\n    if (cred) {\n        pid = g_credentials_get_unix_pid(cred, err);\n        g_object_unref(cred);\n    }\n\n    return pid;\n}","22697":"void dce110_clock_source_destroy(struct clock_source **clk_src)\n{\n\tstruct dce110_clk_src *dce110_clk_src;\n\n\tif (!clk_src)\n\t\treturn;\n\n\tdce110_clk_src = TO_DCE110_CLK_SRC(*clk_src);\n\n\tkfree(dce110_clk_src->dp_ss_params);\n\tkfree(dce110_clk_src->hdmi_ss_params);\n\tkfree(dce110_clk_src->dvi_ss_params);\n\n\tkfree(dce110_clk_src);\n\t*clk_src = NULL;\n}","23008":"static int bson_append_estart( bson *b, int type, const char *name, const int dataSize ) {\n    const int len = strlen( name ) + 1;\n\n    if ( b->finished ) {\n        b->err |= BSON_ALREADY_FINISHED;\n        return BSON_ERROR;\n    }\n\n    if ( bson_ensure_space( b, 1 + len + dataSize ) == BSON_ERROR ) {\n        return BSON_ERROR;\n    }\n\n    if( bson_check_field_name( b, ( const char * )name, len - 1 ) == BSON_ERROR ) {\n        bson_builder_error( b );\n        return BSON_ERROR;\n    }\n\n    bson_append_byte( b, ( char )type );\n    bson_append( b, name, len );\n    return BSON_OK;\n}","23517":"static int kill_proc(struct task_struct *t, unsigned long addr, int trapno,\n\t\t\tunsigned long pfn, struct page *page, int flags)\n{\n\tstruct siginfo si;\n\tint ret;\n\n\tpr_err(\"STR\",\n\t\tpfn, t->comm, t->pid);\n\tsi.si_signo = SIGBUS;\n\tsi.si_errno = 0;\n\tsi.si_addr = (void *)addr;\n#ifdef __ARCH_SI_TRAPNO\n\tsi.si_trapno = trapno;\n#endif\n\tsi.si_addr_lsb = compound_order(compound_head(page)) + PAGE_SHIFT;\n\n\tif ((flags & MF_ACTION_REQUIRED) && t->mm == current->mm) {\n\t\tsi.si_code = BUS_MCEERR_AR;\n\t\tret = force_sig_info(SIGBUS, &si, current);\n\t} else {\n\t\t\n\t\tsi.si_code = BUS_MCEERR_AO;\n\t\tret = send_sig_info(SIGBUS, &si, t);  \n\t}\n\tif (ret < 0)\n\t\tpr_info(\"STR\",\n\t\t\tt->comm, t->pid, ret);\n\treturn ret;\n}","22834":"ldbm_config_entryrdn_noancestorid_get(void *arg __attribute__((unused)))\n{\n    return (void *)((uintptr_t)entryrdn_get_noancestorid());\n}","23642":"int enc_untrusted_inet_pton(int af, const char *src, void *dst) {\n  if (!src || !dst) {\n    return 0;\n  }\n\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{\n      src, std::min(strlen(src) + 1, static_cast<size_t>(INET6_ADDRSTRLEN))});\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetPtonHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"STR\", 3);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return -1;\n  }\n\n  auto klinux_addr_buffer = output.next();\n  size_t max_size = 0;\n  if (af == AF_INET) {\n    max_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    max_size = sizeof(struct in6_addr);\n  }\n  memcpy(dst, klinux_addr_buffer.data(),\n         std::min(klinux_addr_buffer.size(), max_size));\n  return result;\n}","23249":"static RAND_DRBG *rand_drbg_new(int secure,\n                                int type,\n                                unsigned int flags,\n                                RAND_DRBG *parent)\n{\n    RAND_DRBG *drbg = secure ? OPENSSL_secure_zalloc(sizeof(*drbg))\n                             : OPENSSL_zalloc(sizeof(*drbg));\n\n    if (drbg == NULL) {\n        RANDerr(RAND_F_RAND_DRBG_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    drbg->secure = secure && CRYPTO_secure_allocated(drbg);\n    drbg->fork_count = rand_fork_count;\n    drbg->parent = parent;\n\n    if (parent == NULL) {\n        drbg->get_entropy = rand_drbg_get_entropy;\n        drbg->cleanup_entropy = rand_drbg_cleanup_entropy;\n#ifndef RAND_DRBG_GET_RANDOM_NONCE\n        drbg->get_nonce = rand_drbg_get_nonce;\n        drbg->cleanup_nonce = rand_drbg_cleanup_nonce;\n#endif\n\n        drbg->reseed_interval = master_reseed_interval;\n        drbg->reseed_time_interval = master_reseed_time_interval;\n    } else {\n        drbg->get_entropy = rand_drbg_get_entropy;\n        drbg->cleanup_entropy = rand_drbg_cleanup_entropy;\n        \n\n        drbg->reseed_interval = slave_reseed_interval;\n        drbg->reseed_time_interval = slave_reseed_time_interval;\n    }\n\n    if (RAND_DRBG_set(drbg, type, flags) == 0)\n        goto err;\n\n    if (parent != NULL) {\n        rand_drbg_lock(parent);\n        if (drbg->strength > parent->strength) {\n            \n            rand_drbg_unlock(parent);\n            RANDerr(RAND_F_RAND_DRBG_NEW, RAND_R_PARENT_STRENGTH_TOO_WEAK);\n            goto err;\n        }\n        rand_drbg_unlock(parent);\n    }\n\n    return drbg;\n\n err:\n    RAND_DRBG_free(drbg);\n\n    return NULL;\n}","23182":"void vnc_convert_pixel(VncState *vs, uint8_t *buf, uint32_t v)\n{\n    uint8_t r, g, b;\n    VncDisplay *vd = vs->vd;\n\n    r = ((((v & vd->server->pf.rmask) >> vd->server->pf.rshift) << vs->clientds.pf.rbits) >>\n        vd->server->pf.rbits);\n    g = ((((v & vd->server->pf.gmask) >> vd->server->pf.gshift) << vs->clientds.pf.gbits) >>\n        vd->server->pf.gbits);\n    b = ((((v & vd->server->pf.bmask) >> vd->server->pf.bshift) << vs->clientds.pf.bbits) >>\n        vd->server->pf.bbits);\n    v = (r << vs->clientds.pf.rshift) |\n        (g << vs->clientds.pf.gshift) |\n        (b << vs->clientds.pf.bshift);\n    switch(vs->clientds.pf.bytes_per_pixel) {\n    case 1:\n        buf[0] = v;\n        break;\n    case 2:\n        if (vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) {\n            buf[0] = v >> 8;\n            buf[1] = v;\n        } else {\n            buf[1] = v >> 8;\n            buf[0] = v;\n        }\n        break;\n    default:\n    case 4:\n        if (vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) {\n            buf[0] = v >> 24;\n            buf[1] = v >> 16;\n            buf[2] = v >> 8;\n            buf[3] = v;\n        } else {\n            buf[3] = v >> 24;\n            buf[2] = v >> 16;\n            buf[1] = v >> 8;\n            buf[0] = v;\n        }\n        break;\n    }\n}","23079":"    \n    CImg<Tfloat> get_resize_object3d(const float sx, const float sy=-100, const float sz=-100) const {\n      return CImg<Tfloat>(*this,false).resize_object3d(sx,sy,sz);","23063":"genrand_real(void) \n{ \n    unsigned long a=genrand_int32()>>5, b=genrand_int32()>>6; \n    return(a*67108864.0+b)*(1.0\/9007199254740992.0); \n} ","23091":"static void nlmclnt_unlock_callback(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t*req = data;\n\tu32 status = ntohl(req->a_res.status);\n\n\tif (RPC_ASSASSINATED(task))\n\t\tgoto die;\n\n\tif (task->tk_status < 0) {\n\t\tdprintk(\"STR\", -task->tk_status);\n\t\tgoto retry_rebind;\n\t}\n\tif (status == NLM_LCK_DENIED_GRACE_PERIOD) {\n\t\trpc_delay(task, NLMCLNT_GRACE_WAIT);\n\t\tgoto retry_unlock;\n\t}\n\tif (status != NLM_LCK_GRANTED)\n\t\tprintk(KERN_WARNING \"STR\", status);\ndie:\n\treturn;\n retry_rebind:\n\tnlm_rebind_host(req->a_host);\n retry_unlock:\n\trpc_restart_call(task);\n}","22778":"void RGWDelBucketMetaSearch::pre_exec()\n{\n  rgw_bucket_object_pre_exec(s);\n}","23355":"gsd_xrandr_manager_constructor (GType                  type,\n                              guint                  n_construct_properties,\n                              GObjectConstructParam *construct_properties)\n{\n        GsdXrandrManager      *xrandr_manager;\n        GsdXrandrManagerClass *klass;\n\n        klass = GSD_XRANDR_MANAGER_CLASS (g_type_class_peek (GSD_TYPE_XRANDR_MANAGER));\n\n        xrandr_manager = GSD_XRANDR_MANAGER (G_OBJECT_CLASS (gsd_xrandr_manager_parent_class)->constructor (type,\n                                                                                                      n_construct_properties,\n                                                                                                      construct_properties));\n\n        return G_OBJECT (xrandr_manager);\n}","23333":"  virtual GBool supportTextCSPattern(GfxState *state) {\n      return state->getFillColorSpace()->getMode() == csPattern; }","23378":"COMPS_HSList ** comps_mrtree_getp(COMPS_MRTree * rt, const char * key) {\n    COMPS_HSList * subnodes;\n    COMPS_HSListItem * it = NULL;\n    COMPS_MRTreeData * rtdata;\n    unsigned int offset, len, x;\n    char found, ended;\n\n    len = strlen(key);\n    offset = 0;\n    subnodes = rt->subnodes;\n    while (offset != len) {\n        found = 0;\n        for (it = subnodes->first; it != NULL; it=it->next) {\n            if (((COMPS_MRTreeData*)it->data)->key[0] == key[offset]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found)\n            return NULL;\n        rtdata = (COMPS_MRTreeData*)it->data;\n\n        for (x=1; ;x++) {\n            ended=0;\n            if (rtdata->key[x] == 0) ended += 1;\n            if (x == len - offset) ended += 2;\n            if (ended != 0) break;\n            if (key[offset+x] != rtdata->key[x]) break;\n        }\n        if (ended == 3) return &rtdata->data;\n        else if (ended == 1) offset+=x;\n        else return NULL;\n        subnodes = ((COMPS_MRTreeData*)it->data)->subnodes;\n    }\n    if (it)\n        return &((COMPS_MRTreeData*)it->data)->data;\n    else return NULL;\n}","23419":"ZEND_API void zend_hash_bucket_swap(Bucket *p, Bucket *q)\n{\n\tzval val;\n\tzend_ulong h;\n\tzend_string *key;\n\n\tZVAL_COPY_VALUE(&val, &p->val);\n\th = p->h;\n\tkey = p->key;\n\n\tZVAL_COPY_VALUE(&p->val, &q->val);\n\tp->h = q->h;\n\tp->key = q->key;\n\n\tZVAL_COPY_VALUE(&q->val, &val);\n\tq->h = h;\n\tq->key = key;\n}","23466":"static DWORD WINAPI serial_thread_func(LPVOID arg)\n{\n\tIRP* irp;\n\twMessage message;\n\tSERIAL_DEVICE* serial = (SERIAL_DEVICE*)arg;\n\tUINT error = CHANNEL_RC_OK;\n\n\twhile (1)\n\t{\n\t\tif (!MessageQueue_Wait(serial->MainIrpQueue))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"STR\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!MessageQueue_Peek(serial->MainIrpQueue, &message, TRUE))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"STR\");\n\t\t\terror = ERROR_INTERNAL_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (message.id == WMQ_QUIT)\n\t\t{\n\t\t\tterminate_pending_irp_threads(serial);\n\t\t\tbreak;\n\t\t}\n\n\t\tirp = (IRP*)message.wParam;\n\n\t\tif (irp)\n\t\t\tcreate_irp_thread(serial, irp);\n\t}\n\n\tif (error && serial->rdpcontext)\n\t\tsetChannelError(serial->rdpcontext, error, \"STR\");\n\n\tExitThread(error);\n\treturn error;\n}","23451":"invalidate_cached_quoted_dollar_at ()\n{\n  dispose_words (cached_quoted_dollar_at);\n  cached_quoted_dollar_at = 0;\n}","23268":"lys_module_pos(struct lys_module *module)\n{\n    int i;\n    uint32_t pos = 1;\n\n    for (i = 0; i < module->ctx->models.used; ++i) {\n        if (module->ctx->models.list[i] == module) {\n            return pos;\n        }\n        ++pos;\n    }\n\n    LOGINT(module->ctx);\n    return 0;\n}","22746":"_PUBLIC_ size_t strlen_m_ext_handle(struct smb_iconv_handle *ic,\n\t\t\t\t    const char *s, charset_t src_charset, charset_t dst_charset)\n{\n\tsize_t count = 0;\n\n#ifdef DEVELOPER\n\tswitch (dst_charset) {\n\tcase CH_DOS:\n\tcase CH_UNIX:\n\t\tsmb_panic(\"STR\");\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (src_charset) {\n\tcase CH_UTF16LE:\n\tcase CH_UTF16BE:\n\t\tsmb_panic(\"STR\");\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n\tif (!s) {\n\t\treturn 0;\n\t}\n\n\twhile (*s && !(((uint8_t)*s) & 0x80)) {\n\t\ts++;\n\t\tcount++;\n\t}\n\n\tif (!*s) {\n\t\treturn count;\n\t}\n\n\twhile (*s) {\n\t\tsize_t c_size;\n\t\tcodepoint_t c = next_codepoint_handle_ext(ic, s, src_charset, &c_size);\n\t\ts += c_size;\n\n\t\tswitch (dst_charset) {\n\t\tcase CH_UTF16LE:\n\t\tcase CH_UTF16BE:\n\t\tcase CH_UTF16MUNGED:\n\t\t\tif (c < 0x10000) {\n\t\t\t\t\n\t\t\t\tcount += 1;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tcount += 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CH_UTF8:\n\t\t\t\n\t\t\tif (c < 0x80) {\n\t\t\t\tcount += 1;\n\t\t\t} else if (c < 0x800) {\n\t\t\t\tcount += 2;\n\t\t\t} else if (c < 0x10000) {\n\t\t\t\tcount += 3;\n\t\t\t} else {\n\t\t\t\tcount += 4;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t\n\t\t\tcount += 1;\n\t\t}\n\t}\n\n\treturn count;\n}","23292":"Expr *sqlite3Expr(\n  sqlite3 *db,            \n  int op,                 \n  const char *zToken      \n){\n  Token x;\n  x.z = zToken;\n  x.n = sqlite3Strlen30(zToken);\n  return sqlite3ExprAlloc(db, op, &x, 0);\n}","22886":"CompatSet OSD::get_osd_compat_set() {\n  CompatSet compat =  get_osd_initial_compat_set();\n  \n  compat.incompat.insert(CEPH_OSD_FEATURE_INCOMPAT_SHARDS);\n  return compat;\n}","22827":"PHP_FUNCTION(bcdiv)\n{\n\tchar *left, *right;\n\tint left_len, right_len;\n\tlong scale_param = 0;\n\tbc_num first, second, result;\n\tint scale = BCG(bc_precision), argc = ZEND_NUM_ARGS();\n\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"STR\", &left, &left_len, &right, &right_len, &scale_param) == FAILURE) {\n\t\treturn;\n\t}\n\t\n\tif (argc == 3) {\n\t\tscale = (int) ((int)scale_param < 0) ? 0 : scale_param;\n\t}\n\t\n\tbc_init_num(&first TSRMLS_CC);\n\tbc_init_num(&second TSRMLS_CC);\n\tbc_init_num(&result TSRMLS_CC);\n\tphp_str2num(&first, left TSRMLS_CC);\n\tphp_str2num(&second, right TSRMLS_CC);\n\n\tswitch (bc_divide(first, second, &result, scale TSRMLS_CC)) {\n\t\tcase 0: \n\t\t\tif (result->n_scale > scale) {\n\t\t\t\tresult->n_scale = scale;\n\t\t\t}\n\t\t\tZ_STRVAL_P(return_value) = bc_num2str(result);\n\t\t\tZ_STRLEN_P(return_value) = strlen(Z_STRVAL_P(return_value));\n\t\t\tZ_TYPE_P(return_value) = IS_STRING;\n\t\t\tbreak;\n\t\tcase -1: \n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"STR\");\n\t\t\tbreak;\n\t}\n\n\tbc_free_num(&first);\n\tbc_free_num(&second);\n\tbc_free_num(&result);\n\treturn;\n}","23692":"PHP_FUNCTION(enchant_broker_request_dict)\n{\n\tzval *broker;\n\tenchant_broker *pbroker;\n\tenchant_dict *dict;\n\tEnchantDict *d;\n\tchar *tag;\n\tint taglen;\n\tint pos;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"STR\", &broker, &tag, &taglen) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_ENCHANT_GET_BROKER;\n\t\n\tif (taglen == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"STR\");\n\t\tRETURN_FALSE;\n\t}\n\n\td = enchant_broker_request_dict(pbroker->pbroker, (const char *)tag);\n\tif (d) {\n\t\tif (pbroker->dictcnt) {\n\t\t\tpbroker->dict = (enchant_dict **)erealloc(pbroker->dict, sizeof(enchant_dict *) * pbroker->dictcnt);\n\t\t\tpos = pbroker->dictcnt++;\n\t\t} else {\n\t\t\tpbroker->dict = (enchant_dict **)emalloc(sizeof(enchant_dict *));\n\t\t\tpos = 0;\n\t\t\tpbroker->dictcnt++;\n\t\t}\n\n\t\tdict = pbroker->dict[pos] = (enchant_dict *)emalloc(sizeof(enchant_dict));\n\t\tdict->id = pos;\n\t\tdict->pbroker = pbroker;\n\t\tdict->pdict = d;\n\t\tdict->prev = pos ? pbroker->dict[pos-1] : NULL;\n\t\tdict->next = NULL;\n\t\tpbroker->dict[pos] = dict;\n\n\t\tif (pos) {\n\t\t\tpbroker->dict[pos-1]->next = dict;\n\t\t}\n\n\t\tdict->rsrc_id = ZEND_REGISTER_RESOURCE(return_value, dict, le_enchant_dict);\n\t\tzend_list_addref(pbroker->rsrc_id);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}","23351":"static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"STR\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"STR\",\n\t\t alg->cra_ablkcipher.geniv ?: \"STR\");\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}","23558":"static int ext4_dax_writepages(struct address_space *mapping,\n\t\t\t       struct writeback_control *wbc)\n{\n\tint ret;\n\tlong nr_to_write = wbc->nr_to_write;\n\tstruct inode *inode = mapping->host;\n\tstruct ext4_sb_info *sbi = EXT4_SB(mapping->host->i_sb);\n\n\tif (unlikely(ext4_forced_shutdown(EXT4_SB(inode->i_sb))))\n\t\treturn -EIO;\n\n\tpercpu_down_read(&sbi->s_journal_flag_rwsem);\n\ttrace_ext4_writepages(inode, wbc);\n\n\tret = dax_writeback_mapping_range(mapping, inode->i_sb->s_bdev, wbc);\n\ttrace_ext4_writepages_result(inode, wbc, ret,\n\t\t\t\t     nr_to_write - wbc->nr_to_write);\n\tpercpu_up_read(&sbi->s_journal_flag_rwsem);\n\treturn ret;\n}","22727":"void nci_unregister_device(struct nci_dev *ndev)\n{\n\tstruct nci_conn_info *conn_info, *n;\n\n\tnci_close_device(ndev);\n\n\tdestroy_workqueue(ndev->cmd_wq);\n\tdestroy_workqueue(ndev->rx_wq);\n\tdestroy_workqueue(ndev->tx_wq);\n\n\tlist_for_each_entry_safe(conn_info, n, &ndev->conn_info_list, list) {\n\t\tlist_del(&conn_info->list);\n\t\t\n\t}\n\n\tnfc_unregister_device(ndev->nfc_dev);\n}","23651":"void intel_guc_ads_reset(struct intel_guc *guc)\n{\n\tif (!guc->ads_vma)\n\t\treturn;\n\t__guc_ads_init(guc);\n}","23488":"kdc_process_for_user(kdc_realm_t *kdc_active_realm,\n                     krb5_pa_data *pa_data,\n                     krb5_keyblock *tgs_session,\n                     krb5_pa_s4u_x509_user **s4u_x509_user,\n                     const char **status)\n{\n    krb5_error_code             code;\n    krb5_pa_for_user            *for_user;\n    krb5_data                   req_data;\n\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n\n    code = decode_krb5_pa_for_user(&req_data, &for_user);\n    if (code)\n        return code;\n\n    code = verify_for_user_checksum(kdc_context, tgs_session, for_user);\n    if (code) {\n        *status = \"STR\";\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return code;\n    }\n\n    *s4u_x509_user = calloc(1, sizeof(krb5_pa_s4u_x509_user));\n    if (*s4u_x509_user == NULL) {\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return ENOMEM;\n    }\n\n    (*s4u_x509_user)->user_id.user = for_user->user;\n    for_user->user = NULL;\n    krb5_free_pa_for_user(kdc_context, for_user);\n\n    return 0;\n}","23440":"list_file(struct cpio_file_stat* file_hdr, int in_file_des)\n{\n  if (verbose_flag)\n    {\n#ifdef CP_IFLNK\n      if ((file_hdr->c_mode & CP_IFMT) == CP_IFLNK)\n\t{\n\t  if (archive_format != arf_tar && archive_format != arf_ustar)\n\t    {\n\t      char *link_name = NULL;\t\n\n\t      link_name = (char *) xmalloc ((unsigned int) file_hdr->c_filesize + 1);\n\t      link_name[file_hdr->c_filesize] = '\\0';\n\t      tape_buffered_read (link_name, in_file_des, file_hdr->c_filesize);\n\t      long_format (file_hdr, link_name);\n\t      free (link_name);\n\t      tape_skip_padding (in_file_des, file_hdr->c_filesize);\n\t      return;\n\t    }\n\t  else\n\t    {\n\t      long_format (file_hdr, file_hdr->c_tar_linkname);\n\t      return;\n\t    }\n\t}\n      else\n#endif\n\tlong_format (file_hdr, (char *) 0);\n    }\n  else\n    {\n      \n      printf (\"STR\", file_hdr->c_name, name_end);\n    }\n\n  crc = 0;\n  tape_toss_input (in_file_des, file_hdr->c_filesize);\n  tape_skip_padding (in_file_des, file_hdr->c_filesize);\n  if (only_verify_crc_flag)\n    {\n#ifdef CP_IFLNK\n      if ((file_hdr->c_mode & CP_IFMT) == CP_IFLNK)\n\t{\n\t  return;   \n\t}\n#endif\n      if (crc != file_hdr->c_chksum)\n\t{\n\t  error (0, 0, _(\"STR\"),\n\t\t file_hdr->c_name, crc, file_hdr->c_chksum);\n\t}\n    }\n}","22919":"static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MagickPathExtent];\n\n  const MagicInfo\n    *magic_info;    \n\n  FILE\n    *ps_file;\n\n  ImageInfo\n    *clone_info;\n    \n  Image\n    *image2;\n    \n  unsigned char\n    magick[2*MagickPathExtent];    \n    \n\n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n\n  \n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"STR\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n\n  \n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MagickPathExtent, magick);\n  \n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while(PS_Size-- > 0)\n    {\n      (void) fputc(ReadBlobByte(image),ps_file);\n    }\n  (void) fclose(ps_file);\n  \n    \n  magic_info=GetMagicInfo(magick,2*MagickPathExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n  \n  if(exception->severity != UndefinedException) goto FINISH_UNL;     \n  if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n    \n  (void) strncpy(clone_info->magick,magic_info->name,MagickPathExtent-1);\n  \n    \n  \n  FormatLocaleString(clone_info->filename,MagickPathExtent,\"STR\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n\n  if (!image2)\n    goto FINISH_UNL;\n\n  \n  (void) CopyMagickString(image2->filename,image->filename,MagickPathExtent);\n  (void) CopyMagickString(image2->magick_filename,image->magick_filename,MagickPathExtent);\n  (void) CopyMagickString(image2->magick,image->magick,MagickPathExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n\n  AppendImageToList(&image,image2);\n\n FINISH_UNL:    \n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}","23774":"builtin_ord(PyObject *module, PyObject *c)\n\n{\n    long ord;\n    Py_ssize_t size;\n\n    if (PyBytes_Check(c)) {\n        size = PyBytes_GET_SIZE(c);\n        if (size == 1) {\n            ord = (long)((unsigned char)*PyBytes_AS_STRING(c));\n            return PyLong_FromLong(ord);\n        }\n    }\n    else if (PyUnicode_Check(c)) {\n        if (PyUnicode_READY(c) == -1)\n            return NULL;\n        size = PyUnicode_GET_LENGTH(c);\n        if (size == 1) {\n            ord = (long)PyUnicode_READ_CHAR(c, 0);\n            return PyLong_FromLong(ord);\n        }\n    }\n    else if (PyByteArray_Check(c)) {\n        \n        size = PyByteArray_GET_SIZE(c);\n        if (size == 1) {\n            ord = (long)((unsigned char)*PyByteArray_AS_STRING(c));\n            return PyLong_FromLong(ord);\n        }\n    }\n    else {\n        PyErr_Format(PyExc_TypeError,\n                     \"STR\" \\\n                     \"STR\", c->ob_type->tp_name);\n        return NULL;\n    }\n\n    PyErr_Format(PyExc_TypeError,\n                 \"STR\"\n                 \"STR\",\n                 size);\n    return NULL;\n}","22771":"void XMLRPC_SetValueDateTime_ISO8601(XMLRPC_VALUE value, const char* s) {\n   if(value) {\n      time_t time_val = 0;\n      if(s) {\n         date_from_ISO8601(s, &time_val);\n         XMLRPC_SetValueDateTime(value, time_val);\n      }\n   }\n}","22536":"static int kvaser_usb_leaf_flush_queue(struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->id = CMD_FLUSH_QUEUE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_flush_queue);\n\tcmd->u.flush_queue.channel = priv->channel;\n\tcmd->u.flush_queue.flags = 0x00;\n\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\n\tkfree(cmd);\n\treturn rc;\n}","22750":"TEST_F(ConnectionHandlerTest, WildcardListenerWithNoOriginalDst) {\n  TestListener* test_listener1 = addListener(1, true, true, \"STR\");\n  Network::MockListener* listener1 = new Network::MockListener();\n  Network::ListenerCallbacks* listener_callbacks1;\n  EXPECT_CALL(dispatcher_, createListener_(_, _, _))\n      .WillOnce(\n          Invoke([&](Network::Socket&, Network::ListenerCallbacks& cb, bool) -> Network::Listener* {\n            listener_callbacks1 = &cb;\n            return listener1;\n          }));\n  Network::Address::InstanceConstSharedPtr normal_address(\n      new Network::Address::Ipv4Instance(\"STR\", 80));\n  Network::Address::InstanceConstSharedPtr any_address = Network::Utility::getAddressWithPort(\n      *Network::Utility::getIpv4AnyAddress(), normal_address->ip()->port());\n  EXPECT_CALL(test_listener1->socket_, localAddress()).WillRepeatedly(ReturnRef(any_address));\n  handler_->addListener(*test_listener1);\n\n  Network::MockListenerFilter* test_filter = new Network::MockListenerFilter();\n  Network::MockConnectionSocket* accepted_socket = new NiceMock<Network::MockConnectionSocket>();\n  EXPECT_CALL(factory_, createListenerFilterChain(_))\n      .WillRepeatedly(Invoke([&](Network::ListenerFilterManager& manager) -> bool {\n        \n        manager.addAcceptFilter(Network::ListenerFilterPtr{test_filter});\n        return true;\n      }));\n  EXPECT_CALL(*test_filter, onAccept(_)).WillOnce(Return(Network::FilterStatus::Continue));\n  EXPECT_CALL(*accepted_socket, localAddressRestored()).WillOnce(Return(false));\n  EXPECT_CALL(*accepted_socket, localAddress()).WillRepeatedly(ReturnRef(normal_address));\n  EXPECT_CALL(manager_, findFilterChain(_)).WillOnce(Return(filter_chain_.get()));\n  Network::MockConnection* connection = new NiceMock<Network::MockConnection>();\n  EXPECT_CALL(dispatcher_, createServerConnection_()).WillOnce(Return(connection));\n  EXPECT_CALL(factory_, createNetworkFilterChain(_, _)).WillOnce(Return(true));\n  listener_callbacks1->onAccept(Network::ConnectionSocketPtr{accepted_socket});\n  EXPECT_EQ(1UL, handler_->numConnections());\n\n  EXPECT_CALL(*listener1, onDestroy());\n}","22945":"static void set_error_response(h2_stream *stream, int http_status)\n{\n    if (!h2_stream_is_ready(stream)) {\n        stream->rtmp->http_status = http_status;\n    }\n}","22788":"bool SafeX509ExtPrint(const BIOPointer& out, X509_EXTENSION* ext) {\n  const X509V3_EXT_METHOD* method = X509V3_EXT_get(ext);\n\n  if (method != X509V3_EXT_get_nid(NID_subject_alt_name))\n    return false;\n\n  GENERAL_NAMES* names = static_cast<GENERAL_NAMES*>(X509V3_EXT_d2i(ext));\n  if (names == nullptr)\n    return false;\n\n  for (int i = 0; i < sk_GENERAL_NAME_num(names); i++) {\n    GENERAL_NAME* gen = sk_GENERAL_NAME_value(names, i);\n\n    if (i != 0)\n      BIO_write(out.get(), \"STR\", 2);\n\n    if (gen->type == GEN_DNS) {\n      ASN1_IA5STRING* name = gen->d.dNSName;\n\n      BIO_write(out.get(), \"STR\", 4);\n      BIO_write(out.get(), name->data, name->length);\n    } else {\n      STACK_OF(CONF_VALUE)* nval = i2v_GENERAL_NAME(\n          const_cast<X509V3_EXT_METHOD*>(method), gen, nullptr);\n      if (nval == nullptr)\n        return false;\n      X509V3_EXT_val_prn(out.get(), nval, 0, 0);\n      sk_CONF_VALUE_pop_free(nval, X509V3_conf_free);\n    }\n  }\n  sk_GENERAL_NAME_pop_free(names, GENERAL_NAME_free);\n\n  return true;\n}","23361":"static PHP_NAMED_FUNCTION(zif_zip_entry_read)\n{\n\tzval * zip_entry;\n\tzend_long len = 0;\n\tzip_read_rsrc * zr_rsrc;\n\tzend_string *buffer;\n\tint n = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"STR\", &zip_entry, &len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (len <= 0) {\n\t\tlen = 1024;\n\t}\n\n\tif (zr_rsrc->zf) {\n\t\tbuffer = zend_string_alloc(len, 0);\n\t\tn = zip_fread(zr_rsrc->zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\t\tif (n > 0) {\n\t\t\tZSTR_VAL(buffer)[n] = '\\0';\n\t\t\tZSTR_LEN(buffer) = n;\n\t\t\tRETURN_NEW_STR(buffer);\n\t\t} else {\n\t\t\tzend_string_free(buffer);\n\t\t\tRETURN_EMPTY_STRING()\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}","23134":"void CLASS lossless_jpeg_load_raw()\n{\n  int jwide, jrow, jcol, val, jidx, i, j, row=0, col=0;\n  struct jhead jh;\n  ushort *rp;\n\n  if (!ljpeg_start (&jh, 0)) return;\n  jwide = jh.wide * jh.clrs;\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  try {\n#endif\n  for (jrow=0; jrow < jh.high; jrow++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    rp = ljpeg_row (jrow, &jh);\n    if (load_flags & 1)\n      row = jrow & 1 ? height-1-jrow\/2 : jrow\/2;\n    for (jcol=0; jcol < jwide; jcol++) {\n      val = curve[*rp++];\n      if (cr2_slice[0]) {\n\tjidx = jrow*jwide + jcol;\n\ti = jidx \/ (cr2_slice[1]*jh.high);\n\tif ((j = i >= cr2_slice[0]))\n\t\t i  = cr2_slice[0];\n\tjidx -= i * (cr2_slice[1]*jh.high);\n\trow = jidx \/ cr2_slice[1+j];\n\tcol = jidx % cr2_slice[1+j] + i*cr2_slice[1];\n      }\n      if (raw_width == 3984 && (col -= 2) < 0)\n\tcol += (row--,raw_width);\n      if ((unsigned) row < raw_height) RAW(row,col) = val;\n      if (++col >= raw_width)\n\tcol = (row++,0);\n    }\n  }\n#ifdef LIBRAW_LIBRARY_BUILD\n  } catch (...) {\n    ljpeg_end (&jh);\n    throw;\n  }\n#endif\n  ljpeg_end (&jh);\n}","22757":"int ldb_kv_search_dn1(struct ldb_module *module,\n\t\t      struct ldb_dn *dn,\n\t\t      struct ldb_message *msg,\n\t\t      unsigned int unpack_flags)\n{\n\tvoid *data = ldb_module_get_private(module);\n\tstruct ldb_kv_private *ldb_kv =\n\t    talloc_get_type(data, struct ldb_kv_private);\n\tint ret;\n\tuint8_t guid_key[LDB_KV_GUID_KEY_SIZE];\n\tstruct ldb_val key = {\n\t\t.data = guid_key,\n\t\t.length = sizeof(guid_key)\n\t};\n\tTALLOC_CTX *tdb_key_ctx = NULL;\n\n\tif (ldb_kv->cache->GUID_index_attribute == NULL ||\n\t    ldb_dn_is_special(dn)) {\n\n\t\ttdb_key_ctx = talloc_new(msg);\n\t\tif (!tdb_key_ctx) {\n\t\t\treturn ldb_module_oom(module);\n\t\t}\n\n\t\t\n\t\tkey = ldb_kv_key_dn(module, tdb_key_ctx, dn);\n\t\tif (!key.data) {\n\t\t\tTALLOC_FREE(tdb_key_ctx);\n\t\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t\t}\n\t} else {\n\t\t\n\t\tret = ldb_kv_key_dn_from_idx(module, ldb_kv, msg, dn, &key);\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = ldb_kv_search_key(module, ldb_kv, key, msg, unpack_flags);\n\n\tTALLOC_FREE(tdb_key_ctx);\n\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\n\tif ((unpack_flags & LDB_UNPACK_DATA_FLAG_NO_DN) == 0) {\n\t\tif (!msg->dn) {\n\t\t\tmsg->dn = ldb_dn_copy(msg, dn);\n\t\t}\n\t\tif (!msg->dn) {\n\t\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t\t}\n\t}\n\n\treturn LDB_SUCCESS;\n}","23726":"struct dentry *__d_lookup(const struct dentry *parent, const struct qstr *name)\n{\n\tunsigned int len = name->len;\n\tunsigned int hash = name->hash;\n\tconst unsigned char *str = name->name;\n\tstruct hlist_bl_head *b = d_hash(parent, hash);\n\tstruct hlist_bl_node *node;\n\tstruct dentry *found = NULL;\n\tstruct dentry *dentry;\n\n\t\n\n\t\n\trcu_read_lock();\n\t\n\thlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) {\n\n\t\tif (dentry->d_name.hash != hash)\n\t\t\tcontinue;\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_parent != parent)\n\t\t\tgoto next;\n\t\tif (d_unhashed(dentry))\n\t\t\tgoto next;\n\n\t\t\n\t\tif (parent->d_flags & DCACHE_OP_COMPARE) {\n\t\t\tint tlen = dentry->d_name.len;\n\t\t\tconst char *tname = dentry->d_name.name;\n\t\t\tif (parent->d_op->d_compare(parent, dentry, tlen, tname, name))\n\t\t\t\tgoto next;\n\t\t} else {\n\t\t\tif (dentry->d_name.len != len)\n\t\t\t\tgoto next;\n\t\t\tif (dentry_cmp(dentry, str, len))\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tdentry->d_lockref.count++;\n\t\tfound = dentry;\n\t\tspin_unlock(&dentry->d_lock);\n\t\tbreak;\nnext:\n\t\tspin_unlock(&dentry->d_lock);\n \t}\n \trcu_read_unlock();\n\n \treturn found;\n}","23104":"void virDomainHostdevDefFree(virDomainHostdevDefPtr def)\n{\n    if (!def)\n        return;\n\n    \n    virDomainHostdevDefClear(def);\n\n    \n    if (!def->parentnet)\n        VIR_FREE(def);\n}","23782":"cJSON *cJSON_CreateIntArray( int64_t *numbers, int count )\n{\n\tint i;\n\tcJSON *n = 0, *p = 0, *a = cJSON_CreateArray();\n\tfor ( i = 0; a && i < count; ++i ) {\n\t\tn = cJSON_CreateInt( numbers[i] );\n\t\tif ( ! i )\n\t\t\ta->child = n;\n\t\telse\n\t\t\tsuffix_object( p, n );\n\t\tp = n;\n\t}\n\treturn a;\n}","22825":"force_sig_info(int sig, struct siginfo *info, struct task_struct *t)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\tif (action->sa.sa_handler == SIG_DFL)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = specific_send_sig_info(sig, info, t);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}","23303":"GF_FileType get_file_type_by_ext(char *inName)\n{\n\tGF_FileType type = GF_FILE_TYPE_NOT_SUPPORTED;\n\tchar *ext = strrchr(inName, '.');\n\tif (ext) {\n\t\tchar *sep;\n\t\tif (!strcmp(ext, \"STR\")) ext = strrchr(ext-1, '.');\n\t\text+=1;\n\t\tsep = strchr(ext, '.');\n\t\tif (sep) sep[0] = 0;\n\n\t\tif (!stricmp(ext, \"STR\")) {\n\t\t\ttype = GF_FILE_TYPE_ISO_MEDIA;\n\t\t} else if (!stricmp(ext, \"STR\")) {\n\t\t\ttype = GF_FILE_TYPE_BT_WRL_X3DV;\n\t\t} else if (!stricmp(ext, \"STR\")) {\n\t\t\ttype = GF_FILE_TYPE_XMT_X3D;\n\t\t} else if (!stricmp(ext, \"STR\")) {\n\t\t\ttype = GF_FILE_TYPE_LSR_SAF;\n\t\t} else if (!stricmp(ext, \"STR\")) {\n\t\t\ttype = GF_FILE_TYPE_SVG;\n\t\t} else if (!stricmp(ext, \"STR\")) {\n\t\t\ttype = GF_FILE_TYPE_SWF;\n\t\t} else if (!stricmp(ext, \"STR\")) {\n\t\t\tif (sep) sep[0] = '.';\n\t\t\treturn GF_FILE_TYPE_NOT_SUPPORTED;\n\t\t}\n\t\telse type = GF_FILE_TYPE_NOT_SUPPORTED;\n\n\t\tif (sep) sep[0] = '.';\n\t}\n\n\n\t\n\tif (!type && gf_isom_probe_file(inName)) type = GF_FILE_TYPE_ISO_MEDIA;\n\treturn type;\n}","22875":"GF_Err trpy_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_TRPYBox *ptr = (GF_TRPYBox *)s;\n\tif (ptr == NULL) return GF_BAD_PARAM;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u64(bs, ptr->nbBytes);\n\treturn GF_OK;\n}","23657":"PHP_FUNCTION(readfile)\n{\n\tchar *filename;\n\tint filename_len;\n\tint size = 0;\n\tzend_bool use_include_path = 0;\n\tzval *zcontext = NULL;\n\tphp_stream *stream;\n\tphp_stream_context *context = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"STR\", &filename, &filename_len, &use_include_path, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tstream = php_stream_open_wrapper_ex(filename, \"STR\", (use_include_path ? USE_PATH : 0) | ENFORCE_SAFE_MODE | REPORT_ERRORS, NULL, context);\n\tif (stream) {\n\t\tsize = php_stream_passthru(stream);\n\t\tphp_stream_close(stream);\n\t\tRETURN_LONG(size);\n\t}\n\n\tRETURN_FALSE;\n}","22973":"apr_byte_t oidc_post_preserve_javascript(request_rec *r, const char *location,\n\t\tchar **javascript, char **javascript_method) {\n\n\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\treturn FALSE;\n\n\toidc_debug(r, \"STR\");\n\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\n\tif (apr_strnatcmp(method, OIDC_METHOD_FORM_POST) != 0)\n\t\treturn FALSE;\n\n\t\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r, \"STR\");\n\t\treturn FALSE;\n\t}\n\n\tconst apr_array_header_t *arr = apr_table_elts(params);\n\tconst apr_table_entry_t *elts = (const apr_table_entry_t*) arr->elts;\n\tint i;\n\tchar *json = \"\";\n\tfor (i = 0; i < arr->nelts; i++) {\n\t\tjson = apr_psprintf(r->pool, \"STR\", json,\n\t\t\t\toidc_util_escape_string(r, elts[i].key),\n\t\t\t\toidc_util_escape_string(r, elts[i].val),\n\t\t\t\ti < arr->nelts - 1 ? \"STR\");\n\t}\n\tjson = apr_psprintf(r->pool, \"STR\", json);\n\n\tconst char *jmethod = \"STR\";\n\tconst char *jscript =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"STR\"\n\t\t\t\t\t\"STR\"\n\t\t\t\t\t\"STR\"\n\t\t\t\t\t\"STR\"\n\t\t\t\t\t\"STR\"\n\t\t\t\t\t\"STR\", jmethod, json,\n\t\t\t\t\tlocation ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \"STR\",\n\t\t\t\t\t\t\t\t\tlocation) :\n\t\t\t\t\t\t\t\t\t\"\");\n\tif (location == NULL) {\n\t\tif (javascript_method)\n\t\t\t*javascript_method = apr_pstrdup(r->pool, jmethod);\n\t\tif (javascript)\n\t\t\t*javascript = apr_pstrdup(r->pool, jscript);\n\t} else {\n\t\toidc_util_html_send(r, \"STR\", jscript, jmethod,\n\t\t\t\t\"STR\", OK);\n\t}\n\n\treturn TRUE;\n}","23447":"void CLASS bad_pixels (const char *cfname)\n{\n  FILE *fp=NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed=0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n\n  if (!filters) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);\n#endif\n  if (cfname)\n    fp = fopen (cfname, \"STR\");\n#line 4151 \"STR\"\n  if (!fp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n          return;\n      }\n  while (fgets (line, 128, fp)) {\n    cp = strchr (line, '#');\n    if (cp) *cp = 0;\n    if (sscanf (line, \"STR\", &col, &row, &time) != 3) continue;\n    if ((unsigned) col >= width || (unsigned) row >= height) continue;\n    if (time > timestamp) continue;\n    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)\n      for (r = row-rad; r <= row+rad; r++)\n\tfor (c = col-rad; c <= col+rad; c++)\n\t  if ((unsigned) r < height && (unsigned) c < width &&\n\t\t(r != row || c != col) && fcol(r,c) == fcol(row,col)) {\n\t    tot += BAYER2(r,c);\n\t    n++;\n\t  }\n    BAYER2(row,col) = tot\/n;\n#ifdef DCRAW_VERBOSE\n    if (verbose) {\n      if (!fixed++)\n\tfprintf (stderr,_(\"STR\"));\n      fprintf (stderr, \"STR\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed) fputc ('\\n', stderr);\n#endif\n  fclose (fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);\n#endif\n}","23128":"MagickExport MagickBooleanType DeleteImageProfile(Image *image,const char *name)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"STR\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return(MagickFalse);\n  return(DeleteNodeFromSplayTree((SplayTreeInfo *) image->profiles,name));\n}","23673":"static inline void *inline_data_addr(struct inode *inode, struct page *page)\n{\n\tstruct f2fs_inode *ri = F2FS_INODE(page);\n\tint extra_size = get_extra_isize(inode);\n\n\treturn (void *)&(ri->i_addr[extra_size + DEF_INLINE_RESERVED_SIZE]);\n}","23678":"bool LEX::sp_exit_block(THD *thd, sp_label *lab, Item *when)\n{\n  if (!when)\n    return sp_exit_block(thd, lab);\n\n  DBUG_ASSERT(sphead == thd->lex->sphead);\n  DBUG_ASSERT(spcont == thd->lex->spcont);\n  sp_instr_jump_if_not *i= new (thd->mem_root)\n                           sp_instr_jump_if_not(sphead->instructions(),\n                                                spcont,\n                                                when, thd->lex);\n  if (unlikely(i == NULL) ||\n      unlikely(sphead->add_instr(i)) ||\n      unlikely(sp_exit_block(thd, lab)))\n    return true;\n  i->backpatch(sphead->instructions(), spcont);\n  return false;\n}","23289":"_copyCreateTableSpaceStmt(const CreateTableSpaceStmt *from)\n{\n\tCreateTableSpaceStmt *newnode = makeNode(CreateTableSpaceStmt);\n\n\tCOPY_STRING_FIELD(tablespacename);\n\tCOPY_STRING_FIELD(owner);\n\tCOPY_STRING_FIELD(location);\n\tCOPY_NODE_FIELD(options);\n\n\treturn newnode;\n}","23167":"cdf_count_chain(const cdf_sat_t *sat, cdf_secid_t sid, size_t size)\n{\n\tsize_t i, j;\n\tcdf_secid_t maxsector = (cdf_secid_t)(sat->sat_len * size);\n\n\tDPRINTF((\"STR\"));\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tDPRINTF((\"STR\", sid));\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"STR\"));\n\t\t\terrno = EFTYPE;\n\t\t\treturn (size_t)-1;\n\t\t}\n\t\tif (sid > maxsector) {\n\t\t\tDPRINTF((\"STR\", sid, maxsector));\n\t\t\terrno = EFTYPE;\n\t\t\treturn (size_t)-1;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);\n\t}\n\tif (i == 0) {\n\t\tDPRINTF((\"STR\", sid));\n\t\treturn (size_t)-1;\n\n\t}\n\tDPRINTF((\"STR\"));\n\treturn i;\n}","23132":"static pyc_object *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 size = 0;\n\tut32 n1 = 0;\n\tut32 n2 = 0;\n\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn1 = get_ut8(buffer, &error);\n\t} else {\n\t\tn1 = get_st32(buffer, &error);\n\t}\n\tif (error) {\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tut8 *s1 = malloc(n1 + 1);\n\tif (!s1) {\n\t\treturn NULL;\n\t}\n\t\n\tsize = rz_buf_read(buffer, s1, n1);\n\tif (size != n1) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts1[n1] = '\\0';\n\n\tif ((pyc->magic_int & 0xffff) <= 62061) {\n\t\tn2 = get_ut8(buffer, &error);\n\t} else\n\t\tn2 = get_st32(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tut8 *s2 = malloc(n2 + 1);\n\tif (!s2) {\n\t\treturn NULL;\n\t}\n\t\n\tsize = rz_buf_read(buffer, s2, n2);\n\tif (size != n2) {\n\t\tRZ_FREE(s1);\n\t\tRZ_FREE(s2);\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\ts2[n2] = '\\0';\n\n\tret->type = TYPE_COMPLEX;\n\tret->data = rz_str_newf(\"STR\", s1, s2);\n\tRZ_FREE(s1);\n\tRZ_FREE(s2);\n\tif (!ret->data) {\n\t\tRZ_FREE(ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}","23200":"Method* LinkResolver::lookup_method_in_klasses(const LinkInfo& link_info,\n                                               bool checkpolymorphism,\n                                               bool in_imethod_resolve) {\n  NoSafepointVerifier nsv;  \n\n  Klass* klass = link_info.resolved_klass();\n  Symbol* name = link_info.name();\n  Symbol* signature = link_info.signature();\n\n  \n  Method* result = klass->uncached_lookup_method(name, signature, Klass::OverpassLookupMode::skip);\n\n  if (klass->is_array_klass()) {\n    \n    return result;\n  }\n\n  InstanceKlass* ik = InstanceKlass::cast(klass);\n\n  \n  \n  \n  if (in_imethod_resolve &&\n      result != NULL &&\n      ik->is_interface() &&\n      (result->is_static() || !result->is_public()) &&\n      result->method_holder() == vmClasses::Object_klass()) {\n    result = NULL;\n  }\n\n  \n  \n  if (result == NULL) {\n    result = ik->find_method(name, signature);\n  }\n\n  if (result == NULL) {\n    Array<Method*>* default_methods = ik->default_methods();\n    if (default_methods != NULL) {\n      result = InstanceKlass::find_method(default_methods, name, signature);\n    }\n  }\n\n  if (checkpolymorphism && result != NULL) {\n    vmIntrinsics::ID iid = result->intrinsic_id();\n    if (MethodHandles::is_signature_polymorphic(iid)) {\n      \n      return NULL;\n    }\n  }\n  return result;\n}","23624":"static void wait_for_signal_thread_to_end()\n{\n  uint i;\n  \n  for (i= 0 ; i < 100 && signal_thread_in_use; i++)\n  {\n    if (pthread_kill(signal_thread, MYSQL_KILL_SIGNAL) != ESRCH)\n      break;\n    my_sleep(100);\t\t\t\t\n  }\n}","22651":"static void vcpu_kick_intr(void *info)\n{\n#ifdef DEBUG\n\tstruct kvm_vcpu *vcpu = (struct kvm_vcpu *)info;\n\tprintk(KERN_DEBUG \"STR\", vcpu);\n#endif\n}","22841":"lib_file_open_search_with_no_combine(gs_file_path_ptr  lib_path, const gs_memory_t *mem, i_ctx_t *i_ctx_p,\n                                     const char *fname, uint flen, char *buffer, int blen, uint *pclen, ref *pfile,\n                                     gx_io_device *iodev, bool starting_arg_file, char *fmode)\n{\n    stream *s;\n    uint blen1 = blen;\n    if (gp_file_name_reduce(fname, flen, buffer, &blen1) != gp_combine_success)\n      goto skip;\n    if (iodev_os_open_file(iodev, (const char *)buffer, blen1,\n                           (const char *)fmode, &s, (gs_memory_t *)mem) == 0) {\n      if (starting_arg_file ||\n          check_file_permissions_aux(i_ctx_p, buffer, blen1) >= 0) {\n        *pclen = blen1;\n        make_stream_file(pfile, s, \"STR\");\n        return 0;\n      }\n      sclose(s);\n      return_error(e_invalidfileaccess);\n    }\n skip:;\n    return 1;\n}","22956":"static void ima_adpcm_reset1 (_AFmoduleinst *i)\n{\n\tima_adpcm_data\t*d = (ima_adpcm_data *) i->modspec;\n\tAFframecount\tnextTrackFrame;\n\tint\t\tframesPerBlock;\n\n\tframesPerBlock = d->samplesPerBlock \/ d->track->f.channelCount;\n\n\tnextTrackFrame = d->track->nextfframe;\n\td->track->nextfframe = (nextTrackFrame \/ framesPerBlock) *\n\t\tframesPerBlock;\n\n\td->framesToIgnore = nextTrackFrame - d->track->nextfframe;\n\t\n}","22959":"static long btrfs_ioctl_qgroup_assign(struct file *file, void __user *arg)\n{\n\tstruct btrfs_root *root = BTRFS_I(fdentry(file)->d_inode)->root;\n\tstruct btrfs_ioctl_qgroup_assign_args *sa;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\t\n\tif (sa->assign) {\n\t\tret = btrfs_add_qgroup_relation(trans, root->fs_info,\n\t\t\t\t\t\tsa->src, sa->dst);\n\t} else {\n\t\tret = btrfs_del_qgroup_relation(trans, root->fs_info,\n\t\t\t\t\t\tsa->src, sa->dst);\n\t}\n\n\terr = btrfs_end_transaction(trans, root);\n\tif (err && !ret)\n\t\tret = err;\n\nout:\n\tkfree(sa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}","23606":"static int connect_to_db(char *host, char *user,char *passwd)\n{\n  char buff[20+FN_REFLEN];\n  DBUG_ENTER(\"STR\");\n\n  verbose_msg(\"STR\");\n  mysql_init(&mysql_connection);\n  if (opt_compress)\n    mysql_options(&mysql_connection,MYSQL_OPT_COMPRESS,NullS);\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n    mysql_ssl_set(&mysql_connection, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n  mysql_options(&mysql_connection,MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*)&opt_ssl_verify_server_cert);\n#endif\n  if (opt_protocol)\n    mysql_options(&mysql_connection,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);\n#ifdef HAVE_SMEM\n  if (shared_memory_base_name)\n    mysql_options(&mysql_connection,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);\n#endif\n  mysql_options(&mysql_connection, MYSQL_SET_CHARSET_NAME, default_charset);\n\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(&mysql_connection, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(&mysql_connection, MYSQL_DEFAULT_AUTH, opt_default_auth);\n\n  if (using_opt_enable_cleartext_plugin)\n    mysql_options(&mysql_connection, MYSQL_ENABLE_CLEARTEXT_PLUGIN,\n                  (char *) &opt_enable_cleartext_plugin);\n\n  if (!(mysql= mysql_real_connect(&mysql_connection,host,user,passwd,\n                                  NULL,opt_mysql_port,opt_mysql_unix_port,\n                                  0)))\n  {\n    DB_error(&mysql_connection, \"STR\");\n    DBUG_RETURN(1);\n  }\n  if ((mysql_get_server_version(&mysql_connection) < 40100) ||\n      (opt_compatible_mode & 3))\n  {\n    \n    opt_set_charset= 0;\n\n    \n    server_supports_switching_charsets= FALSE;\n  } \n  \n  mysql->reconnect= 0;\n  my_snprintf(buff, sizeof(buff), \"STR\",\n              compatible_mode_normal_str);\n  if (mysql_query_with_error_report(mysql, 0, buff))\n    DBUG_RETURN(1);\n  \n  if (opt_tz_utc)\n  {\n    my_snprintf(buff, sizeof(buff), \"STR\");\n    if (mysql_query_with_error_report(mysql, 0, buff))\n      DBUG_RETURN(1);\n  }\n  DBUG_RETURN(0);\n} ","23514":"  template <class MessageType> static void validate(const MessageType& message) {\n    MessageUtil::validate(message, ProtobufMessage::getStrictValidationVisitor());\n  }","23191":"static int tun_net_close(struct net_device *dev)\n{\n\tnetif_tx_stop_all_queues(dev);\n\treturn 0;\n}","23800":"xdr_sstring_arg(XDR *xdrs, sstring_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->key)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->value)) {\n\t\treturn (FALSE);\n\t}\n\n\treturn (TRUE);\n}","23566":"static void _imap_quote_string (char *dest, size_t dlen, const char *src,\n                                const char *to_quote)\n{\n  char *pt;\n  const char *s;\n\n  if (!(dest && dlen && src && to_quote))\n    return;\n\n  if (dlen < 3)\n  {\n    *dest = 0;\n    return;\n  }\n\n  pt = dest;\n  s  = src;\n\n  \n  dlen -= 3;\n\n  *pt++ = '\"';\n  for (; *s && dlen; s++)\n  {\n    if (strchr (to_quote, *s))\n    {\n      if (dlen < 2)\n        break;\n      dlen -= 2;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = 0;\n}","23300":"static void mptsas_scsi_realize(PCIDevice *dev, Error **errp)\n{\n    MPTSASState *s = MPT_SAS(dev);\n    Error *err = NULL;\n    int ret;\n\n    dev->config[PCI_LATENCY_TIMER] = 0;\n    dev->config[PCI_INTERRUPT_PIN] = 0x01;\n\n    if (s->msi != ON_OFF_AUTO_OFF) {\n        ret = msi_init(dev, 0, 1, true, false, &err);\n        \n        assert(!ret || ret == -ENOTSUP);\n        if (ret && s->msi == ON_OFF_AUTO_ON) {\n            \n            error_append_hint(&err, \"STR\"\n                    \"STR\");\n            error_propagate(errp, err);\n            return;\n        }\n        assert(!err || s->msi == ON_OFF_AUTO_AUTO);\n        \n        error_free(err);\n\n        \n        s->msi_in_use = (ret == 0);\n    }\n\n    memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s,\n                          \"STR\", 0x4000);\n    memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s,\n                          \"STR\", 256);\n    memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,\n                          \"STR\", 0x10000);\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);\n    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io);\n\n    if (!s->sas_addr) {\n        s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |\n                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;\n        s->sas_addr |= (pci_dev_bus_num(dev) << 16);\n        s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);\n        s->sas_addr |= PCI_FUNC(dev->devfn);\n    }\n    s->max_devices = MPTSAS_NUM_PORTS;\n\n    s->request_bh = qemu_bh_new(mptsas_fetch_requests, s);\n\n    QTAILQ_INIT(&s->pending);\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);\n}","22792":"static Bool av1_is_obu_frame(AV1State *state, ObuType obu_type)\n{\n\tswitch (obu_type) {\n\tcase OBU_PADDING:\n\tcase OBU_REDUNDANT_FRAME_HEADER:\n\t\treturn GF_FALSE;\n\tcase OBU_TEMPORAL_DELIMITER:\n\t\treturn state->keep_temporal_delim ? GF_TRUE : GF_FALSE;\n\tdefault:\n\t\treturn GF_TRUE;\n\t}\n}","23360":"For(expr_ty target, expr_ty iter, asdl_seq * body, asdl_seq * orelse, int\n    lineno, int col_offset, int end_lineno, int end_col_offset, PyArena *arena)\n{\n    stmt_ty p;\n    if (!target) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"STR\");\n        return NULL;\n    }\n    if (!iter) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"STR\");\n        return NULL;\n    }\n    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = For_kind;\n    p->v.For.target = target;\n    p->v.For.iter = iter;\n    p->v.For.body = body;\n    p->v.For.orelse = orelse;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;\n}","22798":"static void __dvb_frontend_free(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\n\tif (fepriv)\n\t\tdvb_free_device(fepriv->dvbdev);\n\n\tdvb_frontend_invoke_release(fe, fe->ops.release);\n\n\tif (!fepriv)\n\t\treturn;\n\n\tkfree(fepriv);\n\tfe->frontend_priv = NULL;\n}","23277":"gx_begin_image4(gx_device * dev,\n                const gs_gstate * pgs, const gs_matrix * pmat,\n                const gs_image_common_t * pic, const gs_int_rect * prect,\n                const gx_drawing_color * pdcolor, const gx_clip_path * pcpath,\n                gs_memory_t * mem, gx_image_enum_common_t ** pinfo)\n{\n    gx_image_enum *penum;\n    const gs_image4_t *pim = (const gs_image4_t *)pic;\n    int code = gx_image_enum_alloc(pic, prect, mem, &penum);\n\n    if (code < 0)\n        return code;\n    penum->alpha = gs_image_alpha_none;\n    penum->masked = false;\n    penum->adjust = fixed_0;\n    penum->image_parent_type = gs_image_type4;\n    \n    {\n        bool opaque = false;\n        uint max_value = (1 << pim->BitsPerComponent) - 1;\n        int spp = cs_num_components(pim->ColorSpace);\n        int i;\n\n        for (i = 0; i < spp * 2; i += 2) {\n            uint c0, c1;\n\n            if (pim->MaskColor_is_range)\n                c0 = pim->MaskColor[i], c1 = pim->MaskColor[i + 1];\n            else\n                c0 = c1 = pim->MaskColor[i >> 1];\n\n            if ((c0 | c1) > max_value) {\n                gs_free_object(mem, penum, \"STR\");\n                return_error(gs_error_rangecheck);\n            }\n            if (c0 > c1) {\n                opaque = true;\t\n                break;\n            }\n            penum->mask_color.values[i] = c0;\n            penum->mask_color.values[i + 1] = c1;\n        }\n        penum->use_mask_color = !opaque;\n    }\n    code = gx_image_enum_begin(dev, pgs, pmat, pic, pdcolor, pcpath, mem,\n                               penum);\n    if (code >= 0)\n        *pinfo = (gx_image_enum_common_t *)penum;\n    return code;\n}","23051":"static int llc_ui_autobind(struct socket *sock, struct sockaddr_llc *addr)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct llc_sap *sap;\n\tint rc = -EINVAL;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\tif (!addr->sllc_arphrd)\n\t\taddr->sllc_arphrd = ARPHRD_ETHER;\n\tif (addr->sllc_arphrd != ARPHRD_ETHER)\n\t\tgoto out;\n\trc = -ENODEV;\n\tif (sk->sk_bound_dev_if) {\n\t\tllc->dev = dev_get_by_index(&init_net, sk->sk_bound_dev_if);\n\t\tif (llc->dev && addr->sllc_arphrd != llc->dev->type) {\n\t\t\tdev_put(llc->dev);\n\t\t\tllc->dev = NULL;\n\t\t}\n\t} else\n\t\tllc->dev = dev_getfirstbyhwtype(&init_net, addr->sllc_arphrd);\n\tif (!llc->dev)\n\t\tgoto out;\n\tnetdev_tracker_alloc(llc->dev, &llc->dev_tracker, GFP_KERNEL);\n\trc = -EUSERS;\n\tllc->laddr.lsap = llc_ui_autoport();\n\tif (!llc->laddr.lsap)\n\t\tgoto out;\n\trc = -EBUSY; \n\tsap = llc_sap_open(llc->laddr.lsap, NULL);\n\tif (!sap)\n\t\tgoto out;\n\tmemcpy(llc->laddr.mac, llc->dev->dev_addr, IFHWADDRLEN);\n\tmemcpy(&llc->addr, addr, sizeof(llc->addr));\n\t\n\tllc_sap_add_socket(sap, sk);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trc = 0;\nout:\n\treturn rc;\n}","23513":"PHP_FUNCTION(mkdir)\n{\n\tchar *dir;\n\tint dir_len;\n\tzval *zcontext = NULL;\n\tlong mode = 0777;\n\tzend_bool recursive = 0;\n\tphp_stream_context *context;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"STR\", &dir, &dir_len, &mode, &recursive, &zcontext) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tRETURN_BOOL(php_stream_mkdir(dir, mode, (recursive ? PHP_STREAM_MKDIR_RECURSIVE : 0) | REPORT_ERRORS, context));\n}","23603":"static void do_init_timer(struct timer_list *timer, unsigned int flags,\n\t\t\t  const char *name, struct lock_class_key *key)\n{\n\ttimer->entry.pprev = NULL;\n\ttimer->flags = flags | raw_smp_processor_id();\n#ifdef CONFIG_TIMER_STATS\n\ttimer->start_site = NULL;\n\ttimer->start_pid = -1;\n\tmemset(timer->start_comm, 0, TASK_COMM_LEN);\n#endif\n\tlockdep_init_map(&timer->lockdep_map, name, key, 0);\n}","23302":"static int inet6_fill_ifla6_attrs(struct sk_buff *skb, struct inet6_dev *idev)\n{\n\tstruct nlattr *nla;\n\tstruct ifla_cacheinfo ci;\n\n\tif (nla_put_u32(skb, IFLA_INET6_FLAGS, idev->if_flags))\n\t\tgoto nla_put_failure;\n\tci.max_reasm_len = IPV6_MAXPLEN;\n\tci.tstamp = cstamp_delta(idev->tstamp);\n\tci.reachable_time = jiffies_to_msecs(idev->nd_parms->reachable_time);\n\tci.retrans_time = jiffies_to_msecs(NEIGH_VAR(idev->nd_parms, RETRANS_TIME));\n\tif (nla_put(skb, IFLA_INET6_CACHEINFO, sizeof(ci), &ci))\n\t\tgoto nla_put_failure;\n\tnla = nla_reserve(skb, IFLA_INET6_CONF, DEVCONF_MAX * sizeof(s32));\n\tif (nla == NULL)\n\t\tgoto nla_put_failure;\n\tipv6_store_devconf(&idev->cnf, nla_data(nla), nla_len(nla));\n\n\t\n\n\tnla = nla_reserve(skb, IFLA_INET6_STATS, IPSTATS_MIB_MAX * sizeof(u64));\n\tif (nla == NULL)\n\t\tgoto nla_put_failure;\n\tsnmp6_fill_stats(nla_data(nla), idev, IFLA_INET6_STATS, nla_len(nla));\n\n\tnla = nla_reserve(skb, IFLA_INET6_ICMP6STATS, ICMP6_MIB_MAX * sizeof(u64));\n\tif (nla == NULL)\n\t\tgoto nla_put_failure;\n\tsnmp6_fill_stats(nla_data(nla), idev, IFLA_INET6_ICMP6STATS, nla_len(nla));\n\n\tnla = nla_reserve(skb, IFLA_INET6_TOKEN, sizeof(struct in6_addr));\n\tif (nla == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, IFLA_INET6_ADDR_GEN_MODE, idev->addr_gen_mode))\n\t\tgoto nla_put_failure;\n\n\tread_lock_bh(&idev->lock);\n\tmemcpy(nla_data(nla), idev->token.s6_addr, nla_len(nla));\n\tread_unlock_bh(&idev->lock);\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}","22703":"xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error = 0;\n\n\tif (!acl)\n\t\tgoto set_acl;\n\n\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\n\t\tif (error <= 0) {\n\t\t\tacl = NULL;\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n set_acl:\n\treturn __xfs_set_acl(inode, type, acl);\n}","23090":"int pmd_set_huge(pmd_t *pmdp, phys_addr_t phys, pgprot_t prot)\n{\n\tpgprot_t sect_prot = __pgprot(PMD_TYPE_SECT |\n\t\t\t\t\tpgprot_val(mk_sect_prot(prot)));\n\tBUG_ON(phys & ~PMD_MASK);\n\tset_pmd(pmdp, pfn_pmd(__phys_to_pfn(phys), sect_prot));\n\treturn 1;\n}","23210":"enumerator_next_async (GSocketClientAsyncConnectData *data)\n{\n  \n  g_clear_object (&data->socket);\n  g_clear_object (&data->proxy_addr);\n  g_clear_object (&data->connection);\n\n  g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_RESOLVING, data->connectable, NULL);\n  g_socket_address_enumerator_next_async (data->enumerator,\n\t\t\t\t\t  g_task_get_cancellable (data->task),\n\t\t\t\t\t  g_socket_client_enumerator_callback,\n\t\t\t\t\t  data);\n}","23379":"z2grestore(i_ctx_t *i_ctx_p)\n{\n    if (!restore_page_device(igs, gs_gstate_saved(igs)))\n        return gs_grestore(igs);\n    return push_callout(i_ctx_p, \"STR\");\n}","23374":"static void stub_recv_cmd_submit(struct stub_device *sdev,\n\t\t\t\t struct usbip_header *pdu)\n{\n\tint ret;\n\tstruct stub_priv *priv;\n\tstruct usbip_device *ud = &sdev->ud;\n\tstruct usb_device *udev = sdev->udev;\n\tint pipe = get_pipe(sdev, pdu->base.ep, pdu->base.direction);\n\n\tpriv = stub_priv_alloc(sdev, pdu);\n\tif (!priv)\n\t\treturn;\n\n\t\n\tif (usb_pipeisoc(pipe))\n\t\tpriv->urb = usb_alloc_urb(pdu->u.cmd_submit.number_of_packets,\n\t\t\t\t\t  GFP_KERNEL);\n\telse\n\t\tpriv->urb = usb_alloc_urb(0, GFP_KERNEL);\n\n\tif (!priv->urb) {\n\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);\n\t\treturn;\n\t}\n\n\t\n\tif (pdu->u.cmd_submit.transfer_buffer_length > 0) {\n\t\tpriv->urb->transfer_buffer =\n\t\t\tkzalloc(pdu->u.cmd_submit.transfer_buffer_length,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!priv->urb->transfer_buffer) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t\n\tpriv->urb->setup_packet = kmemdup(&pdu->u.cmd_submit.setup, 8,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!priv->urb->setup_packet) {\n\t\tdev_err(&udev->dev, \"STR\");\n\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);\n\t\treturn;\n\t}\n\n\t\n\tpriv->urb->context                = (void *) priv;\n\tpriv->urb->dev                    = udev;\n\tpriv->urb->pipe                   = pipe;\n\tpriv->urb->complete               = stub_complete;\n\n\tusbip_pack_pdu(pdu, priv->urb, USBIP_CMD_SUBMIT, 0);\n\n\n\tif (usbip_recv_xbuff(ud, priv->urb) < 0)\n\t\treturn;\n\n\tif (usbip_recv_iso(ud, priv->urb) < 0)\n\t\treturn;\n\n\t\n\ttweak_special_requests(priv->urb);\n\n\tmasking_bogus_flags(priv->urb);\n\t\n\tret = usb_submit_urb(priv->urb, GFP_KERNEL);\n\n\tif (ret == 0)\n\t\tusbip_dbg_stub_rx(\"STR\",\n\t\t\t\t  pdu->base.seqnum);\n\telse {\n\t\tdev_err(&udev->dev, \"STR\", ret);\n\t\tusbip_dump_header(pdu);\n\t\tusbip_dump_urb(priv->urb);\n\n\t\t\n\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_SUBMIT);\n\t}\n\n\tusbip_dbg_stub_rx(\"STR\");\n}","23089":"\tCmdResult HandleLocal(LocalUser* user, const Params& parameters) CXX11_OVERRIDE\n\t{\n\t\tsize_t origin = parameters.size() > 1 ? 1 : 0;\n\t\tif (parameters[origin].empty())\n\t\t{\n\t\t\tuser->WriteNumeric(ERR_NOORIGIN, \"STR\");\n\t\t\treturn CMD_FAILURE;\n\t\t}\n\n\t\tClientProtocol::Messages::Pong pong(parameters[0], origin ? parameters[1] : \"\");\n\t\tuser->Send(ServerInstance->GetRFCEvents().pong, pong);\n\t\treturn CMD_SUCCESS;\n\t}","23479":"void Vers_history_point::fix_item()\n{\n  if (item && item->decimals == 0 && item->type() == Item::FUNC_ITEM &&\n      ((Item_func*)item)->functype() == Item_func::NOW_FUNC)\n    item->decimals= 6;\n}","22567":"static void pixel_format_message (VncState *vs) {\n    char pad[3] = { 0, 0, 0 };\n\n    vnc_write_u8(vs, vs->ds->surface->pf.bits_per_pixel); \n    vnc_write_u8(vs, vs->ds->surface->pf.depth); \n\n#ifdef HOST_WORDS_BIGENDIAN\n    vnc_write_u8(vs, 1);             \n#else\n    vnc_write_u8(vs, 0);             \n#endif\n    vnc_write_u8(vs, 1);             \n    vnc_write_u16(vs, vs->ds->surface->pf.rmax);     \n    vnc_write_u16(vs, vs->ds->surface->pf.gmax);     \n    vnc_write_u16(vs, vs->ds->surface->pf.bmax);     \n    vnc_write_u8(vs, vs->ds->surface->pf.rshift);    \n    vnc_write_u8(vs, vs->ds->surface->pf.gshift);    \n    vnc_write_u8(vs, vs->ds->surface->pf.bshift);    \n\n    vnc_hextile_set_pixel_conversion(vs, 0);\n\n    vs->clientds = *(vs->ds->surface);\n    vs->clientds.flags &= ~QEMU_ALLOCATED_FLAG;\n    vs->write_pixels = vnc_write_pixels_copy;\n\n    vnc_write(vs, pad, 3);           \n}","22848":"TEST_CASE(\"STR\")\n{\n    parser parser(R\"(\n       START <- (CHAR)*\n       CHAR  <- .\n    )\");\n\n    std::string ss;\n    parser[\"STR\"] = [&](const SemanticValues& sv) {\n        ss += *sv.c_str();\n    };\n\n    bool ret = parser.parse(\"STR\");\n    REQUIRE(ret == true);\n    REQUIRE(ss == \"STR\");\n}","22748":"  void operator()(OpKernelContext* ctx, const Index num_segments,\n                  const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  const Index data_size, const T* data,\n                  typename TTypes<T, 2>::Tensor output) {\n    output.setConstant(InitialValueF()());\n    if (data_size == 0) {\n      return;\n    }\n    const int64 N = segment_ids.dimension(0);\n    ReductionF reduction;\n    auto data_flat = typename TTypes<T, 2>::ConstTensor(data, N, data_size \/ N);\n    for (int64 i = 0; i < N; ++i) {\n      Index j = internal::SubtleMustCopy(segment_ids(i));\n      if (j < 0) {\n        continue;\n      }\n      OP_REQUIRES(ctx, FastBoundsCheck(j, num_segments),\n                  errors::InvalidArgument(\n                      \"STR\", SliceDebugString(segment_ids_shape, i),\n                      \"STR\"));\n      reduction(data_flat.template chip<0>(i), output.template chip<0>(j));\n    }\n  }","23798":"static void __exit salsa20_generic_mod_fini(void)\n{\n\tcrypto_unregister_alg(&alg);\n}","22974":"void NumberFormatTest::TestBenchmark() {\n\n}","23732":"static void cli_session_setup_gensec_remote_done(struct tevent_req *subreq)\n{\n\tstruct tevent_req *req =\n\t\ttevent_req_callback_data(subreq,\n\t\tstruct tevent_req);\n\tstruct cli_session_setup_gensec_state *state =\n\t\ttevent_req_data(req,\n\t\tstruct cli_session_setup_gensec_state);\n\tNTSTATUS status;\n\n\tTALLOC_FREE(state->inbuf);\n\tTALLOC_FREE(state->recv_iov);\n\n\tstatus = cli_sesssetup_blob_recv(subreq, state, &state->blob_in,\n\t\t\t\t\t &state->inbuf, &state->recv_iov);\n\tTALLOC_FREE(subreq);\n\tdata_blob_free(&state->blob_out);\n\tif (!NT_STATUS_IS_OK(status) &&\n\t    !NT_STATUS_EQUAL(status, NT_STATUS_MORE_PROCESSING_REQUIRED))\n\t{\n\t\ttevent_req_nterror(req, status);\n\t\treturn;\n\t}\n\n\tif (NT_STATUS_IS_OK(status)) {\n\t\tstruct smbXcli_session *session = NULL;\n\t\tbool is_guest = false;\n\n\t\tif (smbXcli_conn_protocol(state->cli->conn) >= PROTOCOL_SMB2_02) {\n\t\t\tsession = state->cli->smb2.session;\n\t\t} else {\n\t\t\tsession = state->cli->smb1.session;\n\t\t}\n\n\t\tis_guest = smbXcli_session_is_guest(session);\n\t\tif (is_guest) {\n\t\t\t\n\t\t\tstate->blob_in = data_blob_null;\n\t\t\tstate->local_ready = true;\n\t\t}\n\n\t\tstate->remote_ready = true;\n\t}\n\n\tif (state->local_ready && state->remote_ready) {\n\t\tcli_session_setup_gensec_ready(req);\n\t\treturn;\n\t}\n\n\tcli_session_setup_gensec_local_next(req);\n}","22713":"static inline uint32_t _ring_fwd_done(pmixp_coll_ring_ctx_t *coll_ctx)\n{\n\treturn !(coll_ctx->coll->peers_cnt - coll_ctx->forward_cnt - 1);\n}","22923":"_pickle_loads_impl(PyObject *module, PyObject *data, int fix_imports,\n                   const char *encoding, const char *errors)\n\n{\n    PyObject *result;\n    UnpicklerObject *unpickler = _Unpickler_New();\n\n    if (unpickler == NULL)\n        return NULL;\n\n    if (_Unpickler_SetStringInput(unpickler, data) < 0)\n        goto error;\n\n    if (_Unpickler_SetInputEncoding(unpickler, encoding, errors) < 0)\n        goto error;\n\n    unpickler->fix_imports = fix_imports;\n\n    result = load(unpickler);\n    Py_DECREF(unpickler);\n    return result;\n\n  error:\n    Py_XDECREF(unpickler);\n    return NULL;\n}","22858":"static struct audit_chunk *find_chunk(struct node *p)\n{\n\tint index = p->index & ~(1U<<31);\n\tp -= index;\n\treturn container_of(p, struct audit_chunk, owners[0]);\n}","23473":"Status QuantizeV2Shape(InferenceContext* c) {\n  int axis = -1;\n  Status s = c->GetAttr(\"STR\", &axis);\n  if (!s.ok() && s.code() != error::NOT_FOUND) {\n    return s;\n  }\n  const int minmax_rank = (axis == -1) ? 0 : 1;\n  TF_RETURN_IF_ERROR(shape_inference::UnchangedShape(c));\n  ShapeHandle minmax;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(1), minmax_rank, &minmax));\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(2), minmax_rank, &minmax));\n  if (axis != -1) {\n    ShapeHandle input;\n    TF_RETURN_IF_ERROR(c->WithRankAtLeast(c->input(0), axis + 1, &input));\n    DimensionHandle depth;\n    TF_RETURN_IF_ERROR(\n        c->Merge(c->Dim(minmax, 0), c->Dim(input, axis), &depth));\n  }\n  c->set_output(1, minmax);\n  c->set_output(2, minmax);\n  return Status::OK();\n}","23784":"yum_repo_path(LrYumRepo *repo, const char *type)\n{\n    assert(repo);\n\n    for (GSList *elem = repo->paths; elem; elem = g_slist_next(elem)) {\n        LrYumRepoPath *yumrepopath = elem->data;\n        assert(yumrepopath);\n        if (!strcmp(yumrepopath->type, type))\n            return yumrepopath->path;\n    }\n    return NULL;\n}","23608":"void ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty)\n{\n    int reslevelno, bandno, precno;\n    for (reslevelno = 0;\n         comp->reslevel && reslevelno < codsty->nreslevels;\n         reslevelno++) {\n        Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;\n\n        for (bandno = 0; bandno < reslevel->nbands; bandno++) {\n            Jpeg2000Band *band = reslevel->band + bandno;\n            for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) {\n                Jpeg2000Prec *prec = band->prec + precno;\n                av_freep(&prec->zerobits);\n                av_freep(&prec->cblkincl);\n                av_freep(&prec->cblk);\n            }\n\n            av_freep(&band->prec);\n        }\n        av_freep(&reslevel->band);\n    }\n\n    ff_dwt_destroy(&comp->dwt);\n    av_freep(&comp->reslevel);\n    av_freep(&comp->i_data);\n    av_freep(&comp->f_data);\n}","23591":"f_assert_equalfile(typval_T *argvars, typval_T *rettv)\n{\n    rettv->vval.v_number = assert_equalfile(argvars);\n}","23635":"snd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,\n\t\t\t\t    void __user **bufs,\n\t\t\t\t    snd_pcm_uframes_t frames)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tint nonblock;\n\tint err;\n\n\terr = pcm_sanity_check(substream);\n\tif (err < 0)\n\t\treturn err;\n\truntime = substream->runtime;\n\tif (runtime->status->state == SNDRV_PCM_STATE_OPEN)\n\t\treturn -EBADFD;\n\n\tnonblock = !!(substream->f_flags & O_NONBLOCK);\n\tif (runtime->access != SNDRV_PCM_ACCESS_RW_NONINTERLEAVED)\n\t\treturn -EINVAL;\n\treturn snd_pcm_lib_read1(substream, (unsigned long)bufs, frames, nonblock, snd_pcm_lib_readv_transfer);\n}","23189":"int message(int priority, const char *msg) {\n    char buf[1024];\n\n    \n    if(errno && priority < 5) {\n\tsprintf(buf, \"STR\", msg, strerror(errno));\n\terrno = 0;\n    } else strcpy(buf, msg);\n    if(use_syslog) syslog(priority, \"STR\", buf);\n    else           fprintf(stderr, \"STR\", progname, buf);\n    return(0);\n}","23430":"free_conversation (GdmSessionConversation *conversation)\n{\n        if (conversation->job != NULL) {\n                g_warning (\"STR\", conversation->service_name);\n        }\n\n        g_free (conversation->service_name);\n        g_free (conversation->starting_username);\n        g_free (conversation->session_id);\n        g_clear_object (&conversation->worker_manager_interface);\n\n        if (conversation->worker_proxy != NULL) {\n                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,\n                                                      G_CALLBACK (worker_on_username_changed),\n                                                      conversation);\n                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,\n                                                      G_CALLBACK (worker_on_session_exited),\n                                                      conversation);\n                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,\n                                                      G_CALLBACK (worker_on_reauthenticated),\n                                                      conversation);\n                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,\n                                                      G_CALLBACK (worker_on_saved_language_name_read),\n                                                      conversation);\n                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,\n                                                      G_CALLBACK (worker_on_saved_session_name_read),\n                                                      conversation);\n                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,\n                                                      G_CALLBACK (worker_on_cancel_pending_query),\n                                                      conversation);\n                g_clear_object (&conversation->worker_proxy);\n        }\n        g_clear_object (&conversation->session);\n        g_free (conversation);\n}","23129":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n\n  \n  if (NumElements(op_context.input1) == 0 ||\n      NumElements(op_context.input2) == 0) {\n    return kTfLiteOk;\n  }\n\n  switch (op_context.output->type) {\n    case kTfLiteFloat32:\n      TFLiteOperation<kernel_type, float, OpType>(context, node, op_context);\n      break;\n    case kTfLiteUInt8:\n      TFLiteOperation<kernel_type, uint8_t, OpType>(context, node, op_context);\n      break;\n    case kTfLiteInt8:\n      TFLiteOperation<kernel_type, int8_t, OpType>(context, node, op_context);\n      break;\n    case kTfLiteInt32:\n      TFLiteOperation<kernel_type, int32_t, OpType>(context, node, op_context);\n      break;\n    case kTfLiteInt64:\n      TFLiteOperation<kernel_type, int64_t, OpType>(context, node, op_context);\n      break;\n    case kTfLiteInt16:\n      TFLiteOperation<kernel_type, int16_t, OpType>(context, node, op_context);\n      break;\n    default:\n      context->ReportError(context,\n                           \"STR\",\n                           op_context.output->type);\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}","23294":"int MDC2_Update(MDC2_CTX *c, const unsigned char *in, size_t len)\n{\n    size_t i, j;\n\n    i = c->num;\n    if (i != 0) {\n        if (i + len < MDC2_BLOCK) {\n            \n            memcpy(&(c->data[i]), in, len);\n            c->num += (int)len;\n            return 1;\n        } else {\n            \n            j = MDC2_BLOCK - i;\n            memcpy(&(c->data[i]), in, j);\n            len -= j;\n            in += j;\n            c->num = 0;\n            mdc2_body(c, &(c->data[0]), MDC2_BLOCK);\n        }\n    }\n    i = len & ~((size_t)MDC2_BLOCK - 1);\n    if (i > 0)\n        mdc2_body(c, in, i);\n    j = len - i;\n    if (j > 0) {\n        memcpy(&(c->data[0]), &(in[i]), j);\n        c->num = (int)j;\n    }\n    return 1;\n}","22887":"int may_umount(struct vfsmount *mnt)\n{\n\tint ret = 1;\n\tdown_read(&namespace_sem);\n\tlock_mount_hash();\n\tif (propagate_mount_busy(real_mount(mnt), 2))\n\t\tret = 0;\n\tunlock_mount_hash();\n\tup_read(&namespace_sem);\n\treturn ret;\n}","23816":"GF_Err blnk_box_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TextBlinkBox*p = (GF_TextBlinkBox*)a;\n\tgf_isom_box_dump_start(a, \"STR\", trace);\n\tgf_fprintf(trace, \"STR\", p->startcharoffset, p->endcharoffset);\n\tgf_isom_box_dump_done(\"STR\", a, trace);\n\treturn GF_OK;\n}","23645":"    void TiffImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"STR\";\n#endif\n        if (io_->open() != 0) throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        IoCloser closer(*io_);\n        \n        if (!isTiffType(*io_, false)) {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"STR\");\n        }\n        clearMetadata();\n\n        ByteOrder bo = TiffParser::decode(exifData_,\n                                          iptcData_,\n                                          xmpData_,\n                                          io_->mmap(),\n                                          (uint32_t) io_->size());\n        setByteOrder(bo);\n\n        \n        Exiv2::ExifKey            key(\"STR\");\n        Exiv2::ExifData::iterator pos   = exifData_.findKey(key);\n        if ( pos != exifData_.end()  ) {\n            iccProfile_.alloc(pos->count());\n            pos->copy(iccProfile_.pData_,bo);\n        }\n\n    } ","23267":"static int read_uids_guids(long long *table_start)\n{\n\tint res, i;\n\tint bytes = SQUASHFS_ID_BYTES(sBlk.s.no_ids);\n\tint indexes = SQUASHFS_ID_BLOCKS(sBlk.s.no_ids);\n\tlong long id_index_table[indexes];\n\n\tTRACE(\"STR\", sBlk.s.no_ids);\n\n\tid_table = malloc(bytes);\n\tif(id_table == NULL) {\n\t\tERROR(\"STR\");\n\t\treturn FALSE;\n\t}\n\n\tres = read_fs_bytes(fd, sBlk.s.id_table_start,\n\t\tSQUASHFS_ID_BLOCK_BYTES(sBlk.s.no_ids), id_index_table);\n\tif(res == FALSE) {\n\t\tERROR(\"STR\");\n\t\treturn FALSE;\n\t}\n\tSQUASHFS_INSWAP_ID_BLOCKS(id_index_table, indexes);\n\n\t\n\t*table_start = id_index_table[0];\n\n\tfor(i = 0; i < indexes; i++) {\n\t\tint expected = (i + 1) != indexes ? SQUASHFS_METADATA_SIZE :\n\t\t\t\t\tbytes & (SQUASHFS_METADATA_SIZE - 1);\n\t\tres = read_block(fd, id_index_table[i], NULL, expected,\n\t\t\t((char *) id_table) + i * SQUASHFS_METADATA_SIZE);\n\t\tif(res == FALSE) {\n\t\t\tERROR(\"STR\"\n\t\t\t\t\"STR\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tSQUASHFS_INSWAP_INTS(id_table, sBlk.s.no_ids);\n\n\treturn TRUE;\n}","22704":"ArgParser::argOiMinArea(char* parameter)\n{\n    o.oi_min_area = QUtil::string_to_uint(parameter);\n}","22583":"void SSL_free(SSL *s)\n\t{\n\tint i;\n\n\tif(s == NULL)\n\t    return;\n\n\ti=CRYPTO_add(&s->references,-1,CRYPTO_LOCK_SSL);\n#ifdef REF_PRINT\n\tREF_PRINT(\"STR\",s);\n#endif\n\tif (i > 0) return;\n#ifdef REF_CHECK\n\tif (i < 0)\n\t\t{\n\t\tfprintf(stderr,\"STR\");\n\t\tabort(); \n\t\t}\n#endif\n\n\tif (s->param)\n\t\tX509_VERIFY_PARAM_free(s->param);\n\n\tCRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL, s, &s->ex_data);\n\n\tif (s->bbio != NULL)\n\t\t{\n\t\t\n\t\tif (s->bbio == s->wbio)\n\t\t\t{\n\t\t\ts->wbio=BIO_pop(s->wbio);\n\t\t\t}\n\t\tBIO_free(s->bbio);\n\t\ts->bbio=NULL;\n\t\t}\n\tif (s->rbio != NULL)\n\t\tBIO_free_all(s->rbio);\n\tif ((s->wbio != NULL) && (s->wbio != s->rbio))\n\t\tBIO_free_all(s->wbio);\n\n\tif (s->init_buf != NULL) BUF_MEM_free(s->init_buf);\n\n\t\n\tif (s->cipher_list != NULL) sk_SSL_CIPHER_free(s->cipher_list);\n\tif (s->cipher_list_by_id != NULL) sk_SSL_CIPHER_free(s->cipher_list_by_id);\n\n\t\n\tif (s->session != NULL)\n\t\t{\n\t\tssl_clear_bad_session(s);\n\t\tSSL_SESSION_free(s->session);\n\t\t}\n\n\tssl_clear_cipher_ctx(s);\n\tssl_clear_hash_ctx(&s->read_hash);\n\tssl_clear_hash_ctx(&s->write_hash);\n\n\tif (s->cert != NULL) ssl_cert_free(s->cert);\n\t\n\n\tif (s->ctx) SSL_CTX_free(s->ctx);\n#ifndef OPENSSL_NO_TLSEXT\n\tif (s->initial_ctx) SSL_CTX_free(s->initial_ctx);\n#ifndef OPENSSL_NO_EC\n\tif (s->tlsext_ecpointformatlist) OPENSSL_free(s->tlsext_ecpointformatlist);\n\tif (s->tlsext_ellipticcurvelist) OPENSSL_free(s->tlsext_ellipticcurvelist);\n#endif \n\tif (s->tlsext_opaque_prf_input) OPENSSL_free(s->tlsext_opaque_prf_input);\n\tif (s->tlsext_ocsp_exts)\n\t\tsk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts,\n\t\t\t\t\t\tX509_EXTENSION_free);\n\tif (s->tlsext_ocsp_ids)\n\t\tsk_OCSP_RESPID_pop_free(s->tlsext_ocsp_ids, OCSP_RESPID_free);\n\tif (s->tlsext_ocsp_resp)\n\t\tOPENSSL_free(s->tlsext_ocsp_resp);\n#endif\n\n\tif (s->client_CA != NULL)\n\t\tsk_X509_NAME_pop_free(s->client_CA,X509_NAME_free);\n\n\tif (s->method != NULL) s->method->ssl_free(s);\n\n#ifndef\tOPENSSL_NO_KRB5\n\tif (s->kssl_ctx != NULL)\n\t\tkssl_ctx_free(s->kssl_ctx);\n#endif\t\n\n\tOPENSSL_free(s);\n\t}","22481":"MD5::checkFileChecksum(char const* const checksum,\n\t\t       char const* filename, int up_to_size)\n{\n    bool result = false;\n    try\n    {\n\tstd::string actual_checksum = getFileChecksum(filename, up_to_size);\n\tresult = (checksum == actual_checksum);\n    }\n    catch (std::runtime_error const&)\n    {\n\t\n    }\n    return result;\n}","23611":"void kvp_get_os_info(void)\n{\n\tFILE\t*file;\n\tchar\t*p, buf[512];\n\n\tuname(&uts_buf);\n\tos_build = uts_buf.release;\n\tprocessor_arch = uts_buf.machine;\n\n\t\n\tp = strchr(os_build, '-');\n\tif (p)\n\t\t*p = '\\0';\n\n\tfile = fopen(\"STR\");\n\tif (file != NULL)\n\t\tgoto kvp_osinfo_found;\n\tfile  = fopen(\"STR\");\n\tif (file != NULL)\n\t\tgoto kvp_osinfo_found;\n\t\n\n\t\n\tos_name = uts_buf.sysname;\n\treturn;\n\nkvp_osinfo_found:\n\t\n\tp = fgets(buf, sizeof(buf), file);\n\tif (p) {\n\t\tp = strchr(buf, '\\n');\n\t\tif (p)\n\t\t\t*p = '\\0';\n\t\tp = strdup(buf);\n\t\tif (!p)\n\t\t\tgoto done;\n\t\tos_name = p;\n\n\t\t\n\t\tp = fgets(buf, sizeof(buf), file);\n\t\tif (p) {\n\t\t\tp = strchr(buf, '\\n');\n\t\t\tif (p)\n\t\t\t\t*p = '\\0';\n\t\t\tp = strdup(buf);\n\t\t\tif (!p)\n\t\t\t\tgoto done;\n\t\t\tos_major = p;\n\n\t\t\t\n\t\t\tp = fgets(buf, sizeof(buf), file);\n\t\t\tif (p)  {\n\t\t\t\tp = strchr(buf, '\\n');\n\t\t\t\tif (p)\n\t\t\t\t\t*p = '\\0';\n\t\t\t\tp = strdup(buf);\n\t\t\t\tif (p)\n\t\t\t\t\tos_minor = p;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tfclose(file);\n\treturn;\n}","23096":"static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tut8 op_MSB,op_LSB;\n\tint ret;\n\tif (!data)\n\t\treturn 0;\n\tmemset (op, '\\0', sizeof (RAnalOp));\n\top->addr = addr;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->jump = op->fail = -1;\n\top->ptr = op->val = -1;\n\n\top->size = 2;\n\n\top_MSB = anal->big_endian? data[0]: data[1];\n\top_LSB = anal->big_endian? data[1]: data[0];\n\tret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));\n\treturn ret;\n}","23375":"ambsdtar_build_argv(\n    application_argument_t *argument,\n    char  *timestamps,\n    char **file_exclude,\n    char **file_include,\n    int    command)\n{\n    int        nb_exclude = 0;\n    int        nb_include = 0;\n    char      *dirname;\n    char       tmppath[PATH_MAX];\n    GPtrArray *argv_ptr = g_ptr_array_new();\n    GSList    *copt;\n\n    ambsdtar_build_exinclude(&argument->dle, 1,\n\t\t\t     &nb_exclude, file_exclude,\n\t\t\t     &nb_include, file_include);\n\n    if (bsdtar_directory) {\n\tdirname = bsdtar_directory;\n    } else {\n\tdirname = argument->dle.device;\n    }\n\n    g_ptr_array_add(argv_ptr, g_strdup(bsdtar_path));\n\n    g_ptr_array_add(argv_ptr, g_strdup(\"STR\"));\n    g_ptr_array_add(argv_ptr, g_strdup(\"STR\"));\n    if (command == CMD_ESTIMATE) {\n        g_ptr_array_add(argv_ptr, g_strdup(\"STR\"));\n    } else {\n        g_ptr_array_add(argv_ptr, g_strdup(\"STR\"));\n    }\n    g_ptr_array_add(argv_ptr, g_strdup(\"STR\"));\n    canonicalize_pathname(dirname, tmppath);\n    g_ptr_array_add(argv_ptr, g_strdup(tmppath));\n    if (timestamps) {\n\tg_ptr_array_add(argv_ptr, g_strdup(\"STR\"));\n\tg_ptr_array_add(argv_ptr, g_strdup(timestamps));\n    }\n    if (bsdtar_onefilesystem)\n\tg_ptr_array_add(argv_ptr, g_strdup(\"STR\"));\n    if (argument->tar_blocksize) {\n\tg_ptr_array_add(argv_ptr, g_strdup(\"STR\"));\n\tg_ptr_array_add(argv_ptr, g_strdup(argument->tar_blocksize));\n    }\n    g_ptr_array_add(argv_ptr, g_strdup(\"STR\"));\n\n    for (copt = argument->command_options; copt != NULL; copt = copt->next) {\n\tg_ptr_array_add(argv_ptr, g_strdup((char *)copt->data));\n    }\n\n    if (*file_exclude) {\n\tg_ptr_array_add(argv_ptr, g_strdup(\"STR\"));\n\tg_ptr_array_add(argv_ptr, g_strdup(*file_exclude));\n    }\n\n    if (*file_include) {\n\tg_ptr_array_add(argv_ptr, g_strdup(\"STR\"));\n\tg_ptr_array_add(argv_ptr, g_strdup(*file_include));\n    } else {\n\tg_ptr_array_add(argv_ptr, g_strdup(\"STR\"));\n    }\n    g_ptr_array_add(argv_ptr, NULL);\n\n    return(argv_ptr);\n}","22734":"ikev2_ID_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_id id;\n\tint id_len, idtype_len, i;\n\tunsigned int dumpascii, dumphex;\n\tconst unsigned char *typedata;\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&id, ext, sizeof(id));\n\tikev2_pay_print(ndo, NPSTR(tpay), id.h.critical);\n\n\tid_len = ntohs(id.h.len);\n\n\tND_PRINT((ndo,\"STR\", id_len - 4));\n\tif (2 < ndo->ndo_vflag && 4 < id_len) {\n\t\tND_PRINT((ndo,\"STR\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), id_len - 4))\n\t\t\tgoto trunc;\n\t}\n\n\tidtype_len =id_len - sizeof(struct ikev2_id);\n\tdumpascii = 0;\n\tdumphex   = 0;\n\ttypedata  = (const unsigned char *)(ext)+sizeof(struct ikev2_id);\n\n\tswitch(id.type) {\n\tcase ID_IPV4_ADDR:\n\t\tND_PRINT((ndo, \"STR\"));\n\t\tdumphex=1;\n\t\tbreak;\n\tcase ID_FQDN:\n\t\tND_PRINT((ndo, \"STR\"));\n\t\tdumpascii=1;\n\t\tbreak;\n\tcase ID_RFC822_ADDR:\n\t\tND_PRINT((ndo, \"STR\"));\n\t\tdumpascii=1;\n\t\tbreak;\n\tcase ID_IPV6_ADDR:\n\t\tND_PRINT((ndo, \"STR\"));\n\t\tdumphex=1;\n\t\tbreak;\n\tcase ID_DER_ASN1_DN:\n\t\tND_PRINT((ndo, \"STR\"));\n\t\tdumphex=1;\n\t\tbreak;\n\tcase ID_DER_ASN1_GN:\n\t\tND_PRINT((ndo, \"STR\"));\n\t\tdumphex=1;\n\t\tbreak;\n\tcase ID_KEY_ID:\n\t\tND_PRINT((ndo, \"STR\"));\n\t\tdumphex=1;\n\t\tbreak;\n\t}\n\n\tif(dumpascii) {\n\t\tND_TCHECK2(*typedata, idtype_len);\n\t\tfor(i=0; i<idtype_len; i++) {\n\t\t\tif(ND_ISPRINT(typedata[i])) {\n\t\t\t\tND_PRINT((ndo, \"STR\", typedata[i]));\n\t\t\t} else {\n\t\t\t\tND_PRINT((ndo, \"STR\"));\n\t\t\t}\n\t\t}\n\t}\n\tif(dumphex) {\n\t\tif (!rawprint(ndo, (const uint8_t *)typedata, idtype_len))\n\t\t\tgoto trunc;\n\t}\n\n\treturn (const u_char *)ext + id_len;\ntrunc:\n\tND_PRINT((ndo,\"STR\", NPSTR(tpay)));\n\treturn NULL;\n}","23366":"static int sst_scan_uuid_seqno (const char* str,\n                                wsrep_uuid_t* uuid, wsrep_seqno_t* seqno)\n{\n  int offt = wsrep_uuid_scan (str, strlen(str), uuid);\n  if (offt > 0 && strlen(str) > (unsigned int)offt && ':' == str[offt])\n  {\n    *seqno = strtoll (str + offt + 1, NULL, 10);\n    if (*seqno != LLONG_MAX || errno != ERANGE)\n    {\n      return 0;\n    }\n  }\n\n  WSREP_ERROR(\"STR\", str);\n  return EINVAL;\n}","23408":"nfsd4_encode_getdeviceinfo(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_getdeviceinfo *gdev)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[gdev->gd_layout_type];\n\tu32 starting_len = xdr->buf->len, needed_len;\n\t__be32 *p;\n\n\tdprintk(\"STR\", __func__, be32_to_cpu(nfserr));\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\n\t*p++ = cpu_to_be32(gdev->gd_layout_type);\n\n\t\n\tif (gdev->gd_maxcount != 0) {\n\t\tnfserr = ops->encode_getdeviceinfo(xdr, gdev);\n\t\tif (nfserr) {\n\t\t\t\n\t\t\tif (xdr->buf->len + 4 > gdev->gd_maxcount)\n\t\t\t\tgoto toosmall;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnfserr = nfserr_resource;\n\tif (gdev->gd_notify_types) {\n\t\tp = xdr_reserve_space(xdr, 4 + 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = cpu_to_be32(1);\t\t\t\n\t\t*p++ = cpu_to_be32(gdev->gd_notify_types);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = 0;\n\t}\n\n\tnfserr = 0;\nout:\n\tkfree(gdev->gd_device);\n\tdprintk(\"STR\", __func__, be32_to_cpu(nfserr));\n\treturn nfserr;\n\ntoosmall:\n\tdprintk(\"STR\", __func__);\n\tneeded_len = xdr->buf->len + 4 ;\n\txdr_truncate_encode(xdr, starting_len);\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p) {\n\t\tnfserr = nfserr_resource;\n\t} else {\n\t\t*p++ = cpu_to_be32(needed_len);\n\t\tnfserr = nfserr_toosmall;\n\t}\n\tgoto out;\n}","23185":"njs_generate_3addr_operation(njs_vm_t *vm, njs_generator_t *generator,\n    njs_parser_node_t *node, njs_bool_t swap)\n{\n    njs_int_t          ret;\n    njs_parser_node_t  *left, *right;\n\n    left = node->left;\n    right = node->right;\n\n    njs_generator_next(generator, njs_generate, left);\n\n    if (left->token_type == NJS_TOKEN_NAME) {\n        return njs_generator_after(vm, generator,\n                                   njs_queue_first(&generator->stack), node,\n                                   njs_generate_3addr_operation_name,\n                                   &swap, sizeof(njs_bool_t));\n    }\n\n    ret = njs_generator_after(vm, generator,\n                              njs_queue_first(&generator->stack), node,\n                              njs_generate_3addr_operation_end, &swap,\n                              sizeof(njs_bool_t));\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    return njs_generator_after(vm, generator,\n                               njs_queue_first(&generator->stack), right,\n                               njs_generate, NULL, 0);\n}","23689":"static void call_read_memory(qpdf_data qpdf)\n{\n    qpdf->qpdf->processMemoryFile(qpdf->filename, qpdf->buffer,\n\t\t\t\t  qpdf->size, qpdf->password);\n}","23703":"static void *route4_get(struct tcf_proto *tp, u32 handle)\n{\n\tstruct route4_head *head = rtnl_dereference(tp->root);\n\tstruct route4_bucket *b;\n\tstruct route4_filter *f;\n\tunsigned int h1, h2;\n\n\th1 = to_hash(handle);\n\tif (h1 > 256)\n\t\treturn NULL;\n\n\th2 = from_hash(handle >> 16);\n\tif (h2 > 32)\n\t\treturn NULL;\n\n\tb = rtnl_dereference(head->table[h1]);\n\tif (b) {\n\t\tfor (f = rtnl_dereference(b->ht[h2]);\n\t\t     f;\n\t\t     f = rtnl_dereference(f->next))\n\t\t\tif (f->handle == handle)\n\t\t\t\treturn f;\n\t}\n\treturn NULL;\n}","22889":"bash_glob_expand_word (count, key)\n     int count, key;\n{\n  return bash_glob_completion_internal ('*');\n}","23205":"int js_pconstruct(js_State *J, int n)\n{\n\tint savetop = TOP - n - 2;\n\tif (js_try(J)) {\n\t\t\n\t\tSTACK[savetop] = STACK[TOP-1];\n\t\tTOP = savetop + 1;\n\t\treturn 1;\n\t}\n\tjs_construct(J, n);\n\tjs_endtry(J);\n\treturn 0;\n}","23569":"static Image *ReadGROUP4Image(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MaxTextExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    offset,\n    strip_offset;\n\n  \n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"STR\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  \n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"STR\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"STR\");\n  length=fwrite(\"STR\",1,10,file);\n  length=fwrite(\"STR\",1,12,file);\n  length=fwrite(\"STR\",1,8,file);\n  length=WriteLSBLong(file,image->columns);\n  length=fwrite(\"STR\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"STR\",1,12,file);\n  length=fwrite(\"STR\",1,12,file);\n  length=fwrite(\"STR\",1,12,file);\n  length=fwrite(\"STR\",1,8,file);\n  strip_offset=10+(12*14)+4+8;\n  length=WriteLSBLong(file,(size_t) strip_offset);\n  length=fwrite(\"STR\",1,8,file);\n  length=WriteLSBLong(file,(size_t) image_info->orientation);\n  length=fwrite(\"STR\",1,12,file);\n  length=fwrite(\"STR\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"STR\",1,12,file);\n  offset=(ssize_t) ftell(file)-4;\n  length=fwrite(\"STR\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"STR\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"STR\",1,12,file);\n  length=fwrite(\"STR\",1,4,file);\n  length=WriteLSBLong(file,(size_t) (image->x_resolution+0.5));\n  length=WriteLSBLong(file,1);\n  status=MagickTrue;\n  for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n    if (fputc(c,file) != c)\n      status=MagickFalse;\n  offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n  length=WriteLSBLong(file,(unsigned int) length);\n  if (ferror(file) != 0)\n    {\n      (void) fclose(file);\n      ThrowImageException(FileOpenError,\"STR\");\n    }\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  \n  read_info=CloneImageInfo((ImageInfo *) NULL);\n  (void) FormatLocaleString(read_info->filename,MaxTextExtent,\"STR\",filename);\n  image=ReadTIFFImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MaxTextExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MaxTextExtent);\n      (void) CopyMagickString(image->magick,\"STR\",MaxTextExtent);\n    }\n  (void) RelinquishUniqueFileResource(filename);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}","23480":"TfLiteRegistration* Register_FLOOR_REF() {\n  static TfLiteRegistration r = {nullptr,\n                                 nullptr, floor::Prepare,\n                                 floor::Eval<floor::kReference>};\n  return &r;\n}","23395":"static void print_footer(void)\n{\n\tif (!include_html(\"STR\")) {\n\t\tprintf(\"STR\");\n\t}\n}","23006":"void BindElectronBrowser(\n    content::RenderFrameHost* frame_host,\n    mojo::PendingReceiver<electron::mojom::ElectronBrowser> receiver) {\n  ElectronBrowserHandlerImpl::Create(frame_host, std::move(receiver));\n}","22706":"cachedb_intcache_store(struct module_qstate* qstate)\n{\n\tuint32_t store_flags = qstate->query_flags;\n\n\tif(qstate->env->cfg->serve_expired)\n\t\tstore_flags |= DNSCACHE_STORE_ZEROTTL;\n\tif(!qstate->return_msg)\n\t\treturn;\n\t(void)dns_cache_store(qstate->env, &qstate->qinfo,\n\t\tqstate->return_msg->rep, 0, qstate->prefetch_leeway, 0,\n\t\tqstate->region, store_flags);\n}","23391":"static struct bpf_verifier_state *push_stack(struct bpf_verifier_env *env,\n\t\t\t\t\t     int insn_idx, int prev_insn_idx,\n\t\t\t\t\t     bool speculative)\n{\n\tstruct bpf_verifier_state *cur = env->cur_state;\n\tstruct bpf_verifier_stack_elem *elem;\n\tint err;\n\n\telem = kzalloc(sizeof(struct bpf_verifier_stack_elem), GFP_KERNEL);\n\tif (!elem)\n\t\tgoto err;\n\n\telem->insn_idx = insn_idx;\n\telem->prev_insn_idx = prev_insn_idx;\n\telem->next = env->head;\n\telem->log_pos = env->log.len_used;\n\tenv->head = elem;\n\tenv->stack_size++;\n\terr = copy_verifier_state(&elem->st, cur);\n\tif (err)\n\t\tgoto err;\n\telem->st.speculative |= speculative;\n\tif (env->stack_size > BPF_COMPLEXITY_LIMIT_JMP_SEQ) {\n\t\tverbose(env, \"STR\",\n\t\t\tenv->stack_size);\n\t\tgoto err;\n\t}\n\tif (elem->st.parent) {\n\t\t++elem->st.parent->branches;\n\t\t\n\t}\n\treturn &elem->st;\nerr:\n\tfree_verifier_state(env->cur_state, true);\n\tenv->cur_state = NULL;\n\t\n\twhile (!pop_stack(env, NULL, NULL, false));\n\treturn NULL;\n}","23017":"archive_read_format_zip_cleanup(struct archive_read *a)\n{\n\tstruct zip *zip;\n\tstruct zip_entry *zip_entry, *next_zip_entry;\n\n\tzip = (struct zip *)(a->format->data);\n\n#ifdef HAVE_ZLIB_H\n\tif (zip->stream_valid)\n\t\tinflateEnd(&zip->stream);\n#endif\n\n#if HAVA_LZMA_H && HAVE_LIBLZMA\n    if (zip->zipx_lzma_valid) {\n\t\tlzma_end(&zip->zipx_lzma_stream);\n\t}\n#endif\n\n#ifdef HAVE_BZLIB_H\n\tif (zip->bzstream_valid) {\n\t\tBZ2_bzDecompressEnd(&zip->bzstream);\n\t}\n#endif\n\n\tfree(zip->uncompressed_buffer);\n\n\tif (zip->ppmd8_valid)\n\t\t__archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);\n\n\tif (zip->zip_entries) {\n\t\tzip_entry = zip->zip_entries;\n\t\twhile (zip_entry != NULL) {\n\t\t\tnext_zip_entry = zip_entry->next;\n\t\t\tarchive_string_free(&zip_entry->rsrcname);\n\t\t\tfree(zip_entry);\n\t\t\tzip_entry = next_zip_entry;\n\t\t}\n\t}\n\tfree(zip->decrypted_buffer);\n\tif (zip->cctx_valid)\n\t\tarchive_decrypto_aes_ctr_release(&zip->cctx);\n\tif (zip->hctx_valid)\n\t\tarchive_hmac_sha1_cleanup(&zip->hctx);\n\tfree(zip->iv);\n\tfree(zip->erd);\n\tfree(zip->v_data);\n\tarchive_string_free(&zip->format_name);\n\tfree(zip);\n\t(a->format->data) = NULL;\n\treturn (ARCHIVE_OK);\n}","23021":"bool timerqueue_del(struct timerqueue_head *head, struct timerqueue_node *node)\n{\n\tWARN_ON_ONCE(RB_EMPTY_NODE(&node->node));\n\n\t\n\tif (head->next == node) {\n\t\tstruct rb_node *rbn = rb_next(&node->node);\n\n\t\thead->next = rb_entry_safe(rbn, struct timerqueue_node, node);\n\t}\n\trb_erase(&node->node, &head->head);\n\tRB_CLEAR_NODE(&node->node);\n\treturn head->next != NULL;\n}","23674":"static inline void net_dmaengine_put(void)\n{\n}","23535":"njs_function_native_frame(njs_vm_t *vm, njs_function_t *function,\n    const njs_value_t *this, const njs_value_t *args, njs_uint_t nargs,\n    njs_bool_t ctor)\n{\n    size_t              size;\n    njs_uint_t          n;\n    njs_value_t         *value, *bound;\n    njs_native_frame_t  *frame;\n\n    size = NJS_NATIVE_FRAME_SIZE\n           + (function->args_offset + nargs) * sizeof(njs_value_t);\n\n    frame = njs_function_frame_alloc(vm, size);\n    if (njs_slow_path(frame == NULL)) {\n        return NJS_ERROR;\n    }\n\n    frame->function = function;\n    frame->nargs = function->args_offset + nargs;\n    frame->ctor = ctor;\n    frame->native = 1;\n    frame->pc = NULL;\n\n    value = (njs_value_t *) ((u_char *) frame + NJS_NATIVE_FRAME_SIZE);\n\n    frame->arguments = value;\n    frame->arguments_offset = value + function->args_offset;\n\n    bound = function->bound;\n\n    if (bound == NULL) {\n        \n        *value++ = *this;\n\n    } else {\n        n = function->args_offset;\n\n        do {\n            \n            *value++ = *bound++;\n            n--;\n        } while (n != 0);\n    }\n\n    if (args != NULL) {\n        memcpy(value, args, nargs * sizeof(njs_value_t));\n    }\n\n    return NJS_OK;\n}","23410":"make_absent_engine(Node** node, int pre_save_right_id, Node* absent,\n                   Node* step_one, int lower, int upper, int possessive,\n                   int is_range_cutter, ScanEnv* env)\n{\n  int r;\n  int i;\n  int id;\n  Node* x;\n  Node* ns[4];\n\n  for (i = 0; i < 4; i++) ns[i] = NULL_NODE;\n\n  ns[1] = absent;\n  ns[3] = step_one; \n  r = node_new_save_gimmick(&ns[0], SAVE_S, env);\n  if (r != 0) goto err;\n\n  id = GIMMICK_(ns[0])->id;\n  r = node_new_update_var_gimmick(&ns[2], UPDATE_VAR_RIGHT_RANGE_FROM_S_STACK,\n                                  id, env);\n  if (r != 0) goto err;\n\n  r = node_new_fail(&ns[3], env);\n  if (r != 0) goto err;\n\n  x = make_list(4, ns);\n  if (IS_NULL(x)) goto err0;\n\n  ns[0] = x;\n  ns[1] = step_one;\n  ns[2] = ns[3] = NULL_NODE;\n\n  x = make_alt(2, ns);\n  if (IS_NULL(x)) goto err0;\n\n  ns[0] = x;\n\n  x = node_new_quantifier(lower, upper, 0);\n  if (IS_NULL(x)) goto err0;\n\n  NODE_BODY(x) = ns[0];\n  ns[0] = x;\n\n  if (possessive != 0) {\n    x = node_new_bag(BAG_STOP_BACKTRACK);\n    if (IS_NULL(x)) goto err0;\n\n    NODE_BODY(x) = ns[0];\n    ns[0] = x;\n  }\n\n  r = node_new_update_var_gimmick(&ns[1], UPDATE_VAR_RIGHT_RANGE_FROM_STACK,\n                                  pre_save_right_id, env);\n  if (r != 0) goto err;\n\n  r = node_new_fail(&ns[2], env);\n  if (r != 0) goto err;\n\n  x = make_list(2, ns + 1);\n  if (IS_NULL(x)) goto err0;\n\n  ns[1] = x; ns[2] = NULL_NODE;\n\n  x = make_alt(2, ns);\n  if (IS_NULL(x)) goto err0;\n\n  if (is_range_cutter != 0)\n    NODE_STATUS_ADD(x, SUPER);\n\n  *node = x;\n  return ONIG_NORMAL;\n\n err0:\n  r = ONIGERR_MEMORY;\n err:\n  for (i = 0; i < 4; i++) onig_node_free(ns[i]);\n  return r;\n}","23184":"      static double mp_complex_tan(_cimg_math_parser& mp) {\n        const double real = _mp_arg(2), imag = _mp_arg(3), denom = std::cos(2*real) + std::cosh(2*imag);\n        double *ptrd = &_mp_arg(1) + 1;\n        ptrd[0] = std::sin(2*real)\/denom;\n        ptrd[1] = std::sinh(2*imag)\/denom;\n        return cimg::type<double>::nan();\n      }","23544":"static BROTLI_INLINE void SortHuffmanTreeItems(HuffmanTree* items,\n    const size_t n, HuffmanTreeComparator comparator) {\n  static const size_t gaps[] = {132, 57, 23, 10, 4, 1};\n  if (n < 13) {\n    \n    size_t i;\n    for (i = 1; i < n; ++i) {\n      HuffmanTree tmp = items[i];\n      size_t k = i;\n      size_t j = i - 1;\n      while (comparator(&tmp, &items[j])) {\n        items[k] = items[j];\n        k = j;\n        if (!j--) break;\n      }\n      items[k] = tmp;\n    }\n    return;\n  } else {\n    \n    int g = n < 57 ? 2 : 0;\n    for (; g < 6; ++g) {\n      size_t gap = gaps[g];\n      size_t i;\n      for (i = gap; i < n; ++i) {\n        size_t j = i;\n        HuffmanTree tmp = items[i];\n        for (; j >= gap && comparator(&tmp, &items[j - gap]); j -= gap) {\n          items[j] = items[j - gap];\n        }\n        items[j] = tmp;\n      }\n    }\n  }\n}","22961":"static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)\n{\n    uint16_t *v = pv;\n    uint16_t v2;\n    qemu_get_be16s(f, &v2);\n\n    if (*v == v2) {\n        return 0;\n    }\n    return -EINVAL;\n}","23011":"static void read_tIME_chunk(Image *image,png_struct *ping,png_info *info)\n{\n  png_timep\n    time;\n\n  if (png_get_tIME(ping,info,&time))\n    {\n      char\n        timestamp[21];\n\n      FormatLocaleString(timestamp,21,\"STR\",\n        time->year,time->month,time->day,time->hour,time->minute,time->second);\n      SetImageProperty(image,\"STR\",timestamp);\n    }\n}","23765":"int load_env(char *envstr, FILE * f) {\n\tlong filepos;\n\tint fileline;\n\tenum env_state state;\n\tchar quotechar, *c, *str, *val;\n\n\tfilepos = ftell(f);\n\tfileline = LineNumber;\n\tskip_comments(f);\n\tif (EOF == get_string(envstr, MAX_ENVSTR, f, \"STR\"))\n\t\treturn (ERR);\n\n\tDebug(DPARS, (\"STR\", envstr));\n\n\tstr = envstr;\n\tstate = NAMEI;\n\tquotechar = '\\0';\n\tc = envstr;\n\twhile (state != ERROR && *c) {\n\t\tswitch (state) {\n\t\tcase NAMEI:\n\t\tcase VALUEI:\n\t\t\tif (*c == '\\'' || *c == '\"')\n\t\t\t\tquotechar = *c++;\n\t\t\tstate++;\n\t\t\t\n\t\tcase NAME:\n\t\tcase VALUE:\n\t\t\tif (quotechar) {\n\t\t\t\tif (*c == quotechar) {\n\t\t\t\t\tstate++;\n\t\t\t\t\tc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (state == NAME && *c == '=') {\n\t\t\t\t\tstate = ERROR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (state == NAME) {\n\t\t\t\t\tif (isspace((unsigned char) *c)) {\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tstate++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (*c == '=') {\n\t\t\t\t\t\tstate++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t*str++ = *c++;\n\t\t\tbreak;\n\n\t\tcase EQ1:\n\t\t\tif (*c == '=') {\n\t\t\t\tstate++;\n\t\t\t\tquotechar = '\\0';\n\t\t\t\t*str++ = *c;\n\t\t\t\tval = str;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!isspace((unsigned char) *c))\n\t\t\t\t\tstate = ERROR;\n\t\t\t}\n\t\t\tc++;\n\t\t\tbreak;\n\n\t\tcase EQ2:\n\t\tcase FINI:\n\t\t\tif (isspace((unsigned char) *c))\n\t\t\t\tc++;\n\t\t\telse\n\t\t\t\tstate++;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tabort();\n\t\t}\n\t}\n\tif (state != FINI && state != EQ2 && !(state == VALUE && !quotechar)) {\n\t\tDebug(DPARS, (\"STR\", state));\n\t\tif (fseek(f, filepos, 0)) {\n\t\t\treturn ERR;\n\t\t}\n\t\tSet_LineNum(fileline);\n\t\treturn (FALSE);\n\t}\n\t*str = '\\0';\n\tif (state == VALUE) {\n\t\t\n\t\twhile (str > val && isspace((unsigned char)str[-1]))\n\t\t\t*(--str) = '\\0';\n\t}\n\treturn TRUE;\n}","22860":"static int udp_v6_push_pending_frames(struct sock *sk, struct udp_sock *up)\n{\n\tstruct sk_buff *skb;\n\tstruct udphdr *uh;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi *fl = &inet->cork.fl;\n\tint err = 0;\n\n\t\n\tif ((skb = skb_peek(&sk->sk_write_queue)) == NULL)\n\t\tgoto out;\n\n\t\n\tuh = skb->h.uh;\n\tuh->source = fl->fl_ip_sport;\n\tuh->dest = fl->fl_ip_dport;\n\tuh->len = htons(up->len);\n\tuh->check = 0;\n\n\tif (sk->sk_no_check == UDP_CSUM_NOXMIT) {\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tgoto send;\n\t}\n\n\tif (skb_queue_len(&sk->sk_write_queue) == 1) {\n\t\tskb->csum = csum_partial((char *)uh,\n\t\t\t\tsizeof(struct udphdr), skb->csum);\n\t\tuh->check = csum_ipv6_magic(&fl->fl6_src,\n\t\t\t\t\t    &fl->fl6_dst,\n\t\t\t\t\t    up->len, fl->proto, skb->csum);\n\t} else {\n\t\tu32 tmp_csum = 0;\n\n\t\tskb_queue_walk(&sk->sk_write_queue, skb) {\n\t\t\ttmp_csum = csum_add(tmp_csum, skb->csum);\n\t\t}\n\t\ttmp_csum = csum_partial((char *)uh,\n\t\t\t\tsizeof(struct udphdr), tmp_csum);\n                tmp_csum = csum_ipv6_magic(&fl->fl6_src,\n\t\t\t\t\t   &fl->fl6_dst,\n\t\t\t\t\t   up->len, fl->proto, tmp_csum);\n                uh->check = tmp_csum;\n\n\t}\n\tif (uh->check == 0)\n\t\tuh->check = -1;\n\nsend:\n\terr = ip6_push_pending_frames(sk);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}","22737":"bool values(JSContext *cx, unsigned argc, Value *vp) {\n  HEADERS_ITERATION_METHOD(0)\n  return JS::MapValues(cx, backing_map, args.rval());\n}","22726":"static void record_init(node_t * n)\n{\n    field_t *info;\n    pointf ul, sz;\n    int flip, len;\n    char *textbuf;\t\t\n    int sides = BOTTOM | RIGHT | TOP | LEFT;\n\n    \n    flip = NOT(GD_realflip(agraphof(n)));\n    reclblp = ND_label(n)->text;\n    len = strlen(reclblp);\n    \n    len = MAX(len, 1);\n    textbuf = N_NEW(len + 1, char);\n    if (!(info = parse_reclbl(n, flip, TRUE, textbuf))) {\n\tagerr(AGERR, \"STR\", ND_label(n)->text);\n\treclblp = \"STR\";\n\tinfo = parse_reclbl(n, flip, TRUE, textbuf);\n    }\n    free(textbuf);\n    size_reclbl(n, info);\n    sz.x = POINTS(ND_width(n));\n    sz.y = POINTS(ND_height(n));\n    if (mapbool(late_string(n, N_fixed, \"STR\"))) {\n\tif ((sz.x < info->size.x) || (sz.y < info->size.y)) {\n\n\t}\n    } else {\n\tsz.x = MAX(info->size.x, sz.x);\n\tsz.y = MAX(info->size.y, sz.y);\n    }\n    resize_reclbl(info, sz, mapbool(late_string(n, N_nojustify, \"STR\")));\n    ul = pointfof(-sz.x \/ 2., sz.y \/ 2.);\t\n    pos_reclbl(info, ul, sides);\n    ND_width(n) = PS2INCH(info->size.x);\n    ND_height(n) = PS2INCH(info->size.y + 1);\t\n    ND_shape_info(n) = (void *) info;\n}","22707":"GF_Err fdsa_Size(GF_Box *s)\n{\n\tGF_HintSample *ptr = (GF_HintSample*)s;\n\tGF_Err e;\n\n\t if (ptr->extra_data) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->extra_data);\n\t\tif (e) return e;\n\t\tptr->size += ptr->extra_data->size;\n\t}\n\treturn gf_isom_box_array_size(s, ptr->packetTable);\n}","23279":"    inline void unused(const T&, ...) {}","22823":"ves_icall_Type_GetInterfaces (MonoReflectionType* type)\n{\n\tMonoError error;\n\tMonoDomain *domain = mono_object_domain (type); \n\tMonoArray *intf;\n\tGPtrArray *ifaces = NULL;\n\tint i;\n\tMonoClass *class = mono_class_from_mono_type (type->type);\n\tMonoClass *parent;\n\tMonoBitSet *slots;\n\tMonoGenericContext *context = NULL;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tif (class->generic_class && class->generic_class->context.class_inst->is_open) {\n\t\tcontext = mono_class_get_context (class);\n\t\tclass = class->generic_class->container_class;\n\t}\n\n\tmono_class_setup_vtable (class);\n\n\tslots = mono_bitset_new (class->max_interface_id + 1, 0);\n\n\tfor (parent = class; parent; parent = parent->parent) {\n\t\tGPtrArray *tmp_ifaces = mono_class_get_implemented_interfaces (parent, &error);\n\t\tif (!mono_error_ok (&error)) {\n\t\t\tmono_bitset_free (slots);\n\t\t\tmono_error_raise_exception (&error);\n\t\t\treturn NULL;\n\t\t} else if (tmp_ifaces) {\n\t\t\tfor (i = 0; i < tmp_ifaces->len; ++i) {\n\t\t\t\tMonoClass *ic = g_ptr_array_index (tmp_ifaces, i);\n\n\t\t\t\tif (mono_bitset_test (slots, ic->interface_id))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmono_bitset_set (slots, ic->interface_id);\n\t\t\t\tif (ifaces == NULL)\n\t\t\t\t\tifaces = g_ptr_array_new ();\n\t\t\t\tg_ptr_array_add (ifaces, ic);\n\t\t\t}\n\t\t\tg_ptr_array_free (tmp_ifaces, TRUE);\n\t\t}\n\t}\n\tmono_bitset_free (slots);\n\n\tif (!ifaces)\n\t\treturn mono_array_new_cached (domain, mono_defaults.monotype_class, 0);\n\t\t\n\tintf = mono_array_new_cached (domain, mono_defaults.monotype_class, ifaces->len);\n\tfor (i = 0; i < ifaces->len; ++i) {\n\t\tMonoClass *ic = g_ptr_array_index (ifaces, i);\n\t\tMonoType *ret = &ic->byval_arg, *inflated = NULL;\n\t\tif (context && ic->generic_class && ic->generic_class->context.class_inst->is_open)\n\t\t\tinflated = ret = mono_class_inflate_generic_type (ret, context);\n\t\t\n\t\tmono_array_setref (intf, i, mono_type_get_object (domain, ret));\n\t\tif (inflated)\n\t\t\tmono_metadata_free_type (inflated);\n\t}\n\tg_ptr_array_free (ifaces, TRUE);\n\n\treturn intf;\n}","23525":"static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) \n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                dctx->w = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 42) {\n                int cid = (state >> 32) & 0xFFFFFFFF;\n\n                if (cid <= 0)\n                    continue;\n\n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (dctx->remaining <= 0) {\n                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (dctx->remaining <= 0)\n                        return dctx->remaining;\n                }\n                if (buf_size - i + 47 >= dctx->remaining) {\n                    int remaining = dctx->remaining;\n\n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}","23250":"      DSA_Signature_Operation(const DSA_PrivateKey& dsa, const std::string& emsa) :\n         PK_Ops::Signature_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_x(dsa.get_x()),\n         m_mod_q(dsa.group_q())\n         {\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n         m_rfc6979_hash = hash_for_emsa(emsa);\n#endif\n         }","22949":" *\/\nstatic xmlXPathParserContextPtr\nxmlXPathCompParserContext(xmlXPathCompExprPtr comp, xmlXPathContextPtr ctxt) {\n    xmlXPathParserContextPtr ret;\n\n    ret = (xmlXPathParserContextPtr) xmlMalloc(sizeof(xmlXPathParserContext));\n    if (ret == NULL) {\n        xmlXPathErrMemory(ctxt, \"STR\");\n\treturn(NULL);\n    }\n    memset(ret, 0 , (size_t) sizeof(xmlXPathParserContext));\n\n    \n    ret->valueTab = (xmlXPathObjectPtr *)\n                     xmlMalloc(10 * sizeof(xmlXPathObjectPtr));\n    if (ret->valueTab == NULL) {\n\txmlFree(ret);\n\txmlXPathErrMemory(ctxt, \"STR\");\n\treturn(NULL);\n    }\n    ret->valueNr = 0;\n    ret->valueMax = 10;\n    ret->value = NULL;\n\n    ret->context = ctxt;\n    ret->comp = comp;\n","22608":"generate_parentside_target_query(struct module_qstate* qstate, \n\tstruct iter_qstate* iq, int id, uint8_t* name, size_t namelen, \n\tuint16_t qtype, uint16_t qclass)\n{\n\tstruct module_qstate* subq;\n\tif(!generate_sub_request(name, namelen, qtype, qclass, qstate, \n\t\tid, iq, INIT_REQUEST_STATE, FINISHED_STATE, &subq, 0))\n\t\treturn 0;\n\tif(subq) {\n\t\tstruct iter_qstate* subiq = \n\t\t\t(struct iter_qstate*)subq->minfo[id];\n\t\t\n\t\tsock_list_insert(&subq->blacklist, NULL, 0, subq->region);\n\t\tsubiq->query_for_pside_glue = 1;\n\t\tif(dname_subdomain_c(name, iq->dp->name)) {\n\t\t\tsubiq->dp = delegpt_copy(iq->dp, subq->region);\n\t\t\tsubiq->dnssec_expected = iter_indicates_dnssec(\n\t\t\t\tqstate->env, subiq->dp, NULL, \n\t\t\t\tsubq->qinfo.qclass);\n\t\t\tsubiq->refetch_glue = 1;\n\t\t} else {\n\t\t\tsubiq->dp = dns_cache_find_delegation(qstate->env, \n\t\t\t\tname, namelen, qtype, qclass, subq->region,\n\t\t\t\t&subiq->deleg_msg,\n\t\t\t\t*qstate->env->now+subq->prefetch_leeway); \n\t\t\t\n\t\t\tif(subiq->dp) { \n\t\t\t\tsubiq->dnssec_expected = iter_indicates_dnssec(\n\t\t\t\t\tqstate->env, subiq->dp, NULL, \n\t\t\t\t\tsubq->qinfo.qclass);\n\t\t\t\tsubiq->refetch_glue = 1;\n\t\t\t}\n\t\t}\n\t}\n\tlog_nametypeclass(VERB_QUERY, \"STR\", name, qtype, qclass);\n\treturn 1;\n}","22869":"apr_status_t h2_stream_recv_frame(h2_stream *stream, int ftype, int flags, size_t frame_len)\n{\n    apr_status_t status = APR_SUCCESS;\n    int new_state, eos = 0;\n\n    new_state = on_frame_recv(stream->state, ftype);\n    if (new_state < 0) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c, \n                      H2_STRM_MSG(stream, \"STR\"), ftype);\n        AP_DEBUG_ASSERT(new_state > S_XXX);\n        return transit(stream, new_state);\n    }\n    \n    switch (ftype) {\n        case NGHTTP2_DATA:\n            eos = (flags & NGHTTP2_FLAG_END_STREAM);\n            break;\n            \n        case NGHTTP2_HEADERS:\n            eos = (flags & NGHTTP2_FLAG_END_STREAM);\n            if (stream->state == H2_SS_OPEN) {\n                \n                if (!eos) {\n                    h2_stream_rst(stream, H2_ERR_PROTOCOL_ERROR);\n                }\n                stream->in_trailer_octets += frame_len;\n            }\n            else {\n                \n                ap_assert(stream->request == NULL);\n                if (stream->rtmp == NULL) {\n                    \n                    return APR_EINVAL;\n                }\n                status = h2_request_end_headers(stream->rtmp, stream->pool, eos, frame_len);\n                if (status != APR_SUCCESS) {\n                    return status;\n                }\n                set_policy_for(stream, stream->rtmp);\n                stream->request = stream->rtmp;\n                stream->rtmp = NULL;\n            }\n            break;\n            \n        default:\n            break;\n    }\n    status = transit(stream, new_state);\n    if (status == APR_SUCCESS && eos) {\n        status = transit(stream, on_event(stream, H2_SEV_CLOSED_R));\n    }\n    return status;\n}","22982":"gdk_pixbuf_new (GdkColorspace colorspace, \n                gboolean      has_alpha,\n                int           bits_per_sample,\n                int           width,\n                int           height)\n{\n\tguchar *buf;\n\tint channels;\n\tint rowstride;\n        gsize bytes;\n\n\tg_return_val_if_fail (colorspace == GDK_COLORSPACE_RGB, NULL);\n\tg_return_val_if_fail (bits_per_sample == 8, NULL);\n\tg_return_val_if_fail (width > 0, NULL);\n\tg_return_val_if_fail (height > 0, NULL);\n\n\tchannels = has_alpha ? 4 : 3;\n        rowstride = width * channels;\n        if (rowstride \/ channels != width || rowstride + 3 < 0) \n                return NULL;\n        \n\t\n\trowstride = (rowstride + 3) & ~3;\n\n        bytes = height * rowstride;\n        if (bytes \/ rowstride !=  height) \n                return NULL;\n            \n\tbuf = g_try_malloc (bytes);\n\tif (!buf)\n\t\treturn NULL;\n\n\treturn gdk_pixbuf_new_from_data (buf, colorspace, has_alpha, bits_per_sample,\n\t\t\t\t\t width, height, rowstride,\n\t\t\t\t\t free_buffer, NULL);\n}","23690":"nma_gconf_connection_changed (NMAGConfConnection *self)\n{\n\tNMAGConfConnectionPrivate *priv;\n\tGHashTable *settings;\n\tNMConnection *wrapped_connection;\n\tNMConnection *gconf_connection;\n\tGHashTable *new_settings;\n\tGError *error = NULL;\n\n\tg_return_val_if_fail (NMA_IS_GCONF_CONNECTION (self), FALSE);\n\n\tpriv = NMA_GCONF_CONNECTION_GET_PRIVATE (self);\n\twrapped_connection = nm_exported_connection_get_connection (NM_EXPORTED_CONNECTION (self));\n\n\tgconf_connection = nm_gconf_read_connection (priv->client, priv->dir);\n\tif (!gconf_connection) {\n\t\tg_warning (\"STR\", priv->dir);\n\t\tgoto invalid;\n\t}\n\n\tutils_fill_connection_certs (gconf_connection);\n\tif (!nm_connection_verify (gconf_connection, &error)) {\n\t\tutils_clear_filled_connection_certs (gconf_connection);\n\t\tg_warning (\"STR\",\n\t\t           __func__, priv->dir,\n\t\t           g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),\n\t\t           error->message, error->code);\n\t\tgoto invalid;\n\t}\n\tutils_clear_filled_connection_certs (gconf_connection);\n\n\t\n\tif (   nm_connection_compare (wrapped_connection, gconf_connection, NM_SETTING_COMPARE_FLAG_EXACT)\n\t    && nm_gconf_compare_private_connection_values (wrapped_connection, gconf_connection))\n\t\treturn TRUE;\n\n\t\n\tnm_gconf_copy_private_connection_values (wrapped_connection, gconf_connection);\n\n\tutils_fill_connection_certs (gconf_connection);\n\tnew_settings = nm_connection_to_hash (gconf_connection);\n\tutils_clear_filled_connection_certs (gconf_connection);\n\n\tif (!nm_connection_replace_settings (wrapped_connection, new_settings, &error)) {\n\t\tutils_clear_filled_connection_certs (wrapped_connection);\n\t\tg_hash_table_destroy (new_settings);\n\n\t\tg_warning (\"STR\",\n\t\t           __func__,\n\t\t           error ? g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)) : \"STR\",\n\t\t           (error && error->message) ? error->message : \"STR\",\n\t\t           error ? error->code : -1);\n\t\tgoto invalid;\n\t}\n\tg_object_unref (gconf_connection);\n\tg_hash_table_destroy (new_settings);\n\n\tfill_vpn_user_name (wrapped_connection);\n\n\tsettings = nm_connection_to_hash (wrapped_connection);\n\tutils_clear_filled_connection_certs (wrapped_connection);\n\n\tnm_exported_connection_signal_updated (NM_EXPORTED_CONNECTION (self), settings);\n\tg_hash_table_destroy (settings);\n\treturn TRUE;\n\ninvalid:\n\tg_clear_error (&error);\n\tnm_exported_connection_signal_removed (NM_EXPORTED_CONNECTION (self));\n\treturn FALSE;\n}","23413":"struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,\n\t\t\t\t    int *peeked, int *off, int *err)\n{\n\tstruct sk_buff *skb;\n\tlong timeo;\n\t\n\tint error = sock_error(sk);\n\n\tif (error)\n\t\tgoto no_packet;\n\n\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\n\tdo {\n\t\t\n\t\tunsigned long cpu_flags;\n\t\tstruct sk_buff_head *queue = &sk->sk_receive_queue;\n\n\t\tspin_lock_irqsave(&queue->lock, cpu_flags);\n\t\tskb_queue_walk(queue, skb) {\n\t\t\t*peeked = skb->peeked;\n\t\t\tif (flags & MSG_PEEK) {\n\t\t\t\tif (*off >= skb->len) {\n\t\t\t\t\t*off -= skb->len;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tskb->peeked = 1;\n\t\t\t\tatomic_inc(&skb->users);\n\t\t\t} else\n\t\t\t\t__skb_unlink(skb, queue);\n\n\t\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\t\treturn skb;\n\t\t}\n\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\n\t\t\n\t\terror = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto no_packet;\n\n\t} while (!wait_for_packet(sk, err, &timeo));\n\n\treturn NULL;\n\nno_packet:\n\t*err = error;\n\treturn NULL;\n}","22965":"edit_done_cb (NMConnectionEditor *editor, gint response, GError *error, gpointer user_data)\n{\n\tEditConnectionInfo *info = (EditConnectionInfo *) user_data;\n\tconst char *message = _(\"STR\");\n\n\tg_hash_table_remove (info->list->editors, info->original_connection);\n\n\tif (response == GTK_RESPONSE_NONE) {\n\t\tif (error && error->message)\n\t\t\tmessage = error->message;\n\t\terror_dialog (GTK_WINDOW (editor->window), _(\"STR\", message);\n\t} else if (response == GTK_RESPONSE_OK) {\n\t\tNMConnection *connection;\n\t\tGError *edit_error = NULL;\n\t\tgboolean success;\n\n\t\tconnection = nm_connection_editor_get_connection (editor);\n\n\t\tutils_fill_connection_certs (connection);\n\t\tsuccess = nm_connection_verify (connection, &edit_error);\n\t\tutils_clear_filled_connection_certs (connection);\n\n\t\tif (success) {\n\t\t\tupdate_connection (info->list, editor, info->original_connection,\n\t\t\t                   connection, connection_updated_cb, info);\n\t\t} else {\n\t\t\tg_warning (\"STR\"\n\t\t\t           \"STR\",\n\t\t\t           __func__,\n\t\t\t           g_type_name (nm_connection_lookup_setting_type_by_quark (edit_error->domain)),\n\t\t\t           edit_error->message, edit_error->code);\n\t\t\tg_error_free (edit_error);\n\t\t\tconnection_updated_cb (info->list, FALSE, user_data);\n\t\t}\n\t}\n}","23476":"drv_setfilter(TERMINAL_CONTROL_BLOCK * TCB)\n{\n    AssertTCB();\n\n    \n    clear_screen     = ABSENT_STRING;\n    cursor_address   = ABSENT_STRING;\n    cursor_down      = ABSENT_STRING;\n    cursor_up        = ABSENT_STRING;\n    parm_down_cursor = ABSENT_STRING;\n    parm_up_cursor   = ABSENT_STRING;\n    row_address      = ABSENT_STRING;\n    cursor_home      = carriage_return;\n\n    if (back_color_erase)\n\tclr_eos = ABSENT_STRING;\n}","23747":"static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t\tunsigned int dataoff, unsigned int *timeouts)\n{\n\treturn true;\n}","23013":"PHP_FUNCTION(locale_get_all_variants)\n{\n\tconst char*  \tloc_name        = NULL;\n\tint    \t\tloc_name_len    = 0;\n\n\tint\tresult\t\t= 0;\n\tchar*\ttoken\t\t= NULL;\n\tchar*\tvariant\t\t= NULL;\n\tchar*\tsaved_ptr\t= NULL;\n\n\tintl_error_reset( NULL TSRMLS_CC );\n\t\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"STR\",\n\t&loc_name, &loc_name_len ) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t     \"STR\", 0 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n\n\tif(loc_name_len == 0) {\n\t\tloc_name = intl_locale_get_default(TSRMLS_C);\n\t}\n\n\n\tarray_init( return_value );\n\n\t\n\tif( findOffset( LOC_GRANDFATHERED , loc_name ) >=  0 ){ \n\t\t\n\t}\n\telse {\t\n\t\n\t\tvariant = get_icu_value_internal( loc_name , LOC_VARIANT_TAG , &result ,0);\n\t\tif( result > 0 && variant){\n\t\t\t\n\t\t\ttoken = php_strtok_r( variant , DELIMITER , &saved_ptr);\t\n\t\t\tadd_next_index_stringl( return_value, token , strlen(token) ,TRUE );\n\t\t\t\n\t\t\twhile( (token = php_strtok_r(NULL , DELIMITER, &saved_ptr)) && (strlen(token)>1) ){\n \t\t\t\tadd_next_index_stringl( return_value, token , strlen(token) ,TRUE );\n\t\t\t}\n\t\t}\n\t\tif( variant ){\n\t\t\tefree( variant );\n\t\t}\n\t}\n\t\t\t\n\n}","23004":"static void vmx_free_vcpu(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tspin_lock(&vmx_vpid_lock);\n\tif (vmx->vpid != 0)\n\t\t__clear_bit(vmx->vpid, vmx_vpid_bitmap);\n\tspin_unlock(&vmx_vpid_lock);\n\tvmx_free_vmcs(vcpu);\n\tkfree(vmx->host_msrs);\n\tkfree(vmx->guest_msrs);\n\tkvm_vcpu_uninit(vcpu);\n\tkmem_cache_free(kvm_vcpu_cache, vmx);\n}","23577":"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_rpsi(\n\t\t\t\t\t    pjmedia_rtcp_session *session, \n\t\t\t\t\t    void *buf,\n\t\t\t\t\t    pj_size_t *length,\n\t\t\t\t\t    const pjmedia_rtcp_fb_rpsi *rpsi)\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    unsigned bitlen, padlen, len;\n\n    PJ_ASSERT_RETURN(session && buf && length && rpsi, PJ_EINVAL);\n\n    bitlen = (unsigned)rpsi->rpsi_bit_len + 16;\n    padlen = (32 - (bitlen % 32)) % 32;\n    len = (3 + (bitlen+padlen)\/32) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    \n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_PSFB;\n    hdr->count = 3; \n    hdr->length = pj_htons((pj_uint16_t)(len\/4 - 1));\n\n    \n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    \n    *p++ = (pj_uint8_t)padlen;\n    \n    *p++ = rpsi->pt & 0x7F;\n    \n    pj_memcpy(p, rpsi->rpsi.ptr, rpsi->rpsi_bit_len\/8);\n    p += rpsi->rpsi_bit_len\/8;\n    if (rpsi->rpsi_bit_len % 8) {\n\t*p++ = *(rpsi->rpsi.ptr + rpsi->rpsi_bit_len\/8);\n    }\n    \n    if (padlen >= 8)\n\tpj_bzero(p, padlen\/8);\n\n    \n    *length = len;\n\n    return PJ_SUCCESS;\n}","23111":"static void fuse_send_readpages(struct fuse_req *req, struct file *file)\n{\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_conn *fc = ff->fc;\n\tloff_t pos = page_offset(req->pages[0]);\n\tsize_t count = req->num_pages << PAGE_CACHE_SHIFT;\n\n\treq->out.argpages = 1;\n\treq->out.page_zeroing = 1;\n\tfuse_read_fill(req, file, pos, count, FUSE_READ);\n\treq->misc.read.attr_ver = fuse_get_attr_version(fc);\n\tif (fc->async_read) {\n\t\treq->ff = fuse_file_get(ff);\n\t\treq->end = fuse_readpages_end;\n\t\tfuse_request_send_background(fc, req);\n\t} else {\n\t\tfuse_request_send(fc, req);\n\t\tfuse_readpages_end(fc, req);\n\t\tfuse_put_request(fc, req);\n\t}\n}","23458":"v3d_reset_by_bridge(struct v3d_dev *v3d)\n{\n\tint version = V3D_BRIDGE_READ(V3D_TOP_GR_BRIDGE_REVISION);\n\n\tif (V3D_GET_FIELD(version, V3D_TOP_GR_BRIDGE_MAJOR) == 2) {\n\t\tV3D_BRIDGE_WRITE(V3D_TOP_GR_BRIDGE_SW_INIT_0,\n\t\t\t\t V3D_TOP_GR_BRIDGE_SW_INIT_0_V3D_CLK_108_SW_INIT);\n\t\tV3D_BRIDGE_WRITE(V3D_TOP_GR_BRIDGE_SW_INIT_0, 0);\n\n\t\t\n\t\tV3D_WRITE(V3D_HUB_AXICFG, V3D_HUB_AXICFG_MAX_LEN_MASK);\n\t} else {\n\t\tWARN_ON_ONCE(V3D_GET_FIELD(version,\n\t\t\t\t\t   V3D_TOP_GR_BRIDGE_MAJOR) != 7);\n\t\tV3D_BRIDGE_WRITE(V3D_TOP_GR_BRIDGE_SW_INIT_1,\n\t\t\t\t V3D_TOP_GR_BRIDGE_SW_INIT_1_V3D_CLK_108_SW_INIT);\n\t\tV3D_BRIDGE_WRITE(V3D_TOP_GR_BRIDGE_SW_INIT_1, 0);\n\t}\n}","22797":"flatpak_proxy_client_init (FlatpakProxyClient *client)\n{\n  init_side (client, &client->client_side);\n  init_side (client, &client->bus_side);\n\n  client->auth_end_offset = AUTH_END_INIT_OFFSET;\n  client->rewrite_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);\n  client->get_owner_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);\n  client->unique_id_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n}","23563":"CursorDown(n)\nregister int n;\n{\n  if (curr->w_y > curr->w_bot)\t\t\n    {\n      if ((curr->w_y += n) > rows - 1)\t\n        curr->w_y = rows - 1;\n    }\n  else\n    if ((curr->w_y += n) > curr->w_bot)\n      curr->w_y = curr->w_bot;\n  LGotoPos(&curr->w_layer, curr->w_x, curr->w_y);\n}","23352":"ClearNameValueList(struct NameValueParserData * pdata)\n{\n    struct NameValue * nv;\n\tif(pdata->portListing)\n\t{\n\t\tfree(pdata->portListing);\n\t\tpdata->portListing = NULL;\n\t\tpdata->portListingLength = 0;\n\t}\n    while((nv = pdata->l_head) != NULL)\n    {\n\t\tpdata->l_head = nv->l_next;\n        free(nv);\n    }\n}","23433":"        bool supportsWriteConcern() const override {\n            return false;\n        }","23696":"static int dlmap_init(DLHandler * const dlhandler, const int clientfd,\n                      void * const tls_clientfd, const int xferfd,\n                      const char * const name, const int f,\n                      void * const tls_fd, const off_t restartat,\n                      const int ascii_mode, const unsigned long bandwidth)\n{\n    if (ascii_mode > 0) {\n#ifdef WITHOUT_ASCII\n        addreply_noformat(450, MSG_ASCII_MODE_UNSUPPORTED);\n        return -1;\n#else\n        addreply_noformat(0, MSG_ASCII_MODE_WARNING);\n#endif\n    }\n    if (dlhandler_init(dlhandler, clientfd, tls_clientfd, xferfd, name, f,\n                       tls_fd, restartat, ascii_mode, bandwidth) != 0) {\n        return -1;\n    }\n    dlhandler->min_chunk_size = DL_MIN_CHUNK_SIZE;\n    if (ascii_mode > 0) {\n        dlhandler->default_chunk_size = dlhandler->max_chunk_size =\n            DL_DEFAULT_CHUNK_SIZE_ASCII;\n    } else {\n        dlhandler->max_chunk_size = DL_MAX_CHUNK_SIZE;\n        if (bandwidth <= 0UL) {\n            dlhandler->default_chunk_size = dlhandler->max_chunk_size;\n        } else {\n            dlhandler->default_chunk_size = DL_DEFAULT_CHUNK_SIZE;\n        }\n    }\n    dlhandler->chunk_size = dlhandler->default_chunk_size;\n    dlhandler->dlmap_size =\n        (DL_DLMAP_SIZE + page_size - (size_t) 1U) & ~(page_size - (size_t) 1U);\n    dlhandler->cur_pos = restartat;\n    dlhandler->dlmap_pos = (off_t) 0;\n    dlhandler->dlmap_fdpos = (off_t) -1;\n    dlhandler->sizeof_map = (size_t) 0U;\n    dlhandler->map_data = NULL;\n    dlhandler->sizeof_map = dlhandler->dlmap_size;\n    dlhandler->map = malloc(dlhandler->sizeof_map);\n    if (dlhandler->map == NULL) {\n        die_mem();\n    }\n    return 0;\n}","22668":"libxlDomainHandleDeath(libxlDriverPrivate *driver, virDomainObj *vm)\n{\n    virObjectEvent *dom_event = NULL;\n\n    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)\n        return;\n\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, VIR_DOMAIN_SHUTOFF_DESTROYED);\n    dom_event = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_STOPPED,\n                                                  VIR_DOMAIN_EVENT_STOPPED_DESTROYED);\n    libxlDomainCleanup(driver, vm);\n    if (!vm->persistent)\n        virDomainObjListRemove(driver->domains, vm);\n    libxlDomainObjEndJob(driver, vm);\n    virObjectEventStateQueue(driver->domainEventState, dom_event);\n}","23485":"bool __net_get_random_once(void *buf, int nbytes, bool *done,\n\t\t\t   struct static_key *once_key)\n{\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (*done) {\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t\treturn false;\n\t}\n\n\tget_random_bytes(buf, nbytes);\n\t*done = true;\n\tspin_unlock_irqrestore(&lock, flags);\n\n\t__net_random_once_disable_jump(once_key);\n\n\treturn true;\n}","22721":"int snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime,\n\t\t\t       unsigned int cond,\n\t\t\t       snd_pcm_hw_param_t var,\n\t\t\t       const struct snd_pcm_hw_constraint_list *l)\n{\n\treturn snd_pcm_hw_rule_add(runtime, cond, var,\n\t\t\t\t   snd_pcm_hw_rule_list, (void *)l,\n\t\t\t\t   var, -1);\n}","23274":"lys_deviation_free(struct lys_module *module, struct lys_deviation *dev,\n                   void (*private_destructor)(const struct lys_node *node, void *priv))\n{\n    int i, j, k;\n    struct ly_ctx *ctx;\n    struct lys_node *next, *elem;\n\n    ctx = module->ctx;\n\n    lydict_remove(ctx, dev->target_name);\n    lydict_remove(ctx, dev->dsc);\n    lydict_remove(ctx, dev->ref);\n    lys_extension_instances_free(ctx, dev->ext, dev->ext_size, private_destructor);\n\n    if (!dev->deviate) {\n        return;\n    }\n\n    \n    if (dev->orig_node) {\n        \n        if (dev->deviate[0].mod == LY_DEVIATE_NO) {\n            \n            LY_TREE_DFS_BEGIN(dev->orig_node, next, elem) {\n                elem->module = module;\n\n                LY_TREE_DFS_END(dev->orig_node, next, elem);\n            }\n            lys_node_free(dev->orig_node, NULL, 0);\n        } else {\n            \n            dev->orig_node->module = module;\n            lys_node_free(dev->orig_node, NULL, 1);\n        }\n    }\n\n    for (i = 0; i < dev->deviate_size; i++) {\n        lys_extension_instances_free(ctx, dev->deviate[i].ext, dev->deviate[i].ext_size, private_destructor);\n\n        for (j = 0; j < dev->deviate[i].dflt_size; j++) {\n            lydict_remove(ctx, dev->deviate[i].dflt[j]);\n        }\n        free(dev->deviate[i].dflt);\n\n        lydict_remove(ctx, dev->deviate[i].units);\n\n        if (dev->deviate[i].mod == LY_DEVIATE_DEL) {\n            for (j = 0; j < dev->deviate[i].must_size; j++) {\n                lys_restr_free(ctx, &dev->deviate[i].must[j], private_destructor);\n            }\n            free(dev->deviate[i].must);\n\n            for (j = 0; j < dev->deviate[i].unique_size; j++) {\n                for (k = 0; k < dev->deviate[i].unique[j].expr_size; k++) {\n                    lydict_remove(ctx, dev->deviate[i].unique[j].expr[k]);\n                }\n                free(dev->deviate[i].unique[j].expr);\n            }\n            free(dev->deviate[i].unique);\n        }\n    }\n    free(dev->deviate);\n}","22666":"DLLEXPORT unsigned long tjBufSize(int width, int height, int jpegSubsamp)\n{\n  unsigned long retval = 0;\n  int mcuw, mcuh, chromasf;\n\n  if (width < 1 || height < 1 || jpegSubsamp < 0 || jpegSubsamp >= NUMSUBOPT)\n    THROWG(\"STR\");\n\n  \n  mcuw = tjMCUWidth[jpegSubsamp];\n  mcuh = tjMCUHeight[jpegSubsamp];\n  chromasf = jpegSubsamp == TJSAMP_GRAY ? 0 : 4 * 64 \/ (mcuw * mcuh);\n  retval = PAD(width, mcuw) * PAD(height, mcuh) * (2 + chromasf) + 2048;\n\nbailout:\n  return retval;\n}","23304":"SAPI_API char *sapi_getenv(char *name, size_t name_len TSRMLS_DC)\n{\n\tif (sapi_module.getenv) { \n\t\tchar *value, *tmp = sapi_module.getenv(name, name_len TSRMLS_CC);\n\t\tif (tmp) {\n\t\t\tvalue = estrdup(tmp);\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (sapi_module.input_filter) {\n\t\t\tsapi_module.input_filter(PARSE_STRING, name, &value, strlen(value), NULL TSRMLS_CC);\n\t\t}\n\t\treturn value;\n\t}\n\treturn NULL;\n}","23308":"static int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\t__be32 spi;\n\n\tspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, spi);\n}","23652":"static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"STR\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"STR\",\n\t\t alg->cra_blkcipher.geniv ?: \"STR\");\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_blkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_blkcipher.ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}","23421":"TEST_F(QueryPlannerTest, ContainedOrPredicateIsLeadingFieldIndexIntersection) {\n    params.options = QueryPlannerParams::INCLUDE_COLLSCAN | QueryPlannerParams::INDEX_INTERSECTION;\n    addIndex(BSON(\"STR\" << 1));\n    addIndex(BSON(\"STR\" << 1));\n\n    runQuery(fromjson(\"STR\"));\n    assertNumSolutions(4);\n    assertSolutionExists(\n        \"STR\"\n        \"STR\"\n        \"STR\"\n        \"STR\"\n        \"STR\");\n    assertSolutionExists(\n        \"STR\"\n        \"STR\"\n        \"STR\"\n        \"STR\");\n    assertSolutionExists(\n        \"STR\"\n        \"STR\"\n        \"STR\"\n        \"STR\"\n        \"STR\"\n        \"STR\"\n        \"STR\"\n        \"STR\");\n    assertSolutionExists(\"STR\");\n}","23380":"static int selinux_proc_get_sid(struct dentry *dentry,\n\t\t\t\tu16 tclass,\n\t\t\t\tu32 *sid)\n{\n\tint rc;\n\tchar *buffer, *path;\n\n\tbuffer = (char *)__get_free_page(GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tpath = dentry_path_raw(dentry, buffer, PAGE_SIZE);\n\tif (IS_ERR(path))\n\t\trc = PTR_ERR(path);\n\telse {\n\t\t\n\t\twhile (path[1] >= '0' && path[1] <= '9') {\n\t\t\tpath[1] = '\/';\n\t\t\tpath++;\n\t\t}\n\t\trc = security_genfs_sid(\"STR\", path, tclass, sid);\n\t}\n\tfree_page((unsigned long)buffer);\n\treturn rc;\n}","23532":"static RList *sections(RBinFile *arch) {\n\treturn sections_cache;\n}","22807":"int __init ip_rt_init(void)\n{\n\tint cpu;\n\n\tip_idents = kmalloc_array(IP_IDENTS_SZ, sizeof(*ip_idents),\n\t\t\t\t  GFP_KERNEL);\n\tif (!ip_idents)\n\t\tpanic(\"STR\");\n\n\tprandom_bytes(ip_idents, IP_IDENTS_SZ * sizeof(*ip_idents));\n\n\tip_tstamps = kcalloc(IP_IDENTS_SZ, sizeof(*ip_tstamps), GFP_KERNEL);\n\tif (!ip_tstamps)\n\t\tpanic(\"STR\");\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct uncached_list *ul = &per_cpu(rt_uncached_list, cpu);\n\n\t\tINIT_LIST_HEAD(&ul->head);\n\t\tspin_lock_init(&ul->lock);\n\t}\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tip_rt_acct = __alloc_percpu(256 * sizeof(struct ip_rt_acct), __alignof__(struct ip_rt_acct));\n\tif (!ip_rt_acct)\n\t\tpanic(\"STR\");\n#endif\n\n\tipv4_dst_ops.kmem_cachep =\n\t\tkmem_cache_create(\"STR\", sizeof(struct rtable), 0,\n\t\t\t\t  SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\n\tipv4_dst_blackhole_ops.kmem_cachep = ipv4_dst_ops.kmem_cachep;\n\n\tif (dst_entries_init(&ipv4_dst_ops) < 0)\n\t\tpanic(\"STR\");\n\n\tif (dst_entries_init(&ipv4_dst_blackhole_ops) < 0)\n\t\tpanic(\"STR\");\n\n\tipv4_dst_ops.gc_thresh = ~0;\n\tip_rt_max_size = INT_MAX;\n\n\tdevinet_init();\n\tip_fib_init();\n\n\tif (ip_rt_proc_init())\n\t\tpr_err(\"STR\");\n#ifdef CONFIG_XFRM\n\txfrm_init();\n\txfrm4_init();\n#endif\n\trtnl_register(PF_INET, RTM_GETROUTE, inet_rtm_getroute, NULL,\n\t\t      RTNL_FLAG_DOIT_UNLOCKED);\n\n#ifdef CONFIG_SYSCTL\n\tregister_pernet_subsys(&sysctl_route_ops);\n#endif\n\tregister_pernet_subsys(&rt_genid_ops);\n\tregister_pernet_subsys(&ipv4_inetpeer_ops);\n\treturn 0;\n}","23435":"SYSCALL_DEFINE5(add_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst void __user *, _payload,\n\t\tsize_t, plen,\n\t\tkey_serial_t, ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tchar type[32], *description;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = NULL;\n\tif (_description) {\n\t\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(description)) {\n\t\t\tret = PTR_ERR(description);\n\t\t\tgoto error;\n\t\t}\n\t\tif (!*description) {\n\t\t\tkfree(description);\n\t\t\tdescription = NULL;\n\t\t} else if ((description[0] == '.') &&\n\t\t\t   (strncmp(type, \"STR\", 7) == 0)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto error2;\n\t\t}\n\t}\n\n\t\n\tpayload = NULL;\n\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error2;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error3;\n\t}\n\n\t\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error3;\n\t}\n\n\t\n\tkey_ref = key_create_or_update(keyring_ref, type, description,\n\t\t\t\t       payload, plen, KEY_PERM_UNDEF,\n\t\t\t\t       KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key_ref)) {\n\t\tret = key_ref_to_ptr(key_ref)->serial;\n\t\tkey_ref_put(key_ref);\n\t}\n\telse {\n\t\tret = PTR_ERR(key_ref);\n\t}\n\n\tkey_ref_put(keyring_ref);\n error3:\n\tkvfree(payload);\n error2:\n\tkfree(description);\n error:\n\treturn ret;\n}","23359":"void OpenSSL_add_all_ciphers(void)\n\t{\n\n#ifndef OPENSSL_NO_DES\n\tEVP_add_cipher(EVP_des_cfb());\n\tEVP_add_cipher(EVP_des_cfb1());\n\tEVP_add_cipher(EVP_des_cfb8());\n\tEVP_add_cipher(EVP_des_ede_cfb());\n\tEVP_add_cipher(EVP_des_ede3_cfb());\n\tEVP_add_cipher(EVP_des_ede3_cfb1());\n\tEVP_add_cipher(EVP_des_ede3_cfb8());\n\n\tEVP_add_cipher(EVP_des_ofb());\n\tEVP_add_cipher(EVP_des_ede_ofb());\n\tEVP_add_cipher(EVP_des_ede3_ofb());\n\n\tEVP_add_cipher(EVP_desx_cbc());\n\tEVP_add_cipher_alias(SN_desx_cbc,\"STR\");\n\tEVP_add_cipher_alias(SN_desx_cbc,\"STR\");\n\n\tEVP_add_cipher(EVP_des_cbc());\n\tEVP_add_cipher_alias(SN_des_cbc,\"STR\");\n\tEVP_add_cipher_alias(SN_des_cbc,\"STR\");\n\tEVP_add_cipher(EVP_des_ede_cbc());\n\tEVP_add_cipher(EVP_des_ede3_cbc());\n\tEVP_add_cipher_alias(SN_des_ede3_cbc,\"STR\");\n\tEVP_add_cipher_alias(SN_des_ede3_cbc,\"STR\");\n\n\tEVP_add_cipher(EVP_des_ecb());\n\tEVP_add_cipher(EVP_des_ede());\n\tEVP_add_cipher(EVP_des_ede3());\n#endif\n\n#ifndef OPENSSL_NO_RC4\n\tEVP_add_cipher(EVP_rc4());\n\tEVP_add_cipher(EVP_rc4_40());\n#ifndef OPENSSL_NO_MD5\n\tEVP_add_cipher(EVP_rc4_hmac_md5());\n#endif\n#endif\n\n#ifndef OPENSSL_NO_IDEA\n\tEVP_add_cipher(EVP_idea_ecb());\n\tEVP_add_cipher(EVP_idea_cfb());\n\tEVP_add_cipher(EVP_idea_ofb());\n\tEVP_add_cipher(EVP_idea_cbc());\n\tEVP_add_cipher_alias(SN_idea_cbc,\"STR\");\n\tEVP_add_cipher_alias(SN_idea_cbc,\"STR\");\n#endif\n\n#ifndef OPENSSL_NO_SEED\n\tEVP_add_cipher(EVP_seed_ecb());\n\tEVP_add_cipher(EVP_seed_cfb());\n\tEVP_add_cipher(EVP_seed_ofb());\n\tEVP_add_cipher(EVP_seed_cbc());\n\tEVP_add_cipher_alias(SN_seed_cbc,\"STR\");\n\tEVP_add_cipher_alias(SN_seed_cbc,\"STR\");\n#endif\n\n#ifndef OPENSSL_NO_RC2\n\tEVP_add_cipher(EVP_rc2_ecb());\n\tEVP_add_cipher(EVP_rc2_cfb());\n\tEVP_add_cipher(EVP_rc2_ofb());\n\tEVP_add_cipher(EVP_rc2_cbc());\n\tEVP_add_cipher(EVP_rc2_40_cbc());\n\tEVP_add_cipher(EVP_rc2_64_cbc());\n\tEVP_add_cipher_alias(SN_rc2_cbc,\"STR\");\n\tEVP_add_cipher_alias(SN_rc2_cbc,\"STR\");\n#endif\n\n#ifndef OPENSSL_NO_BF\n\tEVP_add_cipher(EVP_bf_ecb());\n\tEVP_add_cipher(EVP_bf_cfb());\n\tEVP_add_cipher(EVP_bf_ofb());\n\tEVP_add_cipher(EVP_bf_cbc());\n\tEVP_add_cipher_alias(SN_bf_cbc,\"STR\");\n\tEVP_add_cipher_alias(SN_bf_cbc,\"STR\");\n\tEVP_add_cipher_alias(SN_bf_cbc,\"STR\");\n#endif\n\n#ifndef OPENSSL_NO_CAST\n\tEVP_add_cipher(EVP_cast5_ecb());\n\tEVP_add_cipher(EVP_cast5_cfb());\n\tEVP_add_cipher(EVP_cast5_ofb());\n\tEVP_add_cipher(EVP_cast5_cbc());\n\tEVP_add_cipher_alias(SN_cast5_cbc,\"STR\");\n\tEVP_add_cipher_alias(SN_cast5_cbc,\"STR\");\n\tEVP_add_cipher_alias(SN_cast5_cbc,\"STR\");\n\tEVP_add_cipher_alias(SN_cast5_cbc,\"STR\");\n#endif\n\n#ifndef OPENSSL_NO_RC5\n\tEVP_add_cipher(EVP_rc5_32_12_16_ecb());\n\tEVP_add_cipher(EVP_rc5_32_12_16_cfb());\n\tEVP_add_cipher(EVP_rc5_32_12_16_ofb());\n\tEVP_add_cipher(EVP_rc5_32_12_16_cbc());\n\tEVP_add_cipher_alias(SN_rc5_cbc,\"STR\");\n\tEVP_add_cipher_alias(SN_rc5_cbc,\"STR\");\n#endif\n\n#ifndef OPENSSL_NO_AES\n\tEVP_add_cipher(EVP_aes_128_ecb());\n\tEVP_add_cipher(EVP_aes_128_cbc());\n\tEVP_add_cipher(EVP_aes_128_cfb());\n\tEVP_add_cipher(EVP_aes_128_cfb1());\n\tEVP_add_cipher(EVP_aes_128_cfb8());\n\tEVP_add_cipher(EVP_aes_128_ofb());\n\tEVP_add_cipher(EVP_aes_128_ctr());\n\tEVP_add_cipher(EVP_aes_128_gcm());\n\tEVP_add_cipher(EVP_aes_128_xts());\n\tEVP_add_cipher_alias(SN_aes_128_cbc,\"STR\");\n\tEVP_add_cipher_alias(SN_aes_128_cbc,\"STR\");\n\tEVP_add_cipher(EVP_aes_192_ecb());\n\tEVP_add_cipher(EVP_aes_192_cbc());\n\tEVP_add_cipher(EVP_aes_192_cfb());\n\tEVP_add_cipher(EVP_aes_192_cfb1());\n\tEVP_add_cipher(EVP_aes_192_cfb8());\n\tEVP_add_cipher(EVP_aes_192_ofb());\n\tEVP_add_cipher(EVP_aes_192_ctr());\n\tEVP_add_cipher(EVP_aes_192_gcm());\n\tEVP_add_cipher_alias(SN_aes_192_cbc,\"STR\");\n\tEVP_add_cipher_alias(SN_aes_192_cbc,\"STR\");\n\tEVP_add_cipher(EVP_aes_256_ecb());\n\tEVP_add_cipher(EVP_aes_256_cbc());\n\tEVP_add_cipher(EVP_aes_256_cfb());\n\tEVP_add_cipher(EVP_aes_256_cfb1());\n\tEVP_add_cipher(EVP_aes_256_cfb8());\n\tEVP_add_cipher(EVP_aes_256_ofb());\n\tEVP_add_cipher(EVP_aes_256_ctr());\n\tEVP_add_cipher(EVP_aes_256_gcm());\n\tEVP_add_cipher(EVP_aes_256_xts());\n\tEVP_add_cipher_alias(SN_aes_256_cbc,\"STR\");\n\tEVP_add_cipher_alias(SN_aes_256_cbc,\"STR\");\n#if 0  \n#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)\n\tEVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());\n\tEVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());\n#endif\n#endif\n#endif\n\n#ifndef OPENSSL_NO_CAMELLIA\n\tEVP_add_cipher(EVP_camellia_128_ecb());\n\tEVP_add_cipher(EVP_camellia_128_cbc());\n\tEVP_add_cipher(EVP_camellia_128_cfb());\n\tEVP_add_cipher(EVP_camellia_128_cfb1());\n\tEVP_add_cipher(EVP_camellia_128_cfb8());\n\tEVP_add_cipher(EVP_camellia_128_ofb());\n\tEVP_add_cipher_alias(SN_camellia_128_cbc,\"STR\");\n\tEVP_add_cipher_alias(SN_camellia_128_cbc,\"STR\");\n\tEVP_add_cipher(EVP_camellia_192_ecb());\n\tEVP_add_cipher(EVP_camellia_192_cbc());\n\tEVP_add_cipher(EVP_camellia_192_cfb());\n\tEVP_add_cipher(EVP_camellia_192_cfb1());\n\tEVP_add_cipher(EVP_camellia_192_cfb8());\n\tEVP_add_cipher(EVP_camellia_192_ofb());\n\tEVP_add_cipher_alias(SN_camellia_192_cbc,\"STR\");\n\tEVP_add_cipher_alias(SN_camellia_192_cbc,\"STR\");\n\tEVP_add_cipher(EVP_camellia_256_ecb());\n\tEVP_add_cipher(EVP_camellia_256_cbc());\n\tEVP_add_cipher(EVP_camellia_256_cfb());\n\tEVP_add_cipher(EVP_camellia_256_cfb1());\n\tEVP_add_cipher(EVP_camellia_256_cfb8());\n\tEVP_add_cipher(EVP_camellia_256_ofb());\n\tEVP_add_cipher_alias(SN_camellia_256_cbc,\"STR\");\n\tEVP_add_cipher_alias(SN_camellia_256_cbc,\"STR\");\n#endif\n\t}","23676":"int dane_query_tlsa(dane_state_t s, dane_query_t *r, const char* host, const char* proto, unsigned int port)\n{\n\tchar ns[1024];\n\tint ret;\n\tunsigned int i;\n\n\t*r = calloc(1, sizeof(struct dane_query_st));\n\tif (*r == NULL)\n\t\treturn gnutls_assert_val(DANE_E_MEMORY_ERROR);\n\n\tsnprintf(ns, sizeof(ns), \"STR\", port, proto, host);\n\n\t\n\tret = ub_resolve(s->ctx, ns, 52, 1, &(*r)->result);\n\tif(ret != 0) {\n\t\treturn gnutls_assert_val(DANE_E_RESOLVING_ERROR);\n\t}\n\n\n\tif(!(*r)->result->havedata) {\n\t\treturn gnutls_assert_val(DANE_E_NO_DANE_DATA);\n\t}\n\n\ti = 0;\n\tdo {\n\n\t\tif ((*r)->result->len[i] > 3)\n\t\t\tret = DANE_E_SUCCESS;\n\t\telse {\n\t\t\treturn gnutls_assert_val(DANE_E_RECEIVED_CORRUPT_DATA);\n\t\t}\n\t\n\t\t(*r)->usage[i] = (*r)->result->data[i][0];\n\t\t(*r)->type[i] = (*r)->result->data[i][1];\n\t\t(*r)->match[i] = (*r)->result->data[i][2];\n\t\t(*r)->data[i].data = (void*)&(*r)->result->data[i][3];\n\t\t(*r)->data[i].size = (*r)->result->len[i] - 3;\n\t\ti++;\n\t} while((*r)->result->data[i] != NULL);\n\t\n\t(*r)->data_entries = i;\n\n\tif (!(s->flags & DANE_F_INSECURE) && !(*r)->result->secure) {\n\t\tif ((*r)->result->bogus)\n\t\t\tret = gnutls_assert_val(DANE_E_INVALID_DNSSEC_SIG);\n\t\telse\n\t\t\tret = gnutls_assert_val(DANE_E_NO_DNSSEC_SIG);\n\t}\n\n\t\n\tif ((*r)->result->secure) {\n\t\t(*r)->status = DANE_QUERY_DNSSEC_VERIFIED;\n\t} else if ((*r)->result->bogus) {\n\t        gnutls_assert();\n\t\t(*r)->status = DANE_QUERY_BOGUS;\n\t} else {\n\t        gnutls_assert();\n\t        (*r)->status = DANE_QUERY_NO_DNSSEC;\n        }\n\n\treturn ret;\n}","22813":"ses_put_fname(FILE *fd, char_u *name, unsigned *flagp)\n{\n    char_u\t*sname;\n    char_u\t*p;\n    int\t\tretval = OK;\n\n    sname = home_replace_save(NULL, name);\n    if (sname == NULL)\n\treturn FAIL;\n\n    if (*flagp & SSOP_SLASH)\n    {\n\t\n\tfor (p = sname; *p != NUL; MB_PTR_ADV(p))\n\t    if (*p == '\\\\')\n\t\t*p = '\/';\n    }\n\n    \n    p = vim_strsave_fnameescape(sname, FALSE);\n    vim_free(sname);\n    if (p == NULL)\n\treturn FAIL;\n\n    \n    if (fputs((char *)p, fd) < 0)\n\tretval = FAIL;\n\n    vim_free(p);\n    return retval;\n}","22880":"iperf_set_test_reverse(struct iperf_test *ipt, int reverse)\n{\n    ipt->reverse = reverse;\n    if (ipt->reverse)\n        ipt->sender = ! ipt->sender;\n    check_sender_has_retransmits(ipt);\n}","22892":"static void fts3ColumnFilter(\n  int iCol,                       \n  int bZero,                      \n  char **ppList,                  \n  int *pnList                     \n){\n  char *pList = *ppList;\n  int nList = *pnList;\n  char *pEnd = &pList[nList];\n  int iCurrent = 0;\n  char *p = pList;\n\n  assert( iCol>=0 );\n  while( 1 ){\n    char c = 0;\n    while( p<pEnd && (c | *p)&0xFE ) c = *p++ & 0x80;\n  \n    if( iCol==iCurrent ){\n      nList = (int)(p - pList);\n      break;\n    }\n\n    nList -= (int)(p - pList);\n    pList = p;\n    if( nList<=0 ){\n      break;\n    }\n    p = &pList[1];\n    p += fts3GetVarint32(p, &iCurrent);\n  }\n\n  if( bZero && (pEnd - &pList[nList])>0){\n    memset(&pList[nList], 0, pEnd - &pList[nList]);\n  }\n  *ppList = pList;\n  *pnList = nList;\n}","23429":"static SECURITY_STATUS SEC_ENTRY negotiate_SetCredentialsAttributesA(PCredHandle phCredential,\n                                                                     ULONG ulAttribute,\n                                                                     void* pBuffer, ULONG cbBuffer)\n{\n\tMechCred* creds;\n\n\tcreds = sspi_SecureHandleGetLowerPointer(phCredential);\n\n\tif (!creds)\n\t\treturn SEC_E_INVALID_HANDLE;\n\n\tfor (size_t i = 0; i < MECH_COUNT; i++)\n\t{\n\t\tMechCred* cred = &creds[i];\n\n\t\tif (!cred->valid)\n\t\t\tcontinue;\n\n\t\tWINPR_ASSERT(cred->mech);\n\t\tWINPR_ASSERT(cred->mech->pkg);\n\t\tWINPR_ASSERT(cred->mech->pkg->table);\n\t\tWINPR_ASSERT(cred->mech->pkg->table->SetCredentialsAttributesA);\n\t\tcred->mech->pkg->table->SetCredentialsAttributesA(&cred->cred, ulAttribute, pBuffer,\n\t\t                                                  cbBuffer);\n\t}\n\n\treturn SEC_E_OK;\n}","22793":"Item *Item_func::transform(THD *thd, Item_transformer transformer, uchar *argument)\n{\n  DBUG_ASSERT(!thd->stmt_arena->is_stmt_prepare());\n  if (transform_args(thd, transformer, argument))\n    return 0;\n  return (this->*transformer)(thd, argument);\n}","22513":"cifs_find_smb_ses(struct TCP_Server_Info *server, char *username)\n{\n\tstruct list_head *tmp;\n\tstruct cifsSesInfo *ses;\n\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);\n\t\tif (strncmp(ses->userName, username, MAX_USERNAME_SIZE))\n\t\t\tcontinue;\n\n\t\t++ses->ses_count;\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}","22983":"atol8(const char *p, size_t char_cnt)\n{\n\tint64_t l;\n\tint digit;\n        \n\tl = 0;\n\twhile (char_cnt-- > 0) {\n\t\tif (*p >= '0' && *p <= '7')\n\t\t\tdigit = *p - '0';\n\t\telse\n\t\t\tbreak;\n\t\tp++;\n\t\tl <<= 3;\n\t\tl |= digit;\n\t}\n\treturn (l);\n}","23582":"GC_INNER ptr_t GC_scratch_alloc(size_t bytes)\n{\n    ptr_t result = scratch_free_ptr;\n    word bytes_to_get;\n\n    bytes = ROUNDUP_GRANULE_SIZE(bytes);\n    for (;;) {\n        scratch_free_ptr += bytes;\n        if ((word)scratch_free_ptr <= (word)GC_scratch_end_ptr) {\n            \n            return result;\n        }\n\n        if (bytes >= MINHINCR * HBLKSIZE) {\n            bytes_to_get = ROUNDUP_PAGESIZE_IF_MMAP(bytes);\n            result = (ptr_t)GET_MEM(bytes_to_get);\n            GC_add_to_our_memory(result, bytes_to_get);\n            \n            scratch_free_ptr -= bytes;\n            if (result != NULL) {\n                \n                \n                GC_scratch_last_end_ptr = result + bytes;\n            }\n            return result;\n        }\n\n        bytes_to_get = ROUNDUP_PAGESIZE_IF_MMAP(MINHINCR * HBLKSIZE);\n                                                \n        result = (ptr_t)GET_MEM(bytes_to_get);\n        GC_add_to_our_memory(result, bytes_to_get);\n        if (NULL == result) {\n            WARN(\"STR\"\n                 \"STR\", (word)bytes);\n            scratch_free_ptr -= bytes; \n            bytes_to_get = ROUNDUP_PAGESIZE_IF_MMAP(bytes);\n            result = (ptr_t)GET_MEM(bytes_to_get);\n            GC_add_to_our_memory(result, bytes_to_get);\n            return result;\n        }\n        \n        scratch_free_ptr = result;\n        GC_scratch_end_ptr = scratch_free_ptr + bytes_to_get;\n        GC_scratch_last_end_ptr = GC_scratch_end_ptr;\n    }\n}","23194":"void qemu_spice_add_memslot(SimpleSpiceDisplay *ssd, QXLDevMemSlot *memslot)\n{\n    ssd->worker->add_memslot(ssd->worker, memslot);\n}","23393":"static uint32_t scsi_init_iovec(SCSIDiskReq *r)\n{\n    r->iov.iov_len = MIN(r->sector_count * 512, SCSI_DMA_BUF_SIZE);\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n    return r->qiov.size \/ 512;\n}","22963":"nameUIDPretty(\n\tSyntax *syntax,\n\tstruct berval *val,\n\tstruct berval *out,\n\tvoid *ctx )\n{\n\tassert( val != NULL );\n\tassert( out != NULL );\n\n\n\tDebug( LDAP_DEBUG_TRACE, \"STR\", val->bv_val, 0, 0 );\n\n\tif( BER_BVISEMPTY( val ) ) {\n\t\tber_dupbv_x( out, val, ctx );\n\n\t} else if ( val->bv_len > SLAP_LDAPDN_MAXLEN ) {\n\t\treturn LDAP_INVALID_SYNTAX;\n\n\t} else {\n\t\tint\t\trc;\n\t\tstruct berval\tdnval = *val;\n\t\tstruct berval\tuidval = BER_BVNULL;\n\n\t\tuidval.bv_val = strrchr( val->bv_val, '#' );\n\t\tif ( !BER_BVISNULL( &uidval ) ) {\n\t\t\tuidval.bv_val++;\n\t\t\tuidval.bv_len = val->bv_len - ( uidval.bv_val - val->bv_val );\n\n\t\t\trc = bitStringValidate( NULL, &uidval );\n\n\t\t\tif ( rc == LDAP_SUCCESS ) {\n\t\t\t\tber_dupbv_x( &dnval, val, ctx );\n\t\t\t\tuidval.bv_val--;\n\t\t\t\tdnval.bv_len -= ++uidval.bv_len;\n\t\t\t\tdnval.bv_val[dnval.bv_len] = '\\0';\n\n\t\t\t} else {\n\t\t\t\tBER_BVZERO( &uidval );\n\t\t\t}\n\t\t}\n\n\t\trc = dnPretty( syntax, &dnval, out, ctx );\n\t\tif ( dnval.bv_val != val->bv_val ) {\n\t\t\tslap_sl_free( dnval.bv_val, ctx );\n\t\t}\n\t\tif( rc != LDAP_SUCCESS ) {\n\t\t\treturn rc;\n\t\t}\n\n\t\tif( !BER_BVISNULL( &uidval ) ) {\n\t\t\tchar\t*tmp;\n\n\t\t\ttmp = slap_sl_realloc( out->bv_val, out->bv_len \n\t\t\t\t+ uidval.bv_len + 1,\n\t\t\t\tctx );\n\t\t\tif( tmp == NULL ) {\n\t\t\t\tber_memfree_x( out->bv_val, ctx );\n\t\t\t\treturn LDAP_OTHER;\n\t\t\t}\n\t\t\tout->bv_val = tmp;\n\t\t\tmemcpy( out->bv_val + out->bv_len, uidval.bv_val, uidval.bv_len );\n\t\t\tout->bv_len += uidval.bv_len;\n\t\t\tout->bv_val[out->bv_len] = '\\0';\n\t\t}\n\t}\n\n\tDebug( LDAP_DEBUG_TRACE, \"STR\", out->bv_val, 0, 0 );\n\n\treturn LDAP_SUCCESS;\n}","22954":"void dns_server_unlink(DnsServer *s) {\n        assert(s);\n        assert(s->manager);\n\n        \n\n        if (!s->linked)\n                return;\n\n        switch (s->type) {\n\n        case DNS_SERVER_LINK:\n                assert(s->link);\n                assert(s->link->n_dns_servers > 0);\n                LIST_REMOVE(servers, s->link->dns_servers, s);\n                s->link->n_dns_servers--;\n                break;\n\n        case DNS_SERVER_SYSTEM:\n                assert(s->manager->n_dns_servers > 0);\n                LIST_REMOVE(servers, s->manager->dns_servers, s);\n                s->manager->n_dns_servers--;\n                break;\n\n        case DNS_SERVER_FALLBACK:\n                assert(s->manager->n_dns_servers > 0);\n                LIST_REMOVE(servers, s->manager->fallback_dns_servers, s);\n                s->manager->n_dns_servers--;\n                break;\n        default:\n                assert_not_reached(\"STR\");\n        }\n\n        s->linked = false;\n\n        if (s->link && s->link->current_dns_server == s)\n                link_set_dns_server(s->link, NULL);\n\n        if (s->manager->current_dns_server == s)\n                manager_set_dns_server(s->manager, NULL);\n\n        dns_server_unref(s);\n}","23341":"TEST(LineBasedFrameDecoder, Simple) {\n  auto pipeline = Pipeline<IOBufQueue&, std::unique_ptr<IOBuf>>::create();\n  int called = 0;\n\n  (*pipeline)\n    .addBack(LineBasedFrameDecoder(10))\n    .addBack(test::FrameTester([&](std::unique_ptr<IOBuf> buf) {\n        auto sz = buf->computeChainDataLength();\n        called++;\n        EXPECT_EQ(sz, 3);\n      }))\n    .finalize();\n\n  auto buf = createZeroedBuffer(3);\n\n  IOBufQueue q(IOBufQueue::cacheChainLength());\n\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 0);\n\n  buf = createZeroedBuffer(1);\n  RWPrivateCursor c(buf.get());\n  c.write<char>('\\n');\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n\n  buf = createZeroedBuffer(4);\n  RWPrivateCursor c1(buf.get());\n  c1.write(' ');\n  c1.write(' ');\n  c1.write(' ');\n\n  c1.write('\\r');\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 1);\n\n  buf = createZeroedBuffer(1);\n  RWPrivateCursor c2(buf.get());\n  c2.write('\\n');\n  q.append(std::move(buf));\n  pipeline->read(q);\n  EXPECT_EQ(called, 2);\n}","23034":"struct clock_source *dcn10_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}","22514":"static void do_client_disconnect(void)\n{\n    if (client_connected) {\n        udscs_server_write_all(server, VDAGENTD_CLIENT_DISCONNECTED, 0, 0,\n                               NULL, 0);\n        client_connected = false;\n    }\n}","23454":"HeaderLookupTable_t::lookup (const char *buf, const std::size_t len) const {\n    const HeaderTableRecord *r = HttpHeaderHashTable::lookup(buf, len);\n    if (!r)\n        return BadHdr;\n    return *r;\n}","23402":"art_blend_luminosity_rgb_8(int n_chan, byte *gs_restrict dst, const byte *gs_restrict backdrop,\n                           const byte *gs_restrict src)\n{\n    int rb = backdrop[0], gb = backdrop[1], bb = backdrop[2];\n    int rs = src[0], gs = src[1], bs = src[2];\n    int delta_y;\n    int r, g, b;\n\n    \n    delta_y = ((rs - rb) * 77 + (gs - gb) * 151 + (bs - bb) * 28 + 0x80) >> 8;\n    r = rb + delta_y;\n    g = gb + delta_y;\n    b = bb + delta_y;\n    if ((r | g | b) & 0x100) {\n        int y;\n        int scale;\n\n        y = (rs * 77 + gs * 151 + bs * 28 + 0x80) >> 8;\n        if (delta_y > 0) {\n            int max;\n\n            max = r > g ? r : g;\n            max = b > max ? b : max;\n            scale = ((255 - y) << 16) \/ (max - y);\n        } else {\n            int min;\n\n            min = r < g ? r : g;\n            min = b < min ? b : min;\n            scale = (y << 16) \/ (y - min);\n        }\n        r = y + (((r - y) * scale + 0x8000) >> 16);\n        g = y + (((g - y) * scale + 0x8000) >> 16);\n        b = y + (((b - y) * scale + 0x8000) >> 16);\n    }\n    dst[0] = r;\n    dst[1] = g;\n    dst[2] = b;\n}","23126":"static int get_name(int counter,\n\t\tunsigned char *pkt, unsigned char *start, unsigned char *max,\n\t\tunsigned char *output, int output_max, int *output_len,\n\t\tunsigned char **end, char *name, int *name_len)\n{\n\tunsigned char *p;\n\n\t\n\tif (counter > 10)\n\t\treturn -EINVAL;\n\n\tp = start;\n\twhile (*p) {\n\t\tif ((*p & NS_CMPRSFLGS) == NS_CMPRSFLGS) {\n\t\t\tuint16_t offset = (*p & 0x3F) * 256 + *(p + 1);\n\n\t\t\tif (offset >= max - pkt)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tif (!*end)\n\t\t\t\t*end = p + 2;\n\n\t\t\treturn get_name(counter + 1, pkt, pkt + offset, max,\n\t\t\t\t\toutput, output_max, output_len, end,\n\t\t\t\t\tname, name_len);\n\t\t} else {\n\t\t\tunsigned label_len = *p;\n\n\t\t\tif (pkt + label_len > max)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\tif (*output_len > output_max)\n\t\t\t\treturn -ENOBUFS;\n\n\t\t\t\n\t\t\tname[(*name_len)++] = label_len;\n\t\t\tmemcpy(name + *name_len, p + 1,\tlabel_len + 1);\n\t\t\t*name_len += label_len;\n\n\t\t\t\n\t\t\toutput[0] = NS_CMPRSFLGS;\n\t\t\toutput[1] = 0x0C;\n\t\t\t*output_len = 2;\n\n\t\t\tp += label_len + 1;\n\n\t\t\tif (!*end)\n\t\t\t\t*end = p;\n\n\t\t\tif (p >= max)\n\t\t\t\treturn -ENOBUFS;\n\t\t}\n\t}\n\n\treturn 0;\n}","23557":"jpc_streamlist_t *jpc_streamlist_create()\n{\n\tjpc_streamlist_t *streamlist;\n\tint i;\n\n\tif (!(streamlist = jas_malloc(sizeof(jpc_streamlist_t)))) {\n\t\treturn 0;\n\t}\n\tstreamlist->numstreams = 0;\n\tstreamlist->maxstreams = 100;\n\tif (!(streamlist->streams = jas_malloc(streamlist->maxstreams *\n\t  sizeof(jas_stream_t *)))) {\n\t\tjas_free(streamlist);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < streamlist->maxstreams; ++i) {\n\t\tstreamlist->streams[i] = 0;\n\t}\n\treturn streamlist;\n}","22826":"GF_Err gnrv_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn GF_OK;\n}","22843":"static void Sp_toUpperCase(js_State *J)\n{\n\tconst char *src = checkstring(J, 0);\n\tchar *dst = js_malloc(J, UTFmax * strlen(src) + 1);\n\tconst char *s = src;\n\tchar *d = dst;\n\tRune rune;\n\twhile (*s) {\n\t\ts += chartorune(&rune, s);\n\t\trune = toupperrune(rune);\n\t\td += runetochar(d, &rune);\n\t}\n\t*d = 0;\n\tif (js_try(J)) {\n\t\tjs_free(J, dst);\n\t\tjs_throw(J);\n\t}\n\tjs_pushstring(J, dst);\n\tjs_endtry(J);\n\tjs_free(J, dst);\n}","23471":"PUTTEXT_null(unsigned int x, unsigned int y, const char *s)\n{\n    (void) s;                   \n    (void) x;\n    (void) y;\n}","23288":"static inline void timer_stats_timer_set_start_info(struct timer_list *timer)\n{\n}","23545":"static void nf_tables_commit_release(struct nft_trans *trans)\n{\n\tswitch (trans->msg_type) {\n\tcase NFT_MSG_DELTABLE:\n\t\tnf_tables_table_destroy(&trans->ctx);\n\t\tbreak;\n\tcase NFT_MSG_DELCHAIN:\n\t\tnf_tables_chain_destroy(trans->ctx.chain);\n\t\tbreak;\n\tcase NFT_MSG_DELRULE:\n\t\tnf_tables_rule_destroy(&trans->ctx, nft_trans_rule(trans));\n\t\tbreak;\n\tcase NFT_MSG_DELSET:\n\t\tnft_set_destroy(nft_trans_set(trans));\n\t\tbreak;\n\t}\n\tkfree(trans);\n}","22913":"void init_entity_runnable_average(struct sched_entity *se)\n{\n\tstruct sched_avg *sa = &se->avg;\n\n\tmemset(sa, 0, sizeof(*sa));\n\n\t\n\tif (entity_is_task(se))\n\t\tsa->runnable_load_avg = sa->load_avg = scale_load_down(se->load.weight);\n\n\tse->runnable_weight = se->load.weight;\n\n\t\n}","22691":"MagickExport MagickBooleanType DefineImageOption(ImageInfo *image_info,\n  const char *option)\n{\n  char\n    key[MagickPathExtent],\n    value[MagickPathExtent];\n\n  register char\n    *p;\n\n  assert(image_info != (ImageInfo *) NULL);\n  assert(option != (const char *) NULL);\n  (void) CopyMagickString(key,option,MagickPathExtent);\n  for (p=key; *p != '\\0'; p++)\n    if (*p == '=')\n      break;\n  *value='\\0';\n  if (*p == '=')\n    (void) CopyMagickString(value,p+1,MagickPathExtent);\n  *p='\\0';\n  return(SetImageOption(image_info,key,value));\n}","23119":"\tif(pData->fdErrFile != -1) {\n\t\tclose(pData->fdErrFile);\n\t\tpData->fdErrFile = -1;\n\t}","23087":"httpSetField(http_t       *http,\t\n             http_field_t field,\t\n\t     const char   *value)\t\n{\n  DEBUG_printf((\"STR\", (void *)http, field, http_fields[field], value));\n\n  if (http == NULL ||\n      field < HTTP_FIELD_ACCEPT_LANGUAGE ||\n      field >= HTTP_FIELD_MAX ||\n      value == NULL)\n    return;\n\n  http_add_field(http, field, value, 0);\n}","23627":"static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_name)\n{\n\tzval**\tele_value\t= NULL;\n\n\tif(zend_hash_find(hash_arr , key_name , strlen(key_name) + 1 ,(void **)&ele_value ) == SUCCESS ) {\n\t\tif(Z_TYPE_PP(ele_value)!= IS_STRING ){\n\t\t\t\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 && \n\t\t   strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) {\n\t\t\t\n\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\t}\n\t\tsmart_str_appendl(loc_name, Z_STRVAL_PP(ele_value) , Z_STRLEN_PP(ele_value));\n\t\treturn SUCCESS;\n\t}\n\n\treturn LOC_NOT_FOUND;\n}","23779":"int bson_check_field_name( bson *b, const char *string,\n                           const int length ) {\n\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 1, 1 );\n}","23444":"void PublicKey::AddToEnd(const byte* data, word32 len)\n{\n    mySTL::auto_array<byte> tmp(NEW_TC byte[sz_ + len]);\n\n    memcpy(tmp.get(), key_, sz_);\n    memcpy(tmp.get() + sz_, data, len);\n\n    byte* del = 0;\n    STL::swap(del, key_);\n    tcArrayDelete(del);\n\n    key_ = tmp.release();\n    sz_ += len;\n}","23470":"ListenerImpl::ListenerImpl(const envoy::config::listener::v3::Listener& config,\n                           const std::string& version_info, ListenerManagerImpl& parent,\n                           const std::string& name, bool added_via_api, bool workers_started,\n                           uint64_t hash, uint32_t concurrency)\n    : parent_(parent), address_(Network::Address::resolveProtoAddress(config.address())),\n      bind_to_port_(PROTOBUF_GET_WRAPPED_OR_DEFAULT(config.deprecated_v1(), bind_to_port, true)),\n      hand_off_restored_destination_connections_(\n          PROTOBUF_GET_WRAPPED_OR_DEFAULT(config, hidden_envoy_deprecated_use_original_dst, false)),\n      per_connection_buffer_limit_bytes_(\n          PROTOBUF_GET_WRAPPED_OR_DEFAULT(config, per_connection_buffer_limit_bytes, 1024 * 1024)),\n      listener_tag_(parent_.factory_.nextListenerTag()), name_(name), added_via_api_(added_via_api),\n      workers_started_(workers_started), hash_(hash),\n      validation_visitor_(\n          added_via_api_ ? parent_.server_.messageValidationContext().dynamicValidationVisitor()\n                         : parent_.server_.messageValidationContext().staticValidationVisitor()),\n      listener_init_target_(fmt::format(\"STR\", name),\n                            [this]() { dynamic_init_manager_->initialize(local_init_watcher_); }),\n      dynamic_init_manager_(std::make_unique<Init::ManagerImpl>(\n          fmt::format(\"STR\", name, hash))),\n      config_(config), version_info_(version_info),\n      listener_filters_timeout_(\n          PROTOBUF_GET_MS_OR_DEFAULT(config, listener_filters_timeout, 15000)),\n      continue_on_listener_filters_timeout_(config.continue_on_listener_filters_timeout()),\n      listener_factory_context_(std::make_shared<PerListenerFactoryContextImpl>(\n          parent.server_, validation_visitor_, config, this, *this,\n          parent.factory_.createDrainManager(config.drain_type()))),\n      filter_chain_manager_(address_, listener_factory_context_->parentFactoryContext(),\n                            initManager()),\n      local_init_watcher_(fmt::format(\"STR\", name), [this] {\n        if (workers_started_) {\n          parent_.onListenerWarmed(*this);\n        } else {\n          \n          \n          listener_init_target_.ready();\n        }\n      }) {\n  buildAccessLog();\n  auto socket_type = Network::Utility::protobufAddressSocketType(config.address());\n  buildListenSocketOptions(socket_type);\n  buildUdpListenerFactory(socket_type, concurrency);\n  createListenerFilterFactories(socket_type);\n  validateFilterChains(socket_type);\n  buildFilterChains();\n  if (socket_type == Network::Socket::Type::Datagram) {\n    return;\n  }\n  buildSocketOptions();\n  buildOriginalDstListenerFilter();\n  buildProxyProtocolListenerFilter();\n  buildTlsInspectorListenerFilter();\n  if (!workers_started_) {\n    \n    \n    \n    \n    parent_.server_.initManager().add(listener_init_target_);\n  }\n}","23461":"static int semctl_down(struct ipc_namespace *ns, int semid,\n\t\t       int cmd, int version, void __user *p)\n{\n\tstruct sem_array *sma;\n\tint err;\n\tstruct semid64_ds semid64;\n\tstruct kern_ipc_perm *ipcp;\n\n\tif(cmd == IPC_SET) {\n\t\tif (copy_semid_from_user(&semid64, p, version))\n\t\t\treturn -EFAULT;\n\t}\n\n\tipcp = ipcctl_pre_down_nolock(ns, &sem_ids(ns), semid, cmd,\n\t\t\t\t      &semid64.sem_perm, 0);\n\tif (IS_ERR(ipcp))\n\t\treturn PTR_ERR(ipcp);\n\n\tsma = container_of(ipcp, struct sem_array, sem_perm);\n\n\terr = security_sem_semctl(sma, cmd);\n\tif (err) {\n\t\trcu_read_unlock();\n\t\tgoto out_unlock;\n\t}\n\n\tswitch(cmd){\n\tcase IPC_RMID:\n\t\tipc_lock_object(&sma->sem_perm);\n\t\tfreeary(ns, ipcp);\n\t\tgoto out_up;\n\tcase IPC_SET:\n\t\tipc_lock_object(&sma->sem_perm);\n\t\terr = ipc_update_perm(&semid64.sem_perm, ipcp);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t\tsma->sem_ctime = get_seconds();\n\t\tbreak;\n\tdefault:\n\t\trcu_read_unlock();\n\t\terr = -EINVAL;\n\t\tgoto out_up;\n\t}\n\nout_unlock:\n\tsem_unlock(sma);\nout_up:\n\tup_write(&sem_ids(ns).rw_mutex);\n\treturn err;\n}","22955":"int ssl_check_clienthello_tlsext_late(SSL *s)\n\t{\n\tint ret = SSL_TLSEXT_ERR_OK;\n\tint al;\n\n\t\n\tif ((s->tlsext_status_type != -1) && s->ctx && s->ctx->tlsext_status_cb)\n\t\t{\n\t\tint r;\n\t\tCERT_PKEY *certpkey;\n\t\tcertpkey = ssl_get_server_send_pkey(s);\n\t\t\n\t\tif (certpkey == NULL)\n\t\t\t{\n\t\t\ts->tlsext_status_expected = 0;\n\t\t\treturn 1;\n\t\t\t}\n\t\t\n\t\ts->cert->key = certpkey;\n\t\tr = s->ctx->tlsext_status_cb(s, s->ctx->tlsext_status_arg);\n\t\tswitch (r)\n\t\t\t{\n\t\t\t\n\t\t\tcase SSL_TLSEXT_ERR_NOACK:\n\t\t\t\ts->tlsext_status_expected = 0;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase SSL_TLSEXT_ERR_OK:\n\t\t\t\tif (s->tlsext_ocsp_resp)\n\t\t\t\t\ts->tlsext_status_expected = 1;\n\t\t\t\telse\n\t\t\t\t\ts->tlsext_status_expected = 0;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase SSL_TLSEXT_ERR_ALERT_FATAL:\n\t\t\t\tret = SSL_TLSEXT_ERR_ALERT_FATAL;\n\t\t\t\tal = SSL_AD_INTERNAL_ERROR;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\telse\n\t\ts->tlsext_status_expected = 0;\n\n err:\n\tswitch (ret)\n\t\t{\n\t\tcase SSL_TLSEXT_ERR_ALERT_FATAL:\n\t\t\tssl3_send_alert(s,SSL3_AL_FATAL,al); \n\t\t\treturn -1;\n\n\t\tcase SSL_TLSEXT_ERR_ALERT_WARNING:\n\t\t\tssl3_send_alert(s,SSL3_AL_WARNING,al);\n\t\t\treturn 1; \n\n\t\tdefault:\n\t\t\treturn 1;\n\t\t}\n\t}","22921":"void CoreUserInputHandler::handleSay(const BufferInfo &bufferInfo, const QString &msg)\n{\n    if (bufferInfo.bufferName().isEmpty() || !bufferInfo.acceptsRegularMessages())\n        return;  \n\n    QByteArray encMsg = channelEncode(bufferInfo.bufferName(), msg);\n#ifdef HAVE_QCA2\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg, network()->cipher(bufferInfo.bufferName()));\n#else\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg);\n#endif\n    emit displayMsg(Message::Plain, bufferInfo.type(), bufferInfo.bufferName(), msg, network()->myNick(), Message::Self);\n}","23750":"void unit_unwatch_pid(Unit *u, pid_t pid) {\n        assert(u);\n        assert(pid >= 1);\n\n        hashmap_remove_value(u->manager->watch_pids, LONG_TO_PTR(pid), u);\n        set_remove(u->pids, LONG_TO_PTR(pid));\n}","23475":"void jpc_enc_tile_destroy(jpc_enc_tile_t *tile)\n{\n\tjpc_enc_tcmpt_t *tcmpt;\n\tuint_fast16_t cmptno;\n\n\tif (tile->tcmpts) {\n\t\tfor (cmptno = 0, tcmpt = tile->tcmpts; cmptno <\n\t\t  tile->numtcmpts; ++cmptno, ++tcmpt) {\n\t\t\ttcmpt_destroy(tcmpt);\n\t\t}\n\t\tjas_free(tile->tcmpts);\n\t}\n\tif (tile->lyrsizes) {\n\t\tjas_free(tile->lyrsizes);\n\t}\n\tif (tile->pi) {\n\t\tjpc_pi_destroy(tile->pi);\n\t}\n\tjas_free(tile);\n}","23787":"static void __fanout_link(struct sock *sk, struct packet_sock *po)\n{\n\tstruct packet_fanout *f = po->fanout;\n\n\tspin_lock(&f->lock);\n\tf->arr[f->num_members] = sk;\n\tsmp_wmb();\n\tf->num_members++;\n\tspin_unlock(&f->lock);\n}","22672":"static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client_port *port;\n\tstruct snd_seq_port_callback *callback;\n\n\t\n\tif (info->addr.client != client->number)\n\t\treturn -EPERM;\n\n\tport = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);\n\tif (port == NULL)\n\t\treturn -ENOMEM;\n\n\tif (client->type == USER_CLIENT && info->kernel) {\n\t\tsnd_seq_delete_port(client, port->addr.port);\n\t\treturn -EINVAL;\n\t}\n\tif (client->type == KERNEL_CLIENT) {\n\t\tif ((callback = info->kernel) != NULL) {\n\t\t\tif (callback->owner)\n\t\t\t\tport->owner = callback->owner;\n\t\t\tport->private_data = callback->private_data;\n\t\t\tport->private_free = callback->private_free;\n\t\t\tport->event_input = callback->event_input;\n\t\t\tport->c_src.open = callback->subscribe;\n\t\t\tport->c_src.close = callback->unsubscribe;\n\t\t\tport->c_dest.open = callback->use;\n\t\t\tport->c_dest.close = callback->unuse;\n\t\t}\n\t}\n\n\tinfo->addr = port->addr;\n\n\tsnd_seq_set_port_info(port, info);\n\tsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\n\n\treturn 0;\n}","23009":"dtls1_process_heartbeat(SSL *s)\n\t{\n\tunsigned char *p = &s->s3->rrec.data[0], *pl;\n\tunsigned short hbtype;\n\tunsigned int payload;\n\tunsigned int padding = 16; \n\n\t\n\thbtype = *p++;\n\tn2s(p, payload);\n\tpl = p;\n\n\tif (s->msg_callback)\n\t\ts->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,\n\t\t\t&s->s3->rrec.data[0], s->s3->rrec.length,\n\t\t\ts, s->msg_callback_arg);\n\n\tif (hbtype == TLS1_HB_REQUEST)\n\t\t{\n\t\tunsigned char *buffer, *bp;\n\t\tint r;\n\n\t\t\n\t\tbuffer = OPENSSL_malloc(1 + 2 + payload + padding);\n\t\tbp = buffer;\n\n\t\t\n\t\t*bp++ = TLS1_HB_RESPONSE;\n\t\ts2n(payload, bp);\n\t\tmemcpy(bp, pl, payload);\n\t\tbp += payload;\n\t\t\n\t\tRAND_pseudo_bytes(bp, padding);\n\n\t\tr = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);\n\n\t\tif (r >= 0 && s->msg_callback)\n\t\t\ts->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,\n\t\t\t\tbuffer, 3 + payload + padding,\n\t\t\t\ts, s->msg_callback_arg);\n\n\t\tOPENSSL_free(buffer);\n\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\t}\n\telse if (hbtype == TLS1_HB_RESPONSE)\n\t\t{\n\t\tunsigned int seq;\n\n\t\t\n\t\tn2s(pl, seq);\n\n\t\tif (payload == 18 && seq == s->tlsext_hb_seq)\n\t\t\t{\n\t\t\tdtls1_stop_timer(s);\n\t\t\ts->tlsext_hb_seq++;\n\t\t\ts->tlsext_hb_pending = 0;\n\t\t\t}\n\t\t}\n\n\treturn 0;\n\t}","23076":"jpc_mqenc_t *jpc_mqenc_create(int maxctxs, jas_stream_t *out)\n{\n\tjpc_mqenc_t *mqenc;\n\n\t\n\tif (!(mqenc = jas_malloc(sizeof(jpc_mqenc_t)))) {\n\t\tgoto error;\n\t}\n\tmqenc->out = out;\n\tmqenc->maxctxs = maxctxs;\n\n\t\n\tif (!(mqenc->ctxs = jas_malloc(mqenc->maxctxs * sizeof(jpc_mqstate_t *)))) {\n\t\tgoto error;\n\t}\n\n\t\n\tmqenc->curctx = mqenc->ctxs;\n\n\tjpc_mqenc_init(mqenc);\n\n\t\n\tjpc_mqenc_setctxs(mqenc, 0, 0);\n\n\treturn mqenc;\n\nerror:\n\tif (mqenc) {\n\t\tjpc_mqenc_destroy(mqenc);\n\t}\n\treturn 0;\n}","23780":"static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"STR\");\n\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = git_stream_connect(t->io);\n\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid = (error == GIT_OK);\n\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\n\t\tgiterr_clear();\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"STR\");\n\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\n\tt->connected = 1;\n\treturn 0;\n}","23589":"unsigned _gnutls_fips_mode_enabled(void)\n{\nunsigned f1p = 0, f2p;\nFILE* fd;\nconst char *p;\n\n\tif (_fips_mode != -1)\n\t\treturn _fips_mode;\n\n\tp = getenv(\"STR\");\n\tif (p) {\n\t\tif (p[0] == '1')\n\t\t\t_fips_mode = 1;\n\t\telse if (p[0] == '2')\n\t\t\t_fips_mode = 2;\n\t\telse\n\t\t\t_fips_mode = 0;\n\t\treturn _fips_mode;\n\t}\n\n\tfd = fopen(FIPS_KERNEL_FILE, \"STR\");\n\tif (fd != NULL) {\n\t\tf1p = fgetc(fd);\n\t\tfclose(fd);\n\t\t\n\t\tif (f1p == '1') f1p = 1;\n\t\telse f1p = 0;\n\t}\n\n\tf2p = !access(FIPS_SYSTEM_FILE, F_OK);\n\n\tif (f1p != 0 && f2p != 0) {\n\t\t_gnutls_debug_log(\"STR\");\n\t\t_fips_mode = 1;\n\t\treturn _fips_mode;\n\t}\n\n\tif (f2p != 0) {\n\t\t\n\t\t_gnutls_debug_log(\"STR\");\n\t\t_fips_mode = 2;\n\t\treturn _fips_mode;\n\t}\n\n\t_fips_mode = 0;\n\treturn _fips_mode;\n}","23198":"static int has_usable_cert(SSL *s, const SIGALG_LOOKUP *sig, int idx)\n{\n    const SIGALG_LOOKUP *lu;\n    int mdnid, pknid, supported;\n    size_t i;\n\n    \n    if (idx == -1)\n        idx = sig->sig_idx;\n    if (!ssl_has_cert(s, idx))\n        return 0;\n    if (s->s3.tmp.peer_cert_sigalgs != NULL) {\n        for (i = 0; i < s->s3.tmp.peer_cert_sigalgslen; i++) {\n            lu = tls1_lookup_sigalg(s->s3.tmp.peer_cert_sigalgs[i]);\n            if (lu == NULL\n                || !X509_get_signature_info(s->cert->pkeys[idx].x509, &mdnid,\n                                            &pknid, NULL, NULL)\n                \n                || mdnid != lu->hash\n                || pknid != lu->sig)\n                continue;\n\n            ERR_set_mark();\n            supported = EVP_PKEY_supports_digest_nid(s->cert->pkeys[idx].privatekey,\n                                                     mdnid);\n            if (supported == 0)\n                continue;\n            else if (supported < 0)\n            {\n                \n                ERR_pop_to_mark();\n            }\n            return 1;\n        }\n        return 0;\n    }\n    supported = EVP_PKEY_supports_digest_nid(s->cert->pkeys[idx].privatekey,\n                                             sig->hash);\n    if (supported == 0)\n        return 0;\n    else if (supported < 0)\n        ERR_clear_error();\n\n    return 1;\n}","23246":"static int gfs2_adjust_quota(struct gfs2_inode *ip, loff_t loc,\n\t\t\t     s64 change, struct gfs2_quota_data *qd,\n\t\t\t     struct fs_disk_quota *fdq)\n{\n\tstruct inode *inode = &ip->i_inode;\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned long index = loc >> PAGE_CACHE_SHIFT;\n\tunsigned offset = loc & (PAGE_CACHE_SIZE - 1);\n\tunsigned blocksize, iblock, pos;\n\tstruct buffer_head *bh, *dibh;\n\tstruct page *page;\n\tvoid *kaddr;\n\tstruct gfs2_quota *qp;\n\ts64 value;\n\tint err = -EIO;\n\tu64 size;\n\n\tif (gfs2_is_stuffed(ip))\n\t\tgfs2_unstuff_dinode(ip, NULL);\n\t\n\tpage = grab_cache_page(mapping, index);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tiblock = index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\tif (!buffer_mapped(bh)) {\n\t\tgfs2_block_map(inode, iblock, bh, 1);\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock;\n\t}\n\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block(READ_META, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t}\n\n\tgfs2_trans_add_bh(ip->i_gl, bh, 0);\n\n\tkaddr = kmap_atomic(page, KM_USER0);\n\tqp = kaddr + offset;\n\tvalue = (s64)be64_to_cpu(qp->qu_value) + change;\n\tqp->qu_value = cpu_to_be64(value);\n\tqd->qd_qb.qb_value = qp->qu_value;\n\tif (fdq) {\n\t\tif (fdq->d_fieldmask & FS_DQ_BSOFT) {\n\t\t\tqp->qu_warn = cpu_to_be64(fdq->d_blk_softlimit);\n\t\t\tqd->qd_qb.qb_warn = qp->qu_warn;\n\t\t}\n\t\tif (fdq->d_fieldmask & FS_DQ_BHARD) {\n\t\t\tqp->qu_limit = cpu_to_be64(fdq->d_blk_hardlimit);\n\t\t\tqd->qd_qb.qb_limit = qp->qu_limit;\n\t\t}\n\t}\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr, KM_USER0);\n\n\terr = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (err)\n\t\tgoto unlock;\n\n\tsize = loc + sizeof(struct gfs2_quota);\n\tif (size > inode->i_size) {\n\t\tip->i_disksize = size;\n\t\ti_size_write(inode, size);\n\t}\n\tinode->i_mtime = inode->i_atime = CURRENT_TIME;\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\tgfs2_dinode_out(ip, dibh->b_data);\n\tbrelse(dibh);\n\tmark_inode_dirty(inode);\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn err;\n}","23506":"  virtual bool with_subquery() const\n  {\n    return (*ref)->with_subquery();\n  }","23625":"Fraction Fraction::operator-(const Fraction& b) const\n{\n  if (denominator == b.denominator) {\n    return Fraction { numerator - b.numerator, denominator };\n  }\n  else {\n    return Fraction { numerator * b.denominator - b.numerator * denominator,\n        denominator * b.denominator };\n  }\n}","23487":"get_obj_from_str(str)\n    VALUE str;\n{\n    const char *s = StringValuePtr(str);\n\n#if TCL_MAJOR_VERSION == 8 && TCL_MINOR_VERSION == 0\n    return Tcl_NewStringObj((char*)s, RSTRING_LEN(str));\n#else \n    VALUE enc = rb_attr_get(str, ID_at_enc);\n\n    if (!NIL_P(enc)) {\n        StringValue(enc);\n        if (strcmp(RSTRING_PTR(enc), \"STR\") == 0) {\n            \n            return Tcl_NewByteArrayObj((const unsigned char *)s, RSTRING_LENINT(str));\n        } else {\n            \n            return Tcl_NewStringObj(s, RSTRING_LENINT(str));\n        }\n#ifdef HAVE_RUBY_ENCODING_H\n    } else if (rb_enc_get_index(str) == ENCODING_INDEX_BINARY) {\n        \n        return Tcl_NewByteArrayObj((const unsigned char *)s, RSTRING_LENINT(str));\n#endif\n    } else if (memchr(s, 0, RSTRING_LEN(str))) {\n        \n        return Tcl_NewByteArrayObj((const unsigned char *)s, RSTRING_LENINT(str));\n    } else {\n        \n        return Tcl_NewStringObj(s, RSTRING_LENINT(str));\n    }\n#endif\n}","23335":"      static double mp_atan2(_cimg_math_parser& mp) {\n        return std::atan2(_mp_arg(2),_mp_arg(3));\n      }","23086":"static void __init xen_hvm_guest_init(void)\n{\n\tif (xen_pv_domain())\n\t\treturn;\n\n\tinit_hvm_pv_info();\n\n\treserve_shared_info();\n\txen_hvm_init_shared_info();\n\n\t\n\txen_vcpu_info_reset(0);\n\n\txen_panic_handler_init();\n\n\tif (!no_vector_callback && xen_feature(XENFEAT_hvm_callback_vector))\n\t\txen_have_vector_callback = 1;\n\n\txen_hvm_smp_init();\n\tWARN_ON(xen_cpuhp_setup(xen_cpu_up_prepare_hvm, xen_cpu_dead_hvm));\n\txen_unplug_emulated_devices();\n\tx86_init.irqs.intr_init = xen_init_IRQ;\n\txen_hvm_init_time_ops();\n\txen_hvm_init_mmu_ops();\n\n#ifdef CONFIG_KEXEC_CORE\n\tmachine_ops.shutdown = xen_hvm_shutdown;\n\tmachine_ops.crash_shutdown = xen_hvm_crash_shutdown;\n#endif\n}","23057":"SYSCALL_DEFINE5(fchownat, int, dfd, const char __user *, filename, uid_t, user,\n\t\tgid_t, group, int, flag)\n{\n\tstruct path path;\n\tint error = -EINVAL;\n\tint lookup_flags;\n\n\tif ((flag & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\n\t\tgoto out;\n\n\tlookup_flags = (flag & AT_SYMLINK_NOFOLLOW) ? 0 : LOOKUP_FOLLOW;\n\tif (flag & AT_EMPTY_PATH)\n\t\tlookup_flags |= LOOKUP_EMPTY;\n\terror = user_path_at(dfd, filename, lookup_flags, &path);\n\tif (error)\n\t\tgoto out;\n\terror = mnt_want_write(path.mnt);\n\tif (error)\n\t\tgoto out_release;\n\terror = chown_common(&path, user, group);\n\tmnt_drop_write(path.mnt);\nout_release:\n\tpath_put(&path);\nout:\n\treturn error;\n}","22759":"static void test_bug7990()\n{\n  MYSQL_STMT *stmt;\n  int rc;\n  myheader(\"STR\");\n\n  stmt= mysql_stmt_init(mysql);\n  rc= mysql_stmt_prepare(stmt, \"STR\", 3);\n  \n  DIE_UNLESS(rc && mysql_stmt_errno(stmt) && mysql_errno(mysql));\n  mysql_stmt_close(stmt);\n  DIE_UNLESS(!mysql_errno(mysql));\n}","22978":"const char* ExpressionConcat::getOpName() const {\n    return \"STR\";\n}","23592":"rb_event_length(struct ring_buffer_event *event)\n{\n\tswitch (event->type_len) {\n\tcase RINGBUF_TYPE_PADDING:\n\t\tif (rb_null_event(event))\n\t\t\t\n\t\t\treturn -1;\n\t\treturn  event->array[0] + RB_EVNT_HDR_SIZE;\n\n\tcase RINGBUF_TYPE_TIME_EXTEND:\n\t\treturn RB_LEN_TIME_EXTEND;\n\n\tcase RINGBUF_TYPE_TIME_STAMP:\n\t\treturn RB_LEN_TIME_STAMP;\n\n\tcase RINGBUF_TYPE_DATA:\n\t\treturn rb_event_data_length(event);\n\tdefault:\n\t\tBUG();\n\t}\n\t\n\treturn 0;\n}","23123":"int igmp6_event_query(struct sk_buff *skb)\n{\n\tstruct inet6_dev *idev = __in6_dev_get(skb->dev);\n\n\tif (!idev)\n\t\treturn -EINVAL;\n\n\tif (idev->dead) {\n\t\tkfree_skb(skb);\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_bh(&idev->mc_query_lock);\n\tif (skb_queue_len(&idev->mc_query_queue) < MLD_MAX_SKBS) {\n\t\t__skb_queue_tail(&idev->mc_query_queue, skb);\n\t\tif (!mod_delayed_work(mld_wq, &idev->mc_query_work, 0))\n\t\t\tin6_dev_hold(idev);\n\t}\n\tspin_unlock_bh(&idev->mc_query_lock);\n\n\treturn 0;\n}","23100":"static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret = 0;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkfree(buf);\n\treturn ret;\n}","22618":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  output->type = input->type;\n  return context->ResizeTensor(context, output,\n                               TfLiteIntArrayCopy(input->dims));\n}","23291":"static int isShadowTableName(sqlite3 *db, char *zName){\n  char *zTail;                  \n  Table *pTab;                  \n  Module *pMod;                 \n\n  zTail = strrchr(zName, '_');\n  if( zTail==0 ) return 0;\n  *zTail = 0;\n  pTab = sqlite3FindTable(db, zName, 0);\n  *zTail = '_';\n  if( pTab==0 ) return 0;\n  if( !IsVirtual(pTab) ) return 0;\n  pMod = (Module*)sqlite3HashFind(&db->aModule, pTab->azModuleArg[0]);\n  if( pMod==0 ) return 0;\n  if( pMod->pModule->iVersion<3 ) return 0;\n  if( pMod->pModule->xShadowName==0 ) return 0;\n  return pMod->pModule->xShadowName(zTail+1);\n}","23024":"static int dgram_ioctl(struct sock *sk, int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase SIOCOUTQ:\n\t{\n\t\tint amount = sk_wmem_alloc_get(sk);\n\n\t\treturn put_user(amount, (int __user *)arg);\n\t}\n\n\tcase SIOCINQ:\n\t{\n\t\tstruct sk_buff *skb;\n\t\tunsigned long amount;\n\n\t\tamount = 0;\n\t\tspin_lock_bh(&sk->sk_receive_queue.lock);\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb != NULL) {\n\t\t\t\n\t\t\t\n\t\t\tamount = skb->len - (3+8+8);\n\t\t}\n\t\tspin_unlock_bh(&sk->sk_receive_queue.lock);\n\t\treturn put_user(amount, (int __user *)arg);\n\t}\n\n\t}\n\treturn -ENOIOCTLCMD;\n}","23029":"static int check_trust(X509_STORE_CTX *ctx)\n{\n#ifdef OPENSSL_NO_CHAIN_VERIFY\n\treturn 1;\n#else\n\tint i, ok;\n\tX509 *x;\n\tint (*cb)(int xok,X509_STORE_CTX *xctx);\n\tcb=ctx->verify_cb;\n\n\ti = sk_X509_num(ctx->chain) - 1;\n\tx = sk_X509_value(ctx->chain, i);\n\tok = X509_check_trust(x, ctx->param->trust, 0);\n\tif (ok == X509_TRUST_TRUSTED)\n\t\treturn 1;\n\tctx->error_depth = i;\n\tctx->current_cert = x;\n\tif (ok == X509_TRUST_REJECTED)\n\t\tctx->error = X509_V_ERR_CERT_REJECTED;\n\telse\n\t\tctx->error = X509_V_ERR_CERT_UNTRUSTED;\n\tok = cb(0, ctx);\n\treturn ok;\n#endif\n}","23114":"GF_Err gf_fs_get_last_process_error(GF_FilterSession *fs)\n{\n\tGF_Err e;\n\tif (!fs) return GF_BAD_PARAM;\n\te = fs->last_process_error;\n\tfs->last_process_error = GF_OK;\n\treturn e;\n}","22998":"GF_Err schm_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_SchemeTypeBox *ptr = (GF_SchemeTypeBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->scheme_type = gf_bs_read_u32(bs);\n\tptr->scheme_version = gf_bs_read_u32(bs);\n\n\tif (ptr->size && (ptr->flags & 0x000001)) {\n\t\tu32 len = (u32) (ptr->size);\n\t\tptr->URI = (char*)gf_malloc(sizeof(char)*len);\n\t\tif (!ptr->URI) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->URI, len);\n\t}\n\treturn GF_OK;\n}","22738":"int sta_info_move_state(struct sta_info *sta,\n\t\t\tenum ieee80211_sta_state new_state)\n{\n\tmight_sleep();\n\n\tif (sta->sta_state == new_state)\n\t\treturn 0;\n\n\t\n\n\tswitch (new_state) {\n\tcase IEEE80211_STA_NONE:\n\t\tif (sta->sta_state != IEEE80211_STA_AUTH)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IEEE80211_STA_AUTH:\n\t\tif (sta->sta_state != IEEE80211_STA_NONE &&\n\t\t    sta->sta_state != IEEE80211_STA_ASSOC)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IEEE80211_STA_ASSOC:\n\t\tif (sta->sta_state != IEEE80211_STA_AUTH &&\n\t\t    sta->sta_state != IEEE80211_STA_AUTHORIZED)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IEEE80211_STA_AUTHORIZED:\n\t\tif (sta->sta_state != IEEE80211_STA_ASSOC)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"STR\", new_state);\n\t\treturn -EINVAL;\n\t}\n\n\tsta_dbg(sta->sdata, \"STR\",\n\t\tsta->sta.addr, new_state);\n\n\t\n\tif (test_sta_flag(sta, WLAN_STA_INSERTED)) {\n\t\tint err = drv_sta_state(sta->local, sta->sdata, sta,\n\t\t\t\t\tsta->sta_state, new_state);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t\n\n\tswitch (new_state) {\n\tcase IEEE80211_STA_NONE:\n\t\tif (sta->sta_state == IEEE80211_STA_AUTH)\n\t\t\tclear_bit(WLAN_STA_AUTH, &sta->_flags);\n\t\tbreak;\n\tcase IEEE80211_STA_AUTH:\n\t\tif (sta->sta_state == IEEE80211_STA_NONE) {\n\t\t\tset_bit(WLAN_STA_AUTH, &sta->_flags);\n\t\t} else if (sta->sta_state == IEEE80211_STA_ASSOC) {\n\t\t\tclear_bit(WLAN_STA_ASSOC, &sta->_flags);\n\t\t\tieee80211_recalc_min_chandef(sta->sdata);\n\t\t\tif (!sta->sta.support_p2p_ps)\n\t\t\t\tieee80211_recalc_p2p_go_ps_allowed(sta->sdata);\n\t\t}\n\t\tbreak;\n\tcase IEEE80211_STA_ASSOC:\n\t\tif (sta->sta_state == IEEE80211_STA_AUTH) {\n\t\t\tset_bit(WLAN_STA_ASSOC, &sta->_flags);\n\t\t\tieee80211_recalc_min_chandef(sta->sdata);\n\t\t\tif (!sta->sta.support_p2p_ps)\n\t\t\t\tieee80211_recalc_p2p_go_ps_allowed(sta->sdata);\n\t\t} else if (sta->sta_state == IEEE80211_STA_AUTHORIZED) {\n\t\t\tieee80211_vif_dec_num_mcast(sta->sdata);\n\t\t\tclear_bit(WLAN_STA_AUTHORIZED, &sta->_flags);\n\t\t\tieee80211_clear_fast_xmit(sta);\n\t\t\tieee80211_clear_fast_rx(sta);\n\t\t}\n\t\tbreak;\n\tcase IEEE80211_STA_AUTHORIZED:\n\t\tif (sta->sta_state == IEEE80211_STA_ASSOC) {\n\t\t\tieee80211_vif_inc_num_mcast(sta->sdata);\n\t\t\tset_bit(WLAN_STA_AUTHORIZED, &sta->_flags);\n\t\t\tieee80211_check_fast_xmit(sta);\n\t\t\tieee80211_check_fast_rx(sta);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsta->sta_state = new_state;\n\n\treturn 0;\n}","23330":"static void FNAME_DECL(uncompress_row_seg)(const PIXEL * const prev_row,\n                                           PIXEL * const cur_row,\n                                           int i,\n                                           const int end,\n                                           const unsigned int bpc_mask)\n{\n    DECLARE_STATE_VARIABLES;\n    DECLARE_CHANNEL_VARIABLES;\n    const unsigned int waitmask = bppmask[state->wmidx];\n    int stopidx;\n    int run_index = 0;\n    int run_end;\n\n    spice_assert(end - i > 0);\n\n    if (i == 0) {\n        unsigned int codewordlen;\n\n        UNCOMPRESS_PIX_START(&cur_row[i]);\n        APPLY_ALL_COMP(UNCOMPRESS_ONE_0);\n\n        if (state->waitcnt) {\n            --state->waitcnt;\n        } else {\n            state->waitcnt = (tabrand(&state->tabrand_seed) & waitmask);\n            UPDATE_MODEL(0);\n        }\n        stopidx = ++i + state->waitcnt;\n    } else {\n        stopidx = i + state->waitcnt;\n    }\n    for (;;) {\n        while (stopidx < end) {\n            for (; i <= stopidx; i++) {\n                unsigned int codewordlen;\n                RLE_PRED_IMP;\n                UNCOMPRESS_PIX_START(&cur_row[i]);\n                APPLY_ALL_COMP(UNCOMPRESS_ONE);\n            }\n\n            UPDATE_MODEL(stopidx);\n\n            stopidx = i + (tabrand(&state->tabrand_seed) & waitmask);\n        }\n\n        for (; i < end; i++) {\n            unsigned int codewordlen;\n            RLE_PRED_IMP;\n            UNCOMPRESS_PIX_START(&cur_row[i]);\n            APPLY_ALL_COMP(UNCOMPRESS_ONE);\n        }\n\n        state->waitcnt = stopidx - end;\n\n        return;\n\ndo_run:\n        state->waitcnt = stopidx - i;\n        run_index = i;\n        run_end = i + decode_state_run(encoder, state);\n\n        for (; i < run_end; i++) {\n            UNCOMPRESS_PIX_START(&cur_row[i]);\n            COPY_PIXEL(&cur_row[i], &cur_row[i - 1]);\n        }\n\n        if (i == end) {\n            return;\n        }\n\n        stopidx = i + state->waitcnt;\n    }\n}","22893":"bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\n\t*sockaddr_url = url;\n\turl_begin = strstr(url, \"STR\");\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\n\t\n\tipv6_begin = strstr(url_begin, \"STR\");\n\tipv6_end = strstr(url_begin, \"STR\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \"STR\");\n\telse\n\t\turl_end = strstr(url_begin, \"STR\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\n\tif (url_len < 1)\n\t\treturn false;\n\n\tsprintf(url_address, \"STR\", url_len, url_begin);\n\n\tif (port_len) {\n\t\tchar *slash;\n\n\t\tsnprintf(port, 6, \"STR\", port_len, port_start);\n\t\tslash = strchr(port, '\/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"STR\");\n\n\t*sockaddr_port = strdup(port);\n\t*sockaddr_url = strdup(url_address);\n\n\treturn true;\n}","22705":"struct se_portal_group *tcm_loop_make_naa_tpg(\n\tstruct se_wwn *wwn,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct tcm_loop_hba *tl_hba = container_of(wwn,\n\t\t\tstruct tcm_loop_hba, tl_hba_wwn);\n\tstruct tcm_loop_tpg *tl_tpg;\n\tchar *tpgt_str, *end_ptr;\n\tint ret;\n\tunsigned short int tpgt;\n\n\ttpgt_str = strstr(name, \"STR\");\n\tif (!tpgt_str) {\n\t\tprintk(KERN_ERR \"STR\"\n\t\t\t\t\"STR\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttpgt_str += 5; \n\ttpgt = (unsigned short int) simple_strtoul(tpgt_str, &end_ptr, 0);\n\n\tif (tpgt > TL_TPGS_PER_HBA) {\n\t\tprintk(KERN_ERR \"STR\"\n\t\t\t\t\"STR\", tpgt, TL_TPGS_PER_HBA);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttl_tpg = &tl_hba->tl_hba_tpgs[tpgt];\n\ttl_tpg->tl_hba = tl_hba;\n\ttl_tpg->tl_tpgt = tpgt;\n\t\n\tret = core_tpg_register(&tcm_loop_fabric_configfs->tf_ops,\n\t\t\twwn, &tl_tpg->tl_se_tpg, tl_tpg,\n\t\t\tTRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tprintk(KERN_INFO \"STR\"\n\t\t\"STR\", tcm_loop_dump_proto_id(tl_hba),\n\t\tconfig_item_name(&wwn->wwn_group.cg_item), tpgt);\n\n\treturn &tl_tpg->tl_se_tpg;\n}","23745":"    inline const char* option(const char *const name, const int argc, const char *const *const argv,\n                              const char *const _default, const char *const usage=0) {\n      return option(name,argc,argv,_default,usage,false);\n    }","23600":"INLINE void gdi_RgnToRect(HGDI_RGN rgn, HGDI_RECT rect)\n{\n\trect->left = rgn->x;\n\trect->top = rgn->y;\n\trect->right = rgn->x + rgn->w - 1;\n\trect->bottom = rgn->y + rgn->h - 1;\n}","22940":"GF_Err mvex_Read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, mvex_AddBox);\n}","23503":"hb_set_clear (hb_set_t *set)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->clear ();\n}","22997":"  bool empty() const override { return false; }","23746":"static int ntfs_attr_fill_zero(ntfs_attr *na, s64 pos, s64 count)\n{\n\tchar *buf;\n\ts64 written, size, end = pos + count;\n\ts64 ofsi;\n\tconst runlist_element *rli;\n\tntfs_volume *vol;\n\tint ret = -1;\n\n\tntfs_log_trace(\"STR\", (long long)pos, \n\t\t       (long long)count);\n\t\n\tif (!na || pos < 0 || count < 0) {\n\t\terrno = EINVAL;\n\t\tgoto err_out;\n\t}\n\t\n\tbuf = ntfs_calloc(NTFS_BUF_SIZE);\n\tif (!buf)\n\t\tgoto err_out;\n\t\n\trli = na->rl;\n\tofsi = 0;\n\tvol = na->ni->vol;\n\twhile (pos < end) {\n\t\twhile (rli->length && (ofsi + (rli->length <<\n\t                        vol->cluster_size_bits) <= pos)) {\n\t                ofsi += (rli->length << vol->cluster_size_bits);\n\t\t\trli++;\n\t\t}\n\t\tsize = min(end - pos, NTFS_BUF_SIZE);\n\t\t\t\n\t\tif ((rli->lcn == (LCN)LCN_HOLE)\n\t\t    && (ofsi <= pos)\n\t\t    && (ofsi + (rli->length << vol->cluster_size_bits)\n\t\t\t\t>= (pos + size))) {\n\t\t\tsize = min(end - pos, ofsi - pos\n\t\t\t\t+ (rli->length << vol->cluster_size_bits));\n\t\t\tpos += size;\n\t\t} else {\n\t\t\twritten = ntfs_rl_pwrite(vol, rli, ofsi, pos,\n\t\t\t\t\t\t\tsize, buf);\n\t\t\tif (written <= 0) {\n\t\t\t\tntfs_log_perror(\"STR\");\n\t\t\t\tgoto err_free;\n\t\t\t}\n\t\t\tpos += written;\n\t\t}\n\t}\n\t\n\tret = 0;\nerr_free:\t\n\tfree(buf);\nerr_out:\n\treturn ret;\t\n}","23014":"_nc_find_user_entry(const char *string)\n{\n    const HashData *data = _nc_get_hash_user();\n    int hashvalue;\n    struct user_table_entry const *ptr = 0;\n    struct user_table_entry const *real_table;\n\n    hashvalue = data->hash_of(string);\n\n    if (data->table_data[hashvalue] >= 0) {\n\n\treal_table = _nc_get_userdefs_table();\n\tptr = real_table + data->table_data[hashvalue];\n\twhile (!data->compare_names(ptr->ute_name, string)) {\n\t    if (ptr->ute_link < 0) {\n\t\tptr = 0;\n\t\tbreak;\n\t    }\n\t    ptr = real_table + (ptr->ute_link\n\t\t\t\t+ data->table_data[data->table_size]);\n\t}\n    }\n\n    return (ptr);\n}","22717":"static inline void sem_getref_and_unlock(struct sem_array *sma)\n{\n\tipc_rcu_getref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n}","23720":"int zmq::curve_client_t::produce_hello (msg_t *msg_)\n{\n    uint8_t hello_nonce [crypto_box_NONCEBYTES];\n    uint8_t hello_plaintext [crypto_box_ZEROBYTES + 64];\n    uint8_t hello_box [crypto_box_BOXZEROBYTES + 80];\n\n    \n    memcpy (hello_nonce, \"STR\", 16);\n    memcpy (hello_nonce + 16, &cn_nonce, 8);\n\n    \n    memset (hello_plaintext, 0, sizeof hello_plaintext);\n\n    int rc = crypto_box (hello_box, hello_plaintext,\n                         sizeof hello_plaintext,\n                         hello_nonce, server_key, cn_secret);\n    zmq_assert (rc == 0);\n\n    rc = msg_->init_size (200);\n    errno_assert (rc == 0);\n    uint8_t *hello = static_cast <uint8_t *> (msg_->data ());\n\n    memcpy (hello, \"STR\", 6);\n    \n    memcpy (hello + 6, \"STR\", 2);\n    \n    memset (hello + 8, 0, 72);\n    \n    memcpy (hello + 80, cn_public, crypto_box_PUBLICKEYBYTES);\n    \n    memcpy (hello + 112, hello_nonce + 16, 8);\n    \n    memcpy (hello + 120, hello_box + crypto_box_BOXZEROBYTES, 80);\n\n    cn_nonce++;\n\n    return 0;\n}","23766":"static void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)\n{\n\tstruct se_device *remote_dev;\n\n\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)\n\t\tremote_dev = xop->dst_dev;\n\telse\n\t\tremote_dev = xop->src_dev;\n\n\tpr_debug(\"STR\"\n\t\t  \"STR\",\n\t\t  remote_dev, &remote_dev->dev_group.cg_item);\n\n\ttarget_undepend_item(&remote_dev->dev_group.cg_item);\n}","23646":"bytes_strip(PyBytesObject *self, PyObject *args)\n{\n    if (PyTuple_GET_SIZE(args) == 0)\n        return do_strip(self, BOTHSTRIP); \n    else\n        return do_argstrip(self, BOTHSTRIP, args);\n}","23730":"rfbTightExtensionClientClose(rfbClientPtr cl, void* data) {\n\n\tif(data != NULL)\n\t\tfree(data);\n\n}","22484":"my_recv(ftpbuf_t *ftp, php_socket_t s, void *buf, size_t len)\n{\n\tint\t\tn, nr_bytes;\n\n\tn = php_pollfd_for_ms(s, PHP_POLLREADABLE, ftp->timeout_sec * 1000);\n\tif (n < 1) {\n#if !defined(PHP_WIN32) && !(defined(NETWARE) && defined(USE_WINSOCK))\n\t\tif (n == 0) {\n\t\t\terrno = ETIMEDOUT;\n\t\t}\n#endif\n\t\treturn -1;\n\t}\n\n#if HAVE_OPENSSL_EXT\n\tif (ftp->use_ssl && ftp->fd == s && ftp->ssl_active) {\n\t\tnr_bytes = SSL_read(ftp->ssl_handle, buf, len);\n\t} else if (ftp->use_ssl && ftp->fd != s && ftp->use_ssl_for_data && ftp->data->ssl_active) {\t\n\t\tnr_bytes = SSL_read(ftp->data->ssl_handle, buf, len);\n\t} else {\n#endif\n\t\tnr_bytes = recv(s, buf, len, 0);\n#if HAVE_OPENSSL_EXT\n\t}\n#endif\t\n\treturn (nr_bytes);\n}","22673":"midi_synth_load_patch(int dev, int format, const char __user *addr,\n\t\t      int offs, int count, int pmgr_flag)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\n\tstruct sysex_info sysex;\n\tint             i;\n\tunsigned long   left, src_offs, eox_seen = 0;\n\tint             first_byte = 1;\n\tint             hdr_size = (unsigned long) &sysex.data[0] - (unsigned long) &sysex;\n\n\tleave_sysex(dev);\n\n\tif (!prefix_cmd(orig_dev, 0xf0))\n\t\treturn 0;\n\n\tif (format != SYSEX_PATCH)\n\t{\n\n\t\t  return -EINVAL;\n\t}\n\tif (count < hdr_size)\n\t{\n\n\t\treturn -EINVAL;\n\t}\n\tcount -= hdr_size;\n\n\t\n\n\tif(copy_from_user(&((char *) &sysex)[offs], &(addr)[offs], hdr_size - offs))\n\t\treturn -EFAULT;\n \n \tif (count < sysex.len)\n\t{\n\n\t\tsysex.len = count;\n\t}\n  \tleft = sysex.len;\n  \tsrc_offs = 0;\n\n\tfor (i = 0; i < left && !signal_pending(current); i++)\n\t{\n\t\tunsigned char   data;\n\n\t\tif (get_user(data,\n\t\t    (unsigned char __user *)(addr + hdr_size + i)))\n\t\t\treturn -EFAULT;\n\n\t\teox_seen = (i > 0 && data & 0x80);\t\n\n\t\tif (eox_seen && data != 0xf7)\n\t\t\tdata = 0xf7;\n\n\t\tif (i == 0)\n\t\t{\n\t\t\tif (data != 0xf0)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"STR\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\twhile (!midi_devs[orig_dev]->outputc(orig_dev, (unsigned char) (data & 0xff)) &&\n\t\t\t!signal_pending(current))\n\t\t\tschedule();\n\n\t\tif (!first_byte && data & 0x80)\n\t\t\treturn 0;\n\t\tfirst_byte = 0;\n\t}\n\n\tif (!eox_seen)\n\t\tmidi_outc(orig_dev, 0xf7);\n\treturn 0;\n}","22987":"TPM2B_DIGEST_Marshal(TPM2B_DIGEST *source, BYTE **buffer, INT32 *size)\n{\nUINT16 written = 0;\nwritten += TPM2B_Marshal(&source->b, buffer, size);\nreturn written;\n}","23270":"R_API RBinJavaCPTypeObj *r_bin_java_clone_cp_item(RBinJavaCPTypeObj *obj) {\n\tRBinJavaCPTypeObj *clone_obj = NULL;\n\tif (obj == NULL) {\n\t\treturn clone_obj;\n\t}\n\tclone_obj = R_NEW0 (RBinJavaCPTypeObj);\n\tif (clone_obj) {\n\t\tmemcpy (clone_obj, obj, sizeof (RBinJavaCPTypeObj));\n\t\tclone_obj->metas = (RBinJavaMetaInfo *) R_NEW0 (RBinJavaMetaInfo);\n\t\tclone_obj->metas->type_info = (void *) &R_BIN_JAVA_CP_METAS[clone_obj->tag];\n\t\tclone_obj->name = strdup (obj->name? obj->name: \"STR\");\n\t\tif (obj->tag == R_BIN_JAVA_CP_UTF8) {\n\t\t\tclone_obj->info.cp_utf8.bytes = (ut8 *) malloc (obj->info.cp_utf8.length + 1);\n\t\t\tif (clone_obj->info.cp_utf8.bytes) {\n\t\t\t\tmemcpy (clone_obj->info.cp_utf8.bytes, obj->info.cp_utf8.bytes, clone_obj->info.cp_utf8.length);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\treturn clone_obj;\n}","23671":"blob_get_first_keyid (KEYBOXBLOB blob, u32 *kid)\n{\n  const unsigned char *buffer;\n  size_t length, nkeys, keyinfolen;\n\n  buffer = _keybox_get_blob_image (blob, &length);\n  if (length < 48)\n    return 0; \n\n  nkeys = get16 (buffer + 16);\n  keyinfolen = get16 (buffer + 18);\n  if (!nkeys || keyinfolen < 28)\n    return 0; \n\n  kid[0] = get32 (buffer + 32);\n  kid[1] = get32 (buffer + 36);\n\n  return 1;\n}","22709":"_keybox_dump_find_dups (const char *filename, int print_them, FILE *outfp)\n{\n  FILE *fp;\n  KEYBOXBLOB blob;\n  int rc;\n  unsigned long recno = 0;\n  unsigned char zerodigest[20];\n  struct dupitem_s *dupitems;\n  size_t dupitems_size, dupitems_count, lastn, n;\n  char fprbuf[3*20+1];\n\n  (void)print_them;\n\n  memset (zerodigest, 0, sizeof zerodigest);\n\n  if (!(fp = open_file (&filename, outfp)))\n    return gpg_error_from_syserror ();\n\n  dupitems_size = 1000;\n  dupitems = malloc (dupitems_size * sizeof *dupitems);\n  if (!dupitems)\n    {\n      gpg_error_t tmperr = gpg_error_from_syserror ();\n      fprintf (outfp, \"STR\",\n               filename, strerror(errno));\n      return tmperr;\n    }\n  dupitems_count = 0;\n\n  while ( !(rc = _keybox_read_blob (&blob, fp)) )\n    {\n      unsigned char digest[20];\n\n      if (hash_blob_rawdata (blob, digest))\n        fprintf (outfp, \"STR\", recno, filename);\n      else if (memcmp (digest, zerodigest, 20))\n        {\n          if (dupitems_count >= dupitems_size)\n            {\n              struct dupitem_s *tmp;\n\n              dupitems_size += 1000;\n              tmp = realloc (dupitems, dupitems_size * sizeof *dupitems);\n              if (!tmp)\n                {\n                  gpg_error_t tmperr = gpg_error_from_syserror ();\n                  fprintf (outfp, \"STR\",\n                           filename, strerror(errno));\n                  free (dupitems);\n                  return tmperr;\n                }\n              dupitems = tmp;\n            }\n          dupitems[dupitems_count].recno = recno;\n          memcpy (dupitems[dupitems_count].digest, digest, 20);\n          dupitems_count++;\n        }\n      _keybox_release_blob (blob);\n      recno++;\n    }\n  if (rc == -1)\n    rc = 0;\n  if (rc)\n    fprintf (outfp, \"STR\", filename, gpg_strerror (rc));\n  if (fp != stdin)\n    fclose (fp);\n\n  qsort (dupitems, dupitems_count, sizeof *dupitems, cmp_dupitems);\n\n  for (lastn=0, n=1; n < dupitems_count; lastn=n, n++)\n    {\n      if (!memcmp (dupitems[lastn].digest, dupitems[n].digest, 20))\n        {\n          bin2hexcolon (dupitems[lastn].digest, 20, fprbuf);\n          fprintf (outfp, \"STR\", fprbuf, dupitems[lastn].recno);\n          do\n            fprintf (outfp, \"STR\", dupitems[n].recno);\n          while (++n < dupitems_count\n                 && !memcmp (dupitems[lastn].digest, dupitems[n].digest, 20));\n          putc ('\\n', outfp);\n          n--;\n        }\n    }\n\n  free (dupitems);\n\n  return rc;\n}","23740":"ecma_snapshot_get_literal (const uint8_t *literal_base_p, \n                           ecma_value_t literal_value) \n{\n  JERRY_ASSERT ((literal_value & ECMA_VALUE_TYPE_MASK) == ECMA_TYPE_SNAPSHOT_OFFSET);\n\n  const uint8_t *literal_p = literal_base_p + (literal_value >> JERRY_SNAPSHOT_LITERAL_SHIFT);\n\n  if (literal_value & JERRY_SNAPSHOT_LITERAL_IS_NUMBER)\n  {\n    ecma_number_t num;\n    memcpy (&num, literal_p, sizeof (ecma_number_t));\n    return ecma_find_or_create_literal_number (num);\n  }\n\n#if JERRY_BUILTIN_BIGINT\n  if (literal_value & JERRY_SNAPSHOT_LITERAL_IS_BIGINT)\n  {\n    uint32_t bigint_sign_and_size = *(uint32_t *) literal_p;\n    uint32_t size = bigint_sign_and_size & ~(uint32_t) (sizeof (ecma_bigint_digit_t) - 1);\n\n    ecma_extended_primitive_t *bigint_p = ecma_bigint_create (size);\n\n    if (bigint_p == NULL)\n    {\n      jerry_fatal (ERR_OUT_OF_MEMORY);\n    }\n\n    \n    JERRY_ASSERT (bigint_p->u.bigint_sign_and_size == (bigint_sign_and_size & ~(uint32_t) ECMA_BIGINT_SIGN));\n\n    bigint_p->u.bigint_sign_and_size = bigint_sign_and_size;\n    memcpy (ECMA_BIGINT_GET_DIGITS (bigint_p, 0), literal_p + sizeof (uint32_t), size);\n    return ecma_find_or_create_literal_bigint (ecma_make_extended_primitive_value (bigint_p, ECMA_TYPE_BIGINT));\n  }\n#endif \n\n  uint16_t length = *(const uint16_t *) literal_p;\n\n  return ecma_find_or_create_literal_string (literal_p + sizeof (uint16_t), length);\n} ","23638":"static int encode_remove(struct xdr_stream *xdr, const struct qstr *name)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(8 + name->len);\n\tWRITE32(OP_REMOVE);\n\tWRITE32(name->len);\n\tWRITEMEM(name->name, name->len);\n\n\treturn 0;\n}","22804":"int unit_name_change_suffix(const char *n, const char *suffix, char **ret) {\n        _cleanup_free_ char *s = NULL;\n        size_t a, b;\n        char *e;\n\n        assert(n);\n        assert(suffix);\n        assert(ret);\n\n        if (!unit_name_is_valid(n, UNIT_NAME_ANY))\n                return -EINVAL;\n\n        if (!unit_suffix_is_valid(suffix))\n                return -EINVAL;\n\n        assert_se(e = strrchr(n, '.'));\n\n        a = e - n;\n        b = strlen(suffix);\n\n        s = new(char, a + b + 1);\n        if (!s)\n                return -ENOMEM;\n\n        strcpy(mempcpy(s, n, a), suffix);\n\n        \n        if (!unit_name_is_valid(s, UNIT_NAME_ANY))\n                return -EINVAL;\n\n        *ret = TAKE_PTR(s);\n        return 0;\n}","22770":"__zzip_dir_parse(ZZIP_DIR * dir)\n{\n    zzip_error_t rv;\n    zzip_off_t filesize;\n    struct _disk_trailer trailer;\n    \n\n    HINT2(\"STR\", (int) dir->fd);\n    if ((filesize = dir->io->fd.filesize(dir->fd)) < 0)\n        { rv = ZZIP_DIR_STAT; goto error; }\n\n    HINT2(\"STR\", (long) filesize);\n    if ((rv = __zzip_fetch_disk_trailer(dir->fd, filesize, &trailer,\n                                        dir->io)) != 0)\n        { goto error; }\n\n    HINT5(\"STR\",\n          (long) _disk_trailer_localentries(&trailer),\n          (long) _disk_trailer_finalentries(&trailer),\n          (long) _disk_trailer_rootsize(&trailer),\n          (long) _disk_trailer_rootseek(&trailer));\n\n    if ((rv = __zzip_parse_root_directory(dir->fd, &trailer, &dir->hdr0,\n                                          dir->io)) != 0)\n        { goto error; }\n  error:\n    return rv;\n}","23438":"TfLiteStatus LessEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  bool requires_broadcast = !HaveSameShapes(input1, input2);\n  switch (input1->type) {\n    case kTfLiteFloat32:\n      Comparison<float, reference_ops::LessFn>(input1, input2, output,\n                                               requires_broadcast);\n      break;\n    case kTfLiteInt32:\n      Comparison<int32_t, reference_ops::LessFn>(input1, input2, output,\n                                                 requires_broadcast);\n      break;\n    case kTfLiteInt64:\n      Comparison<int64_t, reference_ops::LessFn>(input1, input2, output,\n                                                 requires_broadcast);\n      break;\n    case kTfLiteUInt8:\n      ComparisonQuantized<uint8_t, reference_ops::LessFn>(\n          input1, input2, output, requires_broadcast);\n      break;\n    case kTfLiteInt8:\n      ComparisonQuantized<int8_t, reference_ops::LessFn>(input1, input2, output,\n                                                         requires_broadcast);\n      break;\n    default:\n      context->ReportError(context,\n                           \"STR\",\n                           input1->type);\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}","23781":"int processInlineBuffer(redisClient *c) {\n    char *newline = strstr(c->querybuf,\"STR\");\n    int argc, j;\n    sds *argv;\n    size_t querylen;\n\n    \n    if (newline == NULL)\n        return REDIS_ERR;\n\n    \n    querylen = newline-(c->querybuf);\n    argv = sdssplitlen(c->querybuf,querylen,\"STR\",1,&argc);\n\n    \n    c->querybuf = sdsrange(c->querybuf,querylen+2,-1);\n\n    \n    if (c->argv) zfree(c->argv);\n    c->argv = zmalloc(sizeof(robj*)*argc);\n\n    \n    for (c->argc = 0, j = 0; j < argc; j++) {\n        if (sdslen(argv[j])) {\n            c->argv[c->argc] = createObject(REDIS_STRING,argv[j]);\n            c->argc++;\n        } else {\n            sdsfree(argv[j]);\n        }\n    }\n    zfree(argv);\n    return REDIS_OK;\n}","23492":"const char *mnt_update_get_filename(struct libmnt_update *upd)\n{\n\treturn upd && !upd->userspace_only ? upd->filename : NULL;\n}","23344":"static void scalar32_min_max_xor(struct bpf_reg_state *dst_reg,\n\t\t\t\t struct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_subreg_is_const(src_reg->var_off);\n\tbool dst_known = tnum_subreg_is_const(dst_reg->var_off);\n\tstruct tnum var32_off = tnum_subreg(dst_reg->var_off);\n\ts32 smin_val = src_reg->s32_min_value;\n\n\t\n\tif (src_known && dst_known)\n\t\treturn;\n\n\t\n\tdst_reg->u32_min_value = var32_off.value;\n\tdst_reg->u32_max_value = var32_off.value | var32_off.mask;\n\n\tif (dst_reg->s32_min_value >= 0 && smin_val >= 0) {\n\t\t\n\t\tdst_reg->s32_min_value = dst_reg->u32_min_value;\n\t\tdst_reg->s32_max_value = dst_reg->u32_max_value;\n\t} else {\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t}\n}","23691":"const char *configEnumGetName(configEnum *ce, int val) {\n    while(ce->name != NULL) {\n        if (ce->val == val) return ce->name;\n        ce++;\n    }\n    return NULL;\n}","23264":"static void snippet_add_content(struct snippet_context *ctx,\n\t\t\t\tstruct snippet_data *target,\n\t\t\t\tconst unsigned char *data, size_t size,\n\t\t\t\tsize_t *count_r)\n{\n\ti_assert(target != NULL);\n\tif (size >= 3 &&\n\t     ((data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF) ||\n\t      (data[0] == 0xBF && data[1] == 0xBB && data[2] == 0xEF))) {\n\t\t*count_r = 3;\n\t\treturn;\n\t}\n\tif (data[0] == '\\0') {\n\t\t\n\t\treturn;\n\t}\n\tif (i_isspace(*data)) {\n\t\t\n\t\tif (str_len(target->snippet) > 1)\n\t\t\tctx->add_whitespace = TRUE;\n\t\tif (data[0] == '\\n')\n\t\t\tctx->state = SNIPPET_STATE_NEWLINE;\n\t\treturn;\n\t}\n\tif (ctx->add_whitespace) {\n\t\tstr_append_c(target->snippet, ' ');\n\t\tctx->add_whitespace = FALSE;\n\t\tif (target->chars_left-- == 0)\n\t\t\treturn;\n\t}\n\tif (target->chars_left == 0)\n\t\treturn;\n\ttarget->chars_left--;\n\t*count_r = uni_utf8_char_bytes(data[0]);\n\ti_assert(*count_r <= size);\n\tstr_append_data(target->snippet, data, *count_r);\n}","22545":"xfs_agf_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(bp);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tif (!uuid_equal(&agf->agf_uuid, &mp->m_sb.sb_meta_uuid))\n\t\t\treturn __this_address;\n\t\tif (!xfs_log_check_lsn(mp,\n\t\t\t\tbe64_to_cpu(XFS_BUF_TO_AGF(bp)->agf_lsn)))\n\t\t\treturn __this_address;\n\t}\n\n\tif (!xfs_verify_magic(bp, agf->agf_magicnum))\n\t\treturn __this_address;\n\n\tif (!(XFS_AGF_GOOD_VERSION(be32_to_cpu(agf->agf_versionnum)) &&\n\t      be32_to_cpu(agf->agf_freeblks) <= be32_to_cpu(agf->agf_length) &&\n\t      be32_to_cpu(agf->agf_flfirst) < xfs_agfl_size(mp) &&\n\t      be32_to_cpu(agf->agf_fllast) < xfs_agfl_size(mp) &&\n\t      be32_to_cpu(agf->agf_flcount) <= xfs_agfl_size(mp)))\n\t\treturn __this_address;\n\n\tif (be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) < 1 ||\n\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) < 1 ||\n\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) > XFS_BTREE_MAXLEVELS ||\n\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) > XFS_BTREE_MAXLEVELS)\n\t\treturn __this_address;\n\n\tif (xfs_sb_version_hasrmapbt(&mp->m_sb) &&\n\t    (be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) < 1 ||\n\t     be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) > XFS_BTREE_MAXLEVELS))\n\t\treturn __this_address;\n\n\t\n\tif (bp->b_pag && be32_to_cpu(agf->agf_seqno) != bp->b_pag->pag_agno)\n\t\treturn __this_address;\n\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) &&\n\t    be32_to_cpu(agf->agf_btreeblks) > be32_to_cpu(agf->agf_length))\n\t\treturn __this_address;\n\n\tif (xfs_sb_version_hasreflink(&mp->m_sb) &&\n\t    (be32_to_cpu(agf->agf_refcount_level) < 1 ||\n\t     be32_to_cpu(agf->agf_refcount_level) > XFS_BTREE_MAXLEVELS))\n\t\treturn __this_address;\n\n\treturn NULL;\n\n}","23737":"install_root_end_handler(void (*handler) (void))\n{\n\tkeyword_t *keyword;\n\n\t\n\tkeyword = vector_slot(keywords, vector_size(keywords) - 1);\n\n\tif (!keyword->active)\n\t\treturn;\n\n\tkeyword->sub_close_handler = handler;\n}","22542":"MONGO_EXPORT bson_bool_t mongo_cmd_authenticate( mongo *conn, const char *db, const char *user, const char *pass ) {\n    bson from_db;\n    bson cmd;\n    const char *nonce;\n    int result;\n\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n    char hex_digest[33];\n\n    if( mongo_simple_int_command( conn, db, \"STR\", 1, &from_db ) == MONGO_OK ) {\n        bson_iterator it;\n        bson_find( &it, &from_db, \"STR\" );\n        nonce = bson_iterator_string( &it );\n    }\n    else {\n        return MONGO_ERROR;\n    }\n\n    mongo_pass_digest( user, pass, hex_digest );\n\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )nonce, strlen( nonce ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )hex_digest, 32 );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n\n    bson_init( &cmd );\n    bson_append_int( &cmd, \"STR\", 1 );\n    bson_append_string( &cmd, \"STR\", user );\n    bson_append_string( &cmd, \"STR\", nonce );\n    bson_append_string( &cmd, \"STR\", hex_digest );\n    bson_finish( &cmd );\n\n    bson_destroy( &from_db );\n\n    result = mongo_run_command( conn, db, &cmd, NULL );\n\n    bson_destroy( &cmd );\n\n    return result;\n}","22657":"static BOOL update_send_create_offscreen_bitmap_order(\n    rdpContext* context, const CREATE_OFFSCREEN_BITMAP_ORDER* create_offscreen_bitmap)\n{\n\twStream* s;\n\tsize_t bm, em, inf;\n\tBYTE orderType;\n\tBYTE controlFlags;\n\tint headerLength;\n\trdpUpdate* update = context->update;\n\theaderLength = 1;\n\torderType = ORDER_TYPE_CREATE_OFFSCREEN_BITMAP;\n\tcontrolFlags = ORDER_SECONDARY | (orderType << 2);\n\tinf = update_approximate_create_offscreen_bitmap_order(create_offscreen_bitmap);\n\tupdate_check_flush(context, headerLength + inf);\n\ts = update->us;\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tbm = Stream_GetPosition(s);\n\n\tif (!Stream_EnsureRemainingCapacity(s, headerLength))\n\t\treturn FALSE;\n\n\tStream_Seek(s, headerLength);\n\n\tif (!update_write_create_offscreen_bitmap_order(s, create_offscreen_bitmap))\n\t\treturn FALSE;\n\n\tem = Stream_GetPosition(s);\n\tStream_SetPosition(s, bm);\n\tStream_Write_UINT8(s, controlFlags); \n\tStream_SetPosition(s, em);\n\tupdate->numberOrders++;\n\treturn TRUE;\n}","23206":"   Returns the maximum supported key size of the algorithm *\/\nPHP_FUNCTION(mcrypt_module_get_algo_key_size)\n{\n\tMCRYPT_GET_MODE_DIR_ARGS(algorithms_dir);\n\t\n\tRETURN_LONG(mcrypt_module_get_algo_key_size(module, dir));","23468":"check_sgr(TERMTYPE2 *tp, char *zero, int num, char *cap, const char *name)\n{\n    char *test;\n\n    _nc_tparm_err = 0;\n    test = TPARM_9(set_attributes,\n\t\t   num == 1,\n\t\t   num == 2,\n\t\t   num == 3,\n\t\t   num == 4,\n\t\t   num == 5,\n\t\t   num == 6,\n\t\t   num == 7,\n\t\t   num == 8,\n\t\t   num == 9);\n    if (test != 0) {\n\tif (PRESENT(cap)) {\n\t    if (!similar_sgr(num, test, cap)) {\n\t\t_nc_warning(\"STR\",\n\t\t\t    name, num,\n\t\t\t    name, _nc_visbuf2(1, cap),\n\t\t\t    num, _nc_visbuf2(2, test));\n\t    }\n\t} else if (_nc_capcmp(test, zero)) {\n\t    _nc_warning(\"STR\", num, name);\n\t}\n    } else if (PRESENT(cap)) {\n\t_nc_warning(\"STR\", num, name);\n    }\n    if (_nc_tparm_err)\n\t_nc_warning(\"STR\", num);\n    return test;\n}","23255":"void jas_matrix_asr(jas_matrix_t *matrix, int n)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tassert(n >= 0);\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t\n\t\t\t\t*data = jas_seqent_asr(*data, n);\n\t\t\t}\n\t\t}\n\t}\n}","23477":"void glyph_cache_register_callbacks(rdpUpdate* update)\n{\n\tupdate->primary->GlyphIndex = update_gdi_glyph_index;\n\tupdate->primary->FastIndex = update_gdi_fast_index;\n\tupdate->primary->FastGlyph = update_gdi_fast_glyph;\n\tupdate->secondary->CacheGlyph = update_gdi_cache_glyph;\n\tupdate->secondary->CacheGlyphV2 = update_gdi_cache_glyph_v2;\n}","23483":"size_t snd_dma_get_reserved_buf(struct snd_dma_buffer *dmab, unsigned int id)\n{\n\tstruct snd_mem_list *mem;\n\n\tsnd_assert(dmab, return 0);\n\n\tmutex_lock(&list_mutex);\n\tlist_for_each_entry(mem, &mem_list_head, list) {\n\t\tif (mem->id == id &&\n\t\t    (mem->buffer.dev.dev == NULL || dmab->dev.dev == NULL ||\n\t\t     ! memcmp(&mem->buffer.dev, &dmab->dev, sizeof(dmab->dev)))) {\n\t\t\tstruct device *dev = dmab->dev.dev;\n\t\t\tlist_del(&mem->list);\n\t\t\t*dmab = mem->buffer;\n\t\t\tif (dmab->dev.dev == NULL)\n\t\t\t\tdmab->dev.dev = dev;\n\t\t\tkfree(mem);\n\t\t\tmutex_unlock(&list_mutex);\n\t\t\treturn dmab->bytes;\n\t\t}\n\t}\n\tmutex_unlock(&list_mutex);\n\treturn 0;\n}","22870":"static void vfio_pci_try_bus_reset(struct vfio_pci_device *vdev)\n{\n\tstruct vfio_devices devs = { .cur_index = 0 };\n\tint i = 0, ret = -EINVAL;\n\tbool needs_reset = false, slot = false;\n\tstruct vfio_pci_device *tmp;\n\n\tif (!pci_probe_reset_slot(vdev->pdev->slot))\n\t\tslot = true;\n\telse if (pci_probe_reset_bus(vdev->pdev->bus))\n\t\treturn;\n\n\tif (vfio_pci_for_each_slot_or_bus(vdev->pdev, vfio_pci_count_devs,\n\t\t\t\t\t  &i, slot) || !i)\n\t\treturn;\n\n\tdevs.max_index = i;\n\tdevs.devices = kcalloc(i, sizeof(struct vfio_device *), GFP_KERNEL);\n\tif (!devs.devices)\n\t\treturn;\n\n\tif (vfio_pci_for_each_slot_or_bus(vdev->pdev,\n\t\t\t\t\t  vfio_pci_get_devs, &devs, slot))\n\t\tgoto put_devs;\n\n\tfor (i = 0; i < devs.cur_index; i++) {\n\t\ttmp = vfio_device_data(devs.devices[i]);\n\t\tif (tmp->needs_reset)\n\t\t\tneeds_reset = true;\n\t\tif (tmp->refcnt)\n\t\t\tgoto put_devs;\n\t}\n\n\tif (needs_reset)\n\t\tret = slot ? pci_try_reset_slot(vdev->pdev->slot) :\n\t\t\t     pci_try_reset_bus(vdev->pdev->bus);\n\nput_devs:\n\tfor (i = 0; i < devs.cur_index; i++) {\n\t\ttmp = vfio_device_data(devs.devices[i]);\n\t\tif (!ret)\n\t\t\ttmp->needs_reset = false;\n\n\t\tif (!tmp->refcnt && !disable_idle_d3)\n\t\t\tpci_set_power_state(tmp->pdev, PCI_D3hot);\n\n\t\tvfio_device_put(devs.devices[i]);\n\t}\n\n\tkfree(devs.devices);\n}","23150":"int ttm_tt_populate(struct ttm_tt *ttm, struct ttm_operation_ctx *ctx)\n{\n\tint ret;\n\n\tif (ttm->state != tt_unpopulated)\n\t\treturn 0;\n\n\tif (ttm->bdev->driver->ttm_tt_populate)\n\t\tret = ttm->bdev->driver->ttm_tt_populate(ttm, ctx);\n\telse\n\t\tret = ttm_pool_populate(ttm, ctx);\n\tif (!ret)\n\t\tttm_tt_add_mapping(ttm);\n\treturn ret;\n}","22488":"cmsIOHANDLER* CMSEXPORT cmsOpenIOhandlerFromFile(cmsContext ContextID, const char* FileName, const char* AccessMode)\n{\n    cmsIOHANDLER* iohandler = NULL;\n    FILE* fm = NULL;\n\n    iohandler = (cmsIOHANDLER*) _cmsMallocZero(ContextID, sizeof(cmsIOHANDLER));\n    if (iohandler == NULL) return NULL;\n\n    switch (*AccessMode) {\n\n    case 'r':\n        fm = fopen(FileName, \"STR\");\n        if (fm == NULL) {\n            _cmsFree(ContextID, iohandler);\n             cmsSignalError(ContextID, cmsERROR_FILE, \"STR\", FileName);\n            return NULL;\n        }\n        iohandler -> ReportedSize = cmsfilelength(fm);\n        break;\n\n    case 'w':\n        fm = fopen(FileName, \"STR\");\n        if (fm == NULL) {\n            _cmsFree(ContextID, iohandler);\n             cmsSignalError(ContextID, cmsERROR_FILE, \"STR\", FileName);\n            return NULL;\n        }\n        iohandler -> ReportedSize = 0;\n        break;\n\n    default:\n        _cmsFree(ContextID, iohandler);\n         cmsSignalError(ContextID, cmsERROR_FILE, \"STR\", *AccessMode);\n        return NULL;\n    }\n\n    iohandler ->ContextID = ContextID;\n    iohandler ->stream = (void*) fm;\n    iohandler ->UsedSpace = 0;\n\n    \n    if (FileName != NULL)  {\n\n        strncpy(iohandler -> PhysicalFile, FileName, sizeof(iohandler -> PhysicalFile)-1);\n        iohandler -> PhysicalFile[sizeof(iohandler -> PhysicalFile)-1] = 0;\n    }\n\n    iohandler ->Read    = FileRead;\n    iohandler ->Seek    = FileSeek;\n    iohandler ->Close   = FileClose;\n    iohandler ->Tell    = FileTell;\n    iohandler ->Write   = FileWrite;\n\n    return iohandler;\n}","23357":"  String_Schema_Obj Parser::parse_css_variable_value(bool top_level)\n  {\n    String_Schema_Obj schema = SASS_MEMORY_NEW(String_Schema, pstate);\n    String_Schema_Obj tok;\n    if (!(tok = parse_css_variable_value_token(top_level))) {\n      return {};\n    }\n\n    schema->concat(tok);\n    while ((tok = parse_css_variable_value_token(top_level))) {\n      schema->concat(tok);\n    }\n\n    return schema.detach();\n  }","23550":"static void rbd_init_layout(struct rbd_device *rbd_dev)\n{\n\tif (rbd_dev->header.stripe_unit == 0 ||\n\t    rbd_dev->header.stripe_count == 0) {\n\t\trbd_dev->header.stripe_unit = rbd_obj_bytes(&rbd_dev->header);\n\t\trbd_dev->header.stripe_count = 1;\n\t}\n\n\trbd_dev->layout.stripe_unit = rbd_dev->header.stripe_unit;\n\trbd_dev->layout.stripe_count = rbd_dev->header.stripe_count;\n\trbd_dev->layout.object_size = rbd_obj_bytes(&rbd_dev->header);\n\trbd_dev->layout.pool_id = rbd_dev->header.data_pool_id == CEPH_NOPOOL ?\n\t\t\t  rbd_dev->spec->pool_id : rbd_dev->header.data_pool_id;\n\tRCU_INIT_POINTER(rbd_dev->layout.pool_ns, NULL);\n}","23343":"SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username)\n{\n    int i;\n    SRP_user_pwd *user;\n    unsigned char digv[SHA_DIGEST_LENGTH];\n    unsigned char digs[SHA_DIGEST_LENGTH];\n    EVP_MD_CTX *ctxt = NULL;\n\n    if (vb == NULL)\n        return NULL;\n    for (i = 0; i < sk_SRP_user_pwd_num(vb->users_pwd); i++) {\n        user = sk_SRP_user_pwd_value(vb->users_pwd, i);\n        if (strcmp(user->id, username) == 0)\n            return user;\n    }\n    if ((vb->seed_key == NULL) ||\n        (vb->default_g == NULL) || (vb->default_N == NULL))\n        return NULL;\n\n\n\n    if ((user = SRP_user_pwd_new()) == NULL)\n        return NULL;\n\n    SRP_user_pwd_set_gN(user, vb->default_g, vb->default_N);\n\n    if (!SRP_user_pwd_set_ids(user, username, NULL))\n        goto err;\n\n    if (RAND_bytes(digv, SHA_DIGEST_LENGTH) <= 0)\n        goto err;\n    ctxt = EVP_MD_CTX_new();\n    EVP_DigestInit_ex(ctxt, EVP_sha1(), NULL);\n    EVP_DigestUpdate(ctxt, vb->seed_key, strlen(vb->seed_key));\n    EVP_DigestUpdate(ctxt, username, strlen(username));\n    EVP_DigestFinal_ex(ctxt, digs, NULL);\n    EVP_MD_CTX_free(ctxt);\n    ctxt = NULL;\n    if (SRP_user_pwd_set_sv_BN(user,\n                               BN_bin2bn(digs, SHA_DIGEST_LENGTH, NULL),\n                               BN_bin2bn(digv, SHA_DIGEST_LENGTH, NULL)))\n        return user;\n\n err:\n    EVP_MD_CTX_free(ctxt);\n    SRP_user_pwd_free(user);\n    return NULL;\n}","22597":"bool Item_sum_sum::fix_length_and_dec()\n{\n  DBUG_ENTER(\"STR\");\n  maybe_null=null_value=1;\n  decimals= args[0]->decimals;\n  switch (args[0]->cast_to_int_type()) {\n  case REAL_RESULT:\n  case STRING_RESULT:\n    set_handler_by_field_type(MYSQL_TYPE_DOUBLE);\n    sum= 0.0;\n    break;\n  case INT_RESULT:\n  case TIME_RESULT:\n  case DECIMAL_RESULT:\n  {\n    \n    int precision= args[0]->decimal_precision() + DECIMAL_LONGLONG_DIGITS;\n    max_length= my_decimal_precision_to_length_no_truncation(precision,\n                                                             decimals,\n                                                             unsigned_flag);\n    curr_dec_buff= 0;\n    set_handler_by_field_type(MYSQL_TYPE_NEWDECIMAL);\n    my_decimal_set_zero(dec_buffs);\n    break;\n  }\n  case ROW_RESULT:\n    DBUG_ASSERT(0);\n  }\n  DBUG_PRINT(\"STR\",\n                      (result_type() == REAL_RESULT ? \"STR\" :\n                       result_type() == DECIMAL_RESULT ? \"STR\" :\n                       result_type() == INT_RESULT ? \"STR\" :\n                       \"STR\"),\n                      max_length,\n                      (int)decimals));\n  DBUG_RETURN(FALSE);\n}","23144":"void WebContents::PrimaryMainFrameRenderProcessGone(\n    base::TerminationStatus status) {\n  auto weak_this = GetWeakPtr();\n  Emit(\"STR\", status == base::TERMINATION_STATUS_PROCESS_WAS_KILLED);\n\n  \n  if (!weak_this || !web_contents())\n    return;\n\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  v8::HandleScope handle_scope(isolate);\n  gin_helper::Dictionary details = gin_helper::Dictionary::CreateEmpty(isolate);\n  details.Set(\"STR\", status);\n  details.Set(\"STR\", web_contents()->GetCrashedErrorCode());\n  Emit(\"STR\", details);\n}","23371":"static void put_prev_task(struct rq *rq, struct task_struct *prev)\n{\n\tif (prev->on_rq || rq->skip_clock_update < 0)\n\t\tupdate_rq_clock(rq);\n\tprev->sched_class->put_prev_task(rq, prev);\n}","22689":"set_unicode_charmap (FT_Face face)\n{\n  int charmap;\n\n  for (charmap = 0; charmap < face->num_charmaps; charmap++)\n    if (face->charmaps[charmap]->encoding == ft_encoding_unicode)\n      {\n\tHB_Error error = FT_Set_Charmap(face, face->charmaps[charmap]);\n\treturn error == HB_Err_Ok;\n      }\n\n  return FALSE;\n}","22927":"ConnectionDone(struct Curl_easy *data, struct connectdata *conn)\n{\n  \n  size_t maxconnects =\n    (data->multi->maxconnects < 0) ? data->multi->num_easy * 4:\n    data->multi->maxconnects;\n  struct connectdata *conn_candidate = NULL;\n\n  \n  conn->inuse = FALSE;\n\n  if(maxconnects > 0 &&\n     data->state.conn_cache->num_connections > maxconnects) {\n    infof(data, \"STR\");\n\n    conn_candidate = Curl_oldest_idle_connection(data);\n\n    if(conn_candidate) {\n      \n      conn_candidate->data = data;\n\n      \n      (void)Curl_disconnect(conn_candidate,  FALSE);\n    }\n  }\n\n  return (conn_candidate == conn) ? FALSE : TRUE;\n}","23414":"static void set_pixel_format(VncState *vs,\n                             int bits_per_pixel, int depth,\n                             int big_endian_flag, int true_color_flag,\n                             int red_max, int green_max, int blue_max,\n                             int red_shift, int green_shift, int blue_shift)\n{\n    if (!true_color_flag) {\n        vnc_client_error(vs);\n        return;\n    }\n\n    switch (bits_per_pixel) {\n    case 8:\n    case 16:\n    case 32:\n        break;\n    default:\n        vnc_client_error(vs);\n        return;\n    }\n\n    vs->client_pf.rmax = red_max;\n    vs->client_pf.rbits = hweight_long(red_max);\n    vs->client_pf.rshift = red_shift;\n    vs->client_pf.rmask = red_max << red_shift;\n    vs->client_pf.gmax = green_max;\n    vs->client_pf.gbits = hweight_long(green_max);\n    vs->client_pf.gshift = green_shift;\n    vs->client_pf.gmask = green_max << green_shift;\n    vs->client_pf.bmax = blue_max;\n    vs->client_pf.bbits = hweight_long(blue_max);\n    vs->client_pf.bshift = blue_shift;\n    vs->client_pf.bmask = blue_max << blue_shift;\n    vs->client_pf.bits_per_pixel = bits_per_pixel;\n    vs->client_pf.bytes_per_pixel = bits_per_pixel \/ 8;\n    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;\n    vs->client_be = big_endian_flag;\n\n    set_pixel_conversion(vs);\n\n    graphic_hw_invalidate(vs->vd->dcl.con);\n    graphic_hw_update(vs->vd->dcl.con);\n}","22899":"int init_aliases(void)\n{\n    FILE *fp;\n    char alias[MAXALIASLEN + 1U];\n    char dir[PATH_MAX + 1U];\n\n    if ((fp = fopen(ALIASES_FILE, \"STR\")) == NULL) {\n        return 0;\n    }\n    while (fgets(alias, sizeof alias, fp) != NULL) {\n        if (*alias == '#' || *alias == '\\n' || *alias == 0) {\n            continue;\n        }\n        {\n            char * const z = alias + strlen(alias) - 1U;\n\n            if (*z != '\\n') {\n                goto bad;\n            }\n            *z = 0;\n        }\n        do {\n            if (fgets(dir, sizeof dir, fp) == NULL || *dir == 0) {\n                goto bad;\n            }\n            {\n                char * const z = dir + strlen(dir) - 1U;\n\n                if (*z == '\\n') {\n                    *z = 0;\n                }\n            }\n        } while (*dir == '#' || *dir == 0);\n        if (head == NULL) {\n            if ((head = tail = malloc(sizeof *head)) == NULL ||\n                (tail->alias = strdup(alias)) == NULL ||\n                (tail->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = NULL;\n        } else {\n            DirAlias *curr;\n\n            if ((curr = malloc(sizeof *curr)) == NULL ||\n                (curr->alias = strdup(alias)) == NULL ||\n                (curr->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = curr;\n            tail = curr;\n        }\n    }\n    fclose(fp);\n    aliases_up++;\n\n    return 0;\n\n    bad:\n    fclose(fp);\n    logfile(LOG_ERR, MSG_ALIASES_BROKEN_FILE \"STR\");\n\n    return -1;\n}","23204":"static int vvalue_tvb_vector_internal(tvbuff_t *tvb, int offset, struct vt_vector *val, struct vtype_data *type, guint num)\n{\n\tconst int offset_in = offset;\n\tconst gboolean varsize = (type->size == -1);\n\tconst guint elsize = varsize ? (guint)sizeof(struct data_blob) : (guint)type->size;\n\tguint8 *data;\n\tint len;\n\tguint i;\n\n\t\n\tif ((guint64)elsize * (guint64)num > G_MAXUINT) {\n\t\t\n\t\tTHROW(ReportedBoundsError);\n\t}\n\n\t\n\ttvb_ensure_bytes_exist(tvb, offset, elsize * num);\n\n\t\n\tdata = (guint8*)wmem_alloc(wmem_packet_scope(), elsize * num);\n\n\tval->len = num;\n\tval->u.vt_ui1 = data;\n\tDISSECTOR_ASSERT((void*)&val->u == ((void*)&val->u.vt_ui1));\n\n\tfor (i=0; i<num; i++) {\n\t\tDISSECTOR_ASSERT_HINT(type->tvb_get != 0,\n\t\t\t\t      \"STR\");\n\t\tlen = type->tvb_get(tvb, offset, data);\n\t\tdata += elsize;\n\t\toffset += len;\n\t\tif (varsize && (offset % 4) ) { \n\t\t\tint padding = 4 - (offset % 4);\n\t\t\toffset += padding;\n\t\t}\n\t}\n\treturn offset - offset_in;\n}","23216":"DEFUN (no_neighbor_filter_list,\n       no_neighbor_filter_list_cmd,\n       NO_NEIGHBOR_CMD2 \"STR\",\n       NO_STR\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"STR\"\n       \"STR\"\n       \"STR\"\n       \"STR\")\n{\n  return peer_aslist_unset_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\tbgp_node_safi (vty), argv[2]);\n}","23151":"static void reindexTable(Parse *pParse, Table *pTab, char const *zColl){\n  if( !IsVirtual(pTab) ){\n    Index *pIndex;              \n\n    for(pIndex=pTab->pIndex; pIndex; pIndex=pIndex->pNext){\n      if( zColl==0 || collationMatch(zColl, pIndex) ){\n        int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n        sqlite3BeginWriteOperation(pParse, 0, iDb);\n        sqlite3RefillIndex(pParse, pIndex, -1);\n      }\n    }\n  }\n}","22562":"getln(int fd, char *buf, size_t bufsiz, int feedback,\n    enum tgetpass_errval *errval)\n{\n    size_t left = bufsiz;\n    ssize_t nr = -1;\n    char *cp = buf;\n    char c = '\\0';\n    debug_decl(getln, SUDO_DEBUG_CONV);\n\n    *errval = TGP_ERRVAL_NOERROR;\n\n    if (left == 0) {\n\t*errval = TGP_ERRVAL_READERROR;\n\terrno = EINVAL;\n\tdebug_return_str(NULL);\t\t\n    }\n\n    while (--left) {\n\tnr = read(fd, &c, 1);\n\tif (nr != 1 || c == '\\n' || c == '\\r')\n\t    break;\n\tif (feedback) {\n\t    if (c == sudo_term_eof) {\n\t\tnr = 0;\n\t\tbreak;\n\t    } else if (c == sudo_term_kill) {\n\t\twhile (cp > buf) {\n\t\t    if (write(fd, \"STR\", 3) == -1)\n\t\t\tbreak;\n\t\t    --cp;\n\t\t}\n\t\tleft = bufsiz;\n\t\tcontinue;\n\t    } else if (c == sudo_term_erase) {\n\t\tif (cp > buf) {\n\t\t    if (write(fd, \"STR\", 3) == -1)\n\t\t\tbreak;\n\t\t    --cp;\n\t\t    left++;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    ignore_result(write(fd, \"STR\", 1));\n\t}\n\t*cp++ = c;\n    }\n    *cp = '\\0';\n    if (feedback) {\n\t\n\twhile (cp > buf) {\n\t    if (write(fd, \"STR\", 3) == -1)\n\t\tbreak;\n\t    --cp;\n\t}\n    }\n\n    switch (nr) {\n    case -1:\n\t\n\tif (errno == EINTR) {\n\t    if (signo[SIGALRM] == 1)\n\t\t*errval = TGP_ERRVAL_TIMEOUT;\n\t} else {\n\t    *errval = TGP_ERRVAL_READERROR;\n\t}\n\tdebug_return_str(NULL);\n    case 0:\n\t\n\tif (left == bufsiz - 1) {\n\t    *errval = TGP_ERRVAL_NOPASSWORD;\n\t    debug_return_str(NULL);\n\t}\n\t\n    default:\n\tdebug_return_str_masked(buf);\n    }\n}","22812":"static void pfkey_dump_sp_done(struct pfkey_sock *pfk)\n{\n\tstruct net *net = sock_net((struct sock *)pfk);\n\n\txfrm_policy_walk_done(&pfk->dump.u.policy, net);\n}","22764":"ssize_t tpm_write(struct file *file, const char __user *buf,\n\t\t  size_t size, loff_t *off)\n{\n\tstruct tpm_chip *chip = file->private_data;\n\tsize_t in_size = size, out_size;\n\n\t\n\twhile (atomic_read(&chip->data_pending) != 0)\n\t\tmsleep(TPM_TIMEOUT);\n\n\tmutex_lock(&chip->buffer_mutex);\n\n\tif (in_size > TPM_BUFSIZE)\n\t\tin_size = TPM_BUFSIZE;\n\n\tif (copy_from_user\n\t    (chip->data_buffer, (void __user *) buf, in_size)) {\n\t\tmutex_unlock(&chip->buffer_mutex);\n\t\treturn -EFAULT;\n\t}\n\n\t\n\tout_size = tpm_transmit(chip, chip->data_buffer, TPM_BUFSIZE);\n\n\tatomic_set(&chip->data_pending, out_size);\n\tmutex_unlock(&chip->buffer_mutex);\n\n\t\n\tmod_timer(&chip->user_read_timer, jiffies + (60 * HZ));\n\n\treturn in_size;\n}","23203":"static int vhost_scsi_deregister(void)\n{\n\treturn misc_deregister(&vhost_scsi_misc);\n}","23516":"int ssh_scp_read(ssh_scp scp, void *buffer, size_t size){\n  int r;\n  int code;\n  if(scp==NULL)\n      return SSH_ERROR;\n  if(scp->state == SSH_SCP_READ_REQUESTED && scp->request_type == SSH_SCP_REQUEST_NEWFILE){\n    r=ssh_scp_accept_request(scp);\n    if(r==SSH_ERROR)\n      return r;\n  }\n  if(scp->state != SSH_SCP_READ_READING){\n    ssh_set_error(scp->session,SSH_FATAL,\"STR\");\n    return SSH_ERROR;\n  }\n  if(scp->processed + size > scp->filelen)\n    size = (size_t) (scp->filelen - scp->processed);\n  if(size > 65536)\n    size=65536; \n  r=ssh_channel_read(scp->channel,buffer,size,0);\n  if(r != SSH_ERROR)\n    scp->processed += r;\n  else {\n    scp->state=SSH_SCP_ERROR;\n    return SSH_ERROR;\n  }\n  \n  if(scp->processed == scp->filelen) {\n    scp->processed=scp->filelen=0;\n    ssh_channel_write(scp->channel,\"\",1);\n    code=ssh_scp_response(scp,NULL);\n    if(code == 0){\n    \tscp->state=SSH_SCP_READ_INITED;\n    \treturn r;\n    }\n    if(code==1){\n    \tscp->state=SSH_SCP_READ_INITED;\n    \treturn SSH_ERROR;\n    }\n    scp->state=SSH_SCP_ERROR;\n    return SSH_ERROR;\n  }\n  return r;\n}","23796":"ipa_cp_c_finalize (void)\n{\n  max_count = profile_count::uninitialized ();\n  overall_size = 0;\n  max_new_size = 0;\n  ipcp_free_transformation_sum ();\n}","23164":"setup_secureChannel(void) {\n    TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes);\n    UA_SecureChannel_init(&testChannel, &UA_ConnectionConfig_default);\n    UA_SecureChannel_setSecurityPolicy(&testChannel, &dummyPolicy, &dummyCertificate);\n\n    testingConnection = createDummyConnection(65535, &sentData);\n    UA_Connection_attachSecureChannel(&testingConnection, &testChannel);\n    testChannel.connection = &testingConnection;\n\n    testChannel.state = UA_SECURECHANNELSTATE_OPEN;\n}","23724":"QPDFObjectHandle::getKeys()\n{\n    assertDictionary();\n    return dynamic_cast<QPDF_Dictionary*>(obj.getPointer())->getKeys();\n}","22530":"static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,\n\t\t\t    int *addr_len, int peer)\n{\n\tstruct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev *hdev = hci_pi(sk)->hdev;\n\n\tBT_DBG(\"STR\", sock, sk);\n\n\tif (!hdev)\n\t\treturn -EBADFD;\n\n\tlock_sock(sk);\n\n\t*addr_len = sizeof(*haddr);\n\thaddr->hci_family = AF_BLUETOOTH;\n\thaddr->hci_dev    = hdev->id;\n\n\trelease_sock(sk);\n\treturn 0;\n}","22512":"struct timespec ns_to_timespec(const s64 nsec)\n{\n\tstruct timespec ts;\n\n\tif (!nsec)\n\t\treturn (struct timespec) {0, 0};\n\n\tts.tv_sec = div_long_long_rem_signed(nsec, NSEC_PER_SEC, &ts.tv_nsec);\n\tif (unlikely(nsec < 0))\n\t\tset_normalized_timespec(&ts, ts.tv_sec, ts.tv_nsec);\n\n\treturn ts;\n}","23064":"ofpact_hdrs_hash(const struct ofpact_hdrs *hdrs)\n{\n    return hash_2words(hdrs->vendor,\n                       ((uint32_t) hdrs->type << 16) | hdrs->ofp_version);\n}","23056":"static void inet_del_ifa(struct in_device *in_dev, struct in_ifaddr **ifap,\n\t\t\t int destroy)\n{\n\t__inet_del_ifa(in_dev, ifap, destroy, NULL, 0);\n}","23082":"static int mb86a20s_read_status(struct dvb_frontend *fe, enum fe_status *status)\n{\n\tstruct mb86a20s_state *state = fe->demodulator_priv;\n\tint val;\n\n\t*status = 0;\n\n\tval = mb86a20s_readreg(state, 0x0a) & 0xf;\n\tif (val < 0)\n\t\treturn val;\n\n\tif (val >= 2)\n\t\t*status |= FE_HAS_SIGNAL;\n\n\tif (val >= 4)\n\t\t*status |= FE_HAS_CARRIER;\n\n\tif (val >= 5)\n\t\t*status |= FE_HAS_VITERBI;\n\n\tif (val >= 7)\n\t\t*status |= FE_HAS_SYNC;\n\n\tif (val >= 8)\t\t\t\t\n\t\t*status |= FE_HAS_LOCK;\n\n\tdev_dbg(&state->i2c->dev, \"STR\",\n\t\t __func__, *status, val);\n\n\treturn val;\n}","22679":"PackLinuxElf64::check_pt_dynamic(Elf64_Phdr const *const phdr)\n{\n    upx_uint64_t t = get_te64(&phdr->p_offset), s = sizeof(Elf64_Dyn) + t;\n    upx_uint64_t filesz = get_te64(&phdr->p_filesz), memsz = get_te64(&phdr->p_memsz);\n    if (s < t || (upx_uint64_t)file_size < s\n    ||  (7 & t) || (0xf & (filesz | memsz))  \n    ||  filesz < sizeof(Elf64_Dyn)\n    ||  memsz  < sizeof(Elf64_Dyn)\n    ||  filesz < memsz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \"STR\",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    sz_dynseg = memsz;\n    return t;\n}","22752":"DEFINE_TEST(test_read_format_rar5_block_by_block)\n{\n\t\n\n\tstruct archive_entry *ae;\n\tstruct archive *a;\n\tuint8_t buf[173];\n\tint bytes_read;\n\tuint32_t computed_crc = 0;\n\n\textract_reference_file(\"STR\");\n\tassert((a = archive_read_new()) != NULL);\n\tassertA(0 == archive_read_support_filter_all(a));\n\tassertA(0 == archive_read_support_format_all(a));\n\tassertA(0 == archive_read_open_filename(a, \"STR\", 130));\n\tassertA(0 == archive_read_next_header(a, &ae));\n\tassertEqualString(\"STR\", archive_entry_pathname(ae));\n\tassertEqualInt(1200, archive_entry_size(ae));\n\n\t\n\n\twhile(1) {\n\t\t\n\n\t\tbytes_read = archive_read_data(a, buf, sizeof(buf));\n\t\tassertA(bytes_read >= 0);\n\t\tif(bytes_read <= 0)\n\t\t\tbreak;\n\n\t\tcomputed_crc = crc32(computed_crc, buf, bytes_read);\n\t}\n\n\tassertEqualInt(computed_crc, 0x7CCA70CD);\n\tEPILOGUE();\n}","23066":"static char *fstrndup(const char *ptr, unsigned long len) {\n  char *result;\n  if (len <= 0) return NULL;\n  result = ALLOC_N(char, len);\n  memccpy(result, ptr, 0, len);\n  return result;\n}","22795":"SRC_RemoveDumpFiles(void)\n{\n  char pattern[PATH_MAX], name[64], *dumpdir, *s;\n  IPAddr ip_addr;\n  glob_t gl;\n  size_t i;\n\n  dumpdir = CNF_GetDumpDir();\n  if (dumpdir[0] == '\\0' ||\n      snprintf(pattern, sizeof (pattern), \"STR\", dumpdir) >= sizeof (pattern))\n    return;\n\n  if (glob(pattern, 0, NULL, &gl))\n    return;\n\n  for (i = 0; i < gl.gl_pathc; i++) {\n    s = strrchr(gl.gl_pathv[i], '\/');\n    if (!s || snprintf(name, sizeof (name), \"STR\", s + 1) >= sizeof (name))\n      continue;\n\n    \n    if (strlen(name) < 4)\n      continue;\n    name[strlen(name) - 4] = '\\0';\n\n    \n    if (strncmp(name, \"STR\", 6) && !UTI_StringToIP(name, &ip_addr))\n      continue;\n\n    DEBUG_LOG(\"STR\", gl.gl_pathv[i]);\n    unlink(gl.gl_pathv[i]);\n  }\n\n  globfree(&gl);\n}","23221":"BitWriter::writeBitsSigned(long long val, unsigned int bits)\n{\n    unsigned long long uval = 0;\n    if (val < 0)\n    {\n        uval = static_cast<unsigned long long>((1 << bits) + val);\n    }\n    else\n    {\n        uval = static_cast<unsigned long long>(val);\n    }\n    writeBits(uval, bits);\n}","23081":"int sock_create_kern(struct net *net, int family, int type, int protocol, struct socket **res)\n{\n\treturn __sock_create(net, family, type, protocol, res, 1);\n}","23387":"static int _consolefs_fsync(oe_fd_t* file)\n{\n    OE_UNUSED(file);\n    OE_RAISE_ERRNO(OE_EINVAL);\ndone:\n    return -1;\n}","23212":"BOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"STR\");\n\t\treturn FALSE;\n\t}\n\n\tStream_Read_UINT16(s, updateType); \n\tWLog_Print(update->log, WLOG_TRACE, \"STR\", UPDATE_TYPE_STRINGS[updateType]);\n\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"STR\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"STR\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tif (!update_read_synchronize(update, s))\n\t\t\t\tgoto fail;\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\nfail:\n\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"STR\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}","23122":"get_unpacker(ImagingDecoderObject* decoder, const char* mode,\n             const char* rawmode)\n{\n    int bits;\n    ImagingShuffler unpack;\n\n    unpack = ImagingFindUnpacker(mode, rawmode, &bits);\n    if (!unpack) {\n        Py_DECREF(decoder);\n        PyErr_SetString(PyExc_ValueError, \"STR\");\n        return -1;\n    }\n\n    decoder->state.shuffle = unpack;\n    decoder->state.bits = bits;\n\n    return 0;\n}","23073":"static int install_relocation_handler(int num_cpus, size_t save_state_size)\n{\n\tstruct smm_loader_params smm_params = {\n\t\t.per_cpu_stack_size = CONFIG_SMM_STUB_STACK_SIZE,\n\t\t.num_concurrent_stacks = num_cpus,\n\t\t.per_cpu_save_state_size = save_state_size,\n\t\t.num_concurrent_save_states = 1,\n\t\t.handler = smm_do_relocation,\n\t};\n\n\t\n\tif (mp_state.ops.adjust_smm_params != NULL)\n\t\tmp_state.ops.adjust_smm_params(&smm_params, 0);\n\n\tif (smm_setup_relocation_handler(&smm_params))\n\t\treturn -1;\n\n\tadjust_smm_apic_id_map(&smm_params);\n\n\treturn 0;\n}","23455":"static void xfrm6_tunnel_spi_fini(void)\n{\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n}","22960":"int ip_recv_error(struct sock *sk, struct msghdr *msg, int len)\n{\n\tstruct sock_exterr_skb *serr;\n\tstruct sk_buff *skb, *skb2;\n\tstruct sockaddr_in *sin;\n\tstruct {\n\t\tstruct sock_extended_err ee;\n\t\tstruct sockaddr_in\t offender;\n\t} errhdr;\n\tint err;\n\tint copied;\n\n\terr = -EAGAIN;\n\tskb = skb_dequeue(&sk->sk_error_queue);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\tserr = SKB_EXT_ERR(skb);\n\n\tsin = (struct sockaddr_in *)msg->msg_name;\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = *(__be32 *)(skb_network_header(skb) +\n\t\t\t\t\t\t   serr->addr_offset);\n\t\tsin->sin_port = serr->port;\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t}\n\n\tmemcpy(&errhdr.ee, &serr->ee, sizeof(struct sock_extended_err));\n\tsin = &errhdr.offender;\n\tsin->sin_family = AF_UNSPEC;\n\tif (serr->ee.ee_origin == SO_EE_ORIGIN_ICMP) {\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tsin->sin_port = 0;\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\tif (inet->cmsg_flags)\n\t\t\tip_cmsg_recv(msg, skb);\n\t}\n\n\tput_cmsg(msg, SOL_IP, IP_RECVERR, sizeof(errhdr), &errhdr);\n\n\t\n\n\tmsg->msg_flags |= MSG_ERRQUEUE;\n\terr = copied;\n\n\t\n\tspin_lock_bh(&sk->sk_error_queue.lock);\n\tsk->sk_err = 0;\n\tskb2 = skb_peek(&sk->sk_error_queue);\n\tif (skb2 != NULL) {\n\t\tsk->sk_err = SKB_EXT_ERR(skb2)->ee.ee_errno;\n\t\tspin_unlock_bh(&sk->sk_error_queue.lock);\n\t\tsk->sk_error_report(sk);\n\t} else\n\t\tspin_unlock_bh(&sk->sk_error_queue.lock);\n\nout_free_skb:\n\tkfree_skb(skb);\nout:\n\treturn err;\n}","23465":"   This function decrypts the crypttext *\/\nPHP_FUNCTION(mcrypt_module_get_supported_key_sizes)\n{\n\tint i, count = 0;\n\tint *key_sizes;\n\t\n\tMCRYPT_GET_MODE_DIR_ARGS(algorithms_dir)\n\tarray_init(return_value);\n\n\tkey_sizes = mcrypt_module_get_algo_supported_key_sizes(module, dir, &count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tadd_index_long(return_value, i, key_sizes[i]);\n\t}\n\tmcrypt_free(key_sizes);","23693":"  select_singlerow_subselect(THD *thd_arg, Item_subselect *item_arg):\n    select_subselect(thd_arg, item_arg)\n  {}","23777":"static void uv__process_child_init(const uv_process_options_t* options,\n                                   int stdio_count,\n                                   int (*pipes)[2],\n                                   int error_fd) {\n  int close_fd;\n  int use_fd;\n  int fd;\n\n  if (options->flags & UV_PROCESS_DETACHED)\n    setsid();\n\n  for (fd = 0; fd < stdio_count; fd++) {\n    close_fd = pipes[fd][0];\n    use_fd = pipes[fd][1];\n\n    if (use_fd < 0) {\n      if (fd >= 3)\n        continue;\n      else {\n        \n        use_fd = open(\"STR\", fd == 0 ? O_RDONLY : O_RDWR);\n        close_fd = use_fd;\n\n        if (use_fd == -1) {\n        uv__write_int(error_fd, -errno);\n          perror(\"STR\");\n          _exit(127);\n        }\n      }\n    }\n\n    if (fd == use_fd)\n      uv__cloexec(use_fd, 0);\n    else\n      dup2(use_fd, fd);\n\n    if (fd <= 2)\n      uv__nonblock(fd, 0);\n\n    if (close_fd != -1)\n      uv__close(close_fd);\n  }\n\n  for (fd = 0; fd < stdio_count; fd++) {\n    use_fd = pipes[fd][1];\n\n    if (use_fd >= 0 && fd != use_fd)\n      close(use_fd);\n  }\n\n  if (options->cwd != NULL && chdir(options->cwd)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"STR\");\n    _exit(127);\n  }\n\n  if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"STR\");\n    _exit(127);\n  }\n\n  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"STR\");\n    _exit(127);\n  }\n\n  if (options->env != NULL) {\n    environ = options->env;\n  }\n\n  execvp(options->file, options->args);\n  uv__write_int(error_fd, -errno);\n  perror(\"STR\");\n  _exit(127);\n}","23712":"folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n\n  TLSMessage msg;\n  \n  \n  \n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"STR\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"STR\",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n\n  if (!msg.fragment || msg.fragment->empty()) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"STR\");\n    }\n  }\n\n  return msg;\n}","23416":"static int rdmsr_interception(struct vcpu_svm *svm)\n{\n\tu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\tu64 data;\n\n\tif (svm_get_msr(&svm->vcpu, ecx, &data)) {\n\t\ttrace_kvm_msr_read_ex(ecx);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_read(ecx, data);\n\n\t\tsvm->vcpu.arch.regs[VCPU_REGS_RAX] = data & 0xffffffff;\n\t\tsvm->vcpu.arch.regs[VCPU_REGS_RDX] = data >> 32;\n\t\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}","22990":"static inline void io_req_work_grab_env(struct io_kiocb *req,\n\t\t\t\t\tconst struct io_op_def *def)\n{\n\tif (!req->work.mm && def->needs_mm) {\n\t\tmmgrab(current->mm);\n\t\treq->work.mm = current->mm;\n\t}\n\tif (!req->work.creds)\n\t\treq->work.creds = get_current_cred();\n}","23595":"_archive_write_disk_close(struct archive *_a)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tstruct fixup_entry *next, *p;\n\tint fd, ret;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,\n\t    \"STR\");\n\tret = _archive_write_disk_finish_entry(&a->archive);\n\n\t\n\tp = sort_dir_list(a->fixup_list);\n\n\twhile (p != NULL) {\n\t\tfd = -1;\n\t\ta->pst = NULL; \n\t\tif (p->fixup &\n\t\t    (TODO_TIMES | TODO_MODE_BASE | TODO_ACLS | TODO_FFLAGS)) {\n\t\t\tfd = open(p->name,\n\t\t\t    O_WRONLY | O_BINARY | O_NOFOLLOW | O_CLOEXEC);\n\t\t}\n\t\tif (p->fixup & TODO_TIMES) {\n\t\t\tset_times(a, fd, p->mode, p->name,\n\t\t\t    p->atime, p->atime_nanos,\n\t\t\t    p->birthtime, p->birthtime_nanos,\n\t\t\t    p->mtime, p->mtime_nanos,\n\t\t\t    p->ctime, p->ctime_nanos);\n\t\t}\n\t\tif (p->fixup & TODO_MODE_BASE) {\n#ifdef HAVE_FCHMOD\n\t\t\tif (fd >= 0)\n\t\t\t\tfchmod(fd, p->mode);\n\t\t\telse\n#endif\n\t\t\tchmod(p->name, p->mode);\n\t\t}\n\t\tif (p->fixup & TODO_ACLS)\n\t\t\tarchive_write_disk_set_acls(&a->archive, fd,\n\t\t\t    p->name, &p->acl, p->mode);\n\t\tif (p->fixup & TODO_FFLAGS)\n\t\t\tset_fflags_platform(a, fd, p->name,\n\t\t\t    p->mode, p->fflags_set, 0);\n\t\tif (p->fixup & TODO_MAC_METADATA)\n\t\t\tset_mac_metadata(a, p->name, p->mac_metadata,\n\t\t\t\t\t p->mac_metadata_size);\n\t\tnext = p->next;\n\t\tarchive_acl_clear(&p->acl);\n\t\tfree(p->mac_metadata);\n\t\tfree(p->name);\n\t\tif (fd >= 0)\n\t\t\tclose(fd);\n\t\tfree(p);\n\t\tp = next;\n\t}\n\ta->fixup_list = NULL;\n\treturn (ret);\n}","23499":"void timer_stats_update_stats(void *timer, pid_t pid, void *startf,\n\t\t\t      void *timerf, char *comm, u32 tflags)\n{\n\t\n\traw_spinlock_t *lock;\n\tstruct entry *entry, input;\n\tunsigned long flags;\n\n\tif (likely(!timer_stats_active))\n\t\treturn;\n\n\tlock = &per_cpu(tstats_lookup_lock, raw_smp_processor_id());\n\n\tinput.timer = timer;\n\tinput.start_func = startf;\n\tinput.expire_func = timerf;\n\tinput.pid = pid;\n\tinput.flags = tflags;\n\n\traw_spin_lock_irqsave(lock, flags);\n\tif (!timer_stats_active)\n\t\tgoto out_unlock;\n\n\tentry = tstat_lookup(&input, comm);\n\tif (likely(entry))\n\t\tentry->count++;\n\telse\n\t\tatomic_inc(&overflow_count);\n\n out_unlock:\n\traw_spin_unlock_irqrestore(lock, flags);\n}","23141":"PHPAPI char *php_unescape_html_entities(unsigned char *old, size_t oldlen, size_t *newlen, int all, int flags, char *hint_charset TSRMLS_DC)\n{\n\tsize_t retlen;\n\tchar *ret;\n\tenum entity_charset charset;\n\tconst entity_ht *inverse_map = NULL;\n\tsize_t new_size = TRAVERSE_FOR_ENTITIES_EXPAND_SIZE(oldlen);\n\n\tif (all) {\n\t\tcharset = determine_charset(hint_charset TSRMLS_CC);\n\t} else {\n\t\tcharset = cs_8859_1; \n\t}\n\n\t\n\n\tif (oldlen > new_size) {\n\t\t\n\t\tret = estrndup((char*)old, oldlen);\n\t\tretlen = oldlen;\n\t\tgoto empty_source;\n\t}\n\tret = emalloc(new_size);\n\t*ret = '\\0';\n\tretlen = oldlen;\n\tif (retlen == 0) {\n\t\tgoto empty_source;\n\t}\n\t\n\tinverse_map = unescape_inverse_map(all, flags);\n\t\n\t\n\ttraverse_for_entities(old, oldlen, ret, &retlen, all, flags, inverse_map, charset);\n\nempty_source:\t\n\t*newlen = retlen;\n\treturn ret;\n}","22805":"static int em_clflush(struct x86_emulate_ctxt *ctxt)\n{\n\t\n\treturn X86EMUL_CONTINUE;\n}","23791":"static void finish(AvahiSAddressResolver *r, AvahiResolverEvent event) {\n    assert(r);\n\n    if (r->time_event) {\n        avahi_time_event_free(r->time_event);\n        r->time_event = NULL;\n    }\n\n    switch (event) {\n        case AVAHI_RESOLVER_FAILURE:\n            r->callback(r, r->interface, r->protocol, event, &r->address, NULL, r->flags, r->userdata);\n            break;\n\n        case AVAHI_RESOLVER_FOUND:\n            assert(r->ptr_record);\n            r->callback(r, r->interface, r->protocol, event, &r->address, r->ptr_record->data.ptr.name, r->flags, r->userdata);\n            break;\n    }\n}","23097":"respip_addr_lookup(const struct reply_info *rep, struct rbtree_type* iptree,\n\tsize_t* rrset_id)\n{\n\tsize_t i;\n\tstruct resp_addr* ra;\n\tstruct sockaddr_storage ss;\n\tsocklen_t addrlen;\n\n\tfor(i=0; i<rep->an_numrrsets; i++) {\n\t\tsize_t j;\n\t\tconst struct packed_rrset_data* rd;\n\t\tuint16_t rtype = ntohs(rep->rrsets[i]->rk.type);\n\n\t\tif(rtype != LDNS_RR_TYPE_A && rtype != LDNS_RR_TYPE_AAAA)\n\t\t\tcontinue;\n\t\trd = rep->rrsets[i]->entry.data;\n\t\tfor(j = 0; j < rd->count; j++) {\n\t\t\tif(!rdata2sockaddr(rd, rtype, j, &ss, &addrlen))\n\t\t\t\tcontinue;\n\t\t\tra = (struct resp_addr*)addr_tree_lookup(iptree, &ss,\n\t\t\t\taddrlen);\n\t\t\tif(ra) {\n\t\t\t\t*rrset_id = i;\n\t\t\t\treturn ra;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}","23193":"static int ieee802154_create(struct net *net, struct socket *sock,\n\t\t\t     int protocol, int kern)\n{\n\tstruct sock *sk;\n\tint rc;\n\tstruct proto *proto;\n\tconst struct proto_ops *ops;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_RAW:\n\t\tproto = &ieee802154_raw_prot;\n\t\tops = &ieee802154_raw_ops;\n\t\tbreak;\n\tcase SOCK_DGRAM:\n\t\tproto = &ieee802154_dgram_prot;\n\t\tops = &ieee802154_dgram_ops;\n\t\tbreak;\n\tdefault:\n\t\trc = -ESOCKTNOSUPPORT;\n\t\tgoto out;\n\t}\n\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_IEEE802154, GFP_KERNEL, proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\n\tsock->ops = ops;\n\n\tsock_init_data(sock, sk);\n\t\n\tsk->sk_family = PF_IEEE802154;\n\n\t\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\n\tif (sk->sk_prot->hash) {\n\t\trc = sk->sk_prot->hash(sk);\n\t\tif (rc) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (sk->sk_prot->init) {\n\t\trc = sk->sk_prot->init(sk);\n\t\tif (rc)\n\t\t\tsk_common_release(sk);\n\t}\nout:\n\treturn rc;\n}","23045":"static int validate_params(uint cmd, struct dm_ioctl *param)\n{\n\t\n\tparam->flags &= ~DM_BUFFER_FULL_FLAG;\n\tparam->flags &= ~DM_UEVENT_GENERATED_FLAG;\n\tparam->flags &= ~DM_SECURE_DATA_FLAG;\n\tparam->flags &= ~DM_DATA_OUT_FLAG;\n\n\t\n\tif (cmd == DM_REMOVE_ALL_CMD ||\n\t    cmd == DM_LIST_DEVICES_CMD ||\n\t    cmd == DM_LIST_VERSIONS_CMD)\n\t\treturn 0;\n\n\tif (cmd == DM_DEV_CREATE_CMD) {\n\t\tif (!*param->name) {\n\t\t\tDMWARN(\"STR\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (*param->uuid && *param->name) {\n\t\tDMWARN(\"STR\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\t\n\tparam->name[DM_NAME_LEN - 1] = '\\0';\n\tparam->uuid[DM_UUID_LEN - 1] = '\\0';\n\n\treturn 0;\n}","23229":"unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,\n\t\tunsigned long len, unsigned long pgoff, unsigned long flags)\n{\n\tstruct vm_area_struct *vmm;\n\n\tif (flags & MAP_FIXED) {\n\t\t\n\t\tif ((flags & MAP_SHARED) &&\n\t\t\t\t((addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1)))\n\t\t\treturn -EINVAL;\n\t\treturn addr;\n\t}\n\n\tif (len > TASK_SIZE)\n\t\treturn -ENOMEM;\n\tif (!addr)\n\t\taddr = TASK_UNMAPPED_BASE;\n\n\tif (flags & MAP_SHARED)\n\t\taddr = COLOUR_ALIGN(addr, pgoff);\n\telse\n\t\taddr = PAGE_ALIGN(addr);\n\n\tfor (vmm = find_vma(current->mm, addr); ; vmm = vmm->vm_next) {\n\t\t\n\t\tif (TASK_SIZE - len < addr)\n\t\t\treturn -ENOMEM;\n\t\tif (!vmm || addr + len <= vmm->vm_start)\n\t\t\treturn addr;\n\t\taddr = vmm->vm_end;\n\t\tif (flags & MAP_SHARED)\n\t\t\taddr = COLOUR_ALIGN(addr, pgoff);\n\t}\n}","23113":"void rds_send_drop_to(struct rds_sock *rs, struct sockaddr_in *dest)\n{\n\tstruct rds_message *rm, *tmp;\n\tstruct rds_connection *conn;\n\tunsigned long flags;\n\tLIST_HEAD(list);\n\n\t\n\tspin_lock_irqsave(&rs->rs_lock, flags);\n\n\tlist_for_each_entry_safe(rm, tmp, &rs->rs_send_queue, m_sock_item) {\n\t\tif (dest && (dest->sin_addr.s_addr != rm->m_daddr ||\n\t\t\t     dest->sin_port != rm->m_inc.i_hdr.h_dport))\n\t\t\tcontinue;\n\n\t\tlist_move(&rm->m_sock_item, &list);\n\t\trds_send_sndbuf_remove(rs, rm);\n\t\tclear_bit(RDS_MSG_ON_SOCK, &rm->m_flags);\n\t}\n\n\t\n\tsmp_mb__after_atomic();\n\n\tspin_unlock_irqrestore(&rs->rs_lock, flags);\n\n\tif (list_empty(&list))\n\t\treturn;\n\n\t\n\tlist_for_each_entry(rm, &list, m_sock_item) {\n\n\t\tconn = rm->m_inc.i_conn;\n\n\t\tspin_lock_irqsave(&conn->c_lock, flags);\n\t\t\n\t\tif (!test_and_clear_bit(RDS_MSG_ON_CONN, &rm->m_flags)) {\n\t\t\tspin_unlock_irqrestore(&conn->c_lock, flags);\n\t\t\tspin_lock_irqsave(&rm->m_rs_lock, flags);\n\t\t\trm->m_rs = NULL;\n\t\t\tspin_unlock_irqrestore(&rm->m_rs_lock, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del_init(&rm->m_conn_item);\n\t\tspin_unlock_irqrestore(&conn->c_lock, flags);\n\n\t\t\n\t\tspin_lock_irqsave(&rm->m_rs_lock, flags);\n\n\t\tspin_lock(&rs->rs_lock);\n\t\t__rds_send_complete(rs, rm, RDS_RDMA_CANCELED);\n\t\tspin_unlock(&rs->rs_lock);\n\n\t\trm->m_rs = NULL;\n\t\tspin_unlock_irqrestore(&rm->m_rs_lock, flags);\n\n\t\trds_message_put(rm);\n\t}\n\n\trds_wake_sk_sleep(rs);\n\n\twhile (!list_empty(&list)) {\n\t\trm = list_entry(list.next, struct rds_message, m_sock_item);\n\t\tlist_del_init(&rm->m_sock_item);\n\t\trds_message_wait(rm);\n\n\t\t\n\t\tspin_lock_irqsave(&rm->m_rs_lock, flags);\n\n\t\tspin_lock(&rs->rs_lock);\n\t\t__rds_send_complete(rs, rm, RDS_RDMA_CANCELED);\n\t\tspin_unlock(&rs->rs_lock);\n\n\t\trm->m_rs = NULL;\n\t\tspin_unlock_irqrestore(&rm->m_rs_lock, flags);\n\n\t\trds_message_put(rm);\n\t}\n}","23704":"static void FVMenuGlyphsWhite(GWindow gw, struct gmenuitem *UNUSED(mi), GEvent *e) {\n    FontView *fv = (FontView *) GDrawGetUserData(gw);\n    int i, gid, doit;\n    EncMap *map = fv->b.map;\n    SplineFont *sf = fv->b.sf;\n    int merge = SelMergeType(e);\n    int layer = fv->b.active_layer;\n\n    for ( i=0; i< map->enccount; ++i ) {\n\tdoit = ( (gid=map->map[i])!=-1 && sf->glyphs[gid]!=NULL &&\n\t\tsf->glyphs[gid]->layers[layer].refs==NULL &&\n\t\tsf->glyphs[gid]->layers[layer].splines==NULL );\n\tfv->b.selected[i] = mergefunc[ merge + (fv->b.selected[i]?2:0) + doit ];\n    }\n    GDrawRequestExpose(fv->v,NULL,false);\n}","23324":"NUM_cache_search(char *str)\n{\n\tint\t\t\ti;\n\tNUMCacheEntry *ent;\n\n\t\n\tif (NUMCounter >= (INT_MAX - NUM_CACHE_FIELDS - 1))\n\t{\n\t\tNUMCounter = 0;\n\n\t\tfor (ent = NUMCache; ent <= (NUMCache + NUM_CACHE_FIELDS); ent++)\n\t\t\tent->age = (++NUMCounter);\n\t}\n\n\tfor (i = 0, ent = NUMCache; i < n_NUMCache; i++, ent++)\n\t{\n\t\tif (strcmp(ent->str, str) == 0)\n\t\t{\n\t\t\tent->age = (++NUMCounter);\n\t\t\tlast_NUMCacheEntry = ent;\n\t\t\treturn ent;\n\t\t}\n\t}\n\n\treturn NULL;\n}","22722":"static void cmd_anal_aav(RCore *core, const char *input) {\n\n\n\tut64 o_align = geti (\"STR\");\n\tbool asterisk = strchr (input, '*');;\n\tbool is_debug = r_config_get_i (core->config, \"STR\");\n\n\t\n\tint archAlign = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_ALIGN);\n\tseti (\"STR\", archAlign);\n\n\tint vsize = 4; \n\tif (core->assembler->bits == 64) {\n\t\tvsize = 8;\n\t}\n\n\t\n\tr_cons_break_push (NULL, NULL);\n\tif (is_debug) {\n\t\tRList *list = r_core_get_boundaries_prot (core, 0, \"STR\");\n\t\tRListIter *iter;\n\t\tRIOMap *map;\n\t\tr_list_foreach (list, iter, map) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\teprintf (\"STR\", map->itv.addr, r_itv_end (map->itv));\n\t\t\t(void)r_core_search_value_in_range (core, map->itv,\n\t\t\t\tmap->itv.addr, r_itv_end (map->itv), vsize, asterisk, _CbInRangeAav);\n\t\t}\n\t\tr_list_free (list);\n\t} else {\n\t\tRList *list = r_core_get_boundaries_prot (core, 0, NULL, \"STR\");\n\t\tRListIter *iter, *iter2;\n\t\tRIOMap *map, *map2;\n\t\tut64 from = UT64_MAX;\n\t\tut64 to = UT64_MAX;\n\t\t\n\t\tr_list_foreach (list, iter2, map2) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfrom = r_itv_begin (map2->itv);\n\t\t\tto = r_itv_end (map2->itv);\n\t\t\teprintf (\"STR\", from, to);\n\t\t\tr_list_foreach (list, iter, map) {\n\t\t\t\tut64 begin = map->itv.addr;\n\t\t\t\tut64 end = r_itv_end (map->itv);\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (end - begin > UT32_MAX) {\n\t\t\t\t\teprintf (\"STR\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\teprintf (\"STR\", from, to, begin, end);\n\t\t\t\t(void)r_core_search_value_in_range (core, map->itv, from, to, vsize, asterisk, _CbInRangeAav);\n\t\t\t\t}\n\t\t}\n\t\tr_list_free (list);\n\t}\n\tr_cons_break_pop ();\n\t\n\tseti (\"STR\", o_align);\n}","22692":"static int alloc_and_link_pwqs(struct workqueue_struct *wq)\n{\n\tbool highpri = wq->flags & WQ_HIGHPRI;\n\tint cpu, ret;\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\twq->cpu_pwqs = alloc_percpu(struct pool_workqueue);\n\t\tif (!wq->cpu_pwqs)\n\t\t\treturn -ENOMEM;\n\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tstruct pool_workqueue *pwq =\n\t\t\t\tper_cpu_ptr(wq->cpu_pwqs, cpu);\n\t\t\tstruct worker_pool *cpu_pools =\n\t\t\t\tper_cpu(cpu_worker_pools, cpu);\n\n\t\t\tinit_pwq(pwq, wq, &cpu_pools[highpri]);\n\n\t\t\tmutex_lock(&wq->mutex);\n\t\t\tlink_pwq(pwq);\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t}\n\t\treturn 0;\n\t} else if (wq->flags & __WQ_ORDERED) {\n\t\tret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);\n\t\t\n\t\tWARN(!ret && (wq->pwqs.next != &wq->dfl_pwq->pwqs_node ||\n\t\t\t      wq->pwqs.prev != &wq->dfl_pwq->pwqs_node),\n\t\t     \"STR\", wq->name);\n\t\treturn ret;\n\t} else {\n\t\treturn apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);\n\t}\n}","22915":"DEFUN (ip_community_list_expanded,\n       ip_community_list_expanded_cmd,\n       \"STR\",\n       IP_STR\n       COMMUNITY_LIST_STR\n       \"STR\"\n       \"STR\"\n       \"STR\"\n       \"STR\")\n{\n  return community_list_set_vty (vty, argc, argv, COMMUNITY_LIST_EXPANDED, 0);\n}","23218":"void HevcUnit::updateBits(int bitOffset, int bitLen, int value)\n{\n    uint8_t* ptr = (uint8_t*)m_reader.getBuffer() + bitOffset \/ 8;\n    BitStreamWriter bitWriter;\n    int byteOffset = bitOffset % 8;\n    bitWriter.setBuffer(ptr, ptr + (bitLen \/ 8 + 5));\n\n    uint8_t* ptr_end = (uint8_t*)m_reader.getBuffer() + (bitOffset + bitLen) \/ 8;\n    int endBitsPostfix = 8 - ((bitOffset + bitLen) % 8);\n\n    if (byteOffset > 0)\n    {\n        int prefix = *ptr >> (8 - byteOffset);\n        bitWriter.putBits(byteOffset, prefix);\n    }\n    bitWriter.putBits(bitLen, value);\n\n    if (endBitsPostfix < 8)\n    {\n        int postfix = *ptr_end & (1 << endBitsPostfix) - 1;\n        bitWriter.putBits(endBitsPostfix, postfix);\n    }\n    bitWriter.flushBits();\n}","23282":"static int dbConnect(char *host, char *user, char *passwd)\n{\n  DBUG_ENTER(\"STR\");\n  if (verbose)\n  {\n    fprintf(stderr, \"STR\");\n  }\n  mysql_init(&mysql_connection);\n  if (opt_compress)\n    mysql_options(&mysql_connection, MYSQL_OPT_COMPRESS, NullS);\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n    mysql_ssl_set(&mysql_connection, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n\t\t  opt_ssl_capath, opt_ssl_cipher);\n#endif\n  if (opt_protocol)\n    mysql_options(&mysql_connection,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);\n#ifdef HAVE_SMEM\n  if (shared_memory_base_name)\n    mysql_options(&mysql_connection,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);\n#endif\n\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(&mysql_connection, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(&mysql_connection, MYSQL_DEFAULT_AUTH, opt_default_auth);\n\n  if (using_opt_enable_cleartext_plugin)\n    mysql_options(&mysql_connection, MYSQL_ENABLE_CLEARTEXT_PLUGIN,\n                  (char *) &opt_enable_cleartext_plugin);\n\n  mysql_options(&mysql_connection, MYSQL_SET_CHARSET_NAME, default_charset);\n  if (!(sock = mysql_connect_ssl_check(&mysql_connection, host, user, passwd,\n                                       NULL, opt_mysql_port,\n                                       opt_mysql_unix_port, 0,\n                                       opt_ssl_required)))\n  {\n    DBerror(&mysql_connection, \"STR\");\n    return 1;\n  }\n  mysql_connection.reconnect= 1;\n  return 0;\n} ","23162":"epson_map_color_rgb(gx_device * dev, gx_color_index color,\n                    gx_color_value prgb[3])\n{\n\n    if (gx_device_has_color(dev))\n        switch ((ushort) color ^ 7) {\n            case BLACK:\n                prgb[0] = 0;\n                prgb[1] = 0;\n                prgb[2] = 0;\n                break;\n            case VIOLET:\n                prgb[0] = 0;\n                prgb[1] = 0;\n                prgb[2] = c1;\n                break;\n            case GREEN:\n                prgb[0] = 0;\n                prgb[1] = c1;\n                prgb[2] = 0;\n                break;\n            case CYAN:\n                prgb[0] = 0;\n                prgb[1] = c1;\n                prgb[2] = c1;\n                break;\n            case RED:\n                prgb[0] = c1;\n                prgb[1] = 0;\n                prgb[2] = 0;\n                break;\n            case MAGENTA:\n                prgb[0] = c1;\n                prgb[1] = 0;\n                prgb[2] = c1;\n                break;\n            case YELLOW:\n                prgb[0] = c1;\n                prgb[1] = c1;\n                prgb[2] = 0;\n                break;\n            case WHITE:\n                prgb[0] = c1;\n                prgb[1] = c1;\n                prgb[2] = c1;\n                break;\n    } else\n        return gx_default_map_color_rgb(dev, color, prgb);\n    return 0;\n}","22817":"static void flush_end_io(struct request *flush_rq, int error)\n{\n\tstruct request_queue *q = flush_rq->q;\n\tstruct list_head *running;\n\tbool queued = false;\n\tstruct request *rq, *n;\n\tunsigned long flags = 0;\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(q, flush_rq->mq_ctx);\n\n\tif (q->mq_ops) {\n\t\tspin_lock_irqsave(&fq->mq_flush_lock, flags);\n\t\tflush_rq->tag = -1;\n\t}\n\n\trunning = &fq->flush_queue[fq->flush_running_idx];\n\tBUG_ON(fq->flush_pending_idx == fq->flush_running_idx);\n\n\t\n\tfq->flush_running_idx ^= 1;\n\n\tif (!q->mq_ops)\n\t\telv_completed_request(q, flush_rq);\n\n\t\n\tlist_for_each_entry_safe(rq, n, running, flush.list) {\n\t\tunsigned int seq = blk_flush_cur_seq(rq);\n\n\t\tBUG_ON(seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH);\n\t\tqueued |= blk_flush_complete_seq(rq, fq, seq, error);\n\t}\n\n\t\n\tif (queued || fq->flush_queue_delayed) {\n\t\tWARN_ON(q->mq_ops);\n\t\tblk_run_queue_async(q);\n\t}\n\tfq->flush_queue_delayed = 0;\n\tif (q->mq_ops)\n\t\tspin_unlock_irqrestore(&fq->mq_flush_lock, flags);\n}","23593":"static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n\t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n\t\t\t\tunsigned int oui, u8 oui_type)\n{\n\tstruct ieee_types_header *vs_ie;\n\tstruct mwifiex_ie *ie = *ie_ptr;\n\tconst u8 *vendor_ie;\n\n\tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n\tif (vendor_ie) {\n\t\tif (!*ie_ptr) {\n\t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!*ie_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tie = *ie_ptr;\n\t\t}\n\n\t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n\t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n\t\t       vs_ie, vs_ie->len + 2);\n\t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);\n\t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n\t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n\t}\n\n\t*ie_ptr = ie;\n\treturn 0;\n}","23217":"static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SOCK_RAW:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tax25->sk    = sk;\n\n\treturn 0;\n}","22831":"\nGF_Box *ssix_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubsegmentIndexBox, GF_ISOM_BOX_TYPE_SSIX);\n\treturn (GF_Box *)tmp;","23752":"TPMI_ALG_RSA_SCHEME_Unmarshal(TPMI_ALG_RSA_SCHEME *target, BYTE **buffer, INT32 *size, BOOL allowNull)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM_ALG_ID_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n#if ALG_RSASSA\n\t  case TPM_ALG_RSASSA:\n#endif\n#if ALG_RSAPSS\n\t  case TPM_ALG_RSAPSS:\n#endif\n#if ALG_RSAES\n\t  case TPM_ALG_RSAES:\n#endif\n#if ALG_OAEP\n\t  case TPM_ALG_OAEP:\n#endif\n\t    break;\n\t  case TPM_ALG_NULL:\n\t    if (allowNull) {\n\t\tbreak;\n\t    }\n\t  default:\n\t    rc = TPM_RC_VALUE;\n\t}\n    }\n    return rc;\n}","23630":"void DeepScanLineInputFile::initialize(const Header& header)\n{\n    try\n    {\n        if (header.type() != DEEPSCANLINE)\n            throw IEX_NAMESPACE::ArgExc(\"STR\"\n            \"STR\");\n        \n        if(header.version()!=1)\n        {\n            THROW(IEX_NAMESPACE::ArgExc, \"STR\");\n        }\n        \n        _data->header = header;\n\n        _data->lineOrder = _data->header.lineOrder();\n\n        const Box2i &dataWindow = _data->header.dataWindow();\n\n        _data->minX = dataWindow.min.x;\n        _data->maxX = dataWindow.max.x;\n        _data->minY = dataWindow.min.y;\n        _data->maxY = dataWindow.max.y;\n\n        _data->sampleCount.resizeErase(_data->maxY - _data->minY + 1,\n                                       _data->maxX - _data->minX + 1);\n        _data->lineSampleCount.resizeErase(_data->maxY - _data->minY + 1);\n\n        Compressor* compressor = newCompressor(_data->header.compression(),\n                                               0,\n                                               _data->header);\n\n        _data->linesInBuffer = numLinesInBuffer (compressor);\n\n        delete compressor;\n\n        _data->nextLineBufferMinY = _data->minY - 1;\n\n        int lineOffsetSize = (dataWindow.max.y - dataWindow.min.y +\n                              _data->linesInBuffer) \/ _data->linesInBuffer;\n\n        _data->lineOffsets.resize (lineOffsetSize);\n\n        for (size_t i = 0; i < _data->lineBuffers.size(); i++)\n            _data->lineBuffers[i] = new LineBuffer ();\n\n        _data->gotSampleCount.resizeErase(_data->maxY - _data->minY + 1);\n        for (int i = 0; i < _data->maxY - _data->minY + 1; i++)\n            _data->gotSampleCount[i] = false;\n\n        _data->maxSampleCountTableSize = min(_data->linesInBuffer, _data->maxY - _data->minY + 1) *\n                                        (_data->maxX - _data->minX + 1) *\n                                        sizeof(unsigned int);\n\n        _data->sampleCountTableBuffer.resizeErase(_data->maxSampleCountTableSize);\n\n        _data->sampleCountTableComp = newCompressor(_data->header.compression(),\n                                                    _data->maxSampleCountTableSize,\n                                                    _data->header);\n\n        _data->bytesPerLine.resize (_data->maxY - _data->minY + 1);\n        \n        const ChannelList & c=header.channels();\n        \n        _data->combinedSampleSize=0;\n        for(ChannelList::ConstIterator i=c.begin();i!=c.end();i++)\n        {\n            switch(i.channel().type)\n            {\n                case OPENEXR_IMF_INTERNAL_NAMESPACE::HALF  :\n                    _data->combinedSampleSize+=Xdr::size<half>();\n                    break;\n                case OPENEXR_IMF_INTERNAL_NAMESPACE::FLOAT :\n                    _data->combinedSampleSize+=Xdr::size<float>();\n                    break;\n                case OPENEXR_IMF_INTERNAL_NAMESPACE::UINT  :\n                    _data->combinedSampleSize+=Xdr::size<unsigned int>();\n                    break;\n                default :\n                    THROW(IEX_NAMESPACE::ArgExc, \"STR\");\n                    \n            }\n        }\n        \n    }\n    catch (...)\n    {\n        delete _data;\n        _data=NULL;\n        throw;\n    }\n}","22523":"gsm_xsmp_client_disconnect (GsmXSMPClient *client)\n{\n        if (client->priv->watch_id > 0) {\n                g_source_remove (client->priv->watch_id);\n        }\n\n        if (client->priv->conn != NULL) {\n                SmsCleanUp (client->priv->conn);\n        }\n\n        if (client->priv->ice_connection != NULL) {\n                IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);\n                IceCloseConnection (client->priv->ice_connection);\n        }\n\n        if (client->priv->protocol_timeout > 0) {\n                g_source_remove (client->priv->protocol_timeout);\n        }\n}","23094":"int ath6kl_wmi_delete_pstream_cmd(struct wmi *wmi, u8 if_idx, u8 traffic_class,\n\t\t\t\t  u8 tsid)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_delete_pstream_cmd *cmd;\n\tu16 active_tsids = 0;\n\tint ret;\n\n\tif (traffic_class > 3) {\n\t\tath6kl_err(\"STR\", traffic_class);\n\t\treturn -EINVAL;\n\t}\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_delete_pstream_cmd *) skb->data;\n\tcmd->traffic_class = traffic_class;\n\tcmd->tsid = tsid;\n\n\tspin_lock_bh(&wmi->lock);\n\tactive_tsids = wmi->stream_exist_for_ac[traffic_class];\n\tspin_unlock_bh(&wmi->lock);\n\n\tif (!(active_tsids & (1 << tsid))) {\n\t\tdev_kfree_skb(skb);\n\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t   \"STR\",\n\t\t\t   tsid, traffic_class);\n\t\treturn -ENODATA;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"STR\",\n\t\t   traffic_class, tsid);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_DELETE_PSTREAM_CMDID,\n\t\t\t\t  SYNC_BEFORE_WMIFLAG);\n\n\tspin_lock_bh(&wmi->lock);\n\twmi->stream_exist_for_ac[traffic_class] &= ~(1 << tsid);\n\tactive_tsids = wmi->stream_exist_for_ac[traffic_class];\n\tspin_unlock_bh(&wmi->lock);\n\n\t\n\tif (!active_tsids) {\n\t\tath6kl_indicate_tx_activity(wmi->parent_dev,\n\t\t\t\t\t    traffic_class, false);\n\t\twmi->fat_pipe_exist &= ~(1 << traffic_class);\n\t}\n\n\treturn ret;\n}","23394":"Address Zone::NewExpand(int size) {\n  \n  \n  ASSERT(size == RoundDown(size, kAlignment));\n  ASSERT(size > limit_ - position_);\n\n  \n  \n  \n  \n  Segment* head = segment_head_;\n  int old_size = (head == NULL) ? 0 : head->size();\n  static const int kSegmentOverhead = sizeof(Segment) + kAlignment;\n  int new_size_no_overhead = size + (old_size << 1);\n  int new_size = kSegmentOverhead + new_size_no_overhead;\n  \n  if (new_size_no_overhead < size || new_size < kSegmentOverhead) {\n    V8::FatalProcessOutOfMemory(\"STR\");\n    return NULL;\n  }\n  if (new_size < kMinimumSegmentSize) {\n    new_size = kMinimumSegmentSize;\n  } else if (new_size > kMaximumSegmentSize) {\n    \n    \n    \n    \n    new_size = Max(kSegmentOverhead + size, kMaximumSegmentSize);\n  }\n  Segment* segment = NewSegment(new_size);\n  if (segment == NULL) {\n    V8::FatalProcessOutOfMemory(\"STR\");\n    return NULL;\n  }\n\n  \n  Address result = RoundUp(segment->start(), kAlignment);\n  position_ = result + size;\n  \n  if (position_ < result) {\n    V8::FatalProcessOutOfMemory(\"STR\");\n    return NULL;\n  }\n  limit_ = segment->end();\n  ASSERT(position_ <= limit_);\n  return result;\n}","22560":"static int http_read_header(URLContext *h, int *new_location)\n{\n    HTTPContext *s = h->priv_data;\n    char line[MAX_URL_SIZE];\n    int err = 0;\n\n    s->chunksize = -1;\n\n    for (;;) {\n        if ((err = http_get_line(s, line, sizeof(line))) < 0)\n            return err;\n\n        av_log(h, AV_LOG_TRACE, \"STR\", line);\n\n        err = process_line(h, line, s->line_count, new_location);\n        if (err < 0)\n            return err;\n        if (err == 0)\n            break;\n        s->line_count++;\n    }\n\n    if (s->seekable == -1 && s->is_mediagateway && s->filesize == 2000000000)\n        h->is_streamed = 1; \n\n    \n    cookie_string(s->cookie_dict, &s->cookies);\n    av_dict_free(&s->cookie_dict);\n\n    return err;\n}","23434":"static void mailbox_release_resources(struct mailbox *mailbox)\n{\n    int i;\n\n    if (mailbox->i.dirty)\n        abort();\n\n    \n    xclose(mailbox->header_fd);\n\n    \n    xclose(mailbox->index_fd);\n    mailbox->index_locktype = 0; \n    if (mailbox->index_base)\n        map_free(&mailbox->index_base, &mailbox->index_len);\n\n    \n    for (i = 0; i < mailbox->caches.count; i++) {\n        struct mappedfile *cachefile = ptrarray_nth(&mailbox->caches, i);\n        mappedfile_close(&cachefile);\n    }\n    ptrarray_fini(&mailbox->caches);\n}","23030":"static int xudc_ep_queue(struct usb_ep *_ep, struct usb_request *_req,\n\t\t\t gfp_t gfp_flags)\n{\n\tstruct xusb_req *req = to_xusb_req(_req);\n\tstruct xusb_ep\t*ep  = to_xusb_ep(_ep);\n\tstruct xusb_udc *udc = ep->udc;\n\tint  ret;\n\tunsigned long flags;\n\n\tif (!ep->desc) {\n\t\tdev_dbg(udc->dev, \"STR\",\n\t\t\t__func__, ep->name);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tdev_dbg(udc->dev, \"STR\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t_req->status = -EINPROGRESS;\n\t_req->actual = 0;\n\n\tif (udc->dma_enabled) {\n\t\tret = usb_gadget_map_request(&udc->gadget, &req->usb_req,\n\t\t\t\t\t     ep->is_in);\n\t\tif (ret) {\n\t\t\tdev_dbg(udc->dev, \"STR\",\n\t\t\t\tep->epnumber);\n\t\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tif (list_empty(&ep->queue)) {\n\t\tif (ep->is_in) {\n\t\t\tdev_dbg(udc->dev, \"STR\");\n\t\t\tif (!xudc_write_fifo(ep, req))\n\t\t\t\treq = NULL;\n\t\t} else {\n\t\t\tdev_dbg(udc->dev, \"STR\");\n\t\t\tif (!xudc_read_fifo(ep, req))\n\t\t\t\treq = NULL;\n\t\t}\n\t}\n\n\tif (req != NULL)\n\t\tlist_add_tail(&req->queue, &ep->queue);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}","23531":"void pin_remove(struct fs_pin *pin)\n{\n\tspin_lock(&pin_lock);\n\thlist_del(&pin->m_list);\n\thlist_del(&pin->s_list);\n\tspin_unlock(&pin_lock);\n\tspin_lock_irq(&pin->wait.lock);\n\tpin->done = 1;\n\twake_up_locked(&pin->wait);\n\tspin_unlock_irq(&pin->wait.lock);\n}","23542":"TEST(HeaderMapImplTest, SetReferenceKey) {\n  HeaderMapImpl headers;\n  LowerCaseString foo(\"STR\");\n  headers.setReferenceKey(foo, \"STR\");\n  EXPECT_NE(\"STR\", headers.get(foo)->value().getStringView().data());\n  EXPECT_EQ(\"STR\", headers.get(foo)->value().getStringView());\n\n  headers.setReferenceKey(foo, \"STR\");\n  EXPECT_NE(\"STR\", headers.get(foo)->value().getStringView().data());\n  EXPECT_EQ(\"STR\", headers.get(foo)->value().getStringView());\n}","22725":"void t_cpp_generator::generate_deserialize_set_element(ofstream& out, t_set* tset, string prefix) {\n  string elem = tmp(\"STR\");\n  t_field felem(tset->get_elem_type(), elem);\n\n  indent(out) << declare_field(&felem) << endl;\n\n  generate_deserialize_field(out, &felem);\n\n  indent(out) << prefix << \"STR\" << endl;\n}","23327":"ClientHttpRequest::mRangeCLen()\n{\n    int64_t clen = 0;\n    MemBuf mb;\n\n    assert(memObject());\n\n    mb.init();\n    HttpHdrRange::iterator pos = request->range->begin();\n\n    while (pos != request->range->end()) {\n        \n        mb.reset();\n        clientPackRangeHdr(memObject()->getReply(),\n                           *pos, range_iter.boundary, &mb);\n        clen += mb.size;\n\n        \n        clen += (*pos)->length;\n\n        debugs(33, 6, \"STR\" << clen);\n        ++pos;\n    }\n\n    \n    mb.reset();\n\n    clientPackTermBound(range_iter.boundary, &mb);\n\n    clen += mb.size;\n\n    mb.clean();\n\n    return clen;\n}","22884":"Pl_AES_PDF::~Pl_AES_PDF()\n{\n    delete [] this->key;\n    delete [] this->rk;\n}","22742":"zzip_mem_disk_entry_to_file_header(ZZIP_MEM_DISK* dir, \n\t\t\t\t   ZZIP_DISK_ENTRY* entry) {\n    return zzip_disk_entry_to_file_header(dir->disk, entry); }","22472":"static const char *txtin_probe_data(const u8 *data, u32 data_size, GF_FilterProbeScore *score)\n{\n\tchar *dst = NULL;\n\tu8 *res;\n\n\tres = gf_utf_get_utf8_string_from_bom((char *)data, data_size, &dst);\n\tif (res) data = res;\n\n\n\t\t*score = _score;\\\n\t\tif (dst) gf_free(dst);\\\n\t\treturn _mime; \\\n\n\n\tif (!strncmp(data, \"STR\", 6)) {\n\t\tPROBE_OK(GF_FPROBE_SUPPORTED, \"STR\")\n\t}\n\tif (strstr(data, \"STR\")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"STR\")\n\t}\n\tif (!strncmp(data, \"STR\", 3)) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"STR\")\n\t}\n\n\tif ((data[0]=='{') && strstr(data, \"STR\")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"STR\")\n\n\t}\n\t\n\tif (!strstr(data, \"STR\") ) {\n\t\tif (dst) gf_free(dst);\n\t\treturn NULL;\n\t}\n\n\tif (strstr(data, \"STR\")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"STR\")\n\t}\n\tif (strstr(data, \"STR\")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"STR\")\n\t}\n\tif (strstr(data, \"STR\")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"STR\")\n\t}\n\n\tif (dst) gf_free(dst);\n\treturn NULL;","22957":"Status CreateTempFile(Env* env, float value, uint64 size, string* filename) {\n  const string dir = testing::TmpDir();\n  *filename = io::JoinPath(dir, strings::StrCat(\"STR\", value));\n  std::unique_ptr<WritableFile> file;\n  TF_RETURN_IF_ERROR(env->NewWritableFile(*filename, &file));\n  for (uint64 i = 0; i < size; ++i) {\n    StringPiece sp(static_cast<char*>(static_cast<void*>(&value)),\n                   sizeof(value));\n    TF_RETURN_IF_ERROR(file->Append(sp));\n  }\n  TF_RETURN_IF_ERROR(file->Close());\n  return Status::OK();\n}","22568":"mp_capable_print(netdissect_options *ndo,\n                 const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_capable *mpc = (const struct mp_capable *) opt;\n\n        if (!(opt_len == 12 && flags & TH_SYN) &&\n            !(opt_len == 20 && (flags & (TH_SYN | TH_ACK)) == TH_ACK))\n                return 0;\n\n        if (MP_CAPABLE_OPT_VERSION(mpc->sub_ver) != 0) {\n                ND_PRINT((ndo, \"STR\", MP_CAPABLE_OPT_VERSION(mpc->sub_ver)));\n                return 1;\n        }\n\n        if (mpc->flags & MP_CAPABLE_C)\n                ND_PRINT((ndo, \"STR\"));\n        ND_PRINT((ndo, \"STR\" PRIx64, EXTRACT_64BITS(mpc->sender_key)));\n        if (opt_len == 20) \n                ND_PRINT((ndo, \"STR\" PRIx64, EXTRACT_64BITS(mpc->receiver_key)));\n        ND_PRINT((ndo, \"STR\"));\n        return 1;\n}","23795":"print_header (struct tar_stat_info *st, union block *blk,\n\t      off_t block_ordinal)\n{\n  if (current_format == POSIX_FORMAT && !volume_label_printed && volume_label)\n    {\n      print_volume_label ();\n      volume_label_printed = true;\n    }\n\n  simple_print_header (st, blk, block_ordinal);\n}","22866":"static void bdrv_dmg_init(void)\n{\n    bdrv_register(&bdrv_dmg);\n}","23230":"int test_gf2m_mod(BIO *bp)\n{\n    BIGNUM *a, *b[2], *c, *d, *e;\n    int i, j, ret = 0;\n    int p0[] = { 163, 7, 6, 3, 0, -1 };\n    int p1[] = { 193, 15, 0, -1 };\n\n    a = BN_new();\n    b[0] = BN_new();\n    b[1] = BN_new();\n    c = BN_new();\n    d = BN_new();\n    e = BN_new();\n\n    BN_GF2m_arr2poly(p0, b[0]);\n    BN_GF2m_arr2poly(p1, b[1]);\n\n    for (i = 0; i < num0; i++) {\n        BN_bntest_rand(a, 1024, 0, 0);\n        for (j = 0; j < 2; j++) {\n            BN_GF2m_mod(c, a, b[j]);\n# if 0                          \n            if (bp != NULL) {\n                if (!results) {\n                    BN_print(bp, a);\n                    BIO_puts(bp, \"STR\");\n                    BN_print(bp, b[j]);\n                    BIO_puts(bp, \"STR\");\n                    BN_print(bp, c);\n                    BIO_puts(bp, \"STR\");\n                }\n            }\n# endif\n            BN_GF2m_add(d, a, c);\n            BN_GF2m_mod(e, d, b[j]);\n            \n            if (!BN_is_zero(e)) {\n                fprintf(stderr, \"STR\");\n                goto err;\n            }\n        }\n    }\n    ret = 1;\n err:\n    BN_free(a);\n    BN_free(b[0]);\n    BN_free(b[1]);\n    BN_free(c);\n    BN_free(d);\n    BN_free(e);\n    return ret;\n}","23660":"static u16 map_class(u16 pol_value)\n{\n\tu16 i;\n\n\tfor (i = 1; i < current_mapping_size; i++) {\n\t\tif (current_mapping[i].value == pol_value)\n\t\t\treturn i;\n\t}\n\n\treturn SECCLASS_NULL;\n}","23177":"static void qemu_input_queue_process(void *opaque)\n{\n    struct QemuInputEventQueueHead *queue = opaque;\n    QemuInputEventQueue *item;\n\n    g_assert(!QTAILQ_EMPTY(queue));\n    item = QTAILQ_FIRST(queue);\n    g_assert(item->type == QEMU_INPUT_QUEUE_DELAY);\n    QTAILQ_REMOVE(queue, item, node);\n    g_free(item);\n\n    while (!QTAILQ_EMPTY(queue)) {\n        item = QTAILQ_FIRST(queue);\n        switch (item->type) {\n        case QEMU_INPUT_QUEUE_DELAY:\n            timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)\n                      + item->delay_ms);\n            return;\n        case QEMU_INPUT_QUEUE_EVENT:\n            qemu_input_event_send(item->src, item->evt);\n            qapi_free_InputEvent(item->evt);\n            break;\n        case QEMU_INPUT_QUEUE_SYNC:\n            qemu_input_event_sync();\n            break;\n        }\n        QTAILQ_REMOVE(queue, item, node);\n        queue_count--;\n        g_free(item);\n    }\n}","22580":"bilinear_box_make_weights (PixopsFilterDimension *dim,\n\t\t\t   double                 scale)\n{\n  int n = ceil (1\/scale + 3.0);\n  double *pixel_weights = g_malloc_n (sizeof (double) * SUBSAMPLE, n);\n  double w;\n  int offset, i;\n\n  dim->offset = -1.0;\n  dim->n = n;\n  dim->weights = pixel_weights;\n\n  for (offset = 0; offset < SUBSAMPLE; offset++)\n    {\n      double x = (double)offset \/ SUBSAMPLE;\n      double a = x + 1 \/ scale;\n\n      for (i = 0; i < n; i++)\n        {\n          w  = linear_box_half (0.5 + i - a, 0.5 + i - x);\n          w += linear_box_half (1.5 + x - i, 1.5 + a - i);\n      \n          *(pixel_weights++) = w * scale;\n        }\n    }\n}","23500":"BitStream::getBits(int nbits)\n{\n    return read_bits(this->p, this->bit_offset,\n\t\t     this->bits_available, nbits);\n}","23677":"decompileCAST(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *iparam=pop();\n\tstruct SWF_ACTIONPUSHPARAM *tparam=pop();\n\tpush(newVar_N( getName(tparam),\"STR\")); \n\treturn 0;\n}","23508":"  bool set(DTCollation &dt1, DTCollation &dt2, uint flags= 0)\n  { set(dt1); return aggregate(dt2, flags); }","23138":"    State()\n        : remote_encode_complete_(false), remote_decode_complete_(false), local_complete_(false),\n          has_1xx_headers_(false), created_filter_chain_(false), is_head_request_(false),\n          is_grpc_request_(false), non_100_response_headers_encoded_(false),\n          under_on_local_reply_(false), decoder_filter_chain_aborted_(false),\n          encoder_filter_chain_aborted_(false), saw_downstream_reset_(false) {}","22904":"static int tcm_loop_queue_status(struct se_cmd *se_cmd)\n{\n\tstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\n\t\t\t\tstruct tcm_loop_cmd, tl_se_cmd);\n\tstruct scsi_cmnd *sc = tl_cmd->sc;\n\n\tTL_CDB_DEBUG(\"STR\"\n\t\t\t\"STR\", sc, sc->cmnd[0]);\n\n\tif (se_cmd->sense_buffer &&\n\t   ((se_cmd->se_cmd_flags & SCF_TRANSPORT_TASK_SENSE) ||\n\t    (se_cmd->se_cmd_flags & SCF_EMULATED_TASK_SENSE))) {\n\n\t\tmemcpy(sc->sense_buffer, se_cmd->sense_buffer,\n\t\t\t\tSCSI_SENSE_BUFFERSIZE);\n\t\tsc->result = SAM_STAT_CHECK_CONDITION;\n\t\tset_driver_byte(sc, DRIVER_SENSE);\n\t} else\n\t\tsc->result = se_cmd->scsi_status;\n\n\tset_host_byte(sc, DID_OK);\n\tsc->scsi_done(sc);\n\treturn 0;\n}","23615":"DEFUN (neighbor_maximum_prefix_threshold_restart,\n       neighbor_maximum_prefix_threshold_restart_cmd,\n       NEIGHBOR_CMD2 \"STR\",\n       NEIGHBOR_STR\n       NEIGHBOR_ADDR_STR2\n       \"STR\"\n       \"STR\"\n       \"STR\"\n       \"STR\"\n       \"STR\")\n{\n  return peer_maximum_prefix_set_vty (vty, argv[0], bgp_node_afi (vty),\n\t\t\t\t      bgp_node_safi (vty), argv[1], argv[2], 0, argv[3]);\n}","23211":"static int open_cred_file(char *file_name,\n\t\t\tstruct parsed_mount_info *parsed_info)\n{\n\tchar *line_buf = NULL;\n\tchar *temp_val = NULL;\n\tFILE *fs = NULL;\n\tint i;\n\tconst int line_buf_size = 4096;\n\tconst int min_non_white = 10;\n\n\ti = toggle_dac_capability(0, 1);\n\tif (i)\n\t\tgoto return_i;\n\n\ti = access(file_name, R_OK);\n\tif (i) {\n\t\ttoggle_dac_capability(0, 0);\n\t\ti = errno;\n\t\tgoto return_i;\n\t}\n\n\tfs = fopen(file_name, \"STR\");\n\tif (fs == NULL) {\n\t\ttoggle_dac_capability(0, 0);\n\t\ti = errno;\n\t\tgoto return_i;\n\t}\n\n\ti = toggle_dac_capability(0, 0);\n\tif (i)\n\t\tgoto return_i;\n\n\tline_buf = (char *)malloc(line_buf_size);\n\tif (line_buf == NULL) {\n\t\ti = EX_SYSERR;\n\t\tgoto return_i;\n\t}\n\n\t\n\twhile (fgets(line_buf, line_buf_size, fs)) {\n\t\t\n\t\tfor (i = 0; i < line_buf_size - min_non_white + 1; i++) {\n\t\t\tif ((line_buf[i] != ' ') && (line_buf[i] != '\\t'))\n\t\t\t\tbreak;\n\t\t}\n\t\tnull_terminate_endl(line_buf);\n\n\t\t\n\t\tswitch (parse_cred_line(line_buf + i, &temp_val)) {\n\t\tcase CRED_USER:\n\t\t\tstrlcpy(parsed_info->username, temp_val,\n\t\t\t\tsizeof(parsed_info->username));\n\t\t\tparsed_info->got_user = 1;\n\t\t\tbreak;\n\t\tcase CRED_PASS:\n\t\t\ti = set_password(parsed_info, temp_val);\n\t\t\tif (i)\n\t\t\t\tgoto return_i;\n\t\t\tbreak;\n\t\tcase CRED_DOM:\n\t\t\tif (parsed_info->verboseflag)\n\t\t\t\tfprintf(stderr, \"STR\",\n\t\t\t\t\ttemp_val);\n\t\t\tstrlcpy(parsed_info->domain, temp_val,\n\t\t\t\tsizeof(parsed_info->domain));\n\t\t\tbreak;\n\t\tcase CRED_UNPARSEABLE:\n\t\t\tif (parsed_info->verboseflag)\n\t\t\t\tfprintf(stderr, \"STR\"\n\t\t\t\t\t\"STR\",\n\t\t\t\t\ttemp_val ? temp_val : \"STR\");\n\t\t\tbreak;\n\t\t}\n\t}\n\ti = 0;\nreturn_i:\n\tif (fs != NULL)\n\t\tfclose(fs);\n\n\t\n\tif (line_buf != NULL)\n\t\tmemset(line_buf, 0, line_buf_size);\n\tfree(line_buf);\n\treturn i;\n}","23286":"vmod_append(VRT_CTX, VCL_HEADER hdr, VCL_STRANDS s)\n{\n\tstruct http *hp;\n\tstruct strands st[1];\n\tconst char *p[s->n + 2];\n\tconst char *b;\n\n\tCHECK_OBJ_NOTNULL(ctx, VRT_CTX_MAGIC);\n\n\t\n\tp[0] = hdr->what + 1;\n\tp[1] = \"STR\";\n\tAN(memcpy(p + 2, s->p, s->n * sizeof *s->p));\n\tst->n = s->n + 2;\n\tst->p = p;\n\n\tb = VRT_StrandsWS(ctx->ws, NULL, st);\n\n\thp = VRT_selecthttp(ctx, hdr->where);\n\thttp_SetHeader(hp, b);\n}","22648":"static bool decode_paged_results_request(void *mem_ctx, DATA_BLOB in, void *_out)\n{\n\tvoid **out = (void **)_out;\n\tDATA_BLOB cookie;\n\tstruct asn1_data *data = asn1_init(mem_ctx);\n\tstruct ldb_paged_control *lprc;\n\n\tif (!data) return false;\n\n\tif (!asn1_load(data, in)) {\n\t\treturn false;\n\t}\n\n\tlprc = talloc(mem_ctx, struct ldb_paged_control);\n\tif (!lprc) {\n\t\treturn false;\n\t}\n\n\tif (!asn1_start_tag(data, ASN1_SEQUENCE(0))) {\n\t\treturn false;\n\t}\n\n\tif (!asn1_read_Integer(data, &(lprc->size))) {\n\t\treturn false;\n\t}\n\t\n\tif (!asn1_read_OctetString(data, mem_ctx, &cookie)) {\n\t\treturn false;\n\t}\n\tlprc->cookie_len = cookie.length;\n\tif (lprc->cookie_len) {\n\t\tlprc->cookie = talloc_memdup(lprc, cookie.data, cookie.length);\n\n\t\tif (!(lprc->cookie)) {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tlprc->cookie = NULL;\n\t}\n\n\tif (!asn1_end_tag(data)) {\n\t\treturn false;\n\t}\n\n\t*out = lprc;\n\n\treturn true;\n}","23318":"void posix_cpu_timers_exit_group(struct task_struct *tsk)\n{\n\tcleanup_timers(tsk->signal->cpu_timers,\n\t\t       cputime_add(tsk->utime, tsk->signal->utime),\n\t\t       cputime_add(tsk->stime, tsk->signal->stime),\n\t\t     tsk->se.sum_exec_runtime + tsk->signal->sum_sched_runtime);\n}","23620":"static void my_output_message(j_common_ptr cinfo)\n{\n  (*cinfo->err->format_message) (cinfo, errStr);\n}","23116":"SMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t  unsigned int *nbytes, char **buf, int *buf_type)\n{\n\tstruct smb_rqst rqst;\n\tint resp_buftype, rc = -EACCES;\n\tstruct smb2_read_plain_req *req = NULL;\n\tstruct smb2_read_rsp *rsp = NULL;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tunsigned int total_len;\n\tint flags = CIFS_LOG_ERROR;\n\tstruct cifs_ses *ses = io_parms->tcon->ses;\n\n\t*nbytes = 0;\n\trc = smb2_new_read_req((void **)&req, &total_len, io_parms, NULL, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (smb3_encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tiov[0].iov_base = (char *)req;\n\tiov[0].iov_len = total_len;\n\n\tmemset(&rqst, 0, sizeof(struct smb_rqst));\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 1;\n\n\trc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);\n\trsp = (struct smb2_read_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\tif (rc != -ENODATA) {\n\t\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);\n\t\t\tcifs_dbg(VFS, \"STR\", rc);\n\t\t\ttrace_smb3_read_err(xid, req->PersistentFileId,\n\t\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t\t    io_parms->offset, io_parms->length,\n\t\t\t\t\t    rc);\n\t\t} else\n\t\t\ttrace_smb3_read_done(xid, req->PersistentFileId,\n\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t    io_parms->offset, 0);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t\treturn rc == -ENODATA ? 0 : rc;\n\t} else\n\t\ttrace_smb3_read_done(xid, req->PersistentFileId,\n\t\t\t\t    io_parms->tcon->tid, ses->Suid,\n\t\t\t\t    io_parms->offset, io_parms->length);\n\n\tcifs_small_buf_release(req);\n\n\t*nbytes = le32_to_cpu(rsp->DataLength);\n\tif ((*nbytes > CIFS_MAX_MSGSIZE) ||\n\t    (*nbytes > io_parms->length)) {\n\t\tcifs_dbg(FYI, \"STR\",\n\t\t\t *nbytes, io_parms->length);\n\t\trc = -EIO;\n\t\t*nbytes = 0;\n\t}\n\n\tif (*buf) {\n\t\tmemcpy(*buf, (char *)rsp + rsp->DataOffset, *nbytes);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t} else if (resp_buftype != CIFS_NO_BUFFER) {\n\t\t*buf = rsp_iov.iov_base;\n\t\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\t\t*buf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\t\t*buf_type = CIFS_LARGE_BUFFER;\n\t}\n\treturn rc;\n}","23169":"TEST_P(DnsImplTest, MultiARecordLookupWithV6) {\n  server_->addHosts(\"STR\"}, RecordType::A);\n  server_->addHosts(\"STR\"}, RecordType::AAAA);\n\n  EXPECT_NE(nullptr,\n            resolveWithExpectations(\"STR\", DnsLookupFamily::V4Only,\n                                    DnsResolver::ResolutionStatus::Success,\n                                    {\"STR\"}, {}, absl::nullopt));\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n\n  EXPECT_NE(nullptr, resolveWithExpectations(\"STR\", DnsLookupFamily::Auto,\n                                             DnsResolver::ResolutionStatus::Success,\n                                             {{\"STR\"}}, {}, absl::nullopt));\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n\n  EXPECT_NE(nullptr, resolveWithExpectations(\"STR\", DnsLookupFamily::V6Only,\n                                             DnsResolver::ResolutionStatus::Success,\n                                             {{\"STR\"}}, {}, absl::nullopt));\n  dispatcher_->run(Event::Dispatcher::RunType::Block);\n}","23273":"bgp_attr_atomic (struct peer *peer, bgp_size_t length, \n\t\t struct attr *attr, u_char flag, u_char *startp)\n{\n  bgp_size_t total;\n\n  total = length + (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN) ? 4 : 3);\n  \n  if (bgp_attr_flag_invalid (peer, BGP_ATTR_ATOMIC_AGGREGATE, flag))\n    return bgp_attr_malformed (peer, BGP_ATTR_ATOMIC_AGGREGATE, flag,\n                               BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,\n                               startp, total);\n  \n  \n  if (length != 0)\n    {\n      zlog (peer->log, LOG_ERR, \"STR\", length);\n      return bgp_attr_malformed (peer, BGP_ATTR_ATOMIC_AGGREGATE, flag,\n                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n                                 startp, total);\n    }\n\n  \n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}","22903":"static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_cipher rcipher;\n\n\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \"STR\");\n\n\trcipher.blocksize = alg->cra_blocksize;\n\trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t    sizeof(struct crypto_report_cipher), &rcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}","23317":"static int usbredir_is_cancelled(USBRedirDevice *dev, uint64_t id)\n{\n    if (!dev->dev.attached) {\n        return 1; \n    }\n    return packet_id_queue_remove(&dev->cancelled, id);\n}","22785":"static int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\n\tBT_DBG(\"STR\", sock, sk);\n\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = sco_send_frame(sk, msg, len);\n\telse\n\t\terr = -ENOTCONN;\n\n\trelease_sock(sk);\n\treturn err;\n}","23709":"void exit_io_context(void)\n{\n\tstruct io_context *ioc;\n\n\ttask_lock(current);\n\tioc = current->io_context;\n\tcurrent->io_context = NULL;\n\ttask_unlock(current);\n\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\n\t}\n\tput_io_context(ioc);\n}","23680":"static int f2fs_quota_on_mount(struct f2fs_sb_info *sbi, int type)\n{\n\treturn dquot_quota_on_mount(sbi->sb, sbi->s_qf_names[type],\n\t\t\t\t\t\tsbi->s_jquota_fmt, type);\n}","23220":"bool BitTestMatchExpression::equivalent(const MatchExpression* other) const {\n    if (matchType() != other->matchType()) {\n        return false;\n    }\n\n    const BitTestMatchExpression* realOther = static_cast<const BitTestMatchExpression*>(other);\n\n    std::vector<uint32_t> myBitPositions = getBitPositions();\n    std::vector<uint32_t> otherBitPositions = realOther->getBitPositions();\n    std::sort(myBitPositions.begin(), myBitPositions.end());\n    std::sort(otherBitPositions.begin(), otherBitPositions.end());\n\n    return path() == realOther->path() && myBitPositions == otherBitPositions;\n}","22894":"VTermState *vterm_obtain_state(VTerm *vt)\n{\n  VTermState *state;\n  if(vt->state)\n    return vt->state;\n\n  state = vterm_state_new(vt);\n  vt->state = state;\n\n  state->combine_chars_size = 16;\n  state->combine_chars = vterm_allocator_malloc(state->vt, state->combine_chars_size * sizeof(state->combine_chars[0]));\n\n  state->tabstops = vterm_allocator_malloc(state->vt, (state->cols + 7) \/ 8);\n\n  state->lineinfo = vterm_allocator_malloc(state->vt, state->rows * sizeof(VTermLineInfo));\n\n  state->encoding_utf8.enc = vterm_lookup_encoding(ENC_UTF8, 'u');\n  if(*state->encoding_utf8.enc->init != NULL)\n    (*state->encoding_utf8.enc->init)(state->encoding_utf8.enc, state->encoding_utf8.data);\n\n  vterm_parser_set_callbacks(vt, &parser_callbacks, state);\n\n  return state;\n}","22749":"libvirt_vmessage(xentoollog_logger *logger_in,\n                 xentoollog_level level,\n                 int errnoval,\n                 const char *context,\n                 const char *format,\n                 va_list args)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt *)logger_in;\n    FILE *logFile = lg->defaultLogFile;\n    char timestamp[VIR_TIME_STRING_BUFLEN];\n    g_autofree char *message = NULL;\n    char *start, *end;\n\n    VIR_DEBUG(\"STR\", context, format);\n\n    if (level < lg->minLevel)\n        return;\n\n    message = g_strdup_vprintf(format, args);\n\n    \n    if ((start = strstr(message, \"STR\")) &&\n        (end = strstr(start + 9, \"STR\"))) {\n        FILE *domainLogFile;\n\n        VIR_DEBUG(\"STR\");\n\n        start = start + 9;\n        *end = '\\0';\n\n        domainLogFile = virHashLookup(lg->files, start);\n        if (domainLogFile)\n            logFile = domainLogFile;\n\n        *end = ':';\n    }\n\n    \n    if (virTimeStringNowRaw(timestamp) < 0)\n        timestamp[0] = '\\0';\n\n    fprintf(logFile, \"STR\", timestamp);\n    if (context)\n        fprintf(logFile, \"STR\", context);\n\n    fprintf(logFile, \"STR\", message);\n\n    if (errnoval >= 0)\n        fprintf(logFile, \"STR\", g_strerror(errnoval));\n\n    fputc('\\n', logFile);\n    fflush(logFile);\n}","22563":"void mlock_vma_page(struct page *page)\n{\n\tBUG_ON(!PageLocked(page));\n\n\tif (!TestSetPageMlocked(page)) {\n\t\tmod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t\tif (!isolate_lru_page(page))\n\t\t\tputback_lru_page(page);\n\t}\n}","23649":"rfbSetClientColourMap(rfbClientPtr cl, int firstColour, int nColours)\n{\n    if (cl->screen->serverFormat.trueColour || !cl->readyForSetColourMapEntries) {\n\treturn TRUE;\n    }\n\n    if (nColours == 0) {\n\tnColours = cl->screen->colourMap.count;\n    }\n\n    if (cl->format.trueColour) {\n\tLOCK(cl->updateMutex);\n\t(*rfbInitColourMapSingleTableFns\n\t    [BPP2OFFSET(cl->format.bitsPerPixel)]) (&cl->translateLookupTable,\n\t\t\t\t\t     &cl->screen->serverFormat, &cl->format,&cl->screen->colourMap);\n\n\tsraRgnDestroy(cl->modifiedRegion);\n\tcl->modifiedRegion =\n\t  sraRgnCreateRect(0,0,cl->screen->width,cl->screen->height);\n\tUNLOCK(cl->updateMutex);\n\n\treturn TRUE;\n    }\n\n    return rfbSendSetColourMapEntries(cl, firstColour, nColours);\n}","23403":"static int get_pipe(struct stub_device *sdev, int epnum, int dir)\n{\n\tstruct usb_device *udev = sdev->udev;\n\tstruct usb_host_endpoint *ep;\n\tstruct usb_endpoint_descriptor *epd = NULL;\n\n\tif (epnum < 0 || epnum > 15)\n\t\tgoto err_ret;\n\n\tif (dir == USBIP_DIR_IN)\n\t\tep = udev->ep_in[epnum & 0x7f];\n\telse\n\t\tep = udev->ep_out[epnum & 0x7f];\n\tif (!ep)\n\t\tgoto err_ret;\n\n\tepd = &ep->desc;\n\tif (usb_endpoint_xfer_control(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndctrlpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvctrlpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_bulk(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndbulkpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvbulkpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_int(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndintpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvintpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_isoc(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndisocpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvisocpipe(udev, epnum);\n\t}\n\nerr_ret:\n\t\n\tdev_err(&sdev->udev->dev, \"STR\", epnum);\n\treturn -1;\n}","23219":"bool kvm_vcpu_is_visible_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tstruct kvm_memory_slot *memslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\n\treturn kvm_is_visible_memslot(memslot);\n}","22702":"    Tfloat linear_atXYZ(const float fx, const float fy, const float fz, const int c, const T& out_value) const {\n      const int\n        x = (int)fx - (fx>=0?0:1), nx = x + 1,\n        y = (int)fy - (fy>=0?0:1), ny = y + 1,\n        z = (int)fz - (fz>=0?0:1), nz = z + 1;\n      const float\n        dx = fx - x,\n        dy = fy - y,\n        dz = fz - z;\n      const Tfloat\n        Iccc = (Tfloat)atXYZ(x,y,z,c,out_value), Incc = (Tfloat)atXYZ(nx,y,z,c,out_value),\n        Icnc = (Tfloat)atXYZ(x,ny,z,c,out_value), Innc = (Tfloat)atXYZ(nx,ny,z,c,out_value),\n        Iccn = (Tfloat)atXYZ(x,y,nz,c,out_value), Incn = (Tfloat)atXYZ(nx,y,nz,c,out_value),\n        Icnn = (Tfloat)atXYZ(x,ny,nz,c,out_value), Innn = (Tfloat)atXYZ(nx,ny,nz,c,out_value);\n      return Iccc +\n        (Incc - Iccc +\n         (Iccc + Innc - Icnc - Incc +\n          (Iccn + Innn + Icnc + Incc - Icnn - Incn - Iccc - Innc)*dz)*dy +\n         (Iccc + Incn - Iccn - Incc)*dz)*dx +\n        (Icnc - Iccc +\n         (Iccc + Icnn - Iccn - Icnc)*dz)*dy +\n        (Iccn - Iccc)*dz;\n    }","22772":"static int hw_atl_utils_write_b1_mbox(struct aq_hw_s *self, u32 addr,\n\t\t\t\t      u32 *p, u32 cnt, enum mcp_area area)\n{\n\tu32 data_offset = 0;\n\tu32 offset = addr;\n\tint err = 0;\n\tu32 val;\n\n\tswitch (area) {\n\tcase MCP_AREA_CONFIG:\n\t\toffset -= self->rpc_addr;\n\t\tbreak;\n\n\tcase MCP_AREA_SETTINGS:\n\t\toffset -= self->settings_addr;\n\t\tbreak;\n\t}\n\n\toffset = offset \/ sizeof(u32);\n\n\tfor (; data_offset < cnt; ++data_offset, ++offset) {\n\t\taq_hw_write_reg(self, 0x328, p[data_offset]);\n\t\taq_hw_write_reg(self, 0x32C,\n\t\t\t\t(area | (0xFFFF & (offset * 4))));\n\t\thw_atl_mcp_up_force_intr_set(self, 1);\n\t\t\n\t\terr = readx_poll_timeout_atomic(hw_atl_scrpad12_get,\n\t\t\t\t\t\tself, val,\n\t\t\t\t\t\t(val & 0xF0000000) !=\n\t\t\t\t\t\tarea,\n\t\t\t\t\t\t10U, 10000U);\n\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}","23369":"llsec_key_alloc(const struct ieee802154_llsec_key *template)\n{\n\tconst int authsizes[3] = { 4, 8, 16 };\n\tstruct mac802154_llsec_key *key;\n\tint i;\n\n\tkey = kzalloc(sizeof(*key), GFP_KERNEL);\n\tif (!key)\n\t\treturn NULL;\n\n\tkref_init(&key->ref);\n\tkey->key = *template;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(authsizes) != ARRAY_SIZE(key->tfm));\n\n\tfor (i = 0; i < ARRAY_SIZE(key->tfm); i++) {\n\t\tkey->tfm[i] = crypto_alloc_aead(\"STR\", 0,\n\t\t\t\t\t\tCRYPTO_ALG_ASYNC);\n\t\tif (IS_ERR(key->tfm[i]))\n\t\t\tgoto err_tfm;\n\t\tif (crypto_aead_setkey(key->tfm[i], template->key,\n\t\t\t\t       IEEE802154_LLSEC_KEY_SIZE))\n\t\t\tgoto err_tfm;\n\t\tif (crypto_aead_setauthsize(key->tfm[i], authsizes[i]))\n\t\t\tgoto err_tfm;\n\t}\n\n\tkey->tfm0 = crypto_alloc_sync_skcipher(\"STR\", 0, 0);\n\tif (IS_ERR(key->tfm0))\n\t\tgoto err_tfm;\n\n\tif (crypto_sync_skcipher_setkey(key->tfm0, template->key,\n\t\t\t\t   IEEE802154_LLSEC_KEY_SIZE))\n\t\tgoto err_tfm0;\n\n\treturn key;\n\nerr_tfm0:\n\tcrypto_free_sync_skcipher(key->tfm0);\nerr_tfm:\n\tfor (i = 0; i < ARRAY_SIZE(key->tfm); i++)\n\t\tif (key->tfm[i])\n\t\t\tcrypto_free_aead(key->tfm[i]);\n\n\tkfree_sensitive(key);\n\treturn NULL;\n}","22836":" *\/\nint re_yyget_lineno  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    \n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    \n    return yylineno;","23224":"void moov_box_del(GF_Box *s)\n{\n\tGF_MovieBox *ptr = (GF_MovieBox *)s;\n\tif (ptr == NULL) return;\n\tgf_list_del(ptr->trackList);\n\tgf_free(ptr);\n}","23381":"HttpTransact::is_stale_cache_response_returnable(State* s)\n{\n  HTTPHdr *cached_response = s->cache_info.object_read->response_get();\n\n  \n  \n  \n  \n  if (!s->cache_info.directives.does_client_permit_lookup) {\n    return false;\n  }\n  \n  \n  \n  uint32_t cc_mask;\n  cc_mask = (MIME_COOKED_MASK_CC_MUST_REVALIDATE |\n             MIME_COOKED_MASK_CC_PROXY_REVALIDATE |\n             MIME_COOKED_MASK_CC_NEED_REVALIDATE_ONCE |\n             MIME_COOKED_MASK_CC_NO_CACHE | MIME_COOKED_MASK_CC_NO_STORE | MIME_COOKED_MASK_CC_S_MAXAGE);\n  if ((cached_response->get_cooked_cc_mask() & cc_mask) || cached_response->is_pragma_no_cache_set()) {\n    DebugTxn(\"STR\");\n    return false;\n  }\n  \n  \n  time_t current_age = HttpTransactHeaders::calculate_document_age(s->cache_info.object_read->request_sent_time_get(),\n                                                                   s->cache_info.object_read->response_received_time_get(),\n                                                                   cached_response,\n                                                                   cached_response->get_date(),\n                                                                   s->current.now);\n  \n  if ((current_age < 0) || (current_age > s->txn_conf->cache_max_stale_age)) {\n    DebugTxn(\"STR\" PRId64,\n             (int64_t)current_age);\n    return false;\n  }\n  \n  Authentication_t auth_needed = AuthenticationNeeded(s->txn_conf, &s->hdr_info.client_request, cached_response);\n\n  if (auth_needed != AUTHENTICATION_SUCCESS) {\n    DebugTxn(\"STR\");\n    return false;\n  }\n\n  DebugTxn(\"STR\");\n  return true;\n}","22857":"virgl_cmd_get_capset_info(VuGpu *g,\n                          struct virtio_gpu_ctrl_command *cmd)\n{\n    struct virtio_gpu_get_capset_info info;\n    struct virtio_gpu_resp_capset_info resp;\n\n    VUGPU_FILL_CMD(info);\n\n    if (info.capset_index == 0) {\n        resp.capset_id = VIRTIO_GPU_CAPSET_VIRGL;\n        virgl_renderer_get_cap_set(resp.capset_id,\n                                   &resp.capset_max_version,\n                                   &resp.capset_max_size);\n    } else if (info.capset_index == 1) {\n        resp.capset_id = VIRTIO_GPU_CAPSET_VIRGL2;\n        virgl_renderer_get_cap_set(resp.capset_id,\n                                   &resp.capset_max_version,\n                                   &resp.capset_max_size);\n    } else {\n        resp.capset_max_version = 0;\n        resp.capset_max_size = 0;\n    }\n    resp.hdr.type = VIRTIO_GPU_RESP_OK_CAPSET_INFO;\n    vg_ctrl_response(g, cmd, &resp.hdr, sizeof(resp));\n}","23265":"void ZipTest::testCrcAndSizeAfterData()\n{\n\tstd::string testFile = getTestFile(\"STR\");\n\tstd::ifstream inp(testFile.c_str(), std::ios::binary);\n\tassert (inp.good());\n\tDecompress dec(inp, Poco::Path());\n\tdec.EError += Poco::Delegate<ZipTest, std::pair<const Poco::Zip::ZipLocalFileHeader, const std::string> >(this, &ZipTest::onDecompressError);\n\tdec.decompressAllFiles();\n\tdec.EError -= Poco::Delegate<ZipTest, std::pair<const Poco::Zip::ZipLocalFileHeader, const std::string> >(this, &ZipTest::onDecompressError);\n\tassert (_errCnt == 0);\n\tassert (!dec.mapping().empty());\n}","22756":"static void addLengthDistance(uivector* values, size_t length, size_t distance)\n{\n  \n\n  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);\n  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);\n  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);\n  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);\n\n  uivector_push_back(values, length_code + FIRST_LENGTH_CODE_INDEX);\n  uivector_push_back(values, extra_length);\n  uivector_push_back(values, dist_code);\n  uivector_push_back(values, extra_distance);\n}","22572":"static struct ip_options *tcp_v4_save_options(struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ip_options *opt = &(IPCB(skb)->opt);\n\tstruct ip_options *dopt = NULL;\n\n\tif (opt && opt->optlen) {\n\t\tint opt_size = optlength(opt);\n\t\tdopt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (dopt) {\n\t\t\tif (ip_options_echo(dopt, skb)) {\n\t\t\t\tkfree(dopt);\n\t\t\t\tdopt = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn dopt;\n}","23377":"notify_exec(const notify_script_t *script)\n{\n\tpid_t pid;\n\n\tif (log_file_name)\n\t\tflush_log_file();\n\n\tpid = local_fork();\n\n\tif (pid < 0) {\n\t\t\n\t\tlog_message(LOG_INFO, \"STR\");\n\t\treturn -1;\n\t}\n\n\tif (pid) {\n\t\t\n\t\treturn 0;\n\t}\n\n#ifdef _MEM_CHECK_\n\tskip_mem_dump();\n#endif\n\n\tsystem_call(script);\n\n\t\n\texit(0);\n}","22928":"\nstatic void kvm_swap_active_memslots(struct kvm *kvm, int as_id)\n{\n\tstruct kvm_memslots *slots = kvm_get_inactive_memslots(kvm, as_id);\n\n\t\n\tu64 gen = __kvm_memslots(kvm, as_id)->generation;\n\n\tWARN_ON(gen & KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS);\n\tslots->generation = gen | KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS;\n\n\t\n\tspin_lock(&kvm->mn_invalidate_lock);\n\tprepare_to_rcuwait(&kvm->mn_memslots_update_rcuwait);\n\twhile (kvm->mn_active_invalidate_count) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&kvm->mn_invalidate_lock);\n\t\tschedule();\n\t\tspin_lock(&kvm->mn_invalidate_lock);\n\t}\n\tfinish_rcuwait(&kvm->mn_memslots_update_rcuwait);\n\trcu_assign_pointer(kvm->memslots[as_id], slots);\n\tspin_unlock(&kvm->mn_invalidate_lock);\n\n\t\n\tmutex_unlock(&kvm->slots_arch_lock);\n\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\n\t\n\tgen = slots->generation & ~KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS;\n\n\t\n\tgen += KVM_ADDRESS_SPACE_NUM;\n\n\tkvm_arch_memslots_updated(kvm, gen);\n\n\tslots->generation = gen;","23588":"void ElectronBrowserHandlerImpl::UpdateDraggableRegions(\n    std::vector<mojom::DraggableRegionPtr> regions) {\n  api::WebContents* api_web_contents = api::WebContents::From(web_contents());\n  if (api_web_contents) {\n    api_web_contents->UpdateDraggableRegions(std::move(regions));\n  }\n}","23118":"libssh2_channel_eof(LIBSSH2_CHANNEL * channel)\n{\n    LIBSSH2_SESSION *session;\n    LIBSSH2_PACKET *packet;\n\n    if(!channel)\n        return LIBSSH2_ERROR_BAD_USE;\n\n    session = channel->session;\n    packet = _libssh2_list_first(&session->packets);\n\n    while(packet) {\n        if(((packet->data[0] == SSH_MSG_CHANNEL_DATA)\n             || (packet->data[0] == SSH_MSG_CHANNEL_EXTENDED_DATA))\n            && (channel->local.id == _libssh2_ntohu32(packet->data + 1))) {\n            \n            return 0;\n        }\n        packet = _libssh2_list_next(&packet->node);\n    }\n\n    return channel->remote.eof;\n}","23293":"static void opj_pi_emit_error(opj_pi_iterator_t * pi, const char* msg)\n{\n    (void)pi;\n    (void)msg;\n}","23178":"void uwbd_stop(struct uwb_rc *rc)\n{\n\tkthread_stop(rc->uwbd.task);\n\tuwbd_flush(rc);\n}","23701":"static int serial_ir_suspend(struct platform_device *dev,\n\t\t\t     pm_message_t state)\n{\n\t\n\tsoutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));\n\n\t\n\tsoutp(UART_IER, sinp(UART_IER) &\n\t      (~(UART_IER_MSI | UART_IER_RLSI | UART_IER_THRI | UART_IER_RDI)));\n\n\t\n\tsinp(UART_LSR);\n\tsinp(UART_RX);\n\tsinp(UART_IIR);\n\tsinp(UART_MSR);\n\n\treturn 0;\n}","22967":"static char *ask_new_shell(char *question, char *oldshell)\n{\n\tint len;\n\tchar *ans = NULL;\n#ifdef HAVE_LIBREADLINE\n\trl_attempted_completion_function = shell_name_completion;\n#else\n\tsize_t dummy = 0;\n#endif\n\tif (!oldshell)\n\t\toldshell = \"\";\n\tprintf(\"STR\", question, oldshell);\n#ifdef HAVE_LIBREADLINE\n\tif ((ans = readline(\"STR\")) == NULL)\n#else\n\tputchar(' ');\n\tfflush(stdout);\n\tif (getline(&ans, &dummy, stdin) < 0)\n#endif\n\t\treturn NULL;\n\t\n\tltrim_whitespace((unsigned char *) ans);\n\tlen = rtrim_whitespace((unsigned char *) ans);\n\tif (len == 0)\n\t\treturn NULL;\n\treturn ans;\n}","22645":"static void do_fcc(script_data_t *sdata, sieve_fileinto_context_t *fcc,\n                   struct buf *header, const char *msg, struct buf *footer)\n{\n    struct appendstate as;\n    const char *userid;\n    char *intname;\n    int r = IMAP_MAILBOX_NONEXISTENT;\n\n    userid = mbname_userid(sdata->mbname);\n\n    if (fcc->specialuse) {\n        intname = mboxname_from_external(fcc->specialuse, sdata->ns, userid);\n        r = mboxlist_lookup(intname, NULL, NULL);\n        if (r) free(intname);\n    }\n    if (r) intname = mboxname_from_externalUTF8(fcc->mailbox, sdata->ns, userid);\n\n    r = mboxlist_lookup(intname, NULL, NULL);\n    if (r == IMAP_MAILBOX_NONEXISTENT) {\n        r = autosieve_createfolder(userid, sdata->authstate,\n                                   intname, fcc->do_create);\n\n        if (!r && fcc->specialuse) {\n            \n            struct buf specialuse = BUF_INITIALIZER;\n            int r2 = specialuse_validate(NULL, userid, fcc->specialuse, &specialuse);\n\n            if (!r2) {\n                annotatemore_write(intname, \"STR\", userid, &specialuse);\n            }\n            buf_free(&specialuse);\n        }\n    }\n    if (!r) {\n        r = append_setup(&as, intname, userid, sdata->authstate,\n                         0, NULL, NULL, 0, EVENT_MESSAGE_APPEND);\n    }\n    if (!r) {\n        struct stagemsg *stage;\n        \n        time_t internaldate = time(NULL) + 1;\n        FILE *f = append_newstage(intname, internaldate,\n                                  strhash(intname) ,\n                                  &stage);\n        if (f) {\n            struct body *body = NULL;\n\n            fprintf(f, \"STR\",\n                    buf_cstring(header), msg, buf_cstring(footer));\n            fclose(f);\n\n            r = append_fromstage(&as, &body, stage,\n                                 internaldate,  0,\n                                 fcc->imapflags, 0,  NULL);\n            if (!r) r = append_commit(&as);\n\n            if (body) {\n                message_free_body(body);\n                free(body);\n            }\n\n            append_removestage(stage);\n        }\n        if (r || !f) append_abort(&as);\n    }\n\n    if (r) {\n        syslog(LOG_NOTICE, \"STR\",\n               fcc->mailbox, error_message(r));\n    }\n\n    free(intname);\n}","23621":"void SM_io_parser<Decorator_>::print() const\n{\n  out << \"STR\" << std::endl;\n  out << \"STR\"  << vn << std::endl;\n  out << \"STR\"     << en << std::endl;\n  out << \"STR\"     << ln << std::endl;\n  out << \"STR\"     << fn << std::endl;\n  if (verbose)\n    out << \"STR\" << std::endl;\n  SVertex_iterator vit;\n  CGAL_forall_svertices(vit,*this) print_vertex(vit);\n  if (verbose)\n    out << \"STR\"\n        << std::endl;\n  SHalfedge_iterator eit;\n  CGAL_forall_shalfedges(eit,*this) print_edge(eit);\n  if (verbose)\n    out << \"STR\" << std::endl;\n  if ( this->has_shalfloop() )\n    { print_loop(this->shalfloop()); print_loop(this->shalfloop()->twin()); }\n  if (verbose)\n    out << \"STR\" << std::endl;\n  SFace_iterator fit;\n  CGAL_forall_sfaces(fit,*this) print_face(fit);\n  out.flush();\n  if (verbose) debug();\n}","22952":"static int l2cap_build_conf_req(struct sock *sk, void *data)\n{\n\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\tstruct l2cap_conf_req *req = data;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tvoid *ptr = req->data;\n\n\tBT_DBG(\"STR\", sk);\n\n\tswitch (pi->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tif (pi->imtu != L2CAP_DEFAULT_MTU)\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->imtu);\n\t\tbreak;\n\n\tcase L2CAP_MODE_ERTM:\n\t\trfc.mode            = L2CAP_MODE_ERTM;\n\t\trfc.txwin_size      = L2CAP_DEFAULT_RX_WINDOW;\n\t\trfc.max_transmit    = L2CAP_DEFAULT_MAX_RECEIVE;\n\t\trfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);\n\t\trfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);\n\t\trfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_RX_APDU);\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\t\tbreak;\n\t}\n\n\t\n\t\n\t\n\n\treq->dcid  = cpu_to_le16(pi->dcid);\n\treq->flags = cpu_to_le16(0);\n\n\treturn ptr - data;\n}","23174":"static inline int cipso_v4_validate(const struct sk_buff *skb,\n\t\t\t\t    unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char err_offset = 0;\n\tu8 opt_len = opt[1];\n\tu8 opt_iter;\n\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto out;\n\t}\n\n\tif (get_unaligned_be32(&opt[2]) == 0) {\n\t\terr_offset = 2;\n\t\tgoto out;\n\t}\n\n\tfor (opt_iter = 6; opt_iter < opt_len;) {\n\t\tif (opt[opt_iter + 1] > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto out;\n\t\t}\n\t\topt_iter += opt[opt_iter + 1];\n\t}\n\nout:\n\t*option = opt + err_offset;\n\treturn err_offset;\n\n}","22610":"FindEmptyObjectSlot(\n\t\t    TPMI_DH_OBJECT  *handle         \n\t\t    )\n{\n    UINT32               i;\n    OBJECT              *object;\n    for(i = 0; i < MAX_LOADED_OBJECTS; i++)\n\t{\n\t    object = &s_objects[i];\n\t    if(object->attributes.occupied == CLEAR)\n\t\t{\n\t\t    if(handle)\n\t\t\t*handle = i + TRANSIENT_FIRST;\n\t\t    \n\t\t    MemorySet(&object->attributes, 0, sizeof(OBJECT_ATTRIBUTES));\n\t\t    return object;\n\t\t}\n\t}\n    return NULL;\n}","23176":"file_extension(const char *s)\t\n{\n  const char\t*extension;\t\n  static char\tbuf[1024];\t\n\n\n  if (s == NULL)\n    return (NULL);\n  else if (!strncmp(s, \"STR\", 15))\n    return (\"STR\");\n  else if (!strncmp(s, \"STR\", 15))\n    return (\"STR\");\n  else if (!strncmp(s, \"STR\", 16))\n    return (\"STR\");\n  else if (!strncmp(s, \"STR\", 15))\n    return (\"STR\");\n  else if ((extension = strrchr(s, '\/')) != NULL)\n    extension ++;\n  else if ((extension = strrchr(s, '\\\\')) != NULL)\n    extension ++;\n  else\n    extension = s;\n\n  if ((extension = strrchr(extension, '.')) == NULL)\n    return (\"\");\n  else\n    extension ++;\n\n  if (strchr(extension, '#') == NULL)\n    return (extension);\n\n  strlcpy(buf, extension, sizeof(buf));\n\n  *(char *)strchr(buf, '#') = '\\0';\n\n  return (buf);\n}","23723":"CIFSSMBUnixQFileInfo(const int xid, struct cifs_tcon *tcon,\n\t\t u16 netfid, FILE_UNIX_BASIC_INFO *pFindData)\n{\n\tstruct smb_t2_qfi_req *pSMB = NULL;\n\tstruct smb_t2_qfi_rsp *pSMBr = NULL;\n\tint rc = 0;\n\tint bytes_returned;\n\t__u16 params, byte_count;\n\nUnixQFileInfoRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tparams = 2  + 2 ;\n\tpSMB->t2.TotalDataCount = 0;\n\tpSMB->t2.MaxParameterCount = cpu_to_le16(4);\n\t\n\tpSMB->t2.MaxDataCount = cpu_to_le16(CIFSMaxBufSize);\n\tpSMB->t2.MaxSetupCount = 0;\n\tpSMB->t2.Reserved = 0;\n\tpSMB->t2.Flags = 0;\n\tpSMB->t2.Timeout = 0;\n\tpSMB->t2.Reserved2 = 0;\n\tpSMB->t2.ParameterOffset = cpu_to_le16(offsetof(struct smb_t2_qfi_req,\n\t\t\t\t\t       Fid) - 4);\n\tpSMB->t2.DataCount = 0;\n\tpSMB->t2.DataOffset = 0;\n\tpSMB->t2.SetupCount = 1;\n\tpSMB->t2.Reserved3 = 0;\n\tpSMB->t2.SubCommand = cpu_to_le16(TRANS2_QUERY_FILE_INFORMATION);\n\tbyte_count = params + 1  ;\n\tpSMB->t2.TotalParameterCount = cpu_to_le16(params);\n\tpSMB->t2.ParameterCount = pSMB->t2.TotalParameterCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_QUERY_FILE_UNIX_BASIC);\n\tpSMB->Pad = 0;\n\tpSMB->Fid = netfid;\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc) {\n\t\tcFYI(1, \"STR\", rc);\n\t} else {\t\t\n\t\trc = validate_t2((struct smb_t2_rsp *)pSMBr);\n\n\t\tif (rc || get_bcc(&pSMBr->hdr) < sizeof(FILE_UNIX_BASIC_INFO)) {\n\t\t\tcERROR(1, \"STR\"\n\t\t\t\t   \"STR\"\n\t\t\t\t   \"STR\");\n\t\t\trc = -EIO;\t\n\t\t} else {\n\t\t\t__u16 data_offset = le16_to_cpu(pSMBr->t2.DataOffset);\n\t\t\tmemcpy((char *) pFindData,\n\t\t\t       (char *) &pSMBr->hdr.Protocol +\n\t\t\t       data_offset,\n\t\t\t       sizeof(FILE_UNIX_BASIC_INFO));\n\t\t}\n\t}\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto UnixQFileInfoRetry;\n\n\treturn rc;\n}","23824":"        \\param dz Depth of images in the written file.\n        \\param dc Spectrum of images in the written file.\n    **\/\n    static void save_empty_cimg(const char *const filename,\n                                const unsigned int nb,\n                                const unsigned int dx, const unsigned int dy=1,","23718":"void rfbFreeZrleData(rfbClientPtr cl)\n{\n  if (cl->zrleData)\n    zrleOutStreamFree(cl->zrleData);\n  cl->zrleData = NULL;\n}","23103":"static PE_DWord bin_pe_va_to_rva(RBinPEObj* pe, PE_DWord va) {\n\tut64 imageBase = PE_(r_bin_pe_get_image_base) (pe);\n\tif (va < imageBase) {\n\t\treturn va;\n\t}\n\treturn va - imageBase;\n}","23197":"  bool matches(const Http::RequestHeaderMap& headers) const override {\n    if (BaseMatcherImpl::matchRoute(headers)) {\n      const Http::HeaderString& path = headers.Path()->value();\n      const absl::string_view query_string = Http::Utility::findQueryStringStart(path);\n      absl::string_view path_view = path.getStringView();\n      path_view.remove_suffix(query_string.length());\n      if (path_matcher_->match(path_view)) {\n        ENVOY_LOG(debug, \"STR\", regex_str_);\n        return true;\n      }\n    }\n    return false;\n  }","23469":"PHP_MSHUTDOWN_FUNCTION(snmp)\n{\n\tsnmp_shutdown(\"STR\");\n\t\n\tzend_hash_destroy(&php_snmp_properties);\n\n\treturn SUCCESS;\n}","23728":"vhost_user_set_req_fd(struct virtio_net **pdev,\n\t\t\tstruct vhu_msg_context *ctx,\n\t\t\tint main_fd __rte_unused)\n{\n\tstruct virtio_net *dev = *pdev;\n\tint fd = ctx->fds[0];\n\n\tif (validate_msg_fds(dev, ctx, 1) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\n\tif (fd < 0) {\n\t\tVHOST_LOG_CONFIG(ERR, \"STR\",\n\t\t\t\tdev->ifname, fd);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\n\tif (dev->slave_req_fd >= 0)\n\t\tclose(dev->slave_req_fd);\n\n\tdev->slave_req_fd = fd;\n\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}","23574":"static int tvaudio_get_ctrl(struct CHIPSTATE *chip,\n\t\t\t    struct v4l2_control *ctrl)\n{\n\tstruct CHIPDESC *desc = chip->desc;\n\n\tswitch (ctrl->id) {\n\tcase V4L2_CID_AUDIO_MUTE:\n\t\tctrl->value=chip->muted;\n\t\treturn 0;\n\tcase V4L2_CID_AUDIO_VOLUME:\n\t\tif (!(desc->flags & CHIP_HAS_VOLUME))\n\t\t\tbreak;\n\t\tctrl->value = max(chip->left,chip->right);\n\t\treturn 0;\n\tcase V4L2_CID_AUDIO_BALANCE:\n\t{\n\t\tint volume;\n\t\tif (!(desc->flags & CHIP_HAS_VOLUME))\n\t\t\tbreak;\n\t\tvolume = max(chip->left,chip->right);\n\t\tif (volume)\n\t\t\tctrl->value=(32768*min(chip->left,chip->right))\/volume;\n\t\telse\n\t\t\tctrl->value=32768;\n\t\treturn 0;\n\t}\n\tcase V4L2_CID_AUDIO_BASS:\n\t\tif (desc->flags & CHIP_HAS_BASSTREBLE)\n\t\t\tbreak;\n\t\tctrl->value = chip->bass;\n\t\treturn 0;\n\tcase V4L2_CID_AUDIO_TREBLE:\n\t\tif (desc->flags & CHIP_HAS_BASSTREBLE)\n\t\t\treturn -EINVAL;\n\t\tctrl->value = chip->treble;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}","22958":"skip_string(char_u *p)\n{\n    int\t    i;\n\n    \n    for ( ; ; ++p)\n    {\n\tif (p[0] == '\\'')\t\t    \n\t{\n\t    if (p[1] == NUL)\t\t    \n\t\tbreak;\n\t    i = 2;\n\t    if (p[1] == '\\\\' && p[2] != NUL)    \n\t    {\n\t\t++i;\n\t\twhile (vim_isdigit(p[i - 1]))   \n\t\t    ++i;\n\t    }\n\t    if (p[i] == '\\'')\t\t    \n\t    {\n\t\tp += i;\n\t\tcontinue;\n\t    }\n\t}\n\telse if (p[0] == '\"')\t\t    \n\t{\n\t    for (++p; p[0]; ++p)\n\t    {\n\t\tif (p[0] == '\\\\' && p[1] != NUL)\n\t\t    ++p;\n\t\telse if (p[0] == '\"')\t    \n\t\t    break;\n\t    }\n\t    if (p[0] == '\"')\n\t\tcontinue; \n\t}\n\telse if (p[0] == 'R' && p[1] == '\"')\n\t{\n\t    \n\t    char_u *delim = p + 2;\n\t    char_u *paren = vim_strchr(delim, '(');\n\n\t    if (paren != NULL)\n\t    {\n\t\tsize_t delim_len = paren - delim;\n\n\t\tfor (p += 3; *p; ++p)\n\t\t    if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0\n\t\t\t    && p[delim_len + 1] == '\"')\n\t\t    {\n\t\t\tp += delim_len + 1;\n\t\t\tbreak;\n\t\t    }\n\t\tif (p[0] == '\"')\n\t\t    continue; \n\t    }\n\t}\n\tbreak;\t\t\t\t    \n    }\n    if (!*p)\n\t--p;\t\t\t\t    \n    return p;\n}","22806":"static void recv_buffer_cleanup(h2_bucket_beam *beam, h2_beam_lock *bl)\n{\n    if (beam->recv_buffer && !APR_BRIGADE_EMPTY(beam->recv_buffer)) {\n        apr_bucket_brigade *bb = beam->recv_buffer;\n        apr_off_t bblen = 0;\n        \n        beam->recv_buffer = NULL;\n        apr_brigade_length(bb, 0, &bblen);\n        beam->received_bytes += bblen;\n        \n        \n        if (bl) leave_yellow(beam, bl);\n        apr_brigade_destroy(bb);\n        if (bl) enter_yellow(beam, bl);\n        \n        if (beam->cons_ev_cb) { \n            beam->cons_ev_cb(beam->cons_ctx, beam);\n        }\n    }\n}","22558":"uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\tif (mp4 == NULL) return NULL;\n\n\tuint32_t *MP4buffer = NULL;\n\tif (index < mp4->indexcount && mp4->mediafp)\n\t{\n\t\tMP4buffer = (uint32_t *)realloc((void *)lastpayload, mp4->metasizes[index]);\n\n\t\tif (MP4buffer)\n\t\t{\n\t\t\tLONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);\n\t\t\tfread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);\n\t\t\treturn MP4buffer;\n\t\t}\n\t}\n\treturn NULL;\n}","22585":"static void pcpu_map_extend_workfn(struct work_struct *work)\n{\n\tstruct pcpu_chunk *chunk = container_of(work, struct pcpu_chunk,\n\t\t\t\t\t\tmap_extend_work);\n\tint new_alloc;\n\n\tspin_lock_irq(&pcpu_lock);\n\tnew_alloc = pcpu_need_to_extend(chunk, false);\n\tspin_unlock_irq(&pcpu_lock);\n\n\tif (new_alloc)\n\t\tpcpu_extend_area_map(chunk, new_alloc);\n}","22896":"static __inline__ void scm_destroy(struct scm_cookie *scm)\n{\n\tscm_destroy_cred(scm);\n\tif (scm && scm->fp)\n\t\t__scm_destroy(scm);\n}","23742":"DSA_PrivateKey::create_signature_op(RandomNumberGenerator& ,\n                                    const std::string& params,\n                                    const std::string& provider) const\n   {\n   if(provider == \"STR\" || provider.empty())\n      return std::unique_ptr<PK_Ops::Signature>(new DSA_Signature_Operation(*this, params));\n   throw Provider_Not_Found(algo_name(), provider);\n   }","23033":"gs_manager_get_property (GObject            *object,\n                         guint               prop_id,\n                         GValue             *value,\n                         GParamSpec         *pspec)\n{\n        GSManager *self;\n\n        self = GS_MANAGER (object);\n\n        switch (prop_id) {\n        case PROP_THROTTLED:\n                g_value_set_boolean (value, self->priv->throttled);\n                break;\n        case PROP_LOCK_ENABLED:\n                g_value_set_boolean (value, self->priv->lock_enabled);\n                break;\n        case PROP_LOCK_TIMEOUT:\n                g_value_set_long (value, self->priv->lock_timeout);\n                break;\n        case PROP_LOGOUT_ENABLED:\n                g_value_set_boolean (value, self->priv->logout_enabled);\n                break;\n        case PROP_KEYBOARD_ENABLED:\n                g_value_set_boolean (value, self->priv->keyboard_enabled);\n                break;\n        case PROP_USER_SWITCH_ENABLED:\n                g_value_set_boolean (value, self->priv->user_switch_enabled);\n                break;\n        case PROP_LOGOUT_TIMEOUT:\n                g_value_set_long (value, self->priv->logout_timeout);\n                break;\n        case PROP_LOGOUT_COMMAND:\n                g_value_set_string (value, self->priv->logout_command);\n                break;\n        case PROP_KEYBOARD_COMMAND:\n                g_value_set_string (value, self->priv->keyboard_command);\n                break;\n        case PROP_AWAY_MESSAGE:\n                g_value_set_string (value, self->priv->away_message);\n                break;\n        case PROP_CYCLE_TIMEOUT:\n                g_value_set_long (value, self->priv->cycle_timeout);\n                break;\n        case PROP_ACTIVE:\n                g_value_set_boolean (value, self->priv->active);\n        default:\n                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n                break;\n        }\n}","22874":"void WebContents::Invoke(\n    bool internal,\n    const std::string& channel,\n    blink::CloneableMessage arguments,\n    electron::mojom::ElectronBrowser::InvokeCallback callback,\n    content::RenderFrameHost* render_frame_host) {\n  TRACE_EVENT1(\"STR\", channel);\n  \n  EmitWithSender(\"STR\", render_frame_host, std::move(callback),\n                 internal, channel, std::move(arguments));\n}","23233":"dissect_kafka_metadata_replica(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset,\n                               kafka_api_version_t api_version _U_)\n{\n    proto_tree_add_item(tree, hf_kafka_replica, tvb, offset, 4, ENC_BIG_ENDIAN);\n    return offset + 4;\n}","23702":"static void coerce_reg_to_size(struct bpf_reg_state *reg, int size)\n{\n\tu64 mask;\n\n\t\n\treg->var_off = tnum_cast(reg->var_off, size);\n\n\t\n\tmask = ((u64)1 << (size * 8)) - 1;\n\tif ((reg->umin_value & ~mask) == (reg->umax_value & ~mask)) {\n\t\treg->umin_value &= mask;\n\t\treg->umax_value &= mask;\n\t} else {\n\t\treg->umin_value = 0;\n\t\treg->umax_value = mask;\n\t}\n\treg->smin_value = reg->umin_value;\n\treg->smax_value = reg->umax_value;\n\n\t\n\tif (size >= 4)\n\t\treturn;\n\t__reg_combine_64_into_32(reg);\n}","22840":"connection_changes_done (gpointer data)\n{\n\tConnectionChangedInfo *info = (ConnectionChangedInfo *) data;\n\tNMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (info->settings);\n\tNMAGConfConnection *connection;\n\n\tconnection = nma_gconf_settings_get_by_path (info->settings, info->path);\n\tif (!connection) {\n\t\t\n\t\tconnection = nma_gconf_connection_new (priv->client, info->path);\n\t\tadd_connection_real (info->settings, connection);\n\t} else {\n\t\tif (gconf_client_dir_exists (priv->client, info->path, NULL)) {\n\t\t\t\n\t\t\tif (!nma_gconf_connection_changed (connection))\n\t\t\t\tpriv->connections = g_slist_remove (priv->connections, connection);\n\t\t}\n\t}\n\n\tg_hash_table_remove (priv->pending_changes, info->path);\n\n\treturn FALSE;\n}","23247":"void Item_func_set_user_var::print_as_stmt(String *str,\n                                           enum_query_type query_type)\n{\n  str->append(STRING_WITH_LEN(\"STR\"));\n  str->append(name.str, name.length);\n  str->append(STRING_WITH_LEN(\"STR\"));\n  args[0]->print_parenthesised(str, query_type, precedence());\n}","23342":"STATIC void\nS_debug_start_match(pTHX_ const REGEXP *prog, const bool utf8_target,\n    const char *start, const char *end, const char *blurb)\n{\n    const bool utf8_pat = RX_UTF8(prog) ? 1 : 0;\n\n    PERL_ARGS_ASSERT_DEBUG_START_MATCH;\n\n    if (!PL_colorset)   \n            reginitcolors();    \n    {\n        RE_PV_QUOTED_DECL(s0, utf8_pat, PERL_DEBUG_PAD_ZERO(0), \n            RX_PRECOMP_const(prog), RX_PRELEN(prog), 60);   \n        \n        RE_PV_QUOTED_DECL(s1, utf8_target, PERL_DEBUG_PAD_ZERO(1),\n            start, end - start, 60); \n        \n        PerlIO_printf(Perl_debug_log, \n            \"STR\", \n\t\t       PL_colors[4], blurb, PL_colors[5], s0, s1); \n        \n        if (utf8_target||utf8_pat)\n            PerlIO_printf(Perl_debug_log, \"STR\",\n                utf8_pat ? \"STR\",\n                utf8_pat && utf8_target ? \"STR\",\n                utf8_target ? \"STR\"\n            ); \n    }","22743":"static int dn_create(struct net *net, struct socket *sock, int protocol,\n\t\t     int kern)\n{\n\tstruct sock *sk;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_SEQPACKET:\n\t\tif (protocol != DNPROTO_NSP)\n\t\t\treturn -EPROTONOSUPPORT;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\n\tif ((sk = dn_alloc_sock(net, sock, GFP_KERNEL, kern)) == NULL)\n\t\treturn -ENOBUFS;\n\n\tsk->sk_protocol = protocol;\n\n\treturn 0;\n}","23427":"bool tcp_alloc_md5sig_pool(void)\n{\n\tif (unlikely(!tcp_md5sig_pool_populated)) {\n\t\tmutex_lock(&tcp_md5sig_mutex);\n\n\t\tif (!tcp_md5sig_pool_populated)\n\t\t\t__tcp_alloc_md5sig_pool();\n\n\t\tmutex_unlock(&tcp_md5sig_mutex);\n\t}\n\treturn tcp_md5sig_pool_populated;\n}","22897":"static u32 ttxt_get_color(char *val)\n{\n\tu32 r, g, b, a, res;\n\tr = g = b = a = 0;\n\tif (sscanf(val, \"STR\", &r, &g, &b, &a) != 4) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"STR\", val));\n\t}\n\tres = (a&0xFF);\n\tres<<=8;\n\tres |= (r&0xFF);\n\tres<<=8;\n\tres |= (g&0xFF);\n\tres<<=8;\n\tres |= (b&0xFF);\n\treturn res;\n}","23070":"struct btrfs_device *btrfs_find_device_by_devspec(\n\t\tstruct btrfs_fs_info *fs_info, u64 devid,\n\t\tconst char *device_path)\n{\n\tstruct btrfs_device *device;\n\n\tif (devid) {\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, NULL,\n\t\t\t\t\t   NULL);\n\t\tif (!device)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn device;\n\t}\n\n\tif (!device_path || !device_path[0])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (strcmp(device_path, \"STR\") == 0) {\n\t\t\n\t\tlist_for_each_entry(device, &fs_info->fs_devices->devices,\n\t\t\t\t    dev_list) {\n\t\t\tif (test_bit(BTRFS_DEV_STATE_IN_FS_METADATA,\n\t\t\t\t     &device->dev_state) && !device->bdev)\n\t\t\t\treturn device;\n\t\t}\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\treturn btrfs_find_device_by_path(fs_info, device_path);\n}","22524":"RawTile KakaduImage::getRegion( int seq, int ang, unsigned int res, int layers, int x, int y, unsigned int w, unsigned int h )\n{\n  \n  unsigned int obpc = bpc;\n  if( bpc <= 16 && bpc > 8 ) obpc = 16;\n  else if( bpc <= 8 ) obpc = 8;\n\n#ifdef DEBUG\n  Timer timer;\n  timer.start();\n#endif\n\n  RawTile rawtile( 0, res, seq, ang, w, h, channels, obpc );\n\n  if( obpc == 16 ) rawtile.data = new unsigned short[w*h*channels];\n  else if( obpc == 8 ) rawtile.data = new unsigned char[w*h*channels];\n  else throw file_error( \"STR\" );\n\n  rawtile.dataLength = w*h*channels*(obpc\/8);\n  rawtile.filename = getImagePath();\n  rawtile.timestamp = timestamp;\n\n  process( res, layers, x, y, w, h, rawtile.data );\n\n#ifdef DEBUG\n  logfile << \"STR\" << endl;\n#endif\n\n  return rawtile;\n\n}","23346":"    int MemIo::seek(int64 offset, Position pos )\n    {\n        int64 newIdx = 0;\n\n        switch (pos) {\n            case BasicIo::cur:\n                newIdx = p_->idx_ + offset;\n                break;\n            case BasicIo::beg:\n                newIdx = offset;\n                break;\n            case BasicIo::end:\n                newIdx = p_->size_ + offset;\n                break;\n        }\n\n        if (newIdx < 0)\n            return 1;\n\n        if (static_cast<size_t>(newIdx) > p_->size_) {\n            p_->eof_ = true;\n            return 1;\n        }\n\n        p_->idx_ = static_cast<size_t>(newIdx);\n        p_->eof_ = false;\n        return 0;\n    }","23383":"static int int_floorlog2(int a)\n{\n    int l;\n    for (l = 0; a > 1; l++) {\n        a >>= 1;\n    }\n    return l;\n}","23285":"gif_prepare_lzw (GifContext *context)\n{\n\tgint i;\n\n\tif (!gif_read (context, &(context->lzw_set_code_size), 1)) {\n\t\t\n\t\treturn -1;\n\t}\n\n\tcontext->lzw_code_size = context->lzw_set_code_size + 1;\n\tcontext->lzw_clear_code = 1 << context->lzw_set_code_size;\n\tcontext->lzw_end_code = context->lzw_clear_code + 1;\n\tcontext->lzw_max_code_size = 2 * context->lzw_clear_code;\n\tcontext->lzw_max_code = context->lzw_clear_code + 2;\n\tcontext->lzw_fresh = TRUE;\n\tcontext->code_curbit = 0;\n\tcontext->code_lastbit = 0;\n\tcontext->code_last_byte = 0;\n\tcontext->code_done = FALSE;\n\n\tfor (i = 0; i < context->lzw_clear_code; ++i) {\n\t\tcontext->lzw_table[0][i] = 0;\n\t\tcontext->lzw_table[1][i] = i;\n\t}\n\tfor (; i < (1 << MAX_LZW_BITS); ++i)\n\t\tcontext->lzw_table[0][i] = context->lzw_table[1][0] = 0;\n\n\tcontext->lzw_sp = context->lzw_stack;\n\tgif_set_get_lzw (context);\n\n\treturn 0;\n}","23534":"static int br_parse_ip_options(struct sk_buff *skb)\n{\n\tstruct ip_options *opt;\n\tstruct iphdr *iph;\n\tstruct net_device *dev = skb->dev;\n\tu32 len;\n\n\tiph = ip_hdr(skb);\n\topt = &(IPCB(skb)->opt);\n\n\t\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\tgoto inhdr_error;\n\n\tif (!pskb_may_pull(skb, iph->ihl*4))\n\t\tgoto inhdr_error;\n\n\tiph = ip_hdr(skb);\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\tgoto inhdr_error;\n\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t} else if (len < (iph->ihl*4))\n\t\tgoto inhdr_error;\n\n\tif (pskb_trim_rcsum(skb, len)) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\n\t\n\tif (iph->ihl == 5) {\n\t\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\t\treturn 0;\n\t}\n\n\topt->optlen = iph->ihl*4 - sizeof(struct iphdr);\n\tif (ip_options_compile(dev_net(dev), opt, skb))\n\t\tgoto inhdr_error;\n\n\t\n\tif (unlikely(opt->srr)) {\n\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev && !IN_DEV_SOURCE_ROUTE(in_dev))\n\t\t\tgoto drop;\n\n\t\tif (ip_options_rcv_srr(skb))\n\t\t\tgoto drop;\n\t}\n\n\treturn 0;\n\ninhdr_error:\n\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);\ndrop:\n\treturn -1;\n}","22828":"static int get_parsed_dns(struct ldb_module *module, TALLOC_CTX *mem_ctx,\n\t\t\t  struct ldb_message_element *el, struct parsed_dn **pdn,\n\t\t\t  const char *ldap_oid, struct ldb_request *parent)\n{\n\tunsigned int i;\n\tbool values_are_sorted = true;\n\tstruct ldb_context *ldb = ldb_module_get_ctx(module);\n\n\tif (el == NULL) {\n\t\t*pdn = NULL;\n\t\treturn LDB_SUCCESS;\n\t}\n\n\t(*pdn) = talloc_array(mem_ctx, struct parsed_dn, el->num_values);\n\tif (!*pdn) {\n\t\tldb_module_oom(module);\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\n\tfor (i=0; i<el->num_values; i++) {\n\t\tstruct ldb_val *v = &el->values[i];\n\t\tNTSTATUS status;\n\t\tstruct ldb_dn *dn;\n\t\tstruct parsed_dn *p;\n\n\t\tp = &(*pdn)[i];\n\n\t\tp->dsdb_dn = dsdb_dn_parse(*pdn, ldb, v, ldap_oid);\n\t\tif (p->dsdb_dn == NULL) {\n\t\t\treturn LDB_ERR_INVALID_DN_SYNTAX;\n\t\t}\n\n\t\tdn = p->dsdb_dn->dn;\n\n\t\tstatus = dsdb_get_extended_dn_guid(dn, &p->guid, \"STR\");\n\t\tif (NT_STATUS_EQUAL(status, NT_STATUS_OBJECT_NAME_NOT_FOUND) ||\n\t\t    unlikely(GUID_all_zero(&p->guid))) {\n\t\t\t\n\t\t\tint ret = dsdb_module_guid_by_dn(module, dn, &p->guid, parent);\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\tchar *dn_str = NULL;\n\t\t\t\tdn_str = ldb_dn_get_extended_linearized(mem_ctx,\n\t\t\t\t\t\t\t\t\t(dn), 1);\n\t\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t\t\"STR\",\n\t\t\t\t\t\tdn_str);\n\t\t\t\tif (ret == LDB_ERR_NO_SUCH_OBJECT &&\n\t\t\t\t    LDB_FLAG_MOD_TYPE(el->flags) == LDB_FLAG_MOD_DELETE &&\n\t\t\t\t    ldb_attr_cmp(el->name, \"STR\") == 0) {\n\t\t\t\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tret = dsdb_set_extended_dn_guid(dn, &p->guid, \"STR\");\n\t\t\tif (ret != LDB_SUCCESS) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else if (!NT_STATUS_IS_OK(status)) {\n\t\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t\t}\n\t\tif (i > 0 && values_are_sorted) {\n\t\t\tint cmp = parsed_dn_compare(p, &(*pdn)[i - 1]);\n\t\t\tif (cmp < 0) {\n\t\t\t\tvalues_are_sorted = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tp->v = v;\n\t}\n\tif (! values_are_sorted) {\n\t\tTYPESAFE_QSORT(*pdn, el->num_values, parsed_dn_compare);\n\t}\n\treturn LDB_SUCCESS;\n}","23640":"static void ldap_decode_attribs(TALLOC_CTX *mem_ctx, struct asn1_data *data,\n\t\t\t\tstruct ldb_message_element **attributes,\n\t\t\t\tint *num_attributes)\n{\n\tasn1_start_tag(data, ASN1_SEQUENCE(0));\n\tldap_decode_attribs_bare(mem_ctx, data, \n\t\t\t\t attributes, num_attributes);\n\tasn1_end_tag(data);\n}","22876":"unsigned int gg_login_hash(const unsigned char *password, unsigned int seed)\n{\n\tunsigned int x, y, z;\n\n\ty = seed;\n\n\tfor (x = 0; *password; password++) {\n\t\tx = (x & 0xffffff00) | *password;\n\t\ty ^= x;\n\t\ty += x;\n\t\tx <<= 8;\n\t\ty ^= x;\n\t\tx <<= 8;\n\t\ty -= x;\n\t\tx <<= 8;\n\t\ty ^= x;\n\n\t\tz = y & 0x1F;\n\t\ty = (y << z) | (y >> (32 - z));\n\t}\n\n\treturn y;\n}","23085":"psutil_users(PyObject *self, PyObject *args) {\n    struct utmp *ut;\n    PyObject *py_retlist = PyList_New(0);\n    PyObject *py_tuple = NULL;\n    PyObject *py_username = NULL;\n    PyObject *py_tty = NULL;\n    PyObject *py_hostname = NULL;\n    PyObject *py_user_proc = NULL;\n\n    if (py_retlist == NULL)\n        return NULL;\n    setutent();\n    while (NULL != (ut = getutent())) {\n        py_tuple = NULL;\n        py_user_proc = NULL;\n        if (ut->ut_type == USER_PROCESS)\n            py_user_proc = Py_True;\n        else\n            py_user_proc = Py_False;\n        py_username = PyUnicode_DecodeFSDefault(ut->ut_user);\n        if (! py_username)\n            goto error;\n        py_tty = PyUnicode_DecodeFSDefault(ut->ut_line);\n        if (! py_tty)\n            goto error;\n        py_hostname = PyUnicode_DecodeFSDefault(ut->ut_host);\n        if (! py_hostname)\n            goto error;\n        py_tuple = Py_BuildValue(\n            \"STR\",\n            py_username,              \n            py_tty,                   \n            py_hostname,              \n            (float)ut->ut_tv.tv_sec,  \n            py_user_proc,             \n            ut->ut_pid                \n        );\n        if (! py_tuple)\n            goto error;\n        if (PyList_Append(py_retlist, py_tuple))\n            goto error;\n        Py_DECREF(py_username);\n        Py_DECREF(py_tty);\n        Py_DECREF(py_hostname);\n        Py_DECREF(py_tuple);\n    }\n    endutent();\n    return py_retlist;\n\nerror:\n    Py_XDECREF(py_username);\n    Py_XDECREF(py_tty);\n    Py_XDECREF(py_hostname);\n    Py_XDECREF(py_tuple);\n    Py_DECREF(py_retlist);\n    endutent();\n    return NULL;\n}","23058":"static int __init xfrm6_tunnel_init(void)\n{\n\tint rv;\n\n\trv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);\n\tif (rv < 0)\n\t\tgoto err;\n\trv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);\n\tif (rv < 0)\n\t\tgoto unreg;\n\trv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);\n\tif (rv < 0)\n\t\tgoto dereg6;\n\trv = xfrm6_tunnel_spi_init();\n\tif (rv < 0)\n\t\tgoto dereg46;\n\trv = register_pernet_subsys(&xfrm6_tunnel_net_ops);\n\tif (rv < 0)\n\t\tgoto deregspi;\n\treturn 0;\n\nderegspi:\n\txfrm6_tunnel_spi_fini();\ndereg46:\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\ndereg6:\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\nunreg:\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\nerr:\n\treturn rv;\n}","23385":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  \n  auto* params =\n      reinterpret_cast<TfLiteFullyConnectedParams*>(node->builtin_data);\n  const TfLiteTensor* filter = GetInput(context, node, kWeightsTensor);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const bool is_quantized =\n      ((filter->type == kTfLiteUInt8) || (filter->type == kTfLiteInt8));\n  const bool is_hybrid = is_quantized && (input->type == kTfLiteFloat32);\n  const bool is_pie = kernel_type == kLegacyPie;\n\n  \n  \n  if (!is_pie && !is_hybrid) {\n    TF_LITE_ENSURE(context, params->activation == kTfLiteActNone ||\n                                params->activation == kTfLiteActRelu ||\n                                params->activation == kTfLiteActReluN1To1 ||\n                                params->activation == kTfLiteActRelu6);\n  }\n  return PrepareImpl(context, node);\n}","22686":"const std::vector<uint8_t>& ThreadCommand::state() const {\n  return state_;\n}","23115":"static int em_ret_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned long eip, cs;\n\tu16 old_cs;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_cs, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\n\trc = emulate_pop(ctxt, &eip, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\t\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\trc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_RET,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_far(ctxt, eip, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\tops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);\n\t}\n\treturn rc;\n}","22724":"size_t c_shquote_strncspn(const char *string,\n                          size_t n_string,\n                          const char *reject) {\n        bool buffer[UCHAR_MAX] = {};\n\n        if (strlen(reject) == 1) {\n                const char *p;\n\n                p = memchr(string, reject[0], n_string);\n                if (!p)\n                        return n_string;\n                else\n                        return p - string;\n        }\n\n        for ( ; *reject; ++reject)\n                buffer[(unsigned char)*reject] = true;\n\n        for (size_t i = 0; i < n_string; ++i)\n                if (buffer[(unsigned char)string[i]])\n                        return i;\n\n        return n_string;\n}","22872":"static void rb_iter_reset(struct ring_buffer_iter *iter)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;\n\n\t\n\titer->head_page = cpu_buffer->reader_page;\n\titer->head = cpu_buffer->reader_page->read;\n\n\titer->cache_reader_page = iter->head_page;\n\titer->cache_read = cpu_buffer->read;\n\n\tif (iter->head)\n\t\titer->read_stamp = cpu_buffer->read_stamp;\n\telse\n\t\titer->read_stamp = iter->head_page->page->time_stamp;\n}","22925":"static DnsServer* dns_server_free(DnsServer *s)  {\n        assert(s);\n\n        dns_stream_unref(s->stream);\n\n#if ENABLE_DNS_OVER_TLS\n        dnstls_server_free(s);\n#endif\n\n        free(s->server_string);\n        return mfree(s);\n}","23099":"static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,\n\t\t\t       struct scm_cookie *scm)\n{\n\tmemset(scm, 0, sizeof(*scm));\n\tunix_get_peersec_dgram(sock, scm);\n\tif (msg->msg_controllen <= 0)\n\t\treturn 0;\n\treturn __scm_send(sock, msg, scm);\n}","22609":"TPM_ST_Unmarshal(TPM_ST *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = UINT16_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n\t  case TPM_ST_RSP_COMMAND:\n\t  case TPM_ST_NULL:\n\t  case TPM_ST_NO_SESSIONS:\n\t  case TPM_ST_SESSIONS:\n\t  case TPM_ST_ATTEST_NV:\n\t  case TPM_ST_ATTEST_COMMAND_AUDIT:\n\t  case TPM_ST_ATTEST_SESSION_AUDIT:\n\t  case TPM_ST_ATTEST_CERTIFY:\n\t  case TPM_ST_ATTEST_QUOTE:\n\t  case TPM_ST_ATTEST_TIME:\n\t  case TPM_ST_ATTEST_CREATION:\n\t  case TPM_ST_CREATION:\n\t  case TPM_ST_VERIFIED:\n\t  case TPM_ST_AUTH_SECRET:\n\t  case TPM_ST_HASHCHECK:\n\t  case TPM_ST_AUTH_SIGNED:\n\t    break;\n\t  default:\n\t    rc = TPM_RC_VALUE;\n\t}\n    }\n    return rc;\n}","23050":"dirserv_count_measured_bws(const smartlist_t *routers)\n{\n  \n  routers_with_measured_bw = 0;\n\n  \n  SMARTLIST_FOREACH_BEGIN(routers, const routerinfo_t *, ri) {\n    \n    if (dirserv_has_measured_bw(ri->cache_info.identity_digest)) {\n      ++routers_with_measured_bw;\n    }\n  } SMARTLIST_FOREACH_END(ri);\n}","23504":"int ptrace_setxregs(struct task_struct *child, void __user *uregs)\n{\n\tstruct thread_info *ti = task_thread_info(child);\n\tstruct pt_regs *regs = task_pt_regs(child);\n\telf_xtregs_t *xtregs = uregs;\n\tint ret = 0;\n\n#if XTENSA_HAVE_COPROCESSORS\n\t\n\tcoprocessor_flush_all(ti);\n\tcoprocessor_release_all(ti);\n\n\tret |= __copy_from_user(&ti->xtregs_cp, &xtregs->cp0, \n\t\t\t\tsizeof(xtregs_coprocessor_t));\n#endif\n\tret |= __copy_from_user(&regs->xtregs_opt, &xtregs->opt,\n\t\t\t\tsizeof(xtregs->opt));\n\tret |= __copy_from_user(&ti->xtregs_user, &xtregs->user,\n\t\t\t\tsizeof(xtregs->user));\n\n\treturn ret ? -EFAULT : 0;\n}","22811":"static int cpu_cgroup_css_online(struct cgroup_subsys_state *css)\n{\n\tstruct task_group *tg = css_tg(css);\n\tstruct task_group *parent = css_tg(css_parent(css));\n\n\tif (parent)\n\t\tsched_online_group(tg, parent);\n\treturn 0;\n}","23409":"int sqlite3ExprListCompare(ExprList *pA, ExprList *pB, int iTab){\n  int i;\n  if( pA==0 && pB==0 ) return 0;\n  if( pA==0 || pB==0 ) return 1;\n  if( pA->nExpr!=pB->nExpr ) return 1;\n  for(i=0; i<pA->nExpr; i++){\n    Expr *pExprA = pA->a[i].pExpr;\n    Expr *pExprB = pB->a[i].pExpr;\n    if( pA->a[i].sortFlags!=pB->a[i].sortFlags ) return 1;\n    if( sqlite3ExprCompare(0, pExprA, pExprB, iTab) ) return 1;\n  }\n  return 0;\n}","23253":"set_point (pixman_point_fixed_t *p, cairo_point_t *c)\n{\n    p->x = _cairo_fixed_to_16_16 (c->x);\n    p->y = _cairo_fixed_to_16_16 (c->y);\n}","23502":"  uint64_t cluster_pos() const { return cluster_pos_; }","22916":"f_screenpos(typval_T *argvars UNUSED, typval_T *rettv)\n{\n    dict_T\t*dict;\n    win_T\t*wp;\n    pos_T\tpos;\n    int\t\trow = 0;\n    int\t\tscol = 0, ccol = 0, ecol = 0;\n\n    if (rettv_dict_alloc(rettv) != OK)\n\treturn;\n    dict = rettv->vval.v_dict;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_number_arg(argvars, 2) == FAIL))\n\treturn;\n\n    wp = find_win_by_nr_or_id(&argvars[0]);\n    if (wp == NULL)\n\treturn;\n\n    pos.lnum = tv_get_number(&argvars[1]);\n    pos.col = tv_get_number(&argvars[2]) - 1;\n    pos.coladd = 0;\n    textpos2screenpos(wp, &pos, &row, &scol, &ccol, &ecol);\n\n    dict_add_number(dict, \"STR\", row);\n    dict_add_number(dict, \"STR\", scol);\n    dict_add_number(dict, \"STR\", ccol);\n    dict_add_number(dict, \"STR\", ecol);\n}","22948":"vim9_declare_error(char_u *name)\n{\n    char *scope = \"\";\n\n    switch (*name)\n    {\n\tcase 'g': scope = _(\"STR\"); break;\n\tcase 'b': scope = _(\"STR\"); break;\n\tcase 'w': scope = _(\"STR\"); break;\n\tcase 't': scope = _(\"STR\"); break;\n\tcase 'v': scope = \"STR\"; break;\n\tcase '$': semsg(_(e_cannot_declare_an_environment_variable), name);\n\t\t  return;\n\tcase '&': semsg(_(e_cannot_declare_an_option), name);\n\t\t  return;\n\tcase '@': semsg(_(e_cannot_declare_a_register_str), name);\n\t\t  return;\n\tdefault: return;\n    }\n    semsg(_(e_cannot_declare_a_scope_variable), scope, name);\n}","23010":"\t__must_hold(&ctx->completion_lock)\n{\n\tu32 seq = ctx->cached_cq_tail - atomic_read(&ctx->cq_timeouts);\n\n\tspin_lock_irq(&ctx->timeout_lock);\n\twhile (!list_empty(&ctx->timeout_list)) {\n\t\tu32 events_needed, events_got;\n\t\tstruct io_kiocb *req = list_first_entry(&ctx->timeout_list,\n\t\t\t\t\t\tstruct io_kiocb, timeout.list);\n\n\t\tif (io_is_timeout_noseq(req))\n\t\t\tbreak;\n\n\t\t\n\t\tevents_needed = req->timeout.target_seq - ctx->cq_last_tm_flush;\n\t\tevents_got = seq - ctx->cq_last_tm_flush;\n\t\tif (events_got < events_needed)\n\t\t\tbreak;\n\n\t\tlist_del_init(&req->timeout.list);\n\t\tio_kill_timeout(req, 0);\n\t}\n\tctx->cq_last_tm_flush = seq;\n\tspin_unlock_irq(&ctx->timeout_lock);\n}","23482":"  CHARSET_INFO *sort_charset(void) const { return &my_charset_bin; }","22547":"int ber_write_sequence_tag(wStream* s, int length)\n{\n\tStream_Write_UINT8(s, (BER_CLASS_UNIV | BER_CONSTRUCT) | (BER_TAG_MASK & BER_TAG_SEQUENCE));\n\treturn ber_write_length(s, length) + 1;\n}","23717":"xsltCompilationCtxtFree(xsltCompilerCtxtPtr cctxt)\n{\n    if (cctxt == NULL)\n\treturn;\n#ifdef WITH_XSLT_DEBUG_PARSING\n    xsltGenericDebug(xsltGenericDebugContext,\n\t\"STR\");\n    xsltGenericDebug(xsltGenericDebugContext,\n\t\"STR\", cctxt->maxNodeInfos);\n    xsltGenericDebug(xsltGenericDebugContext,\n\t\"STR\", cctxt->maxLREs);\n#endif\n    \n    if (cctxt->inodeList != NULL) {\n\txsltCompilerNodeInfoPtr tmp, cur = cctxt->inodeList;\n\twhile (cur != NULL) {\n\t    tmp = cur;\n\t    cur = cur->next;\n\t    xmlFree(tmp);\n\t}\n    }\n    if (cctxt->tmpList != NULL)\n\txsltPointerListFree(cctxt->tmpList);\n#ifdef XSLT_REFACTORED_XPATHCOMP\n    if (cctxt->xpathCtxt != NULL)\n\txmlXPathFreeContext(cctxt->xpathCtxt);\n#endif\n    if (cctxt->nsAliases != NULL)\n\txsltFreeNsAliasList(cctxt->nsAliases);\n\n    if (cctxt->ivars)\n\txsltCompilerVarInfoFree(cctxt);\n\n    xmlFree(cctxt);\n}","23135":"static inline void init_keys(at91_aes_key_size_t *key_size,\n\t\t\t     unsigned int *cipher_key,\n\t\t\t     unsigned int *cmac_key,\n\t\t\t     unsigned int *iv)\n{\n#if defined(CONFIG_AES_KEY_SIZE_128)\n\t*key_size = AT91_AES_KEY_SIZE_128;\n#elif defined(CONFIG_AES_KEY_SIZE_192)\n\t*key_size = AT91_AES_KEY_SIZE_192;\n#elif defined(CONFIG_AES_KEY_SIZE_256)\n\t*key_size = AT91_AES_KEY_SIZE_256;\n#else\n#error \"STR\"\n#endif\n\n\tiv[0]\t\t= CONFIG_AES_IV_WORD0;\n\tiv[1]\t\t= CONFIG_AES_IV_WORD1;\n\tiv[2]\t\t= CONFIG_AES_IV_WORD2;\n\tiv[3]\t\t= CONFIG_AES_IV_WORD3;\n\n\tcipher_key[0]\t= CONFIG_AES_CIPHER_KEY_WORD0;\n\tcmac_key[0]\t= CONFIG_AES_CMAC_KEY_WORD0;\n\tcipher_key[1]\t= CONFIG_AES_CIPHER_KEY_WORD1;\n\tcmac_key[1]\t= CONFIG_AES_CMAC_KEY_WORD1;\n\tcipher_key[2]\t= CONFIG_AES_CIPHER_KEY_WORD2;\n\tcmac_key[2]\t= CONFIG_AES_CMAC_KEY_WORD2;\n\tcipher_key[3]\t= CONFIG_AES_CIPHER_KEY_WORD3;\n\tcmac_key[3]\t= CONFIG_AES_CMAC_KEY_WORD3;\n\n#if defined(CONFIG_AES_KEY_SIZE_192) || defined(CONFIG_AES_KEY_SIZE_256)\n\tcipher_key[4]\t= CONFIG_AES_CIPHER_KEY_WORD4;\n\tcmac_key[4]\t= CONFIG_AES_CMAC_KEY_WORD4;\n\tcipher_key[5]\t= CONFIG_AES_CIPHER_KEY_WORD5;\n\tcmac_key[5]\t= CONFIG_AES_CMAC_KEY_WORD5;\n#endif\n\n#if defined(CONFIG_AES_KEY_SIZE_256)\n\tcipher_key[6]\t= CONFIG_AES_CIPHER_KEY_WORD6;\n\tcmac_key[6]\t= CONFIG_AES_CMAC_KEY_WORD6;\n\tcipher_key[7]\t= CONFIG_AES_CIPHER_KEY_WORD7;\n\tcmac_key[7]\t= CONFIG_AES_CMAC_KEY_WORD7;\n#endif\n}","22912":"u32 __skb_get_hash_symmetric(const struct sk_buff *skb)\n{\n\tstruct flow_keys keys;\n\n\t__flow_hash_secret_init();\n\n\tmemset(&keys, 0, sizeof(keys));\n\t__skb_flow_dissect(NULL, skb, &flow_keys_dissector_symmetric,\n\t\t\t   &keys, NULL, 0, 0, 0,\n\t\t\t   FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL);\n\n\treturn __flow_hash_from_keys(&keys, hashrnd);\n}","23561":"static int walk_pmd_range(pud_t *pud, unsigned long addr, unsigned long end,\n\t\t\t  struct mm_walk *walk)\n{\n\tpmd_t *pmd;\n\tunsigned long next;\n\tint err = 0;\n\n\tpmd = pmd_offset(pud, addr);\n\tdo {\nagain:\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none(*pmd)) {\n\t\t\tif (walk->pte_hole)\n\t\t\t\terr = walk->pte_hole(addr, next, walk);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (walk->pmd_entry)\n\t\t\terr = walk->pmd_entry(pmd, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t\n\t\tif (!walk->pte_entry)\n\t\t\tcontinue;\n\n\t\tsplit_huge_page_pmd(walk->mm, pmd);\n\t\tif (pmd_none_or_clear_bad(pmd))\n\t\t\tgoto again;\n\t\terr = walk_pte_range(pmd, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pmd++, addr = next, addr != end);\n\n\treturn err;\n}","23540":"static inline exporter_ipfix_domain_t *GetExporter(FlowSource_t *fs, ipfix_header_t *ipfix_header) {\n\nchar ipstr[IP_STRING_LEN];\nexporter_ipfix_domain_t **e = (exporter_ipfix_domain_t **)&(fs->exporter_data);\nuint32_t ObservationDomain = ntohl(ipfix_header->ObservationDomain);\n\n\twhile ( *e ) {\n\t\tif ( (*e)->info.id == ObservationDomain && (*e)->info.version == 10 && \n\t\t\t (*e)->info.ip.v6[0] == fs->ip.v6[0] && (*e)->info.ip.v6[1] == fs->ip.v6[1]) \n\t\t\treturn *e;\n\t\te = &((*e)->next);\n\t}\n\n\tif ( fs->sa_family == AF_INET ) {\n\t\tuint32_t _ip = htonl(fs->ip.v4);\n\t\tinet_ntop(AF_INET, &_ip, ipstr, sizeof(ipstr));\n\t} else if ( fs->sa_family == AF_INET6 ) {\n\t\tuint64_t _ip[2];\n\t\t_ip[0] = htonll(fs->ip.v6[0]);\n\t\t_ip[1] = htonll(fs->ip.v6[1]);\n\t\tinet_ntop(AF_INET6, &_ip, ipstr, sizeof(ipstr));\n\t} else {\n\t\tstrncpy(ipstr, \"STR\", IP_STRING_LEN);\n\t}\n\n\t\n\t*e = (exporter_ipfix_domain_t *)malloc(sizeof(exporter_ipfix_domain_t));\n\tif ( !(*e)) {\n\t\tsyslog(LOG_ERR, \"STR\", __FILE__, __LINE__, strerror (errno));\n\t\treturn NULL;\n\t}\n\tmemset((void *)(*e), 0, sizeof(exporter_ipfix_domain_t));\n\t(*e)->info.header.type  = ExporterInfoRecordType;\n\t(*e)->info.header.size  = sizeof(exporter_info_record_t);\n\t(*e)->info.id \t\t\t= ObservationDomain;\n\t(*e)->info.ip\t\t\t= fs->ip;\n\t(*e)->info.sa_family\t= fs->sa_family;\n\t(*e)->info.version \t\t= 10;\n\t(*e)->info.sysid\t \t= 0;\n\n\t(*e)->TemplateRecords \t= 0;\n\t(*e)->DataRecords \t \t= 0;\n\t(*e)->sequence_failure \t= 0;\n\t(*e)->next\t \t\t\t= NULL;\n\t(*e)->sampler \t\t\t= NULL;\n\n\tFlushInfoExporter(fs, &((*e)->info));\n\n\tdbg_printf(\"STR\", \n\t\tObservationDomain, (*e)->info.sysid, ObservationDomain, ipstr);\n\tsyslog(LOG_INFO, \"STR\", \n\t\t(*e)->info.sysid, ObservationDomain, ipstr);\n\n\n\treturn (*e);\n\n} ","23365":"static void ip6_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,\n\t\t\t       struct sk_buff *skb, u32 mtu)\n{\n\tstruct rt6_info *rt6 = (struct rt6_info *)dst;\n\n\tdst_confirm(dst);\n\tif (mtu < dst_mtu(dst) && rt6->rt6i_dst.plen == 128) {\n\t\tstruct net *net = dev_net(dst->dev);\n\n\t\trt6->rt6i_flags |= RTF_MODIFIED;\n\t\tif (mtu < IPV6_MIN_MTU) {\n\t\t\tu32 features = dst_metric(dst, RTAX_FEATURES);\n\t\t\tmtu = IPV6_MIN_MTU;\n\t\t\tfeatures |= RTAX_FEATURE_ALLFRAG;\n\t\t\tdst_metric_set(dst, RTAX_FEATURES, features);\n\t\t}\n\t\tdst_metric_set(dst, RTAX_MTU, mtu);\n\t\trt6_update_expires(rt6, net->ipv6.sysctl.ip6_rt_mtu_expires);\n\t}\n}","23181":"static inline void *buffer_offset(intptr_t i)\n{\n   return (void *)i;\n}","23739":"int kvm_vcpu_preferred_target(struct kvm_vcpu_init *init)\n{\n\tint target = kvm_target_cpu();\n\n\tif (target < 0)\n\t\treturn -ENODEV;\n\n\tmemset(init, 0, sizeof(*init));\n\n\t\n\tinit->target = (__u32)target;\n\n\treturn 0;\n}","23664":"static ssize_t control_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\treturn sprintf(buf, \"STR\",\n\t\t\t\tdev->power.runtime_auto ? ctrl_auto : ctrl_on);\n}","23667":"ServiceProtoHandleSessionRequest(ServiceConnection *conn,\n                                 ProtoRequest *req)\n{\n   VGAuthError err;\n   gchar *packet;\n   gchar *pipeName = NULL;\n\n   \n\n   if (req->reqData.sessionReq.version != atoi(VGAUTH_PROTOCOL_VERSION)) {\n      err = VGAUTH_E_VERSION_MISMATCH;\n      Warning(\"STR\",\n              __FUNCTION__, req->reqData.sessionReq.version,\n              atoi(VGAUTH_PROTOCOL_VERSION));\n      packet = Proto_MakeErrorReply(conn, req, err,\n                                    \"STR\");\n      goto send_err;\n   }\n\n   err = ServiceStartUserConnection(req->reqData.sessionReq.userName,\n                                    &pipeName);\n   if (err != VGAUTH_E_OK) {\n      packet = Proto_MakeErrorReply(conn, req, err, \"STR\");\n   } else {\n      packet = g_markup_printf_escaped(VGAUTH_SESSION_REPLY_FORMAT,\n                                       req->sequenceNumber,\n                                       pipeName);\n   }\n\nsend_err:\n   err = ServiceNetworkWriteData(conn, strlen(packet), packet);\n   if (err != VGAUTH_E_OK) {\n      Warning(\"STR\", __FUNCTION__);\n   }\n\n   g_free(pipeName);\n   g_free(packet);\n\n   return err;\n}","22926":"process_secondary_order(STREAM s)\n{\n\t\n\tuint16 length;\n\tuint16 flags;\n\tuint8 type;\n\tuint8 *next_order;\n\n\tin_uint16_le(s, length);\n\tin_uint16_le(s, flags);\t\n\tin_uint8(s, type);\n\n\tnext_order = s->p + (sint16) length + 7;\n\n\tswitch (type)\n\t{\n\t\tcase RDP_ORDER_RAW_BMPCACHE:\n\t\t\tprocess_raw_bmpcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_COLCACHE:\n\t\t\tprocess_colcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BMPCACHE:\n\t\t\tprocess_bmpcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_FONTCACHE:\n\t\t\tprocess_fontcache(s);\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_RAW_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, False);\t\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, True);\t\n\t\t\tbreak;\n\n\t\tcase RDP_ORDER_BRUSHCACHE:\n\t\t\tprocess_brushcache(s, flags);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tlogger(Graphics, Warning,\n\t\t\t       \"STR\", type);\n\t}\n\n\ts->p = next_order;\n}","23721":"static av_cold void uninit(AVFilterContext *ctx)\n{\n    GradFunContext *s = ctx->priv;\n    av_freep(&s->buf);\n}","23025":"SYSCALL_DEFINE6(io_uring_enter, unsigned int, fd, u32, to_submit,\n\t\tu32, min_complete, u32, flags, const sigset_t __user *, sig,\n\t\tsize_t, sigsz)\n{\n\tstruct io_ring_ctx *ctx;\n\tlong ret = -EBADF;\n\tint submitted = 0;\n\tstruct fd f;\n\n\tio_run_task_work();\n\n\tif (flags & ~(IORING_ENTER_GETEVENTS | IORING_ENTER_SQ_WAKEUP))\n\t\treturn -EINVAL;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tret = -EOPNOTSUPP;\n\tif (f.file->f_op != &io_uring_fops)\n\t\tgoto out_fput;\n\n\tret = -ENXIO;\n\tctx = f.file->private_data;\n\tif (!percpu_ref_tryget(&ctx->refs))\n\t\tgoto out_fput;\n\n\t\n\tret = 0;\n\tif (ctx->flags & IORING_SETUP_SQPOLL) {\n\t\tif (!list_empty_careful(&ctx->cq_overflow_list))\n\t\t\tio_cqring_overflow_flush(ctx, false, NULL, NULL);\n\t\tif (flags & IORING_ENTER_SQ_WAKEUP)\n\t\t\twake_up(&ctx->sqo_wait);\n\t\tsubmitted = to_submit;\n\t} else if (to_submit) {\n\t\tmutex_lock(&ctx->uring_lock);\n\t\tsubmitted = io_submit_sqes(ctx, to_submit, f.file, fd);\n\t\tmutex_unlock(&ctx->uring_lock);\n\n\t\tif (submitted != to_submit)\n\t\t\tgoto out;\n\t}\n\tif (flags & IORING_ENTER_GETEVENTS) {\n\t\tmin_complete = min(min_complete, ctx->cq_entries);\n\n\t\t\n\t\tif (ctx->flags & IORING_SETUP_IOPOLL &&\n\t\t    !(ctx->flags & IORING_SETUP_SQPOLL)) {\n\t\t\tret = io_iopoll_check(ctx, min_complete);\n\t\t} else {\n\t\t\tret = io_cqring_wait(ctx, min_complete, sig, sigsz);\n\t\t}\n\t}\n\nout:\n\tpercpu_ref_put(&ctx->refs);\nout_fput:\n\tfdput(f);\n\treturn submitted ? submitted : ret;\n}","22854":"PHP_METHOD(Phar, compressFiles)\n{\n\tchar *error;\n\tphp_uint32 flags;\n\tlong method;\n\tPHAR_ARCHIVE_OBJECT();\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"STR\", &method) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (PHAR_G(readonly) && !phar_obj->arc.archive->is_data) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC,\n\t\t\t\"STR\");\n\t\treturn;\n\t}\n\n\tswitch (method) {\n\t\tcase PHAR_ENT_COMPRESSED_GZ:\n\t\t\tif (!PHAR_G(has_zlib)) {\n\t\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC,\n\t\t\t\t\t\"STR\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tflags = PHAR_ENT_COMPRESSED_GZ;\n\t\t\tbreak;\n\n\t\tcase PHAR_ENT_COMPRESSED_BZ2:\n\t\t\tif (!PHAR_G(has_bz2)) {\n\t\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC,\n\t\t\t\t\t\"STR\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tflags = PHAR_ENT_COMPRESSED_BZ2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC,\n\t\t\t\t\"STR\");\n\t\t\treturn;\n\t}\n\n\tif (phar_obj->arc.archive->is_tar) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC,\n\t\t\t\"STR\");\n\t\treturn;\n\t}\n\n\tif (!pharobj_cancompress(&phar_obj->arc.archive->manifest TSRMLS_CC)) {\n\t\tif (flags == PHAR_FILE_COMPRESSED_GZ) {\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC,\n\t\t\t\t\"STR\");\n\t\t} else {\n\t\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC,\n\t\t\t\t\"STR\");\n\t\t}\n\t\treturn;\n\t}\n\n\tif (phar_obj->arc.archive->is_persistent && FAILURE == phar_copy_on_write(&(phar_obj->arc.archive) TSRMLS_CC)) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, \"STR\", phar_obj->arc.archive->fname);\n\t\treturn;\n\t}\n\tpharobj_set_compression(&phar_obj->arc.archive->manifest, flags TSRMLS_CC);\n\tphar_obj->arc.archive->is_modified = 1;\n\tphar_flush(phar_obj->arc.archive, 0, 0, 0, &error TSRMLS_CC);\n\n\tif (error) {\n\t\tzend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, \"STR\", error);\n\t\tefree(error);\n\t}\n}","22822":"ldns_tsig_keydata_clone(const ldns_tsig_credentials *tc)\n{\n\treturn strdup(tc->keydata);\n}","23596":"gdm_session_get_display_mode (GdmSession *self)\n{\n        g_debug (\"STR\",\n                 self->priv->session_type,\n                 self->priv->is_program_session? \"STR\",\n                 self->priv->display_seat_id);\n\n#ifdef ENABLE_WAYLAND_SUPPORT\n        \n        if (g_strcmp0 (self->priv->session_type, \"STR\") == 0) {\n                return GDM_SESSION_DISPLAY_MODE_NEW_VT;\n        }\n#endif\n\n        \n        if (g_strcmp0 (self->priv->display_seat_id, \"STR\") != 0) {\n                return GDM_SESSION_DISPLAY_MODE_REUSE_VT;\n        }\n\n        \n        if (self->priv->is_program_session) {\n                return GDM_SESSION_DISPLAY_MODE_NEW_VT;\n        }\n\n        \n        return GDM_SESSION_DISPLAY_MODE_NEW_VT;\n}","22852":"int LUKS2_reencrypt_locked_recovery_by_passphrase(struct crypt_device *cd,\n\tint keyslot_old,\n\tint keyslot_new,\n\tconst char *passphrase,\n\tsize_t passphrase_size,\n\tuint32_t flags __attribute__((unused)),\n\tstruct volume_key **vks)\n{\n\tuint64_t minimal_size, device_size;\n\tint keyslot, r = -EINVAL;\n\tstruct luks2_hdr *hdr = crypt_get_hdr(cd, CRYPT_LUKS2);\n\tstruct volume_key *vk = NULL, *_vks = NULL;\n\n\tlog_dbg(cd, \"STR\");\n\n\tif (LUKS2_get_data_size(hdr, &minimal_size, NULL))\n\t\treturn r;\n\n\tr = LUKS2_keyslot_open_all_segments(cd, keyslot_old, keyslot_new,\n\t\t\tpassphrase, passphrase_size, &_vks);\n\tif (r < 0)\n\t\tgoto out;\n\tkeyslot = r;\n\n\tif (crypt_use_keyring_for_vk(cd))\n\t\tvk = _vks;\n\n\twhile (vk) {\n\t\tr = LUKS2_volume_key_load_in_keyring_by_digest(cd, hdr, vk, crypt_volume_key_get_id(vk));\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t\tvk = crypt_volume_key_next(vk);\n\t}\n\n\tif (LUKS2_reencrypt_check_device_size(cd, hdr, minimal_size, &device_size, true, false))\n\t\tgoto out;\n\n\tr = reencrypt_recovery(cd, hdr, device_size, _vks);\n\n\tif (!r && vks)\n\t\tMOVE_REF(*vks, _vks);\nout:\n\tif (r < 0)\n\t\tcrypt_drop_keyring_key(cd, _vks);\n\tcrypt_free_volume_key(_vks);\n\n\treturn r < 0 ? r : keyslot;\n}","23587":"action_set_classify(const struct ofpact *a)\n{\n    switch (a->type) {\n\n        ACTION_SET_ORDER\n#undef SLOT\n\n\n        ACTION_SET_FINAL_PRIORITY\n#undef FINAL\n\n    case OFPACT_SET_FIELD:\n    case OFPACT_REG_MOVE:\n    case OFPACT_SET_ETH_DST:\n    case OFPACT_SET_ETH_SRC:\n    case OFPACT_SET_IP_DSCP:\n    case OFPACT_SET_IP_ECN:\n    case OFPACT_SET_IP_TTL:\n    case OFPACT_SET_IPV4_DST:\n    case OFPACT_SET_IPV4_SRC:\n    case OFPACT_SET_L4_DST_PORT:\n    case OFPACT_SET_L4_SRC_PORT:\n    case OFPACT_SET_MPLS_LABEL:\n    case OFPACT_SET_MPLS_TC:\n    case OFPACT_SET_MPLS_TTL:\n    case OFPACT_SET_QUEUE:\n    case OFPACT_SET_TUNNEL:\n    case OFPACT_SET_VLAN_PCP:\n    case OFPACT_SET_VLAN_VID:\n        return ACTION_SLOT_SET_OR_MOVE;\n\n    case OFPACT_BUNDLE:\n    case OFPACT_CLEAR_ACTIONS:\n    case OFPACT_CLONE:\n    case OFPACT_NAT:\n    case OFPACT_CONTROLLER:\n    case OFPACT_ENQUEUE:\n    case OFPACT_EXIT:\n    case OFPACT_UNROLL_XLATE:\n    case OFPACT_FIN_TIMEOUT:\n    case OFPACT_GOTO_TABLE:\n    case OFPACT_LEARN:\n    case OFPACT_CONJUNCTION:\n    case OFPACT_METER:\n    case OFPACT_MULTIPATH:\n    case OFPACT_NOTE:\n    case OFPACT_OUTPUT_REG:\n    case OFPACT_OUTPUT_TRUNC:\n    case OFPACT_POP_QUEUE:\n    case OFPACT_SAMPLE:\n    case OFPACT_STACK_POP:\n    case OFPACT_STACK_PUSH:\n    case OFPACT_WRITE_ACTIONS:\n    case OFPACT_WRITE_METADATA:\n    case OFPACT_DEBUG_RECIRC:\n    case OFPACT_DEBUG_SLOW:\n        return ACTION_SLOT_INVALID;\n\n    default:\n        OVS_NOT_REACHED();\n    }\n}","23756":"LibRaw_byte_buffer *LibRaw_abstract_datastream::make_byte_buffer(unsigned int sz)\n{\n    LibRaw_byte_buffer *ret = new LibRaw_byte_buffer(sz);\n    read(ret->get_buffer(),sz,1);\n    return ret;\n}","22695":"TEST_F(QuantizedConv2DTest, SmallWithNoZero) {\n  const int stride = 1;\n  TF_ASSERT_OK(NodeDefBuilder(\"STR\")\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_QUINT8))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr(\"STR\", DataTypeToEnum<qint32>::v())\n                   .Attr(\"STR\", {1, stride, stride, 1})\n                   .Attr(\"STR\")\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  const int depth = 1;\n  const int image_width = 4;\n  const int image_height = 3;\n  const int image_batch_count = 1;\n  \n  \n  \n  const float image_min = 1.0f;\n  const float image_max = 12.0f;\n  Tensor image_float(DT_FLOAT,\n                     {image_batch_count, image_height, image_width, depth});\n  test::FillValues<float>(&image_float,\n                          {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12});\n  Tensor image_quantized =\n      FloatTensorToQuantized<quint8>(image_float, image_min, image_max);\n  const int filter_size = 3;\n  const int filter_count = 1;\n  const float filter_min = 1.0f;\n  const float filter_max = 9.0f;\n  Tensor filter_float(DT_FLOAT,\n                      {filter_size, filter_size, depth, filter_count});\n  test::FillValues<float>(&filter_float, {1, 4, 7, 2, 5, 8, 3, 6, 9});\n  Tensor filter_quantized =\n      FloatTensorToQuantized<quint8>(filter_float, filter_min, filter_max);\n  AddInputFromArray<quint8>(image_quantized.shape(),\n                            image_quantized.flat<quint8>());\n  AddInputFromArray<quint8>(filter_quantized.shape(),\n                            filter_quantized.flat<quint8>());\n  AddInputFromArray<float>(TensorShape({1}), {image_min});\n  AddInputFromArray<float>(TensorShape({1}), {image_max});\n  AddInputFromArray<float>(TensorShape({1}), {filter_min});\n  AddInputFromArray<float>(TensorShape({1}), {filter_max});\n  TF_ASSERT_OK(RunOpKernel());\n  const int expected_width = image_width;\n  const int expected_height = image_height * filter_count;\n  Tensor expected_float(\n      DT_FLOAT, TensorShape({image_batch_count, expected_height, expected_width,\n                             filter_count}));\n  test::FillValues<float>(&expected_float, {105, 150, 183, 95, 235, 312, 357,\n                                            178, 187, 234, 261, 121});\n  const Tensor& output_quantized = *GetOutput(0);\n  const float output_min = GetOutput(1)->flat<float>()(0);\n  const float output_max = GetOutput(2)->flat<float>()(0);\n  Tensor output_float =\n      QuantizedTensorToFloat<qint32>(output_quantized, output_min, output_max);\n  test::ExpectTensorNear<float>(expected_float, output_float, 1.0);\n}","22601":"StringVal EncryptionFunctions::from_base64(FunctionContext* ctx, const StringVal& src) {\n    if (src.len == 0 || src.is_null) {\n        return StringVal::null();\n    }\n\n    int cipher_len = src.len;\n    std::unique_ptr<char[]> p;\n    p.reset(new char[cipher_len]);\n\n    int ret_code = base64_decode((const char*)src.ptr, src.len, p.get());\n    if (ret_code < 0) {\n        return StringVal::null();\n    }\n    return AnyValUtil::from_buffer_temp(ctx, p.get(), ret_code);\n}","23576":"sv_locale (name)\n     char *name;\n{\n  char *v;\n\n  v = get_string_value (name);\n  if (name[0] == 'L' && name[1] == 'A')\t\n    set_lang (name, v);\n  else\n    set_locale_var (name, v);\t\t\n}","22747":"MemTxResult address_space_read_continue(AddressSpace *as, hwaddr addr,\n                                        MemTxAttrs attrs, uint8_t *buf,\n                                        int len, hwaddr addr1, hwaddr l,\n                                        MemoryRegion *mr)\n{\n    uint8_t *ptr;\n    uint64_t val;\n    MemTxResult result = MEMTX_OK;\n    bool release_lock = false;\n\n    for (;;) {\n        if (!memory_access_is_direct(mr, false)) {\n            \n            release_lock |= prepare_mmio_access(mr);\n            l = memory_access_size(mr, l, addr1);\n            switch (l) {\n            case 8:\n                \n                result |= memory_region_dispatch_read(mr, addr1, &val, 8,\n                                                      attrs);\n                stq_p(buf, val);\n                break;\n            case 4:\n                \n                result |= memory_region_dispatch_read(mr, addr1, &val, 4,\n                                                      attrs);\n                stl_p(buf, val);\n                break;\n            case 2:\n                \n                result |= memory_region_dispatch_read(mr, addr1, &val, 2,\n                                                      attrs);\n                stw_p(buf, val);\n                break;\n            case 1:\n                \n                result |= memory_region_dispatch_read(mr, addr1, &val, 1,\n                                                      attrs);\n                stb_p(buf, val);\n                break;\n            default:\n                abort();\n            }\n        } else {\n            \n            ptr = qemu_map_ram_ptr(mr->ram_block, addr1);\n            memcpy(buf, ptr, l);\n        }\n\n        if (release_lock) {\n            qemu_mutex_unlock_iothread();\n            release_lock = false;\n        }\n\n        len -= l;\n        buf += l;\n        addr += l;\n\n        if (!len) {\n            break;\n        }\n\n        l = len;\n        mr = address_space_translate(as, addr, &addr1, &l, false);\n    }\n\n    return result;\n}","23607":"int addattrstrz(struct nlmsghdr *n, int maxlen, int type, const char *str)\n{\n\treturn addattr_l(n, maxlen, type, str, strlen(str)+1);\n}","23386":"DLLEXPORT unsigned long tjBufSizeYUV2(int width, int pad, int height,\n                                      int subsamp)\n{\n  int retval = 0, nc, i;\n\n  if (subsamp < 0 || subsamp >= NUMSUBOPT)\n    THROWG(\"STR\");\n\n  nc = (subsamp == TJSAMP_GRAY ? 1 : 3);\n  for (i = 0; i < nc; i++) {\n    int pw = tjPlaneWidth(i, width, subsamp);\n    int stride = PAD(pw, pad);\n    int ph = tjPlaneHeight(i, height, subsamp);\n\n    if (pw < 0 || ph < 0) return -1;\n    else retval += stride * ph;\n  }\n\nbailout:\n  return retval;\n}","22596":"read_bytes(FILE *fp, void *buf, size_t bytes_to_read, int fail_on_eof,\n    char *errbuf)\n{\n\tsize_t amt_read;\n\n\tamt_read = fread(buf, 1, bytes_to_read, fp);\n\tif (amt_read != bytes_to_read) {\n\t\tif (ferror(fp)) {\n\t\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    errno, \"STR\");\n\t\t} else {\n\t\t\tif (amt_read == 0 && !fail_on_eof)\n\t\t\t\treturn (0);\t\n\t\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE,\n\t\t\t    \"STR\" PRIsize,\n\t\t\t    bytes_to_read, amt_read);\n\t\t}\n\t\treturn (-1);\n\t}\n\treturn (1);\n}","23397":"static void put_aggregate(struct sched_domain *sd)\n{\n\tspin_unlock(&per_cpu(aggregate_lock, sd->first_cpu));\n}","22862":"local int fixed(struct state *s)\n{\n    static int virgin = 1;\n    static short lencnt[MAXBITS+1], lensym[FIXLCODES];\n    static short distcnt[MAXBITS+1], distsym[MAXDCODES];\n    static struct huffman lencode, distcode;\n\n    \n    if (virgin) {\n        int symbol;\n        short lengths[FIXLCODES];\n\n        \n        lencode.count = lencnt;\n        lencode.symbol = lensym;\n        distcode.count = distcnt;\n        distcode.symbol = distsym;\n\n        \n        for (symbol = 0; symbol < 144; symbol++)\n            lengths[symbol] = 8;\n        for (; symbol < 256; symbol++)\n            lengths[symbol] = 9;\n        for (; symbol < 280; symbol++)\n            lengths[symbol] = 7;\n        for (; symbol < FIXLCODES; symbol++)\n            lengths[symbol] = 8;\n        construct(&lencode, lengths, FIXLCODES);\n\n        \n        for (symbol = 0; symbol < MAXDCODES; symbol++)\n            lengths[symbol] = 5;\n        construct(&distcode, lengths, MAXDCODES);\n\n        \n        virgin = 0;\n    }\n\n    \n    return codes(s, &lencode, &distcode);\n}","23075":"static void sev_unpin_memory(struct kvm *kvm, struct page **pages,\n\t\t\t     unsigned long npages)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\tunpin_user_pages(pages, npages);\n\tkvfree(pages);\n\tsev->pages_locked -= npages;\n}","23295":"void\nyyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...)\n{\n  free(*param->value);\n  if (yylloc->first_line != -1) {\n    if (*param->data_node && (*param->data_node) == (*param->actual_node)) {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_LYS, *param->data_node, yyget_text(scanner));\n    } else {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));\n    }\n  }","23665":"gr_uint32 gr_face_lang_by_index(const gr_face* pFace, gr_uint16 i)\n{\n    assert(pFace);\n    return pFace->theSill().getLangName(i);\n}","22667":"evtchn_port_t evtchn_from_irq(unsigned irq)\n{\n\tif (WARN(irq >= nr_irqs, \"STR\", irq))\n\t\treturn 0;\n\n\treturn info_for_irq(irq)->evtchn;\n}","23633":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteSequenceRNNParams*>(node->builtin_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* input_weights = GetInput(context, node, kWeightsTensor);\n  const TfLiteTensor* recurrent_weights =\n      GetInput(context, node, kRecurrentWeightsTensor);\n  const TfLiteTensor* bias = GetInput(context, node, kBiasTensor);\n  \n  TfLiteTensor* hidden_state =\n      const_cast<TfLiteTensor*>(GetInput(context, node, kHiddenStateTensor));\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  switch (input_weights->type) {\n    case kTfLiteFloat32:\n      return EvalFloat(input, input_weights, recurrent_weights, bias, params,\n                       hidden_state, output);\n    case kTfLiteUInt8:\n    case kTfLiteInt8: {\n      \n      auto* op_data = reinterpret_cast<OpData*>(node->user_data);\n      TfLiteTensor* input_quantized = GetTemporary(context, node, 0);\n      TfLiteTensor* hidden_state_quantized = GetTemporary(context, node, 1);\n      TfLiteTensor* scaling_factors = GetTemporary(context, node, 2);\n      TfLiteTensor* accum_scratch = GetTemporary(context, node, 3);\n      TfLiteTensor* zero_points = GetTemporary(context, node, 4);\n      TfLiteTensor* row_sums = GetTemporary(context, node, 5);\n      return EvalHybrid(input, input_weights, recurrent_weights, bias, params,\n                        input_quantized, hidden_state_quantized,\n                        scaling_factors, hidden_state, output, zero_points,\n                        accum_scratch, row_sums, &op_data->compute_row_sums);\n    }\n    default:\n      TF_LITE_KERNEL_LOG(context, \"STR\",\n                         TfLiteTypeGetName(input_weights->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}","23639":"fascist_firewall_allows_md_impl(const microdesc_t *md,\n                                firewall_connection_t fw_connection,\n                                int pref_only, int pref_ipv6)\n{\n  if (!md) {\n    return 0;\n  }\n\n  \n  if (fw_connection == FIREWALL_DIR_CONNECTION) {\n    return 0;\n  }\n\n  \n  return fascist_firewall_allows_address_addr(&md->ipv6_addr, md->ipv6_orport,\n                                              fw_connection, pref_only,\n                                              pref_ipv6);\n}","22796":"int main()\n{\n   initialize_environment();\n\n   test_format_wrong_size();\n   test_blit_info_format_check();\n   test_blit_info_format_check_null_format();\n   test_format_is_plain_nullptr_deref_trigger();\n   test_format_util_format_is_rgb_nullptr_deref_trigger_illegal_resource();\n   test_format_util_format_is_rgb_nullptr_deref_trigger();\n   test_double_free_in_vrend_renderer_blit_int_trigger_invalid_formats();\n   test_double_free_in_vrend_renderer_blit_int_trigger();\n   test_format_is_has_alpha_nullptr_deref_trigger_original();\n   test_format_is_has_alpha_nullptr_deref_trigger_legal_resource();\n\n   test_heap_overflow_vrend_renderer_transfer_write_iov();\n\n   virgl_renderer_context_destroy(ctx_id);\n   virgl_renderer_cleanup(&cookie);\n   virgl_egl_destroy(test_egl);\n\n   return 0;\n}","23467":"bool SQClass::NewSlot(SQSharedState *ss,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic)\n{\n    SQObjectPtr temp;\n    bool belongs_to_static_table = sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE || bstatic;\n    if(_locked && !belongs_to_static_table)\n        return false; \n    if(_members->Get(key,temp) && _isfield(temp)) \n    {\n        _defaultvalues[_member_idx(temp)].val = val;\n        return true;\n    }\n    if(belongs_to_static_table) {\n        SQInteger mmidx;\n        if((sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE) &&\n            (mmidx = ss->GetMetaMethodIdxByName(key)) != -1) {\n            _metamethods[mmidx] = val;\n        }\n        else {\n            SQObjectPtr theval = val;\n            if(_base && sq_type(val) == OT_CLOSURE) {\n                theval = _closure(val)->Clone();\n                _closure(theval)->_base = _base;\n                __ObjAddRef(_base); \n            }\n            if(sq_type(temp) == OT_NULL) {\n                bool isconstructor;\n                SQVM::IsEqual(ss->_constructoridx, key, isconstructor);\n                if(isconstructor) {\n                    _constructoridx = (SQInteger)_methods.size();\n                }\n                SQClassMember m;\n                m.val = theval;\n                _members->NewSlot(key,SQObjectPtr(_make_method_idx(_methods.size())));\n                _methods.push_back(m);\n            }\n            else {\n                _methods[_member_idx(temp)].val = theval;\n            }\n        }\n        return true;\n    }\n    SQClassMember m;\n    m.val = val;\n    _members->NewSlot(key,SQObjectPtr(_make_field_idx(_defaultvalues.size())));\n    _defaultvalues.push_back(m);\n    return true;\n}","23334":"gss_delete_sec_context (minor_status,\n                        context_handle,\n                        output_token)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_buffer_t\t\toutput_token;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n\n    status = val_del_sec_ctx_args(minor_status, context_handle, output_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    \n\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    if (GSSINT_CHK_LOOP(ctx))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    status = gssint_delete_internal_sec_context(minor_status,\n\t\t\t\t\t\tctx->mech_type,\n\t\t\t\t\t\t&ctx->internal_ctx_id,\n\t\t\t\t\t\toutput_token);\n    if (status)\n\treturn status;\n\n    \n    free(ctx->mech_type->elements);\n    free(ctx->mech_type);\n    free(*context_handle);\n    *context_handle = GSS_C_NO_CONTEXT;\n\n    return (GSS_S_COMPLETE);\n}","22762":"static int stimer_set_config(struct kvm_vcpu_hv_stimer *stimer, u64 config,\n\t\t\t     bool host)\n{\n\tunion hv_stimer_config new_config = {.as_uint64 = config},\n\t\told_config = {.as_uint64 = stimer->config.as_uint64};\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\n\tif (!synic->active && !host)\n\t\treturn 1;\n\n\tif (unlikely(!host && hv_vcpu->enforce_cpuid && new_config.direct_mode &&\n\t\t     !(hv_vcpu->cpuid_cache.features_edx &\n\t\t       HV_STIMER_DIRECT_MODE_AVAILABLE)))\n\t\treturn 1;\n\n\ttrace_kvm_hv_stimer_set_config(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, config, host);\n\n\tstimer_cleanup(stimer);\n\tif (old_config.enable &&\n\t    !new_config.direct_mode && new_config.sintx == 0)\n\t\tnew_config.enable = 0;\n\tstimer->config.as_uint64 = new_config.as_uint64;\n\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\n\treturn 0;\n}","22932":"  Item_param *get_item_param() { return this; }","23727":"SPL_METHOD(GlobIterator, count)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (php_stream_is(intern->u.dir.dirp ,&php_glob_stream_ops)) {\n\t\tRETURN_LONG(php_glob_stream_get_count(intern->u.dir.dirp, NULL));\n\t} else {\n\t\t\n\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"STR\");\n\t}\n}","22701":"int dane_verify_crt_raw (dane_state_t s,\n\tconst gnutls_datum_t *chain, unsigned chain_size,\n\tgnutls_certificate_type_t chain_type,\n        dane_query_t r,\n\tunsigned int sflags, unsigned int vflags,\n\tunsigned int *verify)\n{\ndane_state_t _s = NULL;\nint ret;\nunsigned checked = 0;\nunsigned int usage, type, match, idx;\ngnutls_datum_t data;\n\n\tif (chain_type != GNUTLS_CRT_X509)\n\t\treturn gnutls_assert_val(DANE_E_INVALID_REQUEST);\n\n\t*verify = 0;\n\tidx = 0;\n\tdo {\n\t\tret = dane_query_data(r, idx++, &usage, &type, &match, &data);\n\t\tif (ret == DANE_E_REQUESTED_DATA_NOT_AVAILABLE)\n\t\t\tbreak;\n\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (!(vflags & DANE_VFLAG_ONLY_CHECK_EE_USAGE) && (usage == DANE_CERT_USAGE_LOCAL_CA || usage == DANE_CERT_USAGE_CA)) {\n\t\t\tret = verify_ca(chain, chain_size, chain_type, type, match, &data, verify);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto cleanup;\n                        }\n                        checked = 1;\n\t\t} else if (!(vflags & DANE_VFLAG_ONLY_CHECK_CA_USAGE) && (usage == DANE_CERT_USAGE_LOCAL_EE || usage == DANE_CERT_USAGE_EE)) {\n\t\t\tret = verify_ee(&chain[0], chain_type, type, match, &data, verify);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto cleanup;\n                        }\n                        checked = 1;\n\t\t}\n\t} while(1);\n\n\tif ((vflags & DANE_VFLAG_FAIL_IF_NOT_CHECKED) && checked == 0)\n\t\tret = gnutls_assert_val(DANE_E_REQUESTED_DATA_NOT_AVAILABLE);\n\telse\n\t\tret = 0;\n\ncleanup:\n\tif (s == NULL) dane_state_deinit(_s);\n\treturn ret;\n}","23547":"rsvg_handle_close_impl (RsvgHandle * handle, GError ** error)\n{\n    GError *real_error = NULL;\n\n\thandle->priv->is_closed = TRUE;\n\n    handle->priv->error = &real_error;\n\n    if (handle->priv->ctxt != NULL) {\n        xmlDocPtr xmlDoc;\n        int result;\n\n        xmlDoc = handle->priv->ctxt->myDoc;\n\n        result = xmlParseChunk (handle->priv->ctxt, \"\", 0, TRUE);\n        if (result != 0) {\n            rsvg_set_error (error, handle->priv->ctxt);\n            xmlFreeParserCtxt (handle->priv->ctxt);\n            xmlFreeDoc (xmlDoc);\n            return FALSE;\n        }\n\n        xmlFreeParserCtxt (handle->priv->ctxt);\n        xmlFreeDoc (xmlDoc);\n    }\n\n    rsvg_defs_resolve_all (handle->priv->defs);\n    handle->priv->finished = TRUE;\n    handle->priv->error = NULL;\n\n    if (real_error != NULL) {\n        g_propagate_error (error, real_error);\n        return FALSE;\n    }\n\n    return TRUE;\n}","23456":"static void nsc_rle_decode(BYTE* in, BYTE* out, UINT32 originalSize)\n{\n\tUINT32 len;\n\tUINT32 left;\n\tBYTE value;\n\tleft = originalSize;\n\n\twhile (left > 4)\n\t{\n\t\tvalue = *in++;\n\n\t\tif (left == 5)\n\t\t{\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t\telse if (value == *in)\n\t\t{\n\t\t\tin++;\n\n\t\t\tif (*in < 0xFF)\n\t\t\t{\n\t\t\t\tlen = (UINT32) * in++;\n\t\t\t\tlen += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tin++;\n\t\t\t\tlen = *((UINT32*) in);\n\t\t\t\tin += 4;\n\t\t\t}\n\n\t\t\tFillMemory(out, len, value);\n\t\t\tout += len;\n\t\t\tleft -= len;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t}\n\n\t*((UINT32*)out) = *((UINT32*)in);\n}","23579":"f_shellescape(typval_T *argvars, typval_T *rettv)\n{\n    int do_special = non_zero_arg(&argvars[1]);\n\n    rettv->vval.v_string = vim_strsave_shellescape(\n\t\t\t   tv_get_string(&argvars[0]), do_special, do_special);\n    rettv->v_type = VAR_STRING;\n}","23524":"ews_store_set_property (GObject *object,\n                        guint property_id,\n                        const GValue *value,\n                        GParamSpec *pspec)\n{\n\tswitch (property_id) {\n\t\tcase PROP_HAS_OOO_SET:\n\t\t\tcamel_ews_store_set_has_ooo_set (\n\t\t\t\tCAMEL_EWS_STORE (object),\n\t\t\t\tg_value_get_boolean (value));\n\t\t\treturn;\n\t\tcase PROP_OOO_ALERT_STATE:\n\t\t\tcamel_ews_store_set_ooo_alert_state (\n\t\t\t\tCAMEL_EWS_STORE (object),\n\t\t\t\tg_value_get_enum (value));\n\t\t\treturn;\n\t\tcase PROP_CONNECTABLE:\n\t\t\tcamel_network_service_set_connectable (\n\t\t\t\tCAMEL_NETWORK_SERVICE (object),\n\t\t\t\tg_value_get_object (value));\n\t\t\treturn;\n\t}\n\n\tG_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);\n}","22996":"static bool context_has_no_new_privileges(const ExecContext *c) {\n        assert(c);\n\n        if (c->no_new_privileges)\n                return true;\n\n        if (have_effective_cap(CAP_SYS_ADMIN)) \n                return false;\n\n        \n        return context_has_address_families(c) ||\n                c->memory_deny_write_execute ||\n                c->restrict_realtime ||\n                exec_context_restrict_namespaces_set(c) ||\n                c->protect_kernel_tunables ||\n                c->protect_kernel_modules ||\n                c->private_devices ||\n                context_has_syscall_filters(c) ||\n                !set_isempty(c->syscall_archs) ||\n                c->lock_personality ||\n                c->protect_hostname;\n}","22946":"RemotePeer *PeerFactory::createPeer(const ProtoList &protocols, AuthHandler *authHandler, QTcpSocket *socket, Compressor::CompressionLevel level, QObject *parent)\n{\n    foreach(const ProtoDescriptor &protodesc, protocols) {\n        Protocol::Type proto = protodesc.first;\n        quint16 features = protodesc.second;\n        switch(proto) {\n            case Protocol::LegacyProtocol:\n                return new LegacyPeer(authHandler, socket, level, parent);\n            case Protocol::DataStreamProtocol:\n                if (DataStreamPeer::acceptsFeatures(features))\n                    return new DataStreamPeer(authHandler, socket, features, level, parent);\n                break;\n            default:\n                break;\n        }\n    }\n\n    return 0;\n}","22920":"int dom_document_doctype_read(dom_object *obj, zval **retval TSRMLS_DC)\n{\n\txmlDoc *docp;\n\txmlDtdPtr dtdptr;\n\tint ret;\n\n\tdocp = (xmlDocPtr) dom_object_get_node(obj);\n\n\tif (docp == NULL) {\n\t\tphp_dom_throw_error(INVALID_STATE_ERR, 0 TSRMLS_CC);\n\t\treturn FAILURE;\n\t}\n\n\tALLOC_ZVAL(*retval);\n\n\tdtdptr = xmlGetIntSubset(docp);\n\tif (!dtdptr) {\n\t\tZVAL_NULL(*retval);\n\t\treturn SUCCESS;\n\t}\n\n\tif (NULL == (*retval = php_dom_create_object((xmlNodePtr) dtdptr, &ret, *retval, obj TSRMLS_CC))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"STR\");\n\t\treturn FAILURE;\n\t}\n\treturn SUCCESS;\n\n}","22931":"void dtls1_stop_timer(SSL *s)\n{\n    \n    memset(&(s->d1->timeout), 0, sizeof(struct dtls1_timeout_st));\n    memset(&(s->d1->next_timeout), 0, sizeof(struct timeval));\n    s->d1->timeout_duration = 1;\n    BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0,\n             &(s->d1->next_timeout));\n    \n    dtls1_clear_record_buffer(s);\n}","23436":"static int xen_netbk_tx_check_gop(struct xen_netbk *netbk,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct gnttab_copy **gopp)\n{\n\tstruct gnttab_copy *gop = *gopp;\n\tu16 pending_idx = *((u16 *)skb->data);\n\tstruct pending_tx_info *pending_tx_info = netbk->pending_tx_info;\n\tstruct xenvif *vif = pending_tx_info[pending_idx].vif;\n\tstruct xen_netif_tx_request *txp;\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tint nr_frags = shinfo->nr_frags;\n\tint i, err, start;\n\n\t\n\terr = gop->status;\n\tif (unlikely(err)) {\n\t\tpending_ring_idx_t index;\n\t\tindex = pending_index(netbk->pending_prod++);\n\t\ttxp = &pending_tx_info[pending_idx].req;\n\t\tmake_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);\n\t\tnetbk->pending_ring[index] = pending_idx;\n\t\txenvif_put(vif);\n\t}\n\n\t\n\tstart = (frag_get_pending_idx(&shinfo->frags[0]) == pending_idx);\n\n\tfor (i = start; i < nr_frags; i++) {\n\t\tint j, newerr;\n\t\tpending_ring_idx_t index;\n\n\t\tpending_idx = frag_get_pending_idx(&shinfo->frags[i]);\n\n\t\t\n\t\tnewerr = (++gop)->status;\n\t\tif (likely(!newerr)) {\n\t\t\t\n\t\t\tif (unlikely(err))\n\t\t\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\ttxp = &netbk->pending_tx_info[pending_idx].req;\n\t\tmake_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);\n\t\tindex = pending_index(netbk->pending_prod++);\n\t\tnetbk->pending_ring[index] = pending_idx;\n\t\txenvif_put(vif);\n\n\t\t\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\t\n\t\tpending_idx = *((u16 *)skb->data);\n\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\tfor (j = start; j < i; j++) {\n\t\t\tpending_idx = frag_get_pending_idx(&shinfo->frags[j]);\n\t\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\t}\n\n\t\t\n\t\terr = newerr;\n\t}\n\n\t*gopp = gop + 1;\n\treturn err;\n}","23769":"int ssh_scp_push_file(ssh_scp scp, const char *filename, size_t size, int mode){\n\treturn ssh_scp_push_file64(scp, filename, (uint64_t) size, mode);\n}","23753":"static UINT32 nsc_rle_encode(BYTE* in, BYTE* out, UINT32 originalSize)\n{\n\tUINT32 left;\n\tUINT32 runlength = 1;\n\tUINT32 planeSize = 0;\n\tleft = originalSize;\n\n\t\n\twhile (left > 4 && planeSize < originalSize - 4)\n\t{\n\t\tif (left > 5 && *in == *(in + 1))\n\t\t{\n\t\t\trunlength++;\n\t\t}\n\t\telse if (runlength == 1)\n\t\t{\n\t\t\t*out++ = *in;\n\t\t\tplaneSize++;\n\t\t}\n\t\telse if (runlength < 256)\n\t\t{\n\t\t\t*out++ = *in;\n\t\t\t*out++ = *in;\n\t\t\t*out++ = runlength - 2;\n\t\t\trunlength = 1;\n\t\t\tplaneSize += 3;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*out++ = *in;\n\t\t\t*out++ = *in;\n\t\t\t*out++ = 0xFF;\n\t\t\t*out++ = (runlength & 0x000000FF);\n\t\t\t*out++ = (runlength & 0x0000FF00) >> 8;\n\t\t\t*out++ = (runlength & 0x00FF0000) >> 16;\n\t\t\t*out++ = (runlength & 0xFF000000) >> 24;\n\t\t\trunlength = 1;\n\t\t\tplaneSize += 7;\n\t\t}\n\n\t\tin++;\n\t\tleft--;\n\t}\n\n\tif (planeSize < originalSize - 4)\n\t\tCopyMemory(out, in, 4);\n\n\tplaneSize += 4;\n\treturn planeSize;\n}","23101":"    inline int check(int itemSize, int nItems=1)\n    {\n      if (ptr + itemSize * nItems > end) {\n        if (ptr + itemSize > end)\n          return overrun(itemSize, nItems);\n\n        nItems = (end - ptr) \/ itemSize;\n      }\n      return nItems;\n    }","23399":"static unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)\n{\n\tunsigned char present = 0;\n\tstruct page *page;\n\n\t\n#ifdef CONFIG_SWAP\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\t\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\tif (page) {\n\t\tpresent = PageUptodate(page);\n\t\tput_page(page);\n\t}\n\n\treturn present;\n}","23688":"static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,\n\t\t\t      indx, data, size, 100);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"STR\", __func__, ret);\n\treturn ret;\n}","22590":"static void qxl_reset_surfaces(PCIQXLDevice *d)\n{\n    dprint(d, 1, \"STR\", __FUNCTION__);\n    d->mode = QXL_MODE_UNDEFINED;\n    qxl_spice_destroy_surfaces(d);\n}","22621":"static int ahci_dma_prepare_buf(IDEDMA *dma, int is_write)\n{\n    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);\n    IDEState *s = &ad->port.ifs[0];\n\n    ahci_populate_sglist(ad, &s->sg, s->io_buffer_offset);\n    s->io_buffer_size = s->sg.size;\n\n    DPRINTF(ad->port_no, \"STR\", s->io_buffer_size);\n    return s->io_buffer_size != 0;\n}","22521":"static void __init netlink_add_usersock_entry(void)\n{\n\tstruct listeners *listeners;\n\tint groups = 32;\n\n\tlisteners = kzalloc(sizeof(*listeners) + NLGRPSZ(groups), GFP_KERNEL);\n\tif (!listeners)\n\t\tpanic(\"STR\");\n\n\tnetlink_table_grab();\n\n\tnl_table[NETLINK_USERSOCK].groups = groups;\n\trcu_assign_pointer(nl_table[NETLINK_USERSOCK].listeners, listeners);\n\tnl_table[NETLINK_USERSOCK].module = THIS_MODULE;\n\tnl_table[NETLINK_USERSOCK].registered = 1;\n\n\tnetlink_table_ungrab();\n}","23027":"static void enable_no_etm(gnutls_priority_t c)\n{\n\tc->no_etm = 1;\n}","23043":"has_schema_privilege_id_name(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\troleid = PG_GETARG_OID(0);\n\ttext\t   *schemaname = PG_GETARG_TEXT_P(1);\n\ttext\t   *priv_type_text = PG_GETARG_TEXT_P(2);\n\tOid\t\t\tschemaoid;\n\tAclMode\t\tmode;\n\tAclResult\taclresult;\n\n\tschemaoid = convert_schema_name(schemaname);\n\tmode = convert_schema_priv_string(priv_type_text);\n\n\taclresult = pg_namespace_aclcheck(schemaoid, roleid, mode);\n\n\tPG_RETURN_BOOL(aclresult == ACLCHECK_OK);\n}","22883":"cmsPipeline* BuildGrayOutputPipeline(cmsHPROFILE hProfile)\n{\n    cmsToneCurve *GrayTRC, *RevGrayTRC;\n    cmsPipeline* Lut;\n    cmsContext ContextID = cmsGetProfileContextID(hProfile);\n\n    GrayTRC = (cmsToneCurve *) cmsReadTag(hProfile, cmsSigGrayTRCTag);\n    if (GrayTRC == NULL) return NULL;\n\n    RevGrayTRC = cmsReverseToneCurve(GrayTRC);\n    if (RevGrayTRC == NULL) return NULL;\n\n    Lut = cmsPipelineAlloc(ContextID, 3, 1);\n    if (Lut == NULL) {\n        cmsFreeToneCurve(RevGrayTRC);\n        return NULL;\n    }\n\n    if (cmsGetPCS(hProfile) == cmsSigLabData) {\n\n        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 1,  3, PickLstarMatrix, NULL));\n    }\n    else  {\n        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 1,  3, PickYMatrix, NULL));\n    }\n\n    cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 1, &RevGrayTRC));\n    cmsFreeToneCurve(RevGrayTRC);\n\n    return Lut;\n}","23148":"GooString *FileSpec::getFileNameForPlatform()\n{\n  if (platformFileName)\n    return platformFileName;\n\n  Object obj1 = getFileSpecNameForPlatform(&fileSpec);\n  if (obj1.isString())\n    platformFileName = obj1.getString()->copy();\n\n  return platformFileName;\n}","23241":"__perf_event_account_interrupt(struct perf_event *event, int throttle)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint ret = 0;\n\tu64 seq;\n\n\tseq = __this_cpu_read(perf_throttled_seq);\n\tif (seq != hwc->interrupts_seq) {\n\t\thwc->interrupts_seq = seq;\n\t\thwc->interrupts = 1;\n\t} else {\n\t\thwc->interrupts++;\n\t\tif (unlikely(throttle\n\t\t\t     && hwc->interrupts >= max_samples_per_tick)) {\n\t\t\t__this_cpu_inc(perf_throttled_count);\n\t\t\ttick_dep_set_cpu(smp_processor_id(), TICK_DEP_BIT_PERF_EVENTS);\n\t\t\thwc->interrupts = MAX_INTERRUPTS;\n\t\t\tperf_log_throttle(event, 0);\n\t\t\tret = 1;\n\t\t}\n\t}\n\n\tif (event->attr.freq) {\n\t\tu64 now = perf_clock();\n\t\ts64 delta = now - hwc->freq_time_stamp;\n\n\t\thwc->freq_time_stamp = now;\n\n\t\tif (delta > 0 && delta < 2*TICK_NSEC)\n\t\t\tperf_adjust_period(event, delta, hwc->last_period, true);\n\t}\n\n\treturn ret;\n}","22760":"static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tzend_op *opline = EX(opline);\n\tzend_free_op free_op1, free_op2;\n\tzval *result = &EX_T(opline->result.u.var).tmp_var;\n\n\tis_identical_function(result,\n\t\t_get_zval_ptr_var(&opline->op1, EX(Ts), &free_op1 TSRMLS_CC),\n\t\t_get_zval_ptr_tmp(&opline->op2, EX(Ts), &free_op2 TSRMLS_CC) TSRMLS_CC);\n\tZ_LVAL_P(result) = !Z_LVAL_P(result);\n\tif (free_op1.var) {zval_ptr_dtor(&free_op1.var);};\n\tzval_dtor(free_op2.var);\n\tZEND_VM_NEXT_OPCODE();\n}","23329":"static int l2cap_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"STR\", sk, backlog);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_BOUND || sock->type != SOCK_SEQPACKET) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tswitch (l2cap_pi(sk)->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\t\tif (enable_ertm)\n\t\t\tbreak;\n\t\t\n\tdefault:\n\t\terr = -ENOTSUPP;\n\t\tgoto done;\n\t}\n\n\tif (!l2cap_pi(sk)->psm) {\n\t\tbdaddr_t *src = &bt_sk(sk)->src;\n\t\tu16 psm;\n\n\t\terr = -EINVAL;\n\n\t\twrite_lock_bh(&l2cap_sk_list.lock);\n\n\t\tfor (psm = 0x1001; psm < 0x1100; psm += 2)\n\t\t\tif (!__l2cap_get_sock_by_addr(cpu_to_le16(psm), src)) {\n\t\t\t\tl2cap_pi(sk)->psm   = cpu_to_le16(psm);\n\t\t\t\tl2cap_pi(sk)->sport = cpu_to_le16(psm);\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\twrite_unlock_bh(&l2cap_sk_list.lock);\n\n\t\tif (err < 0)\n\t\t\tgoto done;\n\t}\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\tsk->sk_state = BT_LISTEN;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}","23412":"rsvg_new_polyline (void)\n{\n    return rsvg_new_any_poly (TRUE);\n}","23074":"bool Item_func::count_string_result_length(enum_field_types field_type_arg,\n                                           Item **items, uint nitems)\n{\n  if (agg_arg_charsets_for_string_result(collation, items, nitems, 1))\n    return true;\n  if (is_temporal_type(field_type_arg))\n    count_datetime_length(field_type_arg, items, nitems);\n  else\n  {\n    count_only_length(items, nitems);\n    decimals= max_length ? NOT_FIXED_DEC : 0;\n  }\n  return false;\n}","22652":"int mongo_env_read_socket( mongo *conn, void *buf, int len ) {\n    char *cbuf = buf;\n    while ( len ) {\n        int sent = recv( conn->sock, cbuf, len, 0 );\n        if ( sent == 0 || sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, strerror( errno ), errno );\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n\n    return MONGO_OK;\n}","23498":"\nstatic void io_sq_offload_start(struct io_ring_ctx *ctx)\n{\n\tstruct io_sq_data *sqd = ctx->sq_data;\n\n\tif (ctx->flags & IORING_SETUP_SQPOLL)\n\t\tcomplete(&sqd->startup);","23060":"l2tp_q931_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tprint_16bits_val(ndo, (const uint16_t *)dat);\n\tND_PRINT((ndo, \"STR\", dat[2]));\n\tif (length > 3) {\n\t\tND_PRINT((ndo, \"STR\"));\n\t\tprint_string(ndo, dat+3, length-3);\n\t}\n}","22582":"static int ceph_x_proc_ticket_reply(struct ceph_auth_client *ac,\n\t\t\t\t    struct ceph_crypto_key *secret,\n\t\t\t\t    void *buf, void *end)\n{\n\tvoid *p = buf;\n\tchar *dbuf;\n\tchar *ticket_buf;\n\tu8 reply_struct_v;\n\tu32 num;\n\tint ret;\n\n\tdbuf = kmalloc(TEMP_TICKET_BUF_LEN, GFP_NOFS);\n\tif (!dbuf)\n\t\treturn -ENOMEM;\n\n\tret = -ENOMEM;\n\tticket_buf = kmalloc(TEMP_TICKET_BUF_LEN, GFP_NOFS);\n\tif (!ticket_buf)\n\t\tgoto out_dbuf;\n\n\tceph_decode_8_safe(&p, end, reply_struct_v, bad);\n\tif (reply_struct_v != 1)\n\t\treturn -EINVAL;\n\n\tceph_decode_32_safe(&p, end, num, bad);\n\tdout(\"STR\", num);\n\n\twhile (num--) {\n\t\tret = process_one_ticket(ac, secret, &p, end,\n\t\t\t\t\t dbuf, ticket_buf);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tkfree(ticket_buf);\nout_dbuf:\n\tkfree(dbuf);\n\treturn ret;\n\nbad:\n\tret = -EINVAL;\n\tgoto out;\n}","23133":"static int put_v4l2_event32(struct v4l2_event *kp, struct v4l2_event32 __user *up)\n{\n\tif (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||\n\t    put_user(kp->type, &up->type) ||\n\t    copy_to_user(&up->u, &kp->u, sizeof(kp->u)) ||\n\t    put_user(kp->pending, &up->pending) ||\n\t    put_user(kp->sequence, &up->sequence) ||\n\t    put_user(kp->timestamp.tv_sec, &up->timestamp.tv_sec) ||\n\t    put_user(kp->timestamp.tv_nsec, &up->timestamp.tv_nsec) ||\n\t    put_user(kp->id, &up->id) ||\n\t    copy_to_user(up->reserved, kp->reserved, sizeof(kp->reserved)))\n\t\treturn -EFAULT;\n\treturn 0;\n}","23325":"rsvg_new_marker (void)\n{\n    RsvgMarker *marker;\n    marker = g_new (RsvgMarker, 1);\n    _rsvg_node_init (&marker->super);\n    marker->orient = 0;\n    marker->orientAuto = FALSE;\n    marker->preserve_aspect_ratio = RSVG_ASPECT_RATIO_XMID_YMID;\n    marker->refX = marker->refY = _rsvg_css_parse_length (\"STR\");\n    marker->width = marker->height = _rsvg_css_parse_length (\"STR\");\n    marker->bbox = TRUE;\n    marker->vbox.active = FALSE;\n    marker->super.set_atts = rsvg_node_marker_set_atts;\n    return &marker->super;\n}","23105":"void sftp_attributes_free(sftp_attributes file){\n  if (file == NULL) {\n    return;\n  }\n\n  ssh_string_free(file->acl);\n  ssh_string_free(file->extended_data);\n  ssh_string_free(file->extended_type);\n\n  SAFE_FREE(file->name);\n  SAFE_FREE(file->longname);\n  SAFE_FREE(file->group);\n  SAFE_FREE(file->owner);\n\n  SAFE_FREE(file);\n}","23650":"static inline u32 __flow_hash_from_keys(struct flow_keys *keys, u32 keyval)\n{\n\tu32 hash;\n\n\t__flow_hash_consistentify(keys);\n\n\thash = __flow_hash_words(flow_keys_hash_start(keys),\n\t\t\t\t flow_keys_hash_length(keys), keyval);\n\tif (!hash)\n\t\thash = 1;\n\n\treturn hash;\n}","23143":"static struct ip_esp_hdr *esp_output_tcp_encap(struct xfrm_state *x,\n\t\t\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t\t\t    struct esp_info *esp)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}","23448":"TPMI_ALG_RSA_DECRYPT_Unmarshal(TPMI_ALG_RSA_DECRYPT *target, BYTE **buffer, INT32 *size, BOOL allowNull)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM_ALG_ID_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n#if ALG_RSAES\n\t  case TPM_ALG_RSAES:\n#endif\n#if ALG_OAEP\n\t  case TPM_ALG_OAEP:\n#endif\n\t    break;\n\t  case TPM_ALG_NULL:\n\t    if (allowNull) {\n\t\tbreak;\n\t    }\n\t  default:\n\t    rc = TPM_RC_VALUE;\n\t}\n    }\n    return rc;\n}","23349":"static int snd_pcm_oss_get_odelay(struct snd_pcm_oss_file *pcm_oss_file)\n{\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\tsnd_pcm_sframes_t delay;\n\tint err;\n\n\tsubstream = pcm_oss_file->streams[SNDRV_PCM_STREAM_PLAYBACK];\n\tif (substream == NULL)\n\t\treturn -EINVAL;\n\terr = snd_pcm_oss_make_ready(substream);\n\tif (err < 0)\n\t\treturn err;\n\truntime = substream->runtime;\n\tif (runtime->oss.params || runtime->oss.prepare)\n\t\treturn 0;\n\terr = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DELAY, &delay);\n\tif (err == -EPIPE)\n\t\tdelay = 0;\t\n\telse if (err < 0)\n\t\treturn err;\n\treturn snd_pcm_oss_bytes(substream, delay);\n}","23583":"zfs_ace_v0_set_flags(void *acep, uint16_t flags)\n{\n\t((zfs_oldace_t *)acep)->z_flags = flags;\n}","23173":"static int compat_get_entries(struct net *net,\n\t\t\t      struct compat_arpt_get_entries __user *uptr,\n\t\t\t      int *len)\n{\n\tint ret;\n\tstruct compat_arpt_get_entries get;\n\tstruct xt_table *t;\n\n\tif (*len < sizeof(get))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&get, uptr, sizeof(get)) != 0)\n\t\treturn -EFAULT;\n\tif (*len != sizeof(struct compat_arpt_get_entries) + get.size)\n\t\treturn -EINVAL;\n\n\tget.name[sizeof(get.name) - 1] = '\\0';\n\n\txt_compat_lock(NFPROTO_ARP);\n\tt = xt_find_table_lock(net, NFPROTO_ARP, get.name);\n\tif (!IS_ERR(t)) {\n\t\tconst struct xt_table_info *private = t->private;\n\t\tstruct xt_table_info info;\n\n\t\tret = compat_table_info(private, &info);\n\t\tif (!ret && get.size == info.size) {\n\t\t\tret = compat_copy_entries_to_user(private->size,\n\t\t\t\t\t\t\t  t, uptr->entrytable);\n\t\t} else if (!ret)\n\t\t\tret = -EAGAIN;\n\n\t\txt_compat_flush_offsets(NFPROTO_ARP);\n\t\tmodule_put(t->me);\n\t\txt_table_unlock(t);\n\t} else\n\t\tret = PTR_ERR(t);\n\n\txt_compat_unlock(NFPROTO_ARP);\n\treturn ret;\n}","23390":"do_truncate (GVfsBackend *backend,\n             GVfsJobTruncate *job,\n             GVfsBackendHandle handle,\n             goffset size)\n{\n  GSeekable *stream = G_SEEKABLE (handle);\n  GError *error = NULL;\n\n  if (g_seekable_truncate (stream, size, G_VFS_JOB (job)->cancellable, &error))\n    {\n      g_vfs_job_succeeded (G_VFS_JOB (job));\n    }\n  else\n    {\n      g_vfs_job_failed_from_error (G_VFS_JOB (job), error);\n      g_error_free (error);\n    }\n}","23748":"  Item_args(Item *a, Item *b)\n    :args(tmp_arg), arg_count(2)\n  {\n    args[0]= a; args[1]= b;\n  }","23512":"xmlDictComputeBigKey(const xmlChar* data, int namelen) {\n    uint32_t hash;\n    int i;\n\n    if (namelen <= 0 || data == NULL) return(0);\n\n    hash = 0;\n\n    for (i = 0;i < namelen; i++) {\n        hash += data[i];\n\thash += (hash << 10);\n\thash ^= (hash >> 6);\n    }\n    hash += (hash << 3);\n    hash ^= (hash >> 11);\n    hash += (hash << 15);\n\n    return hash;\n}","22714":"static int v9fs_xattr_set_acl(const struct xattr_handler *handler,\n\t\t\t      struct dentry *dentry, struct inode *inode,\n\t\t\t      const char *name, const void *value,\n\t\t\t      size_t size, int flags)\n{\n\tint retval;\n\tstruct posix_acl *acl;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\t\n\tif ((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT)\n\t\treturn v9fs_xattr_set(dentry, handler->name, value, size,\n\t\t\t\t      flags);\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EPERM;\n\tif (value) {\n\t\t\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t\telse if (acl) {\n\t\t\tretval = posix_acl_valid(inode->i_sb->s_user_ns, acl);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t}\n\t} else\n\t\tacl = NULL;\n\n\tswitch (handler->flags) {\n\tcase ACL_TYPE_ACCESS:\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tretval = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto err_out;\n\t\t\telse {\n\t\t\t\tstruct iattr iattr;\n\t\t\t\tif (retval == 0) {\n\t\t\t\t\t\n\t\t\t\t\tacl = NULL;\n\t\t\t\t\tvalue = NULL;\n\t\t\t\t\tsize = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tiattr.ia_mode = ((mode & S_IALLUGO) |\n\t\t\t\t\t\t (inode->i_mode & ~S_IALLUGO));\n\t\t\t\tiattr.ia_valid = ATTR_MODE;\n\t\t\t\t\n\t\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tretval = acl ? -EINVAL : 0;\n\t\t\tgoto err_out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = v9fs_xattr_set(dentry, handler->name, value, size, flags);\n\tif (!retval)\n\t\tset_cached_acl(inode, handler->flags, acl);\nerr_out:\n\tposix_acl_release(acl);\n\treturn retval;\n}","23648":"xmlXPtrNewRangeNodeObject(xmlNodePtr start, xmlXPathObjectPtr end) {\n    xmlXPathObjectPtr ret;\n\n    if (start == NULL)\n\treturn(NULL);\n    if (end == NULL)\n\treturn(NULL);\n    switch (end->type) {\n\tcase XPATH_POINT:\n\tcase XPATH_RANGE:\n\t    break;\n\tcase XPATH_NODESET:\n\t    \n\t    if (end->nodesetval->nodeNr <= 0)\n\t\treturn(NULL);\n\t    break;\n\tdefault:\n\t    \n\t    return(NULL);\n    }\n\n    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));\n    if (ret == NULL) {\n        xmlXPtrErrMemory(\"STR\");\n\treturn(NULL);\n    }\n    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));\n    ret->type = XPATH_RANGE;\n    ret->user = start;\n    ret->index = -1;\n    switch (end->type) {\n\tcase XPATH_POINT:\n\t    ret->user2 = end->user;\n\t    ret->index2 = end->index;\n\t    break;\n\tcase XPATH_RANGE:\n\t    ret->user2 = end->user2;\n\t    ret->index2 = end->index2;\n\t    break;\n\tcase XPATH_NODESET: {\n\t    ret->user2 = end->nodesetval->nodeTab[end->nodesetval->nodeNr - 1];\n\t    ret->index2 = -1;\n\t    break;\n\t}\n\tdefault:\n\t    STRANGE\n\t    return(NULL);\n    }\n    xmlXPtrRangeCheckOrder(ret);\n    return(ret);\n}","23142":"PHP_FUNCTION(cos)\n{\n\tdouble num;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"STR\", &num) == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_DOUBLE(cos(num));\n}","22605":"int nego_recv(rdpTransport* transport, wStream* s, void* extra)\n{\n\tBYTE li;\n\tBYTE type;\n\tUINT16 length;\n\trdpNego* nego = (rdpNego*)extra;\n\n\tif (!tpkt_read_header(s, &length))\n\t\treturn -1;\n\n\tif (!tpdu_read_connection_confirm(s, &li, length))\n\t\treturn -1;\n\n\tif (li > 6)\n\t{\n\t\t\n\t\tStream_Read_UINT8(s, type); \n\n\t\tswitch (type)\n\t\t{\n\t\t\tcase TYPE_RDP_NEG_RSP:\n\t\t\t\tnego_process_negotiation_response(nego, s);\n\t\t\t\tWLog_DBG(TAG, \"STR\", nego->SelectedProtocol);\n\n\t\t\t\t\n\n\t\t\t\tif (nego->SelectedProtocol)\n\t\t\t\t{\n\t\t\t\t\tif ((nego->SelectedProtocol == PROTOCOL_HYBRID) &&\n\t\t\t\t\t    (!nego->EnabledProtocols[PROTOCOL_HYBRID]))\n\t\t\t\t\t{\n\t\t\t\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((nego->SelectedProtocol == PROTOCOL_SSL) &&\n\t\t\t\t\t    (!nego->EnabledProtocols[PROTOCOL_SSL]))\n\t\t\t\t\t{\n\t\t\t\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t\t\t{\n\t\t\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase TYPE_RDP_NEG_FAILURE:\n\t\t\t\tnego_process_negotiation_failure(nego, s);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse if (li == 6)\n\t{\n\t\tWLog_DBG(TAG, \"STR\");\n\n\t\tif (!nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\telse\n\t\t\tnego->state = NEGO_STATE_FINAL;\n\t}\n\telse\n\t{\n\t\tWLog_ERR(TAG, \"STR\");\n\t\tnego->state = NEGO_STATE_FAIL;\n\t}\n\n\tif (!tpkt_ensure_stream_consumed(s, length))\n\t\treturn -1;\n\treturn 0;\n}","23053":"R_API bool r_socket_is_connected (RSocket *s) {\n\treturn false;\n}","22602":"static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) \n{\n\n\tconst char* loc_name        \t= NULL;\n\tint         loc_name_len    \t= 0;\n\n\tchar*       tag_value\t\t= NULL;\n\tchar*       empty_result\t= \"\";\n\n\tint         result    \t\t= 0;\n\tchar*       msg        \t\t= NULL;\n\n\tUErrorCode  status          \t= U_ZERO_ERROR;\n\n\tintl_error_reset( NULL TSRMLS_CC );\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"STR\",\n\t&loc_name ,&loc_name_len ) == FAILURE) {\n\t\tspprintf(&msg , 0, \"STR\", tag_name );\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 TSRMLS_CC );\n\t\tefree(msg);\n\n\t\tRETURN_FALSE;\n    }\n\n\tif(loc_name_len == 0) {\n\t\tloc_name = intl_locale_get_default(TSRMLS_C);\n\t}\n\n\t\n\ttag_value = get_icu_value_internal( loc_name , tag_name , &result ,0);\n\n\t\n\tif( result == -1 ) {\n\t\tif( tag_value){\n\t\t\tefree( tag_value);\n\t\t}\n\t\tRETURN_STRING( empty_result , TRUE);\n\t}\n\n\t\n\tif( tag_value){\n\t\tRETURN_STRING( tag_value , FALSE);\n\t}\n\n\t\n\tif( result ==0) {\n\t\tspprintf(&msg , 0, \"STR\", tag_name , tag_name );\n\t\tintl_error_set( NULL, status, msg , 1 TSRMLS_CC );\n\t\tefree(msg);\n\t\tRETURN_NULL();\n\t}\n\n}","23192":"static void jsR_calllwfunction(js_State *J, int n, js_Function *F, js_Environment *scope)\n{\n\tjs_Value v;\n\tint i;\n\n\tjsR_savescope(J, scope);\n\n\tif (n > F->numparams) {\n\t\tjs_pop(J, F->numparams - n);\n\t\tn = F->numparams;\n\t}\n\tfor (i = n; i < F->varlen; ++i)\n\t\tjs_pushundefined(J);\n\n\tjsR_run(J, F);\n\tv = *stackidx(J, -1);\n\tTOP = --BOT; \n\tjs_pushvalue(J, v);\n\n\tjsR_restorescope(J);\n}","23187":"int fbytes(unsigned char *buf, int num)\n{\n    int ret;\n    BIGNUM *tmp = NULL;\n\n    if (fbytes_counter >= 8)\n        return 0;\n    tmp = BN_new();\n    if (!tmp)\n        return 0;\n    if (!BN_dec2bn(&tmp, numbers[fbytes_counter])) {\n        BN_free(tmp);\n        return 0;\n    }\n    fbytes_counter++;\n    if (num != BN_num_bytes(tmp) || !BN_bn2bin(tmp, buf))\n        ret = 0;\n    else\n        ret = 1;\n    if (tmp)\n        BN_free(tmp);\n    return ret;\n}","22741":"static int lock_fdc(int drive, bool interruptible)\n{\n\tif (WARN(atomic_read(&usage_count) == 0,\n\t\t \"STR\"))\n\t\treturn -1;\n\n\tif (wait_event_interruptible(fdc_wait, !test_and_set_bit(0, &fdc_busy)))\n\t\treturn -EINTR;\n\n\tcommand_status = FD_COMMAND_NONE;\n\n\treschedule_timeout(drive, \"STR\");\n\tset_fdc(drive);\n\treturn 0;\n}","23037":"int32_t Downstream::get_stream_id() const { return stream_id_; }","22969":"prtok (token t)\n{\n  char const *s;\n\n  if (t < 0)\n    fprintf(stderr, \"STR\");\n  else if (t < NOTCHAR)\n    fprintf(stderr, \"STR\", t);\n  else\n    {\n      switch (t)\n        {\n        case EMPTY: s = \"STR\"; break;\n        case BACKREF: s = \"STR\"; break;\n        case BEGLINE: s = \"STR\"; break;\n        case ENDLINE: s = \"STR\"; break;\n        case BEGWORD: s = \"STR\"; break;\n        case ENDWORD: s = \"STR\"; break;\n        case LIMWORD: s = \"STR\"; break;\n        case NOTLIMWORD: s = \"STR\"; break;\n        case QMARK: s = \"STR\"; break;\n        case STAR: s = \"STR\"; break;\n        case PLUS: s = \"STR\"; break;\n        case CAT: s = \"STR\"; break;\n        case OR: s = \"STR\"; break;\n        case LPAREN: s = \"STR\"; break;\n        case RPAREN: s = \"STR\"; break;\n        case ANYCHAR: s = \"STR\"; break;\n        case MBCSET: s = \"STR\"; break;\n        default: s = \"STR\"; break;\n        }\n      fprintf(stderr, \"STR\", s);\n    }\n}","22784":"void brcmf_rx_frame(struct device *dev, struct sk_buff *skb, bool handle_event)\n{\n\tstruct brcmf_if *ifp;\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\n\tbrcmf_dbg(DATA, \"STR\", dev_name(dev), skb);\n\n\tif (brcmf_rx_hdrpull(drvr, skb, &ifp))\n\t\treturn;\n\n\tif (brcmf_proto_is_reorder_skb(skb)) {\n\t\tbrcmf_proto_rxreorder(ifp, skb);\n\t} else {\n\t\t\n\t\tif (handle_event)\n\t\t\tbrcmf_fweh_process_skb(ifp->drvr, skb);\n\n\t\tbrcmf_netif_rx(ifp, skb);\n\t}\n}","22670":"SYSCALL_DEFINE0(vfork)\n{\n\treturn _do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, 0,\n\t\t\t0, NULL, NULL, 0);\n}","23807":"R_API void r_bin_java_print_source_code_file_attr_summary(RBinJavaAttrInfo *attr) {\n\tif (!attr) {\n\t\teprintf (\"STR\");\n\t\treturn;\n\t}\n\tEprintf (\"STR\");\n\tEprintf (\"STR\", attr->file_offset);\n\tEprintf (\"STR\", attr->name_idx, attr->name);\n\tEprintf (\"STR\", attr->length);\n\tEprintf (\"STR\", attr->info.source_file_attr.sourcefile_idx);\n}","23643":"#endif\n    }\n\n    \n    inline int dialog(const char *const title, const char *const msg,\n                      const char *const button1_label, const char *const button2_label, const char *const button3_label,\n                      const char *const button4_label, const char *const button5_label, const char *const button6_label,","23617":"term_close_buffer(buf_T *buf, buf_T *old_curbuf)\n{\n    free_terminal(buf);\n    if (old_curbuf != NULL)\n    {\n\t--curbuf->b_nwindows;\n\tcurbuf = old_curbuf;\n\tcurwin->w_buffer = curbuf;\n\t++curbuf->b_nwindows;\n    }\n\n    \n    do_buffer(DOBUF_WIPE, DOBUF_FIRST, FORWARD, buf->b_fnum, TRUE);\n}","23041":"static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n\n    if (lo->root.posix_locks) {\n        g_hash_table_destroy(lo->root.posix_locks);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->xattrmap);\n    free_xattrmap(lo);\n    free(lo->source);\n}","23437":"static int ntop_get_nologin_username(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_INFO, \"STR\", __FUNCTION__);\n\n  lua_pushstring(vm, NTOP_NOLOGIN_USER);\n\n  return(CONST_LUA_OK);\n}","22498":"int main(int argc, char **argv)\n{\n    int fd;\n    int ret;\n\n    \n    fd = mkstemp(test_image);\n    g_assert(fd >= 0);\n    ret = ftruncate(fd, TEST_IMAGE_SIZE);\n    g_assert(ret == 0);\n    close(fd);\n\n    \n    g_test_init(&argc, &argv, NULL);\n\n    qtest_start(\"STR\");\n    qtest_irq_intercept_in(global_qtest, \"STR\");\n    qtest_add_func(\"STR\", test_cmos);\n    qtest_add_func(\"STR\", test_no_media_on_start);\n    qtest_add_func(\"STR\", test_read_without_media);\n    qtest_add_func(\"STR\", test_media_change);\n    qtest_add_func(\"STR\", test_sense_interrupt);\n    qtest_add_func(\"STR\", test_relative_seek);\n    qtest_add_func(\"STR\", test_read_id);\n    qtest_add_func(\"STR\", test_verify);\n    qtest_add_func(\"STR\", test_media_insert);\n    qtest_add_func(\"STR\", test_read_no_dma_1);\n    qtest_add_func(\"STR\", test_read_no_dma_18);\n    qtest_add_func(\"STR\", test_read_no_dma_19);\n    qtest_add_func(\"STR\", fuzz_registers);\n    qtest_add_func(\"STR\", test_cve_2021_20196);\n\n    ret = g_test_run();\n\n    \n    qtest_end();\n    unlink(test_image);\n\n    return ret;\n}","22735":"interruptible_sleep_on_timeout(wait_queue_head_t *q, long timeout)\n{\n\treturn sleep_on_common(q, TASK_INTERRUPTIBLE, timeout);\n}","22816":"ves_icall_System_Threading_Thread_ClrState (MonoInternalThread* this, guint32 state)\n{\n\tmono_thread_clr_state (this, state);\n\n\tif (state & ThreadState_Background) {\n\t\t\n\t\tSetEvent (background_change_event);\n\t}\n}","23124":"_XkbSetDeviceInfoCheck(ClientPtr client, DeviceIntPtr dev,\n                       xkbSetDeviceInfoReq * stuff)\n{\n    char *wire;\n    xkbExtensionDeviceNotify ed;\n\n    memset((char *) &ed, 0, SIZEOF(xkbExtensionDeviceNotify));\n    ed.deviceID = dev->id;\n    wire = (char *) &stuff[1];\n    if (stuff->change & XkbXI_ButtonActionsMask) {\n        int nBtns, sz, i;\n        XkbAction *acts;\n        DeviceIntPtr kbd;\n\n        nBtns = dev->button->numButtons;\n        acts = dev->button->xkb_acts;\n        if (acts == NULL) {\n            acts = calloc(nBtns, sizeof(XkbAction));\n            if (!acts)\n                return BadAlloc;\n            dev->button->xkb_acts = acts;\n        }\n        if (stuff->firstBtn + stuff->nBtns > nBtns)\n            return BadValue;\n        sz = stuff->nBtns * SIZEOF(xkbActionWireDesc);\n        if (!_XkbCheckRequestBounds(client, stuff, wire, (char *) wire + sz))\n            return BadLength;\n        memcpy((char *) &acts[stuff->firstBtn], (char *) wire, sz);\n        wire += sz;\n        ed.reason |= XkbXI_ButtonActionsMask;\n        ed.firstBtn = stuff->firstBtn;\n        ed.nBtns = stuff->nBtns;\n\n        if (dev->key)\n            kbd = dev;\n        else\n            kbd = inputInfo.keyboard;\n        acts = &dev->button->xkb_acts[stuff->firstBtn];\n        for (i = 0; i < stuff->nBtns; i++, acts++) {\n            if (acts->type != XkbSA_NoAction)\n                XkbSetActionKeyMods(kbd->key->xkbInfo->desc, acts, 0);\n        }\n    }\n    if (stuff->change & XkbXI_IndicatorsMask) {\n        int status = Success;\n\n        wire = SetDeviceIndicators(wire, dev, stuff->change,\n                                   stuff->nDeviceLedFBs, &status, client, &ed,\n                                   stuff);\n        if (status != Success)\n            return status;\n    }\n    if ((stuff->change) && (ed.reason))\n        XkbSendExtensionDeviceNotify(dev, client, &ed);\n    return Success;\n}","22901":"static void __tcp_v6_send_check(struct sk_buff *skb,\n\t\t\t\tconst struct in6_addr *saddr, const struct in6_addr *daddr)\n{\n\tstruct tcphdr *th = tcp_hdr(skb);\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tth->check = ~tcp_v6_check(skb->len, saddr, daddr, 0);\n\t\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\t\tskb->csum_offset = offsetof(struct tcphdr, check);\n\t} else {\n\t\tth->check = tcp_v6_check(skb->len, saddr, daddr,\n\t\t\t\t\t csum_partial(th, th->doff << 2,\n\t\t\t\t\t\t      skb->csum));\n\t}\n}","23568":"      static unsigned char inf() { return max(); }","23663":"    template<typename t>\n    CImgList<t>& move_to(CImgList<t>& list) {\n      list.assign(_width);\n      bool is_one_shared_element = false;\n      cimglist_for(*this,l) is_one_shared_element|=_data[l]._is_shared;\n      if (is_one_shared_element) cimglist_for(*this,l) list[l].assign(_data[l]);\n      else cimglist_for(*this,l) _data[l].move_to(list[l]);\n      assign();\n      return list;","23585":"htmlParseName(htmlParserCtxtPtr ctxt) {\n    const xmlChar *in;\n    const xmlChar *ret;\n    int count = 0;\n\n    GROW;\n\n    \n    in = ctxt->input->cur;\n    if (((*in >= 0x61) && (*in <= 0x7A)) ||\n\t((*in >= 0x41) && (*in <= 0x5A)) ||\n\t(*in == '_') || (*in == ':')) {\n\tin++;\n\twhile (((*in >= 0x61) && (*in <= 0x7A)) ||\n\t       ((*in >= 0x41) && (*in <= 0x5A)) ||\n\t       ((*in >= 0x30) && (*in <= 0x39)) ||\n\t       (*in == '_') || (*in == '-') ||\n\t       (*in == ':') || (*in == '.'))\n\t    in++;\n\tif ((*in > 0) && (*in < 0x80)) {\n\t    count = in - ctxt->input->cur;\n\t    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);\n\t    ctxt->input->cur = in;\n\t    ctxt->nbChars += count;\n\t    ctxt->input->col += count;\n\t    return(ret);\n\t}\n    }\n    return(htmlParseNameComplex(ctxt));\n}","22627":"char* _single_string_alloc_and_copy( LPCWSTR in )\n{\n    char *chr;\n    int len = 0;\n\n    if ( !in )\n    {\n        return in;\n    }\n\n    while ( in[ len ] != 0 )\n    {\n        len ++;\n    }\n\n    chr = malloc( len + 1 );\n\n    len = 0;\n    while ( in[ len ] != 0 )\n    {\n        chr[ len ] = 0xFF & in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = '\\0';\n\n    return chr;\n}","22487":"static unsigned long dtls1_max_handshake_message_len(const SSL *s)\n{\n    unsigned long max_len =\n        DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH;\n    if (max_len < (unsigned long)s->max_cert_list)\n        return s->max_cert_list;\n    return max_len;\n}","22953":"void Magick::Image::erase(void)\n{\n  modifyImage();\n  GetPPException;\n  (void) SetImageBackgroundColor(image(),exceptionInfo);\n  ThrowImageException;\n}","22669":"static inline bool page_is_poisoned(struct page *page) { return false; }","23235":"ImagingNew(const char* mode, int xsize, int ysize)\n{\n    int bytes;\n    Imaging im;\n\n    if (strlen(mode) == 1) {\n        if (mode[0] == 'F' || mode[0] == 'I')\n            bytes = 4;\n        else\n            bytes = 1;\n    } else\n        bytes = strlen(mode); \n\n    if ((int64_t) xsize * (int64_t) ysize <= THRESHOLD \/ bytes) {\n        im = ImagingNewBlock(mode, xsize, ysize);\n        if (im)\n            return im;\n        \n        ImagingError_Clear();\n    }\n\n    return ImagingNewArray(mode, xsize, ysize);\n}","22906":"LIR_Opr LIRGenerator::safepoint_poll_register() {\n  NOT_LP64( return new_register(T_ADDRESS); )\n  return LIR_OprFact::illegalOpr;\n}","22586":"static int64_t http_seek_internal(URLContext *h, int64_t off, int whence, int force_reconnect)\n{\n    HTTPContext *s = h->priv_data;\n    URLContext *old_hd = s->hd;\n    int64_t old_off = s->off;\n    uint8_t old_buf[BUFFER_SIZE];\n    int old_buf_size, ret;\n    AVDictionary *options = NULL;\n\n    if (whence == AVSEEK_SIZE)\n        return s->filesize;\n    else if (!force_reconnect &&\n             ((whence == SEEK_CUR && off == 0) ||\n              (whence == SEEK_SET && off == s->off)))\n        return s->off;\n    else if ((s->filesize == -1 && whence == SEEK_END))\n        return AVERROR(ENOSYS);\n\n    if (whence == SEEK_CUR)\n        off += s->off;\n    else if (whence == SEEK_END)\n        off += s->filesize;\n    else if (whence != SEEK_SET)\n        return AVERROR(EINVAL);\n    if (off < 0)\n        return AVERROR(EINVAL);\n    s->off = off;\n\n    if (s->off && h->is_streamed)\n        return AVERROR(ENOSYS);\n\n    \n    old_buf_size = s->buf_end - s->buf_ptr;\n    memcpy(old_buf, s->buf_ptr, old_buf_size);\n    s->hd = NULL;\n\n    \n    if ((ret = http_open_cnx(h, &options)) < 0) {\n        av_dict_free(&options);\n        memcpy(s->buffer, old_buf, old_buf_size);\n        s->buf_ptr = s->buffer;\n        s->buf_end = s->buffer + old_buf_size;\n        s->hd      = old_hd;\n        s->off     = old_off;\n        return ret;\n    }\n    av_dict_free(&options);\n    ffurl_close(old_hd);\n    return off;\n}","23284":"Header::type()\n{\n    return typedAttribute <StringAttribute> (\"STR\").value();\n}","23560":"Item *Lex_trim_st::make_item_func_trim_std(THD *thd) const\n{\n  if (m_remove)\n  {\n    switch (m_spec) {\n    case TRIM_BOTH:\n      return new (thd->mem_root) Item_func_trim(thd, m_source, m_remove);\n    case TRIM_LEADING:\n      return new (thd->mem_root) Item_func_ltrim(thd, m_source, m_remove);\n    case TRIM_TRAILING:\n     return new (thd->mem_root) Item_func_rtrim(thd, m_source, m_remove);\n    }\n  }\n\n  switch (m_spec) {\n  case TRIM_BOTH:\n    return new (thd->mem_root) Item_func_trim(thd, m_source);\n  case TRIM_LEADING:\n    return new (thd->mem_root) Item_func_ltrim(thd, m_source);\n  case TRIM_TRAILING:\n   return new (thd->mem_root) Item_func_rtrim(thd, m_source);\n  }\n  DBUG_ASSERT(0);\n  return NULL;\n}","23792":"write_ct_md(struct dp_packet *pkt, uint16_t zone, const struct conn *conn,\n            const struct conn_key *key, const struct alg_exp_node *alg_exp)\n{\n    pkt->md.ct_state |= CS_TRACKED;\n    pkt->md.ct_zone = zone;\n\n    if (conn) {\n        ovs_mutex_lock(&conn->lock);\n        pkt->md.ct_mark = conn->mark;\n        pkt->md.ct_label = conn->label;\n        ovs_mutex_unlock(&conn->lock);\n    } else {\n        pkt->md.ct_mark = 0;\n        pkt->md.ct_label = OVS_U128_ZERO;\n    }\n\n    \n    if (conn) {\n        if (conn->alg_related) {\n            key = &conn->parent_key;\n        } else {\n            key = &conn->key;\n        }\n    } else if (alg_exp) {\n        pkt->md.ct_mark = alg_exp->parent_mark;\n        pkt->md.ct_label = alg_exp->parent_label;\n        key = &alg_exp->parent_key;\n    }\n\n    pkt->md.ct_orig_tuple_ipv6 = false;\n\n    if (key) {\n        if (key->dl_type == htons(ETH_TYPE_IP)) {\n            pkt->md.ct_orig_tuple.ipv4 = (struct ovs_key_ct_tuple_ipv4) {\n                key->src.addr.ipv4,\n                key->dst.addr.ipv4,\n                key->nw_proto != IPPROTO_ICMP\n                ? key->src.port : htons(key->src.icmp_type),\n                key->nw_proto != IPPROTO_ICMP\n                ? key->dst.port : htons(key->src.icmp_code),\n                key->nw_proto,\n            };\n        } else {\n            pkt->md.ct_orig_tuple_ipv6 = true;\n            pkt->md.ct_orig_tuple.ipv6 = (struct ovs_key_ct_tuple_ipv6) {\n                key->src.addr.ipv6,\n                key->dst.addr.ipv6,\n                key->nw_proto != IPPROTO_ICMPV6\n                ? key->src.port : htons(key->src.icmp_type),\n                key->nw_proto != IPPROTO_ICMPV6\n                ? key->dst.port : htons(key->src.icmp_code),\n                key->nw_proto,\n            };\n        }\n    } else {\n        memset(&pkt->md.ct_orig_tuple, 0, sizeof pkt->md.ct_orig_tuple);\n    }\n}","23028":"static int mailimf_trace_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_trace ** result)\n{\n  size_t cur_token;\n  struct mailimf_return * return_path;\n  clist * received_list;\n  struct mailimf_trace * trace;\n  int r;\n  int res;\n\n  cur_token = * indx;\n  return_path = NULL;\n  received_list = NULL;\n\n  r = mailimf_return_parse(message, length, &cur_token, &return_path);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  r = mailimf_struct_multiple_parse(message, length, &cur_token,\n\t\t\t\t    &received_list,\n\t\t\t\t    (mailimf_struct_parser *)\n\t\t\t\t    mailimf_received_parse,\n\t\t\t\t    (mailimf_struct_destructor *)\n\t\t\t\t    mailimf_received_free);\n  if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n    res = r;\n    goto err;\n  }\n\n  if ((received_list == NULL) && (return_path == NULL)) {\n    res = MAILIMF_ERROR_PARSE;\n    goto free_return;\n  }\n\n  trace = mailimf_trace_new(return_path, received_list);\n  if (trace == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_list;\n  }\n\n  * result = trace;\n  * indx = cur_token;\n\n  return MAILIMF_NO_ERROR;\n\n free_list:\n  clist_foreach(received_list, (clist_func) mailimf_received_free, NULL);\n  clist_free(received_list);\n free_return:\n  if (return_path != NULL)\n    mailimf_return_free(return_path);\n err:\n  return res;\n}","23398":"static __inline__ void scm_set_cred(struct scm_cookie *scm,\n\t\t\t\t    struct pid *pid, const struct cred *cred)\n{\n\tscm->pid  = get_pid(pid);\n\tscm->cred = cred ? get_cred(cred) : NULL;\n\tscm->creds.pid = pid_vnr(pid);\n\tscm->creds.uid = cred ? cred->euid : INVALID_UID;\n\tscm->creds.gid = cred ? cred->egid : INVALID_GID;\n}","23088":"unsigned long get_pmcs_ext_regs(int idx)\n{\n\tstruct cpu_hw_events *cpuhw = this_cpu_ptr(&cpu_hw_events);\n\n\treturn cpuhw->pmcs[idx];\n}","23686":"PHP_FUNCTION(locale_get_display_script) \n{\n    get_icu_disp_value_src_php( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}","22768":"void kvm_arch_flush_shadow_memslot(struct kvm *kvm,\n\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tkvm_arch_flush_shadow_all(kvm);\n}","22522":"ctcompare(const char *a,\t\t\n          const char *b)\t\t\n{\n  int\tresult = 0;\t\t\t\n\n\n  while (*a && *b)\n  {\n    result |= *a ^ *b;\n    a ++;\n    b ++;\n  }\n\n  return (result);\n}","22723":"static inline int getmiso(const struct spi_device *spi)\n{\n\tstruct spi_gpio *spi_gpio = spi_to_spi_gpio(spi);\n\n\tif (spi->mode & SPI_3WIRE)\n\t\treturn !!gpiod_get_value_cansleep(spi_gpio->mosi);\n\telse\n\t\treturn !!gpiod_get_value_cansleep(spi_gpio->miso);\n}","23237":"void memory_region_del_subregion(MemoryRegion *mr,\n                                 MemoryRegion *subregion)\n{\n    memory_region_transaction_begin();\n    assert(subregion->container == mr);\n    subregion->container = NULL;\n    QTAILQ_REMOVE(&mr->subregions, subregion, subregions_link);\n    mr->uc->memory_region_update_pending = true;\n    memory_region_transaction_commit(mr);\n}","23016":"static void test_bug1180()\n{\n  MYSQL_STMT *stmt;\n  int rc;\n  MYSQL_BIND my_bind[1];\n  ulong length[1];\n  char szData[11];\n  char query[MAX_TEST_QUERY_LENGTH];\n\n  myheader(\"STR\");\n\n  rc= mysql_query(mysql, \"STR\");\n  myquery(rc);\n\n  rc= mysql_query(mysql, \"STR\");\n  myquery(rc);\n  rc= mysql_query(mysql, \"STR\");\n  myquery(rc);\n\n  strmov(query, \"STR\"\n                \"STR\");\n  stmt= mysql_simple_prepare(mysql, query);\n  check_stmt(stmt);\n\n  verify_param_count(stmt, 1);\n\n  \n  bzero((char*) my_bind, sizeof(my_bind));\n\n  strmov(szData, (char *)\"STR\");\n  my_bind[0].buffer_type= MYSQL_TYPE_STRING;\n  my_bind[0].buffer= (void *)szData;\n  my_bind[0].buffer_length= 10;\n  my_bind[0].length= &length[0];\n  length[0]= 3;\n  my_bind[0].is_null= 0;\n\n  rc= mysql_stmt_bind_param(stmt, my_bind);\n  check_execute(stmt, rc);\n\n  rc= mysql_stmt_execute(stmt);\n  check_execute(stmt, rc);\n\n  rc= my_process_stmt_result(stmt);\n  DIE_UNLESS(rc == 0);\n\n  strmov(szData, (char *)\"STR\");\n  my_bind[0].buffer_type= MYSQL_TYPE_STRING;\n  my_bind[0].buffer= (void *)szData;\n  my_bind[0].buffer_length= 10;\n  my_bind[0].length= &length[0];\n  length[0]= 4;\n  my_bind[0].is_null= 0;\n\n  rc= mysql_stmt_bind_param(stmt, my_bind);\n  check_execute(stmt, rc);\n\n  rc= mysql_stmt_execute(stmt);\n  check_execute(stmt, rc);\n\n  rc= my_process_stmt_result(stmt);\n  DIE_UNLESS(rc == 1);\n\n  strmov(szData, (char *)\"STR\");\n  my_bind[0].buffer_type= MYSQL_TYPE_STRING;\n  my_bind[0].buffer= (void *)szData;\n  my_bind[0].buffer_length= 10;\n  my_bind[0].length= &length[0];\n  length[0]= 3;\n  my_bind[0].is_null= 0;\n\n  rc= mysql_stmt_bind_param(stmt, my_bind);\n  check_execute(stmt, rc);\n\n  rc= mysql_stmt_execute(stmt);\n  check_execute(stmt, rc);\n\n  rc= my_process_stmt_result(stmt);\n  DIE_UNLESS(rc == 0);\n\n  mysql_stmt_close(stmt);\n}","22745":"static int *get_userlist(struct proclistlist *pll, int *num_users){\n  int *ret=calloc(sizeof(int),pll->length);\n  int lokke;\n\n  *num_users=0;\n\n  for(lokke=0;lokke<pll->length;lokke++){\n    glibtop_proc_uid uid;\n    glibtop_get_proc_uid(&uid,pll->proclist[lokke].pid);\n    if( ! is_a_member(uid.uid,ret,*num_users)){ \n      ret[*num_users]=uid.uid;\n      (*num_users)++;\n    }\n  }\n  return ret;\n}","23715":"vhost_user_send_rarp(struct virtio_net **pdev,\n\t\t\tstruct vhu_msg_context *ctx,\n\t\t\tint main_fd __rte_unused)\n{\n\tstruct virtio_net *dev = *pdev;\n\tuint8_t *mac = (uint8_t *)&ctx->msg.payload.u64;\n\tstruct rte_vdpa_device *vdpa_dev;\n\n\tif (validate_msg_fds(dev, ctx, 0) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\n\tVHOST_LOG_CONFIG(DEBUG, \"STR\",\n\t\tdev->ifname, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n\tmemcpy(dev->mac.addr_bytes, mac, 6);\n\n\t\n\t__atomic_store_n(&dev->broadcast_rarp, 1, __ATOMIC_RELEASE);\n\tvdpa_dev = dev->vdpa_dev;\n\tif (vdpa_dev && vdpa_dev->ops->migration_done)\n\t\tvdpa_dev->ops->migration_done(dev->vid);\n\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}","23734":"static int64_t seek_to_sector(BlockDriverState *bs, int64_t sector_num)\n{\n    BDRVBochsState *s = bs->opaque;\n    int64_t offset = sector_num * 512;\n    int64_t extent_index, extent_offset, bitmap_offset;\n    char bitmap_entry;\n\n    \n    extent_index = offset \/ s->extent_size;\n    extent_offset = (offset % s->extent_size) \/ 512;\n\n    if (s->catalog_bitmap[extent_index] == 0xffffffff) {\n\treturn -1; \n    }\n\n    bitmap_offset = s->data_offset + (512 * s->catalog_bitmap[extent_index] *\n\t(s->extent_blocks + s->bitmap_blocks));\n\n    \n    if (bdrv_pread(bs->file, bitmap_offset + (extent_offset \/ 8),\n                   &bitmap_entry, 1) != 1) {\n        return -1;\n    }\n\n    if (!((bitmap_entry >> (extent_offset % 8)) & 1)) {\n\treturn -1; \n    }\n\n    return bitmap_offset + (512 * (s->bitmap_blocks + extent_offset));\n}","22658":"  void getType3GlyphWidth (double *wx, double *wy) { *wx = t3_glyph_wx; *wy = t3_glyph_wy; }","22640":"static const char *str_in6_addr(struct in6_addr *addr)\n{\n\tstatic char buf[INET6_ADDRSTRLEN];\n\n\treturn inet_ntop(AF_INET6, addr, buf, sizeof(buf));\n}","22571":"        void clear()\n        {\n            req = crow::request();\n            header_field.clear();\n            header_value.clear();\n            header_building_state = 0;\n            qs_point = 0;\n        }","23183":"static void ExportRedQuantum(QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const PixelPacket *magick_restrict p,\n  unsigned char *magick_restrict q)\n{\n  QuantumAny\n    range;\n\n  ssize_t\n    x;\n\n  switch (quantum_info->depth)\n  {\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToChar(GetPixelRed(p));\n        q=PopCharPixel(pixel,q);\n        p++;\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelRed(p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p++;\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToShort(GetPixelRed(p));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p++;\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopFloatPixel(quantum_info,(float) GetPixelRed(p),q);\n            p++;\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        pixel=ScaleQuantumToLong(GetPixelRed(p));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p++;\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopDoublePixel(quantum_info,(double) GetPixelRed(p),q);\n            p++;\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,\n          ScaleQuantumToAny(GetPixelRed(p),range),q);\n        p++;\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}","22891":"AcpiNsLocal (\n    ACPI_OBJECT_TYPE        Type)\n{\n    ACPI_FUNCTION_TRACE (NsLocal);\n\n\n    if (!AcpiUtValidObjectType (Type))\n    {\n        \n\n        ACPI_WARNING ((AE_INFO, \"STR\", Type));\n        return_UINT32 (ACPI_NS_NORMAL);\n    }\n\n    return_UINT32 (AcpiGbl_NsProperties[Type] & ACPI_NS_LOCAL);\n}","23251":"static void xhci_port_update(XHCIPort *port, int is_detach)\n{\n    uint32_t pls = PLS_RX_DETECT;\n\n    port->portsc = PORTSC_PP;\n    if (!is_detach && xhci_port_have_device(port)) {\n        port->portsc |= PORTSC_CCS;\n        switch (port->uport->dev->speed) {\n        case USB_SPEED_LOW:\n            port->portsc |= PORTSC_SPEED_LOW;\n            pls = PLS_POLLING;\n            break;\n        case USB_SPEED_FULL:\n            port->portsc |= PORTSC_SPEED_FULL;\n            pls = PLS_POLLING;\n            break;\n        case USB_SPEED_HIGH:\n            port->portsc |= PORTSC_SPEED_HIGH;\n            pls = PLS_POLLING;\n            break;\n        case USB_SPEED_SUPER:\n            port->portsc |= PORTSC_SPEED_SUPER;\n            port->portsc |= PORTSC_PED;\n            pls = PLS_U0;\n            break;\n        }\n    }\n    set_field(&port->portsc, pls, PORTSC_PLS);\n    trace_usb_xhci_port_link(port->portnr, pls);\n    xhci_port_notify(port, PORTSC_CSC);\n}","23432":"static inline Quantum ScaleShortToQuantum(const unsigned short value)\n{\n  return((Quantum) (281479271743489.0*value));\n}","23735":"vhost_user_set_postcopy_advise(struct virtio_net **pdev,\n\t\t\tstruct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tstruct virtio_net *dev = *pdev;\n#ifdef RTE_LIBRTE_VHOST_POSTCOPY\n\tstruct uffdio_api api_struct;\n\n\tdev->postcopy_ufd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n\n\tif (dev->postcopy_ufd == -1) {\n\t\tRTE_LOG(ERR, VHOST_CONFIG, \"STR\",\n\t\t\tstrerror(errno));\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tapi_struct.api = UFFD_API;\n\tapi_struct.features = 0;\n\tif (ioctl(dev->postcopy_ufd, UFFDIO_API, &api_struct)) {\n\t\tRTE_LOG(ERR, VHOST_CONFIG, \"STR\",\n\t\t\tstrerror(errno));\n\t\tclose(dev->postcopy_ufd);\n\t\tdev->postcopy_ufd = -1;\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tmsg->fds[0] = dev->postcopy_ufd;\n\tmsg->fd_num = 1;\n\n\treturn RTE_VHOST_MSG_RESULT_REPLY;\n#else\n\tdev->postcopy_ufd = -1;\n\tmsg->fd_num = 0;\n\n\treturn RTE_VHOST_MSG_RESULT_ERR;\n#endif\n}","23258":"static int read_user_tlv(struct snd_kcontrol *kctl, unsigned int __user *buf,\n\t\t\t unsigned int size)\n{\n\tstruct user_element *ue = kctl->private_data;\n\n\tif (ue->tlv_data_size == 0 || ue->tlv_data == NULL)\n\t\treturn -ENXIO;\n\n\tif (size < ue->tlv_data_size)\n\t\treturn -ENOSPC;\n\n\tif (copy_to_user(buf, ue->tlv_data, ue->tlv_data_size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}","23521":"SPL_METHOD(SplFileObject, fgetcsv)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar delimiter = intern->u.file.delimiter, enclosure = intern->u.file.enclosure, escape = intern->u.file.escape;\n\tchar *delim = NULL, *enclo = NULL, *esc = NULL;\n\tint d_len = 0, e_len = 0, esc_len = 0;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"STR\", &delim, &d_len, &enclo, &e_len, &esc, &esc_len) == SUCCESS) {\n\t\tswitch(ZEND_NUM_ARGS())\n\t\t{\n\t\tcase 3:\n\t\t\tif (esc_len != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"STR\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tescape = esc[0];\n\t\t\t\n\t\tcase 2:\n\t\t\tif (e_len != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"STR\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tenclosure = enclo[0];\n\t\t\t\n\t\tcase 1:\n\t\t\tif (d_len != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"STR\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tdelimiter = delim[0];\n\t\t\t\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t\tspl_filesystem_file_read_csv(intern, delimiter, enclosure, escape, return_value TSRMLS_CC);\n\t}\n}","23046":"static int perf_swevent_init(struct perf_event *event)\n{\n\tint event_id = event->attr.config;\n\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\t\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (event_id) {\n\tcase PERF_COUNT_SW_CPU_CLOCK:\n\tcase PERF_COUNT_SW_TASK_CLOCK:\n\t\treturn -ENOENT;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (event_id >= PERF_COUNT_SW_MAX)\n\t\treturn -ENOENT;\n\n\tif (!event->parent) {\n\t\tint err;\n\n\t\terr = swevent_hlist_get(event);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstatic_key_slow_inc(&perf_swevent_enabled[event_id]);\n\t\tevent->destroy = sw_perf_event_destroy;\n\t}\n\n\treturn 0;\n}","23481":"  LiteralString(std::string &&s, bool ignore_case)\n      : lit_(s), ignore_case_(ignore_case), is_word_(false) {}","23733":"gdm_session_handle_info (GdmDBusWorkerManager  *worker_manager_interface,\n                         GDBusMethodInvocation *invocation,\n                         const char            *service_name,\n                         const char            *info,\n                         GdmSession            *self)\n{\n        gdm_dbus_worker_manager_complete_info (worker_manager_interface,\n                                               invocation);\n\n        if (self->priv->user_verifier_interface != NULL) {\n                gdm_dbus_user_verifier_emit_info (self->priv->user_verifier_interface,\n                                                  service_name,\n                                                  info);\n        }\n\n        return TRUE;\n}","23332":"decrypt_response(struct sc_card *card, unsigned char *in, unsigned char *out, size_t * out_len)\n{\n\tsize_t in_len;\n\tsize_t i;\n\tunsigned char iv[16] = { 0 };\n\tunsigned char plaintext[4096] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\t\n\tif (in[0] == 0x99)\n\t\treturn 0;\n\n\t\n\tif (0x01 == in[2] && 0x82 != in[1]) {\n\t\tin_len = in[1];\n\t\ti = 3;\n\t}\n\telse if (0x01 == in[3] && 0x81 == in[1]) {\n\t\tin_len = in[2];\n\t\ti = 4;\n\t}\n\telse if (0x01 == in[4] && 0x82 == in[1]) {\n\t\tin_len = in[2] * 0x100;\n\t\tin_len += in[3];\n\t\ti = 5;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n\n\t\n\tif (KEY_TYPE_AES == exdata->smtype)\n\t\taes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], in_len - 1, plaintext);\n\telse\n\t\tdes3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], in_len - 1, plaintext);\n\n\t\n\twhile (0x80 != plaintext[in_len - 2] && (in_len - 2 > 0))\n\t\tin_len--;\n\n\tif (2 == in_len)\n\t\treturn -1;\n\n\tmemcpy(out, plaintext, in_len - 2);\n\t*out_len = in_len - 2;\n\treturn 0;\n}","23038":"parser_module_parse_export_clause (parser_context_t *context_p) \n{\n  bool has_module_specifier = false;\n\n  if (context_p->source_p == context_p->next_scanner_info_p->source_p)\n  {\n    has_module_specifier = true;\n    JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_EXPORT_MODULE_SPECIFIER);\n    scanner_release_next (context_p, sizeof (scanner_info_t));\n  }\n\n  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_BRACE);\n  lexer_next_token (context_p);\n\n  while (true)\n  {\n    if (context_p->token.type == LEXER_RIGHT_BRACE)\n    {\n      lexer_next_token (context_p);\n      break;\n    }\n\n    \n    if (context_p->token.type != LEXER_LITERAL\n        || context_p->token.lit_location.type != LEXER_IDENT_LITERAL\n        || context_p->token.keyword_type >= LEXER_FIRST_FUTURE_STRICT_RESERVED_WORD)\n    {\n      parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);\n    }\n\n    ecma_string_t *export_name_p = NULL;\n    ecma_string_t *local_name_p = NULL;\n\n    lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_NEW_IDENT_LITERAL);\n\n    if (!has_module_specifier\n        && !scanner_literal_exists (context_p, context_p->lit_object.index))\n    {\n      parser_raise_error (context_p, PARSER_ERR_EXPORT_NOT_DEFINED);\n    }\n\n    uint16_t local_name_index = context_p->lit_object.index;\n    uint16_t export_name_index = PARSER_MAXIMUM_NUMBER_OF_LITERALS;\n\n    lexer_next_token (context_p);\n    if (lexer_token_is_identifier (context_p, \"STR\", 2))\n    {\n      lexer_next_token (context_p);\n\n      if (context_p->token.type != LEXER_LITERAL\n          || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)\n      {\n        parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);\n      }\n\n      lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_NEW_IDENT_LITERAL);\n\n      export_name_index = context_p->lit_object.index;\n\n      lexer_next_token (context_p);\n    }\n\n    lexer_literal_t *literal_p = PARSER_GET_LITERAL (local_name_index);\n    local_name_p = ecma_new_ecma_string_from_utf8 (literal_p->u.char_p, literal_p->prop.length);\n\n    if (export_name_index != PARSER_MAXIMUM_NUMBER_OF_LITERALS)\n    {\n      lexer_literal_t *as_literal_p = PARSER_GET_LITERAL (export_name_index);\n      export_name_p = ecma_new_ecma_string_from_utf8 (as_literal_p->u.char_p, as_literal_p->prop.length);\n    }\n    else\n    {\n      export_name_p = local_name_p;\n      ecma_ref_ecma_string (local_name_p);\n    }\n\n    if (parser_module_check_duplicate_export (context_p, export_name_p))\n    {\n      ecma_deref_ecma_string (local_name_p);\n      ecma_deref_ecma_string (export_name_p);\n      parser_raise_error (context_p, PARSER_ERR_DUPLICATED_EXPORT_IDENTIFIER);\n    }\n\n    parser_module_add_names_to_node (context_p, export_name_p, local_name_p);\n    ecma_deref_ecma_string (local_name_p);\n    ecma_deref_ecma_string (export_name_p);\n\n    if (context_p->token.type != LEXER_COMMA\n        && context_p->token.type != LEXER_RIGHT_BRACE)\n    {\n      parser_raise_error (context_p, PARSER_ERR_RIGHT_BRACE_COMMA_EXPECTED);\n    }\n    else if (context_p->token.type == LEXER_COMMA)\n    {\n      lexer_next_token (context_p);\n    }\n\n    if (lexer_token_is_identifier (context_p, \"STR\", 4))\n    {\n      parser_raise_error (context_p, PARSER_ERR_RIGHT_BRACE_EXPECTED);\n    }\n  }\n} ","23280":"void PngImg::RotateRight() {\n    Rotate_([](const Point& p, const ImgInfo& img) {\n        return Point{img.height - p.y - 1, p.x};\n    });\n}","23213":"auth_delkeys(void)\n{\n\tsymkey *\tsk;\n\n\tITER_DLIST_BEGIN(key_listhead, sk, llink, symkey)\n\t\tif (sk->keyid > NTP_MAXKEY) {\t\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (KEY_TRUSTED & sk->flags) {\n\t\t\tif (sk->secret != NULL) {\n\t\t\t\tmemset(sk->secret, '\\0', sk->secretsize);\n\t\t\t\tfree(sk->secret);\n\t\t\t\tsk->secret = NULL; \n\t\t\t}\n\t\t\tsk->secretsize = 0;\n\t\t\tsk->lifetime = 0;\n\t\t} else {\n\t\t\tfreesymkey(sk, &key_hash[KEYHASH(sk->keyid)]);\n\t\t}\n\tITER_DLIST_END()\n}","23457":"usm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval = (struct usmStateReference *)\n        calloc(1, sizeof(struct usmStateReference));\n\n    return retval;\n}                               ","22943":"void CairoOutputDev::popTransparencyGroup() {\n  \n  ColorSpaceStack *css = groupColorSpaceStack;\n  if (css->knockout) {\n    knockoutCount--;\n    if (!knockoutCount) {\n      \n      cairo_destroy(cairo_shape);\n      cairo_shape = NULL;\n    }\n  }\n  groupColorSpaceStack = css->next;\n  delete css;\n}","22942":"\tswitch (yych) {\n\t\tcase 'a': goto yy43;\n\t\tdefault: goto yy41;\n\t}"},"target":{"22849":0,"22732":0,"23384":0,"23072":1,"23710":1,"23202":1,"22526":1,"22867":0,"23426":1,"23323":1,"23705":1,"23442":0,"23623":0,"23695":1,"23228":1,"23662":0,"23226":0,"22810":1,"23555":0,"22801":0,"23526":0,"22929":0,"23716":0,"22888":0,"23125":0,"22851":1,"23565":0,"22493":1,"23685":0,"23231":0,"22936":0,"23120":0,"23755":1,"23256":0,"23020":0,"23392":0,"23484":0,"23491":0,"23047":1,"23313":0,"23298":1,"22839":1,"22800":0,"23495":0,"22607":1,"23077":1,"23486":0,"22845":0,"23762":0,"22780":0,"23199":1,"22553":1,"23775":1,"23670":1,"23339":1,"23515":0,"23320":0,"23679":1,"23312":1,"23683":0,"22914":1,"23509":1,"23159":1,"23245":0,"22964":0,"23112":1,"22684":0,"22624":1,"23613":1,"23655":0,"22837":0,"22532":1,"23152":0,"23543":1,"23370":0,"22941":1,"23682":1,"23382":0,"23776":0,"23272":0,"22859":1,"23418":0,"23254":0,"23811":0,"22773":1,"23172":1,"22656":0,"23759":1,"22979":1,"22731":0,"23048":0,"23283":1,"23445":1,"22728":1,"23227":0,"23519":0,"23186":0,"23188":1,"22687":0,"23055":0,"22655":1,"23022":1,"22881":1,"23821":0,"23802":0,"22820":1,"23026":1,"22654":1,"23632":0,"23080":0,"23252":0,"22676":0,"22790":1,"23741":0,"22976":1,"23684":0,"23808":0,"22497":1,"22779":0,"23405":0,"23522":0,"23406":1,"23061":0,"23738":0,"23161":1,"23758":1,"23749":0,"22644":1,"23507":1,"23446":1,"23818":0,"23564":1,"22680":0,"23350":0,"23597":0,"23584":0,"22683":0,"22986":1,"22868":1,"23713":1,"23626":1,"23290":1,"22968":0,"23005":0,"22865":0,"23554":1,"23629":0,"23068":0,"22486":1,"23609":0,"22592":1,"22873":1,"22930":1,"22591":1,"23168":0,"22908":0,"23474":0,"23785":1,"23520":1,"23107":0,"22579":1,"22824":0,"23478":1,"22970":0,"23400":0,"22856":1,"23035":1,"23195":1,"23155":1,"22993":1,"23225":0,"23567":1,"22685":1,"23236":1,"22924":1,"23536":1,"23586":1,"23571":1,"22971":0,"22935":0,"22671":1,"23530":0,"22755":1,"23018":1,"22980":1,"23594":0,"23672":1,"23743":1,"23340":0,"23700":0,"22690":0,"22879":1,"23757":1,"23622":1,"22808":1,"22995":0,"23239":1,"23354":1,"22855":0,"22985":0,"23281":1,"23190":1,"23562":0,"22700":1,"22515":1,"23449":1,"23539":0,"22781":0,"23362":0,"23316":1,"23428":1,"22981":1,"23559":0,"22662":1,"23618":1,"22850":0,"23127":1,"23331":0,"23423":0,"23464":0,"23518":1,"23019":0,"23276":1,"22933":0,"23452":1,"22844":0,"23389":0,"22638":0,"22787":0,"23243":0,"23744":0,"23180":1,"23287":0,"22977":0,"23108":0,"23372":0,"23319":0,"23556":0,"23472":1,"22677":0,"22832":1,"23232":0,"22635":0,"22766":0,"22682":0,"23570":0,"23404":0,"22809":1,"23628":0,"23598":0,"23147":0,"23153":0,"23590":1,"23453":1,"23023":1,"23788":0,"23572":0,"23078":1,"23093":1,"22871":0,"23179":0,"22966":0,"23069":1,"23714":1,"22650":0,"23095":0,"23459":0,"23262":1,"23156":0,"22611":1,"23261":1,"22898":0,"23175":1,"23160":0,"23003":1,"23083":1,"22782":0,"23761":0,"23812":0,"22830":1,"23751":0,"23801":0,"22947":1,"22620":1,"22712":1,"22907":0,"23240":0,"22989":1,"23681":0,"23439":0,"22715":1,"22918":1,"22799":1,"23601":1,"23322":1,"23441":0,"23551":0,"22786":1,"22802":0,"22922":0,"22765":1,"22485":1,"22625":1,"23527":1,"23109":0,"23424":0,"22934":1,"22769":0,"23529":0,"22711":0,"23666":1,"23052":0,"23165":1,"23345":0,"22730":0,"22708":1,"23462":0,"23110":1,"23411":0,"22549":1,"23496":0,"23163":1,"22853":1,"23669":0,"22519":1,"22754":0,"22674":1,"23145":0,"22653":1,"23049":0,"23725":0,"22694":1,"22716":0,"23353":0,"22504":1,"23548":0,"23326":0,"22938":0,"23581":1,"23417":0,"23541":1,"22499":1,"23763":1,"23552":0,"22910":1,"23367":1,"23754":1,"23309":1,"23460":0,"23248":0,"22835":0,"22729":1,"23196":0,"22878":1,"23687":1,"22917":1,"23605":0,"22475":1,"22821":1,"23463":0,"23510":1,"23659":0,"22937":0,"22660":0,"23259":0,"23768":0,"22774":1,"23708":1,"22911":1,"22900":1,"22663":0,"22641":0,"22564":1,"22777":0,"23604":1,"22696":1,"23039":0,"23139":0,"23044":1,"23654":1,"23059":1,"23007":1,"23783":1,"23415":1,"23573":1,"23719":0,"22842":0,"23656":0,"22847":1,"22783":0,"22736":0,"23170":0,"23425":0,"22636":1,"23154":0,"22718":0,"22675":0,"22789":1,"23493":1,"23578":0,"23616":1,"22767":1,"23234":0,"23310":0,"22647":1,"23786":0,"23736":0,"23420":0,"22818":0,"23368":0,"23770":0,"23299":1,"23636":0,"22594":1,"22885":0,"23501":0,"23336":0,"23537":1,"22719":1,"22699":1,"23257":1,"23158":0,"22639":1,"23813":0,"23296":0,"23711":1,"23407":1,"22890":1,"23364":1,"23208":1,"22951":0,"23015":1,"22664":0,"23201":0,"23528":0,"23358":0,"23314":0,"22758":1,"23731":0,"23269":1,"22581":1,"23699":1,"23612":0,"23098":1,"23422":0,"23634":0,"23328":1,"22962":1,"23065":0,"22814":1,"23136":0,"23244":1,"22659":0,"22791":0,"22507":1,"23631":1,"23599":0,"23443":1,"22877":0,"23121":0,"22634":0,"23166":0,"22740":1,"23661":0,"23307":0,"22739":1,"22733":0,"22950":1,"22939":0,"22574":1,"23238":0,"22649":1,"22646":0,"22882":1,"23207":1,"23209":1,"22775":1,"23102":0,"23305":1,"22763":0,"23067":1,"23553":1,"22905":0,"23042":1,"22698":0,"23036":1,"22559":1,"23767":0,"23311":0,"23647":1,"23511":1,"23450":1,"23271":0,"23266":1,"22992":0,"23489":0,"22540":1,"23697":0,"23505":0,"22529":1,"23698":0,"23001":0,"23242":0,"22693":0,"23373":0,"23157":0,"23137":0,"23388":0,"22566":1,"23106":1,"22637":0,"23675":0,"22861":1,"22480":1,"23054":0,"23275":0,"23497":1,"23149":1,"23822":0,"23668":1,"23431":0,"23002":0,"23533":0,"23694":0,"23549":0,"23619":1,"23117":0,"22909":0,"22803":0,"22864":1,"22531":1,"23523":1,"22643":1,"23644":1,"23347":0,"22595":1,"23764":1,"23602":0,"23797":0,"23338":0,"22761":1,"23062":0,"22491":1,"22863":0,"23140":1,"22623":1,"23722":0,"22665":0,"23012":0,"23610":0,"22661":0,"22991":0,"22944":0,"22776":0,"23575":1,"23658":1,"23348":0,"23071":0,"23641":0,"22833":1,"23772":1,"22838":0,"22476":1,"23032":1,"23773":0,"22846":0,"23131":0,"22710":1,"23546":0,"23278":0,"22819":0,"23538":1,"23084":1,"23760":1,"23707":0,"22975":1,"23321":0,"23301":0,"23215":0,"23614":0,"22688":0,"22681":1,"22678":1,"23494":0,"22751":0,"22642":1,"22753":0,"22972":0,"23356":1,"23315":1,"23337":0,"23376":1,"22988":0,"23260":0,"23706":0,"22829":1,"23401":0,"22794":0,"22984":1,"22994":0,"23214":1,"23396":1,"23031":0,"23130":1,"22606":1,"23000":0,"22720":1,"23297":0,"22815":0,"23771":0,"23490":0,"23363":1,"23778":0,"23092":0,"23306":0,"23637":0,"23171":0,"23222":0,"22895":0,"23653":1,"23263":0,"22999":0,"23040":1,"23146":0,"22902":1,"23729":0,"23580":0,"22744":0,"23223":1,"22697":0,"23008":1,"23517":0,"22834":0,"23642":1,"23249":1,"23182":1,"23079":0,"23063":1,"23091":1,"22778":0,"23355":0,"23333":0,"23378":0,"23419":0,"23466":0,"23451":0,"23268":0,"22746":1,"23292":0,"22886":0,"22827":1,"23692":1,"23351":1,"23558":0,"22727":1,"23651":1,"23488":1,"23440":1,"22919":1,"23774":0,"22771":1,"22536":1,"22750":1,"22945":1,"22788":1,"23361":1,"23134":1,"22757":1,"23726":0,"23104":0,"23782":1,"22825":1,"23303":0,"22875":0,"23657":1,"22973":1,"23447":1,"23128":0,"23673":0,"23678":0,"23289":0,"23167":1,"23132":1,"23200":0,"23624":0,"22651":0,"22841":1,"22956":1,"22959":0,"23606":1,"23514":0,"23191":0,"23800":0,"23566":0,"23300":1,"22792":0,"23360":1,"22798":1,"23277":1,"23051":1,"23513":1,"23603":1,"23302":0,"22703":1,"23090":1,"23210":1,"23379":1,"23374":1,"23089":1,"23479":0,"22567":1,"22848":1,"22748":1,"23798":0,"22974":0,"23732":1,"22713":0,"22923":0,"22858":1,"23473":1,"23784":0,"23608":1,"23591":0,"23635":0,"23189":1,"23430":1,"23129":0,"23294":1,"22887":0,"23816":0,"23645":1,"23267":1,"22704":0,"22583":1,"22481":1,"23611":0,"23096":1,"23375":1,"22734":1,"23366":0,"23408":1,"23185":0,"23689":1,"23703":0,"22889":0,"23205":0,"23569":0,"23480":0,"23395":0,"23006":1,"22706":1,"23391":0,"23017":1,"23021":1,"23674":1,"23535":0,"23410":0,"23184":0,"23544":1,"22961":0,"23011":0,"23765":1,"22860":0,"22737":0,"22726":1,"22707":0,"23279":0,"22823":0,"23525":1,"23250":1,"22949":1,"22608":1,"22869":1,"22982":1,"23690":1,"23413":1,"22965":1,"23476":0,"23747":1,"23013":1,"23004":0,"23577":1,"23111":0,"23458":0,"22797":1,"23563":0,"23352":0,"23433":0,"23696":0,"22668":1,"23485":0,"22721":0,"23274":1,"22666":1,"23304":1,"23308":1,"23652":1,"23421":0,"23380":0,"23532":0,"22807":1,"23435":1,"23359":1,"23676":1,"22813":0,"22880":0,"22892":0,"23429":1,"22793":0,"22513":1,"22983":1,"23582":1,"23194":1,"23393":1,"22963":0,"22954":1,"23341":0,"23034":1,"22514":1,"23454":1,"23402":0,"23126":1,"23557":1,"22826":0,"22843":0,"23471":0,"23288":1,"23545":0,"22913":0,"22691":0,"23119":0,"23087":0,"23627":1,"23779":1,"23444":0,"23470":1,"23461":1,"22955":0,"22921":1,"23750":1,"23475":1,"23787":1,"22672":1,"23009":1,"23076":1,"23780":0,"23589":1,"23198":1,"23246":1,"23506":0,"23625":0,"23487":1,"23335":0,"23086":1,"23057":0,"22759":0,"22978":0,"23592":0,"23123":1,"23100":1,"22618":1,"23291":1,"23024":0,"23029":1,"23114":0,"22998":1,"22738":1,"23330":1,"22893":1,"22705":1,"23745":0,"23600":0,"22940":0,"23503":1,"22997":0,"23746":0,"23014":1,"22717":1,"23720":1,"23766":1,"23646":0,"23730":1,"22484":1,"22673":1,"22987":1,"23270":0,"23671":0,"22709":0,"23740":1,"23638":0,"22804":0,"22770":0,"23438":1,"23781":0,"23492":0,"23344":1,"23691":0,"23264":1,"22545":1,"23737":0,"22542":1,"22657":0,"23206":1,"23468":1,"23255":1,"23477":0,"23483":0,"22870":0,"23150":0,"22488":1,"23357":1,"23550":0,"23343":1,"22597":1,"23144":0,"23371":0,"22689":1,"22927":0,"23414":1,"22899":1,"23204":1,"23216":0,"23151":0,"22562":1,"22812":0,"22764":1,"23203":0,"23516":1,"23796":0,"23164":1,"23724":0,"22530":1,"22512":1,"23064":0,"23056":0,"23082":1,"22679":1,"22752":0,"23066":1,"22795":1,"23221":1,"23081":0,"23387":0,"23212":1,"23122":0,"23073":1,"23455":1,"22960":1,"23465":1,"23693":0,"23777":1,"23712":1,"23416":0,"22990":1,"23595":1,"23499":1,"23141":1,"22805":0,"23791":0,"23097":0,"23193":1,"23045":0,"23229":1,"23113":0,"23704":0,"23324":0,"22722":0,"22692":0,"22915":0,"23218":0,"23282":1,"23162":0,"22817":1,"23593":1,"23217":1,"22831":0,"23752":1,"23630":1,"22523":1,"23094":1,"23394":1,"22560":1,"23434":0,"23030":0,"23531":1,"23542":1,"22725":0,"23327":1,"22884":0,"22742":1,"22472":1,"22957":1,"22568":1,"23795":0,"22866":0,"23230":0,"23660":0,"23177":1,"22580":1,"23500":1,"23677":0,"23508":0,"23138":1,"22904":0,"23615":0,"23211":1,"23286":1,"22648":0,"23318":0,"23620":0,"23116":1,"23169":0,"23273":1,"22903":1,"23317":0,"22785":1,"23709":1,"23680":0,"23220":0,"22894":1,"22749":1,"22563":1,"23649":0,"23403":1,"23219":0,"22702":0,"22772":0,"23369":1,"22836":1,"23224":0,"23381":0,"22857":1,"23265":1,"22756":0,"22572":1,"23377":1,"22928":0,"23588":1,"23118":1,"23293":1,"23178":1,"23701":0,"22967":1,"22645":0,"23621":0,"22952":1,"23174":1,"22610":1,"23176":1,"23723":0,"23824":0,"23718":1,"23103":0,"23197":1,"23469":1,"23728":0,"23574":1,"22958":1,"22806":1,"22558":1,"22585":1,"22896":0,"23742":1,"23033":0,"22874":1,"23233":0,"23702":0,"22840":1,"23247":0,"23342":0,"22743":1,"23427":0,"22897":0,"23070":1,"22524":1,"23346":0,"23383":0,"23285":1,"23534":1,"22828":0,"23640":1,"22876":0,"23085":1,"23058":1,"23385":1,"22686":0,"23115":1,"22724":1,"22872":0,"22925":1,"23099":1,"22609":1,"23050":0,"23504":1,"22811":0,"23409":0,"23253":0,"23502":0,"22916":0,"22948":0,"23010":1,"23482":0,"22547":1,"23717":0,"23135":1,"22912":1,"23561":1,"23540":1,"23365":1,"23181":0,"23739":0,"23664":1,"23667":0,"22926":1,"23721":0,"23025":1,"22854":0,"22822":0,"23596":0,"22852":0,"23587":0,"23756":1,"22695":1,"22601":1,"23576":1,"22747":1,"23607":0,"23386":1,"22596":1,"23397":0,"22862":0,"23075":0,"23295":1,"23665":0,"22667":1,"23633":1,"23639":0,"22796":1,"23467":1,"23334":1,"22762":1,"22932":0,"23727":1,"22701":0,"23547":0,"23456":1,"23579":0,"23524":0,"22996":1,"22946":1,"22920":0,"22931":1,"23436":1,"23769":1,"23753":1,"23101":1,"23399":1,"23688":1,"22590":1,"22621":1,"22521":1,"23027":0,"23043":0,"22883":1,"23148":0,"23241":0,"22760":0,"23329":1,"23412":1,"23074":0,"22652":1,"23498":1,"23060":1,"22582":1,"23133":1,"23325":1,"23105":0,"23650":1,"23143":0,"23448":1,"23349":0,"23583":0,"23173":0,"23390":0,"23748":0,"23512":1,"22714":1,"23648":1,"23142":0,"22605":1,"23053":0,"22602":1,"23192":1,"23187":1,"22741":1,"23037":0,"22969":1,"22784":1,"22670":0,"23807":0,"23643":0,"23617":0,"23041":1,"23437":0,"22498":1,"22735":0,"22816":0,"23124":1,"22901":0,"23568":0,"23663":0,"23585":1,"22627":1,"22487":1,"22953":0,"22669":0,"23235":1,"22906":0,"22586":1,"23284":0,"23560":0,"23792":0,"23028":0,"23398":1,"23088":0,"23686":1,"22768":0,"22522":1,"22723":0,"23237":0,"23016":0,"22745":0,"23715":0,"23734":1,"22658":0,"22640":0,"22571":1,"23183":1,"22891":0,"23251":0,"23432":0,"23735":1,"23258":0,"23521":1,"23046":1,"23481":0,"23733":0,"23332":1,"23038":1,"23280":0,"23213":1,"23457":1,"22943":0,"22942":1},"cwe":{"22849":["CWE-241","CWE-824"],"22732":["CWE-119","CWE-788"],"23384":[],"23072":["CWE-20"],"23710":["CWE-125"],"23202":["CWE-125"],"22526":["CWE-20"],"22867":["CWE-400"],"23426":["CWE-20"],"23323":["CWE-416"],"23705":["CWE-20"],"23442":["CWE-287"],"23623":[],"23695":[],"23228":[],"23662":["CWE-416","CWE-125"],"23226":["CWE-787"],"22810":["CWE-399","CWE-404"],"23555":["CWE-399"],"22801":["CWE-617"],"23526":["CWE-416","CWE-362"],"22929":["CWE-416"],"23716":["CWE-20"],"22888":["CWE-125"],"23125":["CWE-476"],"22851":["CWE-295"],"23565":["CWE-416"],"22493":["CWE-20","CWE-787"],"23685":["CWE-703","CWE-264"],"23231":["CWE-288"],"22936":["CWE-399"],"23120":["CWE-416"],"23755":["CWE-125"],"23256":[],"23020":["CWE-416","CWE-362"],"23392":[],"23484":["CWE-787"],"23491":["CWE-200"],"23047":[],"23313":[],"23298":[],"22839":[],"22800":["CWE-284","CWE-264"],"23495":["CWE-22"],"22607":[],"23077":["CWE-770"],"23486":["CWE-400","CWE-703"],"22845":["CWE-190"],"23762":["CWE-125","CWE-345"],"22780":["CWE-787"],"23199":["CWE-125"],"22553":["CWE-77"],"23775":[],"23670":["CWE-125"],"23339":["CWE-125"],"23515":["CWE-20"],"23320":["CWE-400"],"23679":["CWE-787"],"23312":["CWE-20","CWE-787"],"23683":["CWE-416","CWE-284","CWE-264"],"22914":["CWE-613","CWE-703"],"23509":["CWE-269","CWE-94"],"23159":[],"23245":["CWE-399"],"22964":["CWE-703"],"23112":["CWE-787"],"22684":["CWE-787"],"22624":[],"23613":["CWE-400","CWE-703","CWE-401"],"23655":["CWE-287","CWE-284"],"22837":["CWE-862"],"22532":["CWE-367"],"23152":[],"23543":["CWE-459"],"23370":[],"22941":["CWE-125"],"23682":["CWE-20"],"23382":["CWE-119"],"23776":["CWE-362"],"23272":["CWE-200"],"22859":[],"23418":["CWE-772"],"23254":["CWE-119","CWE-703"],"23811":[],"22773":["CWE-20","CWE-269"],"23172":["CWE-770"],"22656":["CWE-399"],"23759":["CWE-476"],"22979":["CWE-125"],"22731":["CWE-787"],"23048":["CWE-399"],"23283":[],"23445":["CWE-119","CWE-787"],"22728":["CWE-190"],"23227":["CWE-787"],"23519":["CWE-94"],"23186":["CWE-703"],"23188":["CWE-787"],"22687":[],"23055":[],"22655":["CWE-863"],"23022":["CWE-284","CWE-295"],"22881":["CWE-459"],"23821":["CWE-20","CWE-476"],"23802":[],"22820":["CWE-617"],"23026":["CWE-787"],"22654":[],"23632":[],"23080":["CWE-17"],"23252":["CWE-362"],"22676":["CWE-416"],"22790":["CWE-189"],"23741":[],"22976":["CWE-77","CWE-295"],"23684":["CWE-119","CWE-787"],"23808":["CWE-400","CWE-703"],"22497":["CWE-20"],"22779":[],"23405":["CWE-787"],"23522":["CWE-310"],"23406":["CWE-20"],"23061":["CWE-787"],"23738":["CWE-416"],"23161":["CWE-190"],"23758":["CWE-703","CWE-835"],"23749":["CWE-200"],"22644":["CWE-787"],"23507":["CWE-125","CWE-835"],"23446":[],"23818":["CWE-502"],"23564":["CWE-399"],"22680":["CWE-200","CWE-909"],"23350":["CWE-22"],"23597":["CWE-703","CWE-674"],"23584":["CWE-703"],"22683":["CWE-703","CWE-770"],"22986":[],"22868":["CWE-416"],"23713":["CWE-362"],"23626":["CWE-323"],"23290":[],"22968":["CWE-200"],"23005":[],"22865":["CWE-190"],"23554":["CWE-20","CWE-79"],"23629":["CWE-476","CWE-787"],"23068":["CWE-20"],"22486":["CWE-327"],"23609":["CWE-276"],"22592":["CWE-703"],"22873":["CWE-362"],"22930":["CWE-20","CWE-22"],"22591":[],"23168":["CWE-327"],"22908":["CWE-125"],"23474":["CWE-200"],"23785":["CWE-400"],"23520":["CWE-476"],"23107":["CWE-476"],"22579":["CWE-20"],"22824":[],"23478":["CWE-476","CWE-125"],"22970":["CWE-835"],"23400":["CWE-703"],"22856":["CWE-787"],"23035":["CWE-287"],"23195":["CWE-362"],"23155":["CWE-119"],"22993":["CWE-119"],"23225":["CWE-787"],"23567":[],"22685":["CWE-399"],"23236":["CWE-787"],"22924":["CWE-416","CWE-125","CWE-189"],"23536":["CWE-119"],"23586":["CWE-264"],"23571":["CWE-119"],"22971":["CWE-22"],"22935":["CWE-400","CWE-703"],"22671":["CWE-125"],"23530":["CWE-125"],"22755":["CWE-617","CWE-703"],"23018":[],"22980":["CWE-284"],"23594":["CWE-703"],"23672":["CWE-190"],"23743":["CWE-264","CWE-269"],"23340":["CWE-284"],"23700":["CWE-476","CWE-119"],"22690":["CWE-703"],"22879":["CWE-20","CWE-269"],"23757":["CWE-125"],"23622":["CWE-20"],"22808":["CWE-190"],"22995":["CWE-20","CWE-269"],"23239":["CWE-416"],"23354":["CWE-18","CWE-763"],"22855":["CWE-119","CWE-787"],"22985":["CWE-369"],"23281":["CWE-119"],"23190":[],"23562":[],"22700":["CWE-415"],"22515":["CWE-416"],"23449":["CWE-476"],"23539":["CWE-400","CWE-703"],"22781":["CWE-416"],"23362":["CWE-190","CWE-787"],"23316":["CWE-416"],"23428":["CWE-310"],"22981":["CWE-703","CWE-369"],"23559":["CWE-78"],"22662":["CWE-125"],"23618":["CWE-416"],"22850":["CWE-476"],"23127":["CWE-119","CWE-787"],"23331":["CWE-200"],"23423":["CWE-119"],"23464":["CWE-400"],"23518":[],"23019":[],"23276":["CWE-119"],"22933":["CWE-119"],"23452":["CWE-119"],"22844":["CWE-20","CWE-190"],"23389":["CWE-787"],"22638":["CWE-119","CWE-787"],"22787":["CWE-416"],"23243":[],"23744":[],"23180":["CWE-552","CWE-703"],"23287":["CWE-703","CWE-189"],"22977":["CWE-310"],"23108":["CWE-703"],"23372":["CWE-290"],"23319":["CWE-787"],"23556":["CWE-476"],"23472":["CWE-284"],"22677":["CWE-415"],"22832":["CWE-254"],"23232":[],"22635":["CWE-476"],"22766":["CWE-200"],"22682":["CWE-362"],"23570":["CWE-119","CWE-787"],"23404":["CWE-287"],"22809":[],"23628":["CWE-125","CWE-787"],"23598":["CWE-416"],"23147":["CWE-476","CWE-787"],"23153":["CWE-369"],"23590":[],"23453":["CWE-77","CWE-295"],"23023":["CWE-287","CWE-284"],"23788":["CWE-400","CWE-703"],"23572":["CWE-416"],"23078":["CWE-284","CWE-264"],"23093":["CWE-200"],"22871":["CWE-400","CWE-703"],"23179":["CWE-119"],"22966":["CWE-362"],"23069":["CWE-120","CWE-295"],"23714":["CWE-200"],"22650":["CWE-703"],"23095":["CWE-125"],"23459":["CWE-703","CWE-264"],"23262":["CWE-416"],"23156":["CWE-20"],"22611":["CWE-476"],"23261":["CWE-476"],"22898":["CWE-284","CWE-264"],"23175":["CWE-787"],"23160":["CWE-400"],"23003":["CWE-200"],"23083":["CWE-125","CWE-787"],"22782":[],"23761":["CWE-125"],"23812":["CWE-416"],"22830":["CWE-327"],"23751":["CWE-416","CWE-362"],"23801":[],"22947":["CWE-319"],"22620":["CWE-787"],"22712":["CWE-399"],"22907":["CWE-125"],"23240":["CWE-22"],"22989":["CWE-120","CWE-119","CWE-787"],"23681":["CWE-476"],"23439":["CWE-119","CWE-787"],"22715":[],"22918":[],"22799":[],"23601":["CWE-399","CWE-190"],"23322":["CWE-362"],"23441":["CWE-20"],"23551":["CWE-703","CWE-189"],"22786":["CWE-787"],"22802":["CWE-770"],"22922":["CWE-732"],"22765":["CWE-310"],"22485":["CWE-416"],"22625":["CWE-193"],"23527":["CWE-200","CWE-552"],"23109":["CWE-787"],"23424":["CWE-835"],"22934":[],"22769":["CWE-78"],"23529":[],"22711":[],"23666":["CWE-400"],"23052":["CWE-787"],"23165":[],"23345":["CWE-94"],"22730":["CWE-125"],"22708":["CWE-295"],"23462":[],"23110":["CWE-369"],"23411":[],"22549":["CWE-125","CWE-787"],"23496":["CWE-416"],"23163":["CWE-369","CWE-189"],"22853":["CWE-835"],"23669":["CWE-770"],"22519":["CWE-787"],"22754":["CWE-400","CWE-703","CWE-835"],"22674":["CWE-404","CWE-703"],"23145":["CWE-59","CWE-61"],"22653":["CWE-119"],"23049":["CWE-362"],"23725":["CWE-416"],"22694":["CWE-200"],"22716":["CWE-125"],"23353":["CWE-787"],"22504":["CWE-415"],"23548":[],"23326":["CWE-284","CWE-264"],"22938":["CWE-119","CWE-703","CWE-787"],"23581":[],"23417":["CWE-400","CWE-703","CWE-264"],"23541":["CWE-399","CWE-404"],"22499":[],"23763":["CWE-787"],"23552":["CWE-20"],"22910":["CWE-416"],"23367":["CWE-20"],"23754":["CWE-119"],"23309":[],"23460":["CWE-400","CWE-401"],"23248":["CWE-400","CWE-399","CWE-703"],"22835":["CWE-415"],"22729":[],"23196":["CWE-310"],"22878":[],"23687":["CWE-89"],"22917":[],"23605":["CWE-400","CWE-399","CWE-703"],"22475":["CWE-120"],"22821":["CWE-287","CWE-284"],"23463":["CWE-399"],"23510":["CWE-125"],"23659":["CWE-787"],"22937":["CWE-269"],"22660":["CWE-362"],"23259":["CWE-122","CWE-787"],"23768":["CWE-125"],"22774":["CWE-369","CWE-787"],"23708":["CWE-125"],"22911":["CWE-416"],"22900":["CWE-190"],"22663":["CWE-295"],"22641":["CWE-190"],"22564":[],"22777":["CWE-416","CWE-703"],"23604":["CWE-190"],"22696":[],"23039":["CWE-401"],"23139":["CWE-200"],"23044":["CWE-416"],"23654":[],"23059":["CWE-20"],"23007":["CWE-78"],"23783":["CWE-119"],"23415":["CWE-330"],"23573":["CWE-284"],"23719":["CWE-119"],"22842":["CWE-703","CWE-754"],"23656":["CWE-862"],"22847":["CWE-327"],"22783":["CWE-125"],"22736":["CWE-416"],"23170":["CWE-22"],"23425":[],"22636":["CWE-918"],"23154":["CWE-416","CWE-125"],"22718":["CWE-295"],"22675":["CWE-400","CWE-401"],"22789":["CWE-20"],"23493":["CWE-310"],"23578":["CWE-284"],"23616":["CWE-200","CWE-552"],"22767":["CWE-703"],"23234":["CWE-20","CWE-129"],"23310":["CWE-416","CWE-284"],"22647":["CWE-119"],"23786":["CWE-703"],"23736":["CWE-125"],"23420":["CWE-200"],"22818":["CWE-189"],"23368":["CWE-416","CWE-787"],"23770":["CWE-772"],"23299":["CWE-125"],"23636":["CWE-119"],"22594":["CWE-476"],"22885":[],"23501":["CWE-125","CWE-787"],"23336":["CWE-20","CWE-129"],"23537":["CWE-611"],"22719":["CWE-264"],"22699":["CWE-125"],"23257":["CWE-416"],"23158":["CWE-252"],"22639":[],"23813":["CWE-264"],"23296":["CWE-20"],"23711":["CWE-20"],"23407":["CWE-190"],"22890":[],"23364":["CWE-22"],"23208":[],"22951":["CWE-59","CWE-241"],"23015":["CWE-119"],"22664":["CWE-119"],"23201":["CWE-94"],"23528":["CWE-703"],"23358":["CWE-416"],"23314":["CWE-770"],"22758":[],"23731":["CWE-190"],"23269":[],"22581":["CWE-125"],"23699":["CWE-89"],"23612":[],"23098":["CWE-327"],"23422":["CWE-476","CWE-190"],"23634":["CWE-119","CWE-125"],"23328":["CWE-400","CWE-703"],"22962":["CWE-310"],"23065":["CWE-119"],"22814":[],"23136":["CWE-476"],"23244":["CWE-787"],"22659":["CWE-190"],"22791":["CWE-20"],"22507":[],"23631":["CWE-295"],"23599":[],"23443":[],"22877":["CWE-787"],"23121":["CWE-190"],"22634":["CWE-415"],"23166":["CWE-119","CWE-787"],"22740":["CWE-20"],"23661":["CWE-862","CWE-285"],"23307":["CWE-416"],"22739":[],"22733":["CWE-400"],"22950":["CWE-20"],"22939":[],"22574":["CWE-703"],"23238":["CWE-703","CWE-835"],"22649":["CWE-269","CWE-94"],"22646":["CWE-264"],"22882":["CWE-125"],"23207":["CWE-189"],"23209":["CWE-476"],"22775":["CWE-476","CWE-125"],"23102":["CWE-20"],"23305":[],"22763":["CWE-770"],"23067":[],"23553":["CWE-22"],"22905":["CWE-617"],"23042":["CWE-125"],"22698":["CWE-125","CWE-787"],"23036":["CWE-125","CWE-787"],"22559":["CWE-787"],"23767":[],"23311":["CWE-862"],"23647":["CWE-125"],"23511":[],"23450":["CWE-772"],"23271":["CWE-416"],"23266":[],"22992":["CWE-401"],"23489":["CWE-190"],"22540":["CWE-295"],"23697":[],"23505":["CWE-269"],"22529":["CWE-20"],"23698":["CWE-125"],"23001":["CWE-416"],"23242":["CWE-400"],"22693":["CWE-190"],"23373":["CWE-668"],"23157":["CWE-200"],"23137":["CWE-122","CWE-787"],"23388":["CWE-129"],"22566":["CWE-119"],"23106":["CWE-310"],"22637":["CWE-284"],"23675":[],"22861":["CWE-787"],"22480":["CWE-787"],"23054":["CWE-119"],"23275":["CWE-20"],"23497":["CWE-20","CWE-79"],"23149":["CWE-125"],"23822":["CWE-119"],"23668":["CWE-190"],"23431":[],"23002":["CWE-20"],"23533":["CWE-125"],"23694":["CWE-125"],"23549":["CWE-284","CWE-295"],"23619":["CWE-416"],"23117":["CWE-20"],"22909":[],"22803":["CWE-400","CWE-703"],"22864":["CWE-416"],"22531":[],"23523":["CWE-119"],"22643":["CWE-269"],"23644":["CWE-59"],"23347":["CWE-269"],"22595":["CWE-787"],"23764":["CWE-287"],"23602":["CWE-416"],"23797":["CWE-284","CWE-295"],"23338":["CWE-415"],"22761":["CWE-835"],"23062":["CWE-552","CWE-703"],"22491":["CWE-416"],"22863":["CWE-125"],"23140":["CWE-362"],"22623":["CWE-125"],"23722":[],"22665":["CWE-476"],"23012":["CWE-703"],"23610":["CWE-400","CWE-119","CWE-703"],"22661":["CWE-352"],"22991":["CWE-119"],"22944":["CWE-20"],"22776":["CWE-203"],"23575":["CWE-125"],"23658":["CWE-416"],"23348":["CWE-400"],"23071":["CWE-125"],"23641":["CWE-190"],"22833":["CWE-863"],"23772":["CWE-20"],"22838":["CWE-20","CWE-129"],"22476":["CWE-59"],"23032":["CWE-703"],"23773":["CWE-362","CWE-347"],"22846":["CWE-416","CWE-295"],"23131":["CWE-416"],"22710":["CWE-190"],"23546":["CWE-119","CWE-787"],"23278":[],"22819":["CWE-125"],"23538":["CWE-415"],"23084":["CWE-125"],"23760":["CWE-190"],"23707":["CWE-125"],"22975":["CWE-20"],"23321":["CWE-20","CWE-125"],"23301":["CWE-787"],"23215":[],"23614":["CWE-787"],"22688":["CWE-310"],"22681":["CWE-125"],"22678":["CWE-400","CWE-703"],"23494":[],"22751":["CWE-200"],"22642":["CWE-119"],"22753":["CWE-763"],"22972":["CWE-284"],"23356":["CWE-415"],"23315":["CWE-125","CWE-787"],"23337":[],"23376":["CWE-835"],"22988":[],"23260":["CWE-416"],"23706":["CWE-416"],"22829":["CWE-20"],"23401":["CWE-400"],"22794":["CWE-20"],"22984":[],"22994":[],"23214":["CWE-476"],"23396":["CWE-415","CWE-119"],"23031":["CWE-476"],"23130":["CWE-399"],"22606":["CWE-459"],"23000":[],"22720":["CWE-264"],"23297":["CWE-416"],"22815":["CWE-863"],"23771":["CWE-665"],"23490":[],"23363":["CWE-19"],"23778":["CWE-20","CWE-129"],"23092":[],"23306":["CWE-125"],"23637":["CWE-77"],"23171":["CWE-125"],"23222":[],"22895":["CWE-770"],"23653":[],"23263":["CWE-476"],"22999":[],"23040":["CWE-125"],"23146":["CWE-909"],"22902":[],"23729":["CWE-732","CWE-703","CWE-269"],"23580":["CWE-200"],"22744":["CWE-287","CWE-284"],"23223":["CWE-362"],"22697":["CWE-400","CWE-401"],"23008":["CWE-190"],"23517":[],"22834":["CWE-399","CWE-203"],"23642":["CWE-125"],"23249":["CWE-330"],"23182":["CWE-125"],"23079":["CWE-119","CWE-787"],"23063":["CWE-20"],"23091":["CWE-400","CWE-399","CWE-703"],"22778":["CWE-770"],"23355":[],"23333":[],"23378":["CWE-416","CWE-862"],"23419":["CWE-190"],"23466":["CWE-125"],"23451":[],"23268":["CWE-119"],"22746":["CWE-200"],"23292":["CWE-476"],"22886":["CWE-287","CWE-284"],"22827":["CWE-20"],"23692":["CWE-119"],"23351":["CWE-310"],"23558":["CWE-416"],"22727":[],"23651":["CWE-20","CWE-190"],"23488":["CWE-20","CWE-617"],"23440":[],"22919":["CWE-400"],"23774":["CWE-125"],"22771":[],"22536":["CWE-200","CWE-908"],"22750":["CWE-835"],"22945":["CWE-476"],"22788":["CWE-295"],"23361":["CWE-190"],"23134":[],"22757":["CWE-20"],"23726":["CWE-401","CWE-254"],"23104":["CWE-212"],"23782":["CWE-120","CWE-119","CWE-787"],"22825":["CWE-400"],"23303":["CWE-476"],"22875":["CWE-400","CWE-401"],"23657":[],"22973":["CWE-79"],"23447":["CWE-189"],"23128":["CWE-190"],"23673":["CWE-476"],"23678":["CWE-703"],"23289":["CWE-362"],"23167":["CWE-20"],"23132":["CWE-787"],"23200":[],"23624":["CWE-264"],"22651":["CWE-476"],"22841":[],"22956":["CWE-119"],"22959":["CWE-310"],"23606":["CWE-295"],"23514":[],"23191":["CWE-476"],"23800":["CWE-703"],"23566":["CWE-22"],"23300":["CWE-416"],"22792":["CWE-190","CWE-787"],"23360":["CWE-125"],"22798":["CWE-416"],"23277":[],"23051":["CWE-703"],"23513":[],"23603":["CWE-200"],"23302":["CWE-20"],"22703":["CWE-862","CWE-285"],"23090":[],"23210":["CWE-754"],"23379":[],"23374":["CWE-125"],"23089":["CWE-200","CWE-732"],"23479":["CWE-416"],"22567":["CWE-125"],"22848":["CWE-125"],"22748":["CWE-703","CWE-681","CWE-787"],"23798":["CWE-20","CWE-200"],"22974":["CWE-190"],"23732":["CWE-94"],"22713":["CWE-120"],"22923":["CWE-190","CWE-369"],"22858":["CWE-362"],"23473":["CWE-125"],"23784":["CWE-22"],"23608":["CWE-703"],"23591":["CWE-78"],"23635":["CWE-416","CWE-362"],"23189":[],"23430":[],"23129":["CWE-125"],"23294":["CWE-787"],"22887":["CWE-269"],"23816":["CWE-787"],"23645":["CWE-787"],"23267":["CWE-20","CWE-190"],"22704":["CWE-787"],"22583":[],"22481":["CWE-787"],"23611":["CWE-20"],"23096":["CWE-125"],"23375":["CWE-264"],"22734":["CWE-125","CWE-787"],"23366":["CWE-77"],"23408":["CWE-20","CWE-129"],"23185":["CWE-703","CWE-754"],"23689":["CWE-787"],"23703":["CWE-416","CWE-200"],"22889":["CWE-20"],"23205":["CWE-476"],"23569":["CWE-401"],"23480":["CWE-125","CWE-787"],"23395":[],"23006":[],"22706":["CWE-613","CWE-703"],"23391":["CWE-119","CWE-681","CWE-787"],"23017":["CWE-399","CWE-401"],"23021":["CWE-665"],"23674":[],"23535":["CWE-416"],"23410":["CWE-400","CWE-399","CWE-674"],"23184":["CWE-770"],"23544":["CWE-120"],"22961":["CWE-119"],"23011":["CWE-835"],"23765":["CWE-476"],"22860":["CWE-476"],"22737":["CWE-94"],"22726":["CWE-120"],"22707":["CWE-125"],"23279":["CWE-125"],"22823":["CWE-264"],"23525":["CWE-476"],"23250":["CWE-200"],"22949":["CWE-415"],"22608":["CWE-400"],"22869":["CWE-770"],"22982":[],"23690":["CWE-310"],"23413":[],"22965":["CWE-310"],"23476":[],"23747":["CWE-20","CWE-254","CWE-787"],"23013":["CWE-125"],"23004":["CWE-20"],"23577":["CWE-200","CWE-787"],"23111":[],"23458":["CWE-400","CWE-401"],"22797":["CWE-284","CWE-436"],"23563":[],"23352":["CWE-119","CWE-787"],"23433":["CWE-20"],"23696":["CWE-434"],"22668":["CWE-667"],"23485":["CWE-200"],"22721":["CWE-416","CWE-362"],"23274":["CWE-617"],"22666":["CWE-787"],"23304":["CWE-601"],"23308":["CWE-399"],"23652":["CWE-310"],"23421":[],"23380":["CWE-264"],"23532":["CWE-415"],"22807":["CWE-327"],"23435":["CWE-476"],"23359":["CWE-310"],"23676":["CWE-119"],"22813":["CWE-78"],"22880":["CWE-120","CWE-119","CWE-787"],"22892":["CWE-787"],"23429":[],"22793":["CWE-120"],"22513":["CWE-284","CWE-264"],"22983":["CWE-125"],"23582":["CWE-119"],"23194":[],"23393":["CWE-119","CWE-787"],"22963":["CWE-617"],"22954":["CWE-416"],"23341":["CWE-119","CWE-787"],"23034":["CWE-400","CWE-703","CWE-401"],"22514":["CWE-200"],"23454":["CWE-116","CWE-79"],"23402":["CWE-476"],"23126":["CWE-119"],"23557":["CWE-189"],"22826":["CWE-787"],"22843":["CWE-400","CWE-674","CWE-787"],"23471":["CWE-787"],"23288":["CWE-200"],"23545":["CWE-19"],"22913":["CWE-400","CWE-703","CWE-835"],"22691":["CWE-399"],"23119":["CWE-399"],"23087":["CWE-120"],"23627":["CWE-125"],"23779":["CWE-190"],"23444":["CWE-254"],"23470":["CWE-400"],"23461":["CWE-703","CWE-189"],"22955":[],"22921":["CWE-399"],"23750":[],"23475":["CWE-416"],"23787":["CWE-362"],"22672":["CWE-416","CWE-362"],"23009":[],"23076":["CWE-189"],"23780":["CWE-284"],"23589":["CWE-20"],"23198":["CWE-476"],"23246":["CWE-399"],"23506":["CWE-617"],"23625":["CWE-703"],"23487":[],"23335":["CWE-770"],"23086":[],"23057":["CWE-732"],"22759":["CWE-284","CWE-295"],"22978":["CWE-835"],"23592":["CWE-190"],"23123":["CWE-703"],"23100":["CWE-284","CWE-264","CWE-269"],"22618":["CWE-125","CWE-787"],"23291":[],"23024":["CWE-20"],"23029":[],"23114":["CWE-787"],"22998":["CWE-703"],"22738":["CWE-287"],"23330":[],"22893":["CWE-119","CWE-787"],"22705":["CWE-119","CWE-787"],"23745":["CWE-770"],"23600":["CWE-190"],"22940":["CWE-400","CWE-401"],"23503":["CWE-787"],"22997":[],"23746":["CWE-703"],"23014":["CWE-125"],"22717":["CWE-703","CWE-189"],"23720":[],"23766":["CWE-22"],"23646":["CWE-190"],"23730":["CWE-416"],"22484":["CWE-189"],"22673":["CWE-703","CWE-189"],"22987":["CWE-787"],"23270":["CWE-787"],"23671":["CWE-20"],"22709":["CWE-20"],"23740":["CWE-416"],"23638":["CWE-703"],"22804":["CWE-703"],"22770":["CWE-770"],"23438":["CWE-125","CWE-787"],"23781":["CWE-20"],"23492":["CWE-399"],"23344":["CWE-125"],"23691":["CWE-119","CWE-787"],"23264":["CWE-20"],"22545":["CWE-400","CWE-703","CWE-835"],"23737":["CWE-59","CWE-61"],"22542":["CWE-190"],"22657":["CWE-125"],"23206":["CWE-190"],"23468":[],"23255":["CWE-20","CWE-190"],"23477":["CWE-703","CWE-125"],"23483":[],"22870":["CWE-399","CWE-190"],"23150":[],"22488":[],"23357":["CWE-674"],"23550":["CWE-863"],"23343":["CWE-399"],"22597":["CWE-120"],"23144":[],"23371":["CWE-200"],"22689":[],"22927":["CWE-416"],"23414":[],"22899":["CWE-824"],"23204":["CWE-770"],"23216":["CWE-125"],"23151":["CWE-674","CWE-787"],"22562":["CWE-787"],"22812":[],"22764":["CWE-200"],"23203":["CWE-200","CWE-119"],"23516":[],"23796":["CWE-20"],"23164":["CWE-703","CWE-770"],"23724":["CWE-835"],"22530":["CWE-200"],"22512":["CWE-189"],"23064":["CWE-416"],"23056":["CWE-399"],"23082":["CWE-119"],"22679":["CWE-415"],"22752":["CWE-20","CWE-125"],"23066":["CWE-119","CWE-787"],"22795":["CWE-59"],"23221":["CWE-787"],"23081":["CWE-241","CWE-19"],"23387":["CWE-200","CWE-552"],"23212":["CWE-125"],"23122":["CWE-119"],"23073":["CWE-269"],"23455":[],"22960":["CWE-20"],"23465":["CWE-190"],"23693":["CWE-416"],"23777":["CWE-273","CWE-284","CWE-264"],"23712":["CWE-400","CWE-703","CWE-770"],"23416":["CWE-400"],"22990":[],"23595":["CWE-59","CWE-269"],"23499":["CWE-200"],"23141":["CWE-190"],"22805":["CWE-399"],"23791":[],"23097":["CWE-190"],"23193":["CWE-276"],"23045":["CWE-787"],"23229":["CWE-119"],"23113":["CWE-362"],"23704":["CWE-119","CWE-787"],"23324":["CWE-120"],"22722":["CWE-416","CWE-908"],"22692":["CWE-200"],"22915":["CWE-125"],"23218":["CWE-22"],"23282":["CWE-319"],"23162":["CWE-120"],"22817":["CWE-362","CWE-264"],"23593":["CWE-120","CWE-787"],"23217":[],"22831":["CWE-400","CWE-401"],"23752":["CWE-787"],"23630":["CWE-125"],"22523":["CWE-125","CWE-835"],"23094":["CWE-125"],"23394":["CWE-119"],"22560":["CWE-119","CWE-787"],"23434":[],"23030":["CWE-20","CWE-129"],"23531":["CWE-703"],"23542":["CWE-400","CWE-703"],"22725":["CWE-20"],"23327":["CWE-116"],"22884":["CWE-787"],"22742":["CWE-119"],"22472":["CWE-276"],"22957":["CWE-125"],"22568":["CWE-125","CWE-787"],"23795":["CWE-125"],"22866":["CWE-119"],"23230":["CWE-200"],"23660":["CWE-20"],"23177":["CWE-772"],"22580":["CWE-119"],"23500":["CWE-787"],"23677":["CWE-119","CWE-125"],"23508":[],"23138":["CWE-416"],"22904":["CWE-119","CWE-787"],"23615":["CWE-125"],"23211":["CWE-200","CWE-668"],"23286":["CWE-476"],"22648":["CWE-399"],"23318":["CWE-189"],"23620":["CWE-787"],"23116":["CWE-416"],"23169":["CWE-400"],"23273":[],"22903":["CWE-310"],"23317":["CWE-770"],"22785":["CWE-416"],"23709":["CWE-20","CWE-703","CWE-400"],"23680":["CWE-20"],"23220":["CWE-190"],"22894":["CWE-476"],"22749":["CWE-703","CWE-667"],"22563":["CWE-400","CWE-703","CWE-264"],"23649":[],"23403":["CWE-119"],"23219":["CWE-401"],"22702":["CWE-770"],"22772":["CWE-787"],"23369":["CWE-416"],"22836":["CWE-476","CWE-703","CWE-125"],"23224":["CWE-787"],"23381":["CWE-119"],"22857":[],"23265":["CWE-22"],"22756":["CWE-401"],"22572":["CWE-362"],"23377":["CWE-200"],"22928":["CWE-459"],"23588":[],"23118":["CWE-787"],"23293":["CWE-20"],"23178":["CWE-119","CWE-787"],"23701":["CWE-416"],"22967":["CWE-209"],"22645":["CWE-269"],"23621":["CWE-269"],"22952":["CWE-200","CWE-119","CWE-787"],"23174":["CWE-400","CWE-703"],"22610":["CWE-119"],"23176":["CWE-476"],"23723":["CWE-362","CWE-119","CWE-189"],"23824":["CWE-770"],"23718":[],"23103":["CWE-400","CWE-703"],"23197":["CWE-476","CWE-703"],"23469":["CWE-416"],"23728":["CWE-125","CWE-787"],"23574":["CWE-399"],"22958":["CWE-787"],"22806":["CWE-400"],"22558":["CWE-125","CWE-369","CWE-787"],"22585":[],"22896":[],"23742":["CWE-200"],"23033":[],"22874":[],"23233":["CWE-401"],"23702":["CWE-119","CWE-681","CWE-787"],"22840":["CWE-200"],"23247":["CWE-120"],"23342":["CWE-416"],"22743":[],"23427":["CWE-399","CWE-835"],"22897":["CWE-276"],"23070":["CWE-476","CWE-284"],"22524":["CWE-190"],"23346":["CWE-125"],"23383":["CWE-787"],"23285":["CWE-20"],"23534":[],"22828":["CWE-200"],"23640":["CWE-399"],"22876":["CWE-310"],"23085":["CWE-415"],"23058":[],"23385":["CWE-125","CWE-787"],"22686":["CWE-787"],"23115":["CWE-200"],"22724":["CWE-787"],"22872":["CWE-190"],"22925":["CWE-416"],"23099":["CWE-287","CWE-284"],"22609":["CWE-787"],"23050":[],"23504":["CWE-200"],"22811":["CWE-200"],"23409":["CWE-476"],"23253":["CWE-787"],"23502":["CWE-20"],"22916":["CWE-122"],"22948":["CWE-416"],"23010":["CWE-416"],"23482":["CWE-416","CWE-703"],"22547":["CWE-476"],"23717":[],"23135":["CWE-212","CWE-326","CWE-61"],"22912":["CWE-330"],"23561":["CWE-264"],"23540":[],"23365":["CWE-17"],"23181":["CWE-787"],"23739":["CWE-20"],"23664":["CWE-787"],"23667":[],"22926":["CWE-119","CWE-125","CWE-703","CWE-787"],"23721":["CWE-119","CWE-787"],"23025":[],"22854":["CWE-416"],"22822":[],"23596":[],"22852":["CWE-345"],"23587":["CWE-416"],"23756":["CWE-703"],"22695":["CWE-20","CWE-476"],"22601":["CWE-200"],"23576":[],"22747":["CWE-125"],"23607":[],"23386":["CWE-787"],"22596":["CWE-20","CWE-703","CWE-770"],"23397":[],"22862":["CWE-20"],"23075":[],"23295":["CWE-415"],"23665":["CWE-476"],"22667":["CWE-362","CWE-476"],"23633":["CWE-125","CWE-787"],"23639":[],"22796":[],"23467":["CWE-125"],"23334":["CWE-415"],"22762":["CWE-476"],"22932":["CWE-617"],"23727":["CWE-190"],"22701":["CWE-119"],"23547":[],"23456":["CWE-200","CWE-787"],"23579":["CWE-78"],"23524":["CWE-295"],"22996":["CWE-269"],"22946":[],"22920":["CWE-20"],"22931":["CWE-399"],"23436":["CWE-399"],"23769":[],"23753":["CWE-200","CWE-787"],"23101":["CWE-20","CWE-787"],"23399":["CWE-200","CWE-319"],"23688":["CWE-119","CWE-284"],"22590":[],"22621":["CWE-399"],"22521":["CWE-284"],"23027":["CWE-310"],"23043":["CWE-264"],"22883":[],"23148":["CWE-670"],"23241":["CWE-190"],"22760":[],"23329":["CWE-200","CWE-119","CWE-787"],"23412":[],"23074":["CWE-120"],"22652":["CWE-190"],"23498":["CWE-667"],"23060":["CWE-125","CWE-787"],"22582":["CWE-399","CWE-119"],"23133":["CWE-787"],"23325":[],"23105":[],"23650":["CWE-330"],"23143":["CWE-787"],"23448":["CWE-787"],"23349":["CWE-362"],"23583":["CWE-200","CWE-732"],"23173":["CWE-476"],"23390":[],"23748":["CWE-617"],"23512":["CWE-399"],"22714":["CWE-862","CWE-285"],"23648":["CWE-119"],"23142":[],"22605":["CWE-125"],"23053":["CWE-78"],"22602":["CWE-125"],"23192":["CWE-476"],"23187":["CWE-203"],"22741":["CWE-362"],"23037":[],"22969":["CWE-189"],"22784":["CWE-20"],"22670":["CWE-416","CWE-703"],"23807":["CWE-787"],"23643":["CWE-119","CWE-787"],"23617":["CWE-476"],"23041":["CWE-281"],"23437":["CWE-254"],"22498":["CWE-787"],"22735":[],"22816":["CWE-399","CWE-264"],"23124":["CWE-94","CWE-787"],"22901":["CWE-362"],"23568":["CWE-770"],"23663":["CWE-125"],"23585":["CWE-125"],"22627":["CWE-119","CWE-369"],"22487":["CWE-399"],"22953":["CWE-416"],"22669":["CWE-119"],"23235":["CWE-284"],"22906":[],"22586":["CWE-119","CWE-787"],"23284":["CWE-125"],"23560":["CWE-703"],"23792":["CWE-400"],"23028":["CWE-476"],"23398":["CWE-284","CWE-264"],"23088":["CWE-476"],"23686":["CWE-125"],"22768":[],"22522":["CWE-284"],"22723":["CWE-400","CWE-401"],"23237":["CWE-476"],"23016":["CWE-416"],"22745":["CWE-119","CWE-787"],"23715":["CWE-125","CWE-787"],"23734":["CWE-190"],"22658":[],"22640":["CWE-284"],"22571":["CWE-416"],"23183":["CWE-190"],"22891":["CWE-200","CWE-755"],"23251":["CWE-835"],"23432":["CWE-190"],"23735":[],"23258":["CWE-416","CWE-125"],"23521":["CWE-190"],"23046":["CWE-703","CWE-189"],"23481":["CWE-125"],"23733":[],"23332":["CWE-125"],"23038":["CWE-416"],"23280":["CWE-190","CWE-787"],"23213":["CWE-416"],"23457":["CWE-415"],"22943":[],"22942":["CWE-787"]},"project":{"22849":"neomutt","22732":"radare2","23384":"tk","23072":"php-src","23710":"openmpt","23202":"linux","22526":"tinygltf","22867":"linux-stable-rt","23426":"php-src","23323":"envoy","23705":"linux","23442":"PackageKit","23623":"linux","23695":"linux","23228":"php-src","23662":"vim","23226":"qemu","22810":"linux","23555":"linux","22801":"soundtouch","23526":"linux","22929":"irssi","23716":"bash","22888":"CImg","23125":"linux","22851":"evolution-ews","23565":"server","22493":"tigervnc","23685":"linux","23231":"atheme","22936":"util-linux","23120":"MilkyTracker","23755":"qpdf","23256":"net","23020":"linux","23392":"nasm","23484":"aircrack-ng","23491":"wesnoth","23047":"dpdk","23313":"curl","23298":"samba","22839":"tar","22800":"linux","23495":"ruby","22607":"httpd","23077":"ceph","23486":"libexpat","22845":"php-src","23762":"wolfssl","22780":"bird","23199":"pjproject","22553":"mysql-wsrep","23775":"php-src","23670":"php-src","23339":"qemu","23515":"mono","23320":"envoy","23679":"ghostpdl","23312":"tigervnc","23683":"linux","22914":"unbound","23509":"firejail","23159":"linux-2.6","23245":"busybox","22964":"linux","23112":"libssh2","22684":"radare2","22624":"pango","23613":"linux","23655":"ceph","22837":"linux","22532":"bpf","23152":"envoy","23543":"linux","23370":"qemu","22941":"FreeRDP","23682":"mongo","23382":"qemu","23776":"linux","23272":"tang","22859":"ldns","23418":"ovs","23254":"linux","23811":"qemu","22773":"linux","23172":"envoy","22656":"gnutls","23759":"ImageMagick","22979":"leptonica","22731":"linux","23048":"net-next","23283":"linux","23445":"linux","22728":"ghostpdl","23227":"mutt","23519":"linux-2.6","23186":"FFmpeg","23188":"linux","22687":"linux-2.6","23055":"linux-2.6","22655":"linux","23022":"mysql-server","22881":"linux","23821":"linux","23802":"linux","22820":"libyang","23026":"libtpms","22654":"gnutls","23632":"gnutls","23080":"lxc","23252":"linux","22676":"linux","22790":"linux-2.6","23741":"bash","22976":"osquery","23684":"fontforge","23808":"envoy","22497":"linux","22779":"linux","23405":"libtpms","23522":"openssl","23406":"openjpeg","23061":"linux","23738":"curl","23161":"dpdk","23758":"tensorflow","23749":"net","22644":"qpdf","23507":"gnome-session","23446":"ncurses","23818":"libxml2","23564":"linux","22680":"linux","23350":"samba","23597":"mujs","23584":"bluez","22683":"fbthrift","22986":"qemu","22868":"linux","23713":"linux-2.6","23626":"ceph","23290":"linux","22968":"tor","23005":"node","22865":"php-src","23554":"qBittorrent","23629":"gpac","23068":"linux","22486":"linux","23609":"linux","22592":"FFmpeg","22873":"linux","22930":"cantata","22591":"net","23168":"bind9","22908":"rsync","23474":"linux","23785":"envoy","23520":"linux","23107":"radare2","22579":"tensorflow","22824":"openssl","23478":"linux","22970":"mongo","23400":"krb5","22856":"linux","23035":"linux","23195":"zstd","23155":"net","22993":"linux","23225":"openthread","23567":"linux","22685":"linux","23236":"linux","22924":"linux","23536":"bdwgc","23586":"linux","23571":"audiofile","22971":"git","22935":"envoy","22671":"qemu","23530":"busybox","22755":"acrn-hypervisor","23018":"rpm","22980":"Fast-DDS","23594":"systemd-stable","23672":"mongo-c-driver-legacy","23743":"linux","23340":"linux","23700":"LibRaw","22690":"linux","22879":"linux","23757":"php-src","23622":"file-roller","22808":"php-src","22995":"linux","23239":"linux","23354":"krb5","22855":"linux","22985":"deark","23281":"mupdf","23190":"linux-2.6","23562":"Little-CMS","22700":"krb5","22515":"linux","23449":"linux","23539":"envoy","22781":"linux","23362":"gpac","23316":"Crow","23428":"gnome-online-accounts","22981":"tensorflow","23559":"vim","22662":"asylo","23618":"libvirt","22850":"ntopng","23127":"folly","23331":"openvpn","23423":"Pillow","23464":"envoy","23518":"qemu-kvm","23019":"net","23276":"openssl","22933":"ext-http","23452":"qemu","22844":"tinyexr","23389":"php-src","22638":"frr","22787":"linux","23243":"php-src","23744":"linux","23180":"util-linux","23287":"linux","22977":"openssl","23108":"linux","23372":"linux","23319":"radare2","23556":"openssl","23472":"linux","22677":"libxml2","22832":"mysql-server","23232":"jdk17u","22635":"irssi","22766":"linux","22682":"ndjbdns","23570":"php-src","23404":"PackageKit","22809":"taglib","23628":"tensorflow","23598":"linux","23147":"gpac","23153":"deark","23590":"ghostpdl","23453":"osquery","23023":"ceph","23788":"libexif","23572":"vim","23078":"linux","23093":"curl","22871":"linux","23179":"libxml2","22966":"spice-vd_agent","23069":"openmpt","23714":"linux","22650":"rizin","23095":"OpenSC","23459":"linux","23262":"bluez","23156":"nautilus","22611":"linux","23261":"opencv","22898":"linux","23175":"pdfresurrect","23160":"linux-2.6","23003":"wesnoth","23083":"radare2","22782":"epiphany","23761":"mupdf","23812":"fontforge","22830":"openssl","23751":"linux","23801":"net","22947":"mysql-server","22620":"re2c","22712":"file","22907":"oniguruma","23240":"patch","22989":"iperf","23681":"linux","23439":"redis","22715":"src","22918":"cups","22799":"linux-2.6","23601":"linux","23322":"linux","23441":"gnupg","23551":"postgres","22786":"re2c","22802":"kopano-core","22922":"android_kernel_xiaomi_msm8996","22765":"polarssl","22485":"linux","22625":"spice","23527":"openenclave","23109":"linux","23424":"linux","22934":"linux-2.6","22769":"radare2","23529":"tor","22711":"ghostpdl","23666":"linux-2.6","23052":"u-boot","23165":"linux","23345":"linux-2.6","22730":"sqlite","22708":"evolution-ews","23462":"tor","23110":"tensorflow","23411":"Little-CMS","22549":"tensorflow","23496":"irssi","23163":"libsndfile","22853":"ImageMagick","23669":"cimg","22519":"libtpms","22754":"linux","22674":"linux","23145":"keepalived","22653":"qemu","23049":"postgres","23725":"linux","22694":"linux-2.6","22716":"rsync","23353":"libxml2","22504":"php-src","23548":"mongo","23326":"ippusbxd","22938":"uwsgi","23581":"linux","23417":"linux","23541":"linux","22499":"linux-2.6","23763":"qpdf","23552":"bash","22910":"envoy","23367":"openjpeg","23754":"qemu","23309":"gvfs","23460":"gpac","23248":"linux","22835":"389-ds-base","22729":"php-src","23196":"openssl","22878":"linux","23687":"firebird","22917":"librsvg","23605":"linux","22475":"libmicrohttpd","22821":"ceph","23463":"libxml2","23510":"radare2","23659":"LibRaw","22937":"systemd","22660":"linux-2.6","23259":"vim","23768":"asylo","22774":"libtiff","23708":"Espruino","22911":"linux","22900":"icu","22663":"stunnel","22641":"net","22564":"openssl","22777":"server","23604":"FFmpeg","22696":"mysql-server","23039":"qemu","23139":"gerbv","23044":"linux","23654":"qemu","23059":"samba","23007":"newsbeuter","23783":"audiofile","23415":"mod_auth_openidc","23573":"linux","23719":"qemu","22842":"njs","23656":"linux","22847":"openssl","22783":"openssl","22736":"ImageMagick","23170":"file-roller","23425":"mysql-server","22636":"arangodb","23154":"vim","22718":"glib-networking","22675":"gpac","22789":"ghostpdl","23493":"openssl","23578":"Fast-DDS","23616":"openenclave","22767":"linux","23234":"FFmpeg","23310":"linux","22647":"qemu","23786":"httpd","23736":"qemu","23420":"linux","22818":"libtiff","23368":"nDPI","23770":"squid","23299":"irssi","23636":"w3m","22594":"net-next","22885":"clamav-devel","23501":"tensorflow","23336":"linux","23537":"libexpat","22719":"linux","22699":"libgd","23257":"server","23158":"libyang","22639":"linux","23813":"linux-2.6","23296":"mongo","23711":"libvpx","23407":"ImageMagick","22890":"openssl","23364":"core","23208":"server","22951":"w3m","23015":"node","22664":"php-src","23201":"postgres","23528":"server","23358":"linux","23314":"ceph","22758":"qemu","23731":"mongo-c-driver-legacy","23269":"openssl","22581":"openssl","23699":"server","23612":"systemd","23098":"optee_os","23422":"mruby","23634":"libming","23328":"envoy","22962":"libgadu","23065":"ZRTPCPP","22814":"php-src","23136":"gpac","23244":"qemu","22659":"ImageMagick","22791":"linux","22507":"bash","23631":"evolution-ews","23599":"kvm","23443":"tor","22877":"cracklib","23121":"mongo","22634":"psutil","23166":"linux","22740":"linux","23661":"linux","23307":"server","22739":"qemu-kvm","22733":"envoy","22950":"file","22939":"linux","22574":"linux","23238":"libxml2","22649":"firejail","22646":"net","22882":"openexr","23207":"libxml2","23209":"libsass","22775":"FreeRDP","23102":"samba","23305":"libvncserver","22763":"cimg","23067":"bluetooth-next","23553":"libreport","22905":"server","23042":"ImageMagick","22698":"radare2","23036":"tcpdump","22559":"libvncserver","23767":"samba","23311":"kvm","23647":"libtiff","23511":"linux-2.6","23450":"qemu","23271":"server","23266":"ncurses","22992":"linux","23489":"mongo-c-driver-legacy","22540":"node","23697":"nghttp2","23505":"ioq3","22529":"linux","23698":"qpdf","23001":"linux-stable","23242":"ovs","22693":"vim","23373":"flatpak","23157":"tip","23137":"vim","23388":"sqlite","22566":"zziplib","23106":"polarssl","22637":"linux","23675":"libssh","22861":"libarchive","22480":"libtpms","23054":"linux","23275":"gcc","23497":"qBittorrent","23149":"openssl","23822":"libxml2","23668":"libxml2","23431":"chrony","23002":"php-src","23533":"linux","23694":"linux","23549":"mysql-server","23619":"linux","23117":"mumble","22909":"linux","22803":"envoy","22864":"linux","22531":"nghttp2","23523":"bdwgc","22643":"Varnish-Cache","23644":"chrony","23347":"user-namespace","22595":"qpdf","23764":"ntp","23602":"server","23797":"mysql-server","23338":"389-ds-base","22761":"linux","23062":"util-linux","22491":"linux","22863":"linux","23140":"linux","22623":"FreeRDP","23722":"Little-CMS","22665":"linux","23012":"linux","23610":"linux","22661":"gnupg","22991":"linux","22944":"mongo","22776":"linux","23575":"LibRaw","23658":"radare2","23348":"exiv2","23071":"OpenSC","23641":"icu","22833":"mongo","23772":"libreport","22838":"linux","22476":"samba","23032":"linux","23773":"linux","22846":"curl","23131":"linux","22710":"jasper","23546":"ImageMagick","23278":"linux-2.6","22819":"frr","23538":"psutil","23084":"libgxps","23760":"linux","23707":"tensorflow","22975":"ntp","23321":"libarchive","23301":"php-src","23215":"src","23614":"linux","22688":"openssl","22681":"curl","22678":"linux","23494":"src","22751":"samba","22642":"ioq3","22753":"nanopb","22972":"Fast-DDS","23356":"radare2","23315":"tensorflow","23337":"openssl","23376":"linux","22988":"suricata","23260":"node","23706":"server","22829":"nautilus","23401":"linux-2.6","22794":"FreeRDP","22984":"net","22994":"poppler","23214":"jasper","23396":"systemd","23031":"linux","23130":"net-next","22606":"linux","23000":"linux-2.6","22720":"net","23297":"server","22815":"linux","23771":"kernel","23490":"linux","23363":"php-src","23778":"FFmpeg","23092":"cups","23306":"libtiff","23637":"thrift","23171":"linux","23222":"mysql-server","22895":"cimg","23653":"librsvg","23263":"vim","22999":"njs","23040":"linux","23146":"linux","22902":"bluez","23729":"src","23580":"samba","22744":"ceph","23223":"spice-vd_agent","22697":"linux","23008":"mongo-c-driver-legacy","23517":"linux","22834":"389-ds-base","23642":"asylo","23249":"openssl","23182":"qemu","23079":"CImg","23063":"ruby","23091":"linux","22778":"ceph","23355":"gnome-settings-daemon","23333":"poppler","23378":"libcomps","23419":"php-src","23466":"FreeRDP","23451":"bash","23268":"libyang","22746":"samba","23292":"sqlite","22886":"ceph","22827":"php-src","23692":"php-src","23351":"linux","23558":"linux","22727":"linux","23651":"linux","23488":"krb5","23440":"cpio","22919":"ImageMagick","23774":"cpython","22771":"php-src","22536":"linux","22750":"envoy","22945":"httpd","22788":"node","23361":"php-src","23134":"LibRaw","22757":"samba","23726":"linux","23104":"libvirt","23782":"iperf","22825":"linux-stable-rt","23303":"gpac","22875":"gpac","23657":"php-src","22973":"mod_auth_openidc","23447":"LibRaw","23128":"ImageMagick","23673":"linux","23678":"server","23289":"postgres","23167":"file","23132":"rizin","23200":"jdk17u","23624":"mysql-server","22651":"linux-2.6","22841":"ghostpdl","22956":"audiofile","22959":"linux-2.6","23606":"mysql-server","23514":"envoy","23191":"linux","23800":"krb5","23566":"mutt","23300":"qemu","22792":"gpac","23360":"cpython","22798":"linux","23277":"ghostpdl","23051":"linux","23513":"php-src","23603":"tip","23302":"linux","22703":"linux","23090":"linux","23210":"glib","23379":"ghostpdl","23374":"linux","23089":"inspircd","23479":"server","22567":"qemu","22848":"cpp-peglib","22748":"tensorflow","23798":"linux","22974":"icu","23732":"samba","22713":"slurm","22923":"cpython","22858":"linux-2.6","23473":"tensorflow","23784":"librepo","23608":"FFmpeg","23591":"vim","23635":"linux","23189":"netmask","23430":"gdm","23129":"tensorflow","23294":"openssl","22887":"user-namespace","23816":"gpac","23645":"exiv2","23267":"squashfs-tools","22704":"qpdf","22583":"openssl","22481":"qpdf","23611":"linux-2.6","23096":"radare2","23375":"amanda","22734":"tcpdump","23366":"mysql-wsrep","23408":"linux","23185":"njs","23689":"qpdf","23703":"linux","22889":"bash","23205":"mujs","23569":"ImageMagick6","23480":"tensorflow","23395":"samba","23006":"electron","22706":"unbound","23391":"linux","23017":"libarchive","23021":"tip","23674":"linux","23535":"njs","23410":"oniguruma","23184":"cimg","23544":"brotli","22961":"qemu","23011":"ImageMagick6","23765":"cronie","22860":"linux-2.6","22737":"js-compute-runtime","22726":"graphviz","22707":"gpac","23279":"CImg","22823":"mono","23525":"FFmpeg","23250":"botan","22949":"libxml2","22608":"unbound","22869":"mod_h2","22982":"gdk-pixbuf","23690":"network-manager-applet","23413":"linux-2.6","22965":"network-manager-applet","23476":"ncurses","23747":"linux","23013":"php-src","23004":"linux-2.6","23577":"pjproject","23111":"linux-2.6","23458":"linux","22797":"flatpak","23563":"screen","23352":"miniupnp","23433":"mongo","23696":"pure-ftpd","22668":"libvirt","23485":"linux","22721":"linux","23274":"libyang","22666":"libjpeg-turbo","23304":"php-src","23308":"linux","23652":"linux","23421":"mongo","23380":"linux","23532":"radare2","22807":"linux","23435":"linux","23359":"openssl","23676":"gnutls","22813":"vim","22880":"iperf","22892":"sqlite","23429":"FreeRDP","22793":"server","22513":"linux","22983":"libarchive","23582":"bdwgc","23194":"qemu-kvm","23393":"qemu","22963":"openldap","22954":"systemd","23341":"wangle","23034":"linux","22514":"spice-vd_agent","23454":"squid","23402":"ghostpdl","23126":"connman","23557":"jasper","22826":"gpac","22843":"mujs","23471":"gnuplot","23288":"tip","23545":"nf","22913":"linux","22691":"ImageMagick","23119":"rsyslog","23087":"cups","23627":"php-src","23779":"mongo-c-driver-legacy","23444":"mysql-server","23470":"envoy","23461":"linux","22955":"openssl","22921":"quassel","23750":"systemd","23475":"jasper","23787":"linux","22672":"linux","23009":"openssl","23076":"jasper","23780":"libgit2","23589":"gnutls","23198":"openssl","23246":"linux-2.6","23506":"server","23625":"libheif","23487":"tk","23335":"cimg","23086":"linux","23057":"linux-stable","22759":"mysql-server","22978":"mongo","23592":"linux-stable","23123":"linux","23100":"linux","22618":"tensorflow","23291":"sqlite","23024":"net","23029":"openssl","23114":"gpac","22998":"gpac","22738":"linux","23330":"spice-common","22893":"cgminer","22705":"linux","23745":"cimg","23600":"FreeRDP","22940":"gpac","23503":"harfbuzz","22997":"envoy","23746":"ntfs-3g","23014":"ncurses","22717":"linux","23720":"libzmq","23766":"linux","23646":"cpython","23730":"libvncserver","22484":"php-src","22673":"linux","22987":"libtpms","23270":"radare2","23671":"gnupg","22709":"gnupg","23740":"jerryscript","23638":"linux","22804":"systemd-stable","22770":"zziplib","23438":"tensorflow","23781":"redis","23492":"util-linux","23344":"bpf","23691":"redis","23264":"core","22545":"linux","23737":"keepalived","22542":"mongo-c-driver-legacy","22657":"FreeRDP","23206":"php-src","23468":"ncurses","23255":"jasper","23477":"FreeRDP","23483":"linux-2.6","22870":"linux","23150":"linux","22488":"Little-CMS","23357":"libsass","23550":"linux","23343":"openssl","22597":"server","23144":"electron","23371":"linux","22689":"pango","22927":"curl","23414":"qemu","22899":"pure-ftpd","23204":"wireshark","23216":"frr","23151":"sqlite","22562":"sudo","22812":"linux","22764":"tpm","23203":"linux","23516":"libssh","23796":"gcc","23164":"open62541","23724":"qpdf","22530":"linux","22512":"linux","23064":"ovs","23056":"net-next","23082":"media_tree","22679":"upx","22752":"libarchive","23066":"json","22795":"chrony","23221":"qpdf","23081":"linux","23387":"openenclave","23212":"FreeRDP","23122":"Pillow","23073":"coreboot","23455":"linux-2.6","22960":"net","23465":"php-src","23693":"server","23777":"libuv","23712":"fizz","23416":"linux-2.6","22990":"linux","23595":"libarchive","23499":"tip","23141":"php-src","22805":"kvm","23791":"avahi","23097":"unbound","23193":"linux","23045":"linux","23229":"linux","23113":"linux","23704":"fontforge","23324":"postgres","22722":"radare2","22692":"tip","22915":"frr","23218":"tsMuxer","23282":"mysql-server","23162":"ghostpdl","22817":"linux","23593":"linux","23217":"net","22831":"gpac","23752":"libtpms","23630":"openexr","22523":"gnome-session","23094":"linux","23394":"node","22560":"FFmpeg","23434":"cyrus-imapd","23030":"linux","23531":"linux","23542":"envoy","22725":"thrift","23327":"squid","22884":"qpdf","22742":"zziplib","22472":"gpac","22957":"tensorflow","22568":"tcpdump","23795":"tar","22866":"qemu","23230":"openssl","23660":"linux","23177":"qemu","22580":"gdk-pixbuf","23500":"qpdf","23677":"libming","23508":"mysql-server","23138":"envoy","22904":"linux","23615":"frr","23211":"cifs-utils","23286":"varnish-modules","22648":"samba","23318":"linux","23620":"libjpeg-turbo","23116":"linux","23169":"envoy","23273":"quagga","22903":"linux","23317":"qemu","22785":"linux","23709":"linux","23680":"linux","23220":"mongo","22894":"vim","22749":"libvirt","22563":"linux","23649":"libvncserver","23403":"linux","23219":"linux","22702":"cimg","22772":"net","23369":"linux","22836":"yara","23224":"gpac","23381":"trafficserver","22857":"qemu","23265":"poco","22756":"FreeRDP","22572":"linux-2.6","23377":"keepalived","22928":"linux","23588":"electron","23118":"libssh2","23293":"openjpeg","23178":"linux","23701":"linux","22967":"util-linux","22645":"cyrus-imapd","23621":"cgal","22952":"linux","23174":"linux","22610":"libtpms","23176":"htmldoc","23723":"linux","23824":"cimg","23718":"libvncserver","23103":"radare2","23197":"envoy","23469":"php-src","23728":"dpdk","23574":"linux-2.6","22958":"vim","22806":"mod_h2","22558":"gpmf-parser","22585":"linux","22896":"linux-2.6","23742":"botan","23033":"gnome-screensaver","22874":"electron","23233":"wireshark","23702":"linux","22840":"network-manager-applet","23247":"server","23342":"perl5","22743":"net","23427":"linux","22897":"gpac","23070":"linux","22524":"iipsrv","23346":"exiv2","23383":"openjpeg","23285":"gdk-pixbuf","23534":"linux-2.6","22828":"samba","23640":"samba","22876":"libgadu","23085":"psutil","23058":"linux-2.6","23385":"tensorflow","22686":"LIEF","23115":"linux","22724":"c-shquote","22872":"linux-stable","22925":"systemd","23099":"linux","22609":"libtpms","23050":"tor","23504":"linux-2.6","22811":"linux","23409":"sqlite","23253":"cairo","23502":"libvpx","22916":"vim","22948":"vim","23010":"linux","23482":"server","22547":"FreeRDP","23717":"libxslt","23135":"at91bootstrap","22912":"linux","23561":"linux-2.6","23540":"nfdump","23365":"linux-stable","23181":"virglrenderer","23739":"linux","23664":"linux","23667":"open-vm-tools","22926":"rdesktop","23721":"FFmpeg","23025":"linux","22854":"php-src","22822":"ldns","23596":"gdm","22852":"cryptsetup","23587":"ovs","23756":"LibRaw","22695":"tensorflow","22601":"incubator-doris","23576":"bash","22747":"qemu","23607":"iproute2","23386":"libjpeg-turbo","22596":"libpcap","23397":"linux-2.6","22862":"libtorrent","23075":"linux","23295":"libyang","23665":"graphite","22667":"linux","23633":"tensorflow","23639":"tor","22796":"virglrenderer","23467":"squirrel","23334":"krb5","22762":"linux","22932":"server","23727":"php-src","22701":"gnutls","23547":"librsvg","23456":"FreeRDP","23579":"vim","23524":"evolution-ews","22996":"systemd","22946":"quassel","22920":"php-src","22931":"openssl","23436":"linux","23769":"libssh","23753":"FreeRDP","23101":"tigervnc","23399":"linux","23688":"linux","22590":"qemu-kvm","22621":"qemu","22521":"linux","23027":"gnutls","23043":"postgres","22883":"Little-CMS","23148":"poppler","23241":"linux","22760":"php-src","23329":"linux","23412":"librsvg","23074":"server","22652":"mongo-c-driver-legacy","23498":"linux","23060":"tcpdump","22582":"linux","23133":"linux","23325":"librsvg","23105":"libssh","23650":"linux","23143":"linux","23448":"libtpms","23349":"linux","23583":"zfs","23173":"linux","23390":"gvfs","23748":"server","23512":"libxml2","22714":"linux","23648":"libxml2","23142":"php-src","22605":"FreeRDP","23053":"radare2","22602":"php-src","23192":"mujs","23187":"openssl","22741":"linux","23037":"nghttp2","22969":"grep","22784":"linux","22670":"linux","23807":"radare2","23643":"CImg","23617":"vim","23041":"qemu","23437":"ntopng","22498":"qemu","22735":"linux-2.6","22816":"mono","23124":"xorg-xserver","22901":"linux-2.6","23568":"cimg","23663":"CImg","23585":"libxml2","22627":"unixODBC","22487":"openssl","22953":"ImageMagick","22669":"linux","23235":"Pillow","22906":"jdk17u","22586":"FFmpeg","23284":"openexr","23560":"server","23792":"ovs","23028":"libetpan","23398":"linux","23088":"linux","23686":"php-src","22768":"linux","22522":"cups","22723":"linux","23237":"unicorn","23016":"server","22745":"das_watchdog","23715":"dpdk","23734":"qemu","22658":"poppler","22640":"libndp","22571":"Crow","23183":"ImageMagick6","22891":"acpica","23251":"qemu","23432":"ImageMagick","23735":"dpdk","23258":"linux","23521":"php-src","23046":"linux","23481":"cpp-peglib","23733":"gdm","23332":"OpenSC","23038":"jerryscript","23280":"png-img","23213":"ntp","23457":"net-snmp","22943":"poppler","22942":"re2c"},"size":{"22849":13,"22732":32,"23384":16,"23072":44,"23710":61,"23202":39,"22526":15,"22867":53,"23426":35,"23323":36,"23705":25,"23442":10,"23623":14,"23695":37,"23228":32,"23662":48,"23226":19,"22810":19,"23555":63,"22801":19,"23526":51,"22929":23,"23716":51,"22888":1,"23125":70,"22851":37,"23565":6,"22493":3,"23685":12,"23231":16,"22936":11,"23120":7,"23755":22,"23256":108,"23020":15,"23392":17,"23484":16,"23491":21,"23047":11,"23313":24,"23298":23,"22839":33,"22800":8,"23495":11,"22607":45,"23077":25,"23486":7,"22845":24,"23762":8,"22780":17,"23199":42,"22553":44,"23775":40,"23670":4,"23339":56,"23515":10,"23320":23,"23679":13,"23312":10,"23683":43,"22914":59,"23509":27,"23159":5,"23245":9,"22964":13,"23112":94,"22684":62,"22624":26,"23613":22,"23655":25,"22837":33,"22532":4,"23152":4,"23543":21,"23370":4,"22941":63,"23682":46,"23382":23,"23776":25,"23272":4,"22859":39,"23418":24,"23254":67,"23811":28,"22773":64,"23172":4,"22656":16,"23759":156,"22979":30,"22731":54,"23048":45,"23283":6,"23445":29,"22728":22,"23227":9,"23519":18,"23186":8,"23188":11,"22687":29,"23055":4,"22655":70,"23022":119,"22881":45,"23821":72,"23802":4,"22820":89,"23026":28,"22654":19,"23632":63,"23080":49,"23252":5,"22676":14,"22790":15,"23741":35,"22976":44,"23684":18,"23808":19,"22497":14,"22779":71,"23405":19,"23522":64,"23406":94,"23061":23,"23738":10,"23161":44,"23758":7,"23749":60,"22644":9,"23507":24,"23446":82,"23818":57,"23564":51,"22680":8,"23350":7,"23597":34,"23584":11,"22683":3,"22986":17,"22868":7,"23713":55,"23626":8,"23290":30,"22968":7,"23005":6,"22865":24,"23554":36,"23629":16,"23068":8,"22486":29,"23609":4,"22592":31,"22873":13,"22930":77,"22591":33,"23168":13,"22908":7,"23474":13,"23785":2,"23520":35,"23107":26,"22579":32,"22824":63,"23478":30,"22970":12,"23400":33,"22856":6,"23035":115,"23195":23,"23155":74,"22993":53,"23225":9,"23567":31,"22685":24,"23236":97,"22924":17,"23536":17,"23586":88,"23571":13,"22971":6,"22935":69,"22671":9,"23530":47,"22755":53,"23018":10,"22980":21,"23594":33,"23672":44,"23743":6,"23340":23,"23700":22,"22690":26,"22879":71,"23757":24,"23622":44,"22808":10,"22995":5,"23239":45,"23354":12,"22855":9,"22985":5,"23281":42,"23190":22,"23562":7,"22700":48,"22515":11,"23449":18,"23539":28,"22781":18,"23362":66,"23316":19,"23428":73,"22981":49,"23559":4,"22662":36,"23618":41,"22850":10,"23127":5,"23331":14,"23423":34,"23464":1,"23518":8,"23019":6,"23276":22,"22933":40,"23452":67,"22844":44,"23389":12,"22638":57,"22787":12,"23243":36,"23744":52,"23180":4,"23287":6,"22977":12,"23108":15,"23372":14,"23319":4,"23556":17,"23472":11,"22677":36,"22832":13,"23232":18,"22635":34,"22766":36,"22682":12,"23570":85,"23404":28,"22809":26,"23628":35,"23598":21,"23147":42,"23153":5,"23590":45,"23453":21,"23023":8,"23788":9,"23572":10,"23078":10,"23093":10,"22871":13,"23179":15,"22966":68,"23069":25,"23714":44,"22650":7,"23095":63,"23459":16,"23262":47,"23156":9,"22611":31,"23261":27,"22898":8,"23175":40,"23160":27,"23003":21,"23083":22,"22782":6,"23761":15,"23812":34,"22830":58,"23751":4,"23801":37,"22947":96,"22620":34,"22712":55,"22907":24,"23240":5,"22989":4,"23681":6,"23439":21,"22715":23,"22918":30,"22799":14,"23601":36,"23322":87,"23441":6,"23551":53,"22786":4,"22802":7,"22922":20,"22765":11,"22485":6,"22625":42,"23527":14,"23109":22,"23424":26,"22934":39,"22769":19,"23529":19,"22711":22,"23666":36,"23052":37,"23165":8,"23345":18,"22730":34,"22708":102,"23462":16,"23110":55,"23411":7,"22549":18,"23496":20,"23163":36,"22853":22,"23669":3,"22519":25,"22754":18,"22674":35,"23145":22,"22653":17,"23049":10,"23725":83,"22694":60,"22716":22,"23353":10,"22504":10,"23548":34,"23326":50,"22938":4,"23581":35,"23417":4,"23541":14,"22499":21,"23763":15,"23552":11,"22910":1,"23367":47,"23754":20,"23309":23,"23460":39,"23248":9,"22835":10,"22729":21,"23196":4,"22878":19,"23687":3,"22917":15,"23605":7,"22475":15,"22821":9,"23463":16,"23510":13,"23659":20,"22937":33,"22660":4,"23259":14,"23768":4,"22774":43,"23708":59,"22911":26,"22900":4,"22663":8,"22641":8,"22564":52,"22777":11,"23604":32,"22696":83,"23039":6,"23139":21,"23044":13,"23654":40,"23059":16,"23007":12,"23783":53,"23415":47,"23573":17,"23719":5,"22842":32,"23656":10,"22847":71,"22783":21,"22736":28,"23170":16,"23425":3,"22636":23,"23154":8,"22718":7,"22675":31,"22789":58,"23493":65,"23578":9,"23616":38,"22767":43,"23234":49,"23310":45,"22647":53,"23786":32,"23736":7,"23420":10,"22818":6,"23368":3,"23770":18,"23299":32,"23636":18,"22594":32,"22885":12,"23501":5,"23336":83,"23537":28,"22719":27,"22699":53,"23257":52,"23158":60,"22639":40,"23813":17,"23296":5,"23711":33,"23407":4,"22890":56,"23364":30,"23208":26,"22951":14,"23015":20,"22664":32,"23201":71,"23528":16,"23358":19,"23314":1,"22758":26,"23731":15,"23269":71,"22581":53,"23699":1,"23612":21,"23098":58,"23422":33,"23634":12,"23328":9,"22962":78,"23065":3,"22814":83,"23136":13,"23244":18,"22659":57,"22791":22,"22507":79,"23631":51,"23599":39,"23443":19,"22877":22,"23121":3,"22634":34,"23166":9,"22740":15,"23661":34,"23307":47,"22739":33,"22733":21,"22950":20,"22939":5,"22574":22,"23238":22,"22649":24,"22646":15,"22882":6,"23207":48,"23209":6,"22775":88,"23102":4,"23305":53,"22763":4,"23067":13,"23553":15,"22905":2,"23042":106,"22698":14,"23036":61,"22559":14,"23767":13,"23311":24,"23647":15,"23511":8,"23450":68,"23271":49,"23266":46,"22992":3,"23489":6,"22540":8,"23697":5,"23505":13,"22529":79,"23698":10,"23001":9,"23242":80,"22693":9,"23373":43,"23157":4,"23137":52,"23388":3,"22566":2,"23106":11,"22637":5,"23675":14,"22861":9,"22480":6,"23054":41,"23275":27,"23497":16,"23149":27,"23822":35,"23668":60,"23431":18,"23002":4,"23533":9,"23694":8,"23549":6,"23619":13,"23117":18,"22909":36,"22803":44,"22864":9,"22531":33,"23523":8,"22643":39,"23644":29,"23347":6,"22595":11,"23764":27,"23602":80,"23797":7,"23338":8,"22761":79,"23062":16,"22491":28,"22863":37,"23140":16,"22623":55,"23722":55,"22665":38,"23012":18,"23610":4,"22661":19,"22991":4,"22944":3,"22776":9,"23575":50,"23658":40,"23348":12,"23071":70,"23641":3,"22833":37,"23772":16,"22838":14,"22476":39,"23032":35,"23773":7,"22846":7,"23131":5,"22710":51,"23546":64,"23278":3,"22819":28,"23538":60,"23084":66,"23760":40,"23707":5,"22975":60,"23321":63,"23301":20,"23215":20,"23614":5,"22688":15,"22681":40,"22678":106,"23494":8,"22751":14,"22642":37,"22753":63,"22972":61,"23356":64,"23315":44,"23337":5,"23376":34,"22988":43,"23260":3,"23706":10,"22829":66,"23401":5,"22794":20,"22984":48,"22994":41,"23214":109,"23396":85,"23031":4,"23130":5,"22606":54,"23000":7,"22720":43,"23297":59,"22815":5,"23771":18,"23490":20,"23363":80,"23778":7,"23092":27,"23306":13,"23637":47,"23171":14,"23222":83,"22895":3,"23653":9,"23263":78,"22999":23,"23040":26,"23146":31,"22902":28,"23729":17,"23580":35,"22744":3,"23223":19,"22697":16,"23008":21,"23517":34,"22834":4,"23642":33,"23249":63,"23182":43,"23079":3,"23063":5,"23091":25,"22778":4,"23355":15,"23333":2,"23378":38,"23419":18,"23466":41,"23451":5,"23268":15,"22746":79,"23292":10,"22886":6,"22827":41,"23692":50,"23351":21,"23558":20,"22727":17,"23651":6,"23488":36,"23440":56,"22919":83,"23774":43,"22771":9,"22536":19,"22750":37,"22945":6,"22788":34,"23361":35,"23134":45,"22757":63,"23726":70,"23104":14,"23782":14,"22825":24,"23303":37,"22875":11,"23657":25,"22973":60,"23447":59,"23128":10,"23673":7,"23678":18,"23289":11,"23167":28,"23132":65,"23200":52,"23624":14,"22651":7,"22841":22,"22956":15,"22959":46,"23606":71,"23514":3,"23191":5,"23800":17,"23566":41,"23300":57,"22792":12,"23360":28,"22798":15,"23277":50,"23051":42,"23513":17,"23603":12,"23302":46,"22703":30,"23090":8,"23210":13,"23379":6,"23374":84,"23089":13,"23479":6,"22567":27,"22848":16,"22748":24,"23798":4,"22974":51,"23732":56,"22713":4,"22923":26,"22858":6,"23473":22,"23784":12,"23608":27,"23591":4,"23635":20,"23189":12,"23430":35,"23129":36,"23294":31,"22887":11,"23816":8,"23645":30,"23267":47,"22704":4,"22583":89,"22481":15,"23611":74,"23096":18,"23375":67,"22734":80,"23366":16,"23408":68,"23185":30,"23689":5,"23703":25,"22889":5,"23205":13,"23569":116,"23480":6,"23395":6,"23006":5,"22706":12,"23391":47,"23017":51,"23021":14,"23674":3,"23535":50,"23410":78,"23184":7,"23544":35,"22961":11,"23011":15,"23765":97,"22860":56,"22737":4,"22726":44,"22707":12,"23279":1,"22823":64,"23525":74,"23250":10,"22949":27,"22608":37,"22869":56,"22982":36,"23690":71,"23413":56,"22965":36,"23476":17,"23747":5,"23013":51,"23004":14,"23577":46,"23111":21,"23458":21,"22797":10,"23563":13,"23352":15,"23433":3,"23696":45,"22668":17,"23485":20,"22721":9,"23274":63,"22666":19,"23304":16,"23308":8,"23652":21,"23421":29,"23380":27,"23532":3,"22807":61,"23435":79,"23359":168,"23676":62,"22813":31,"22880":7,"22892":37,"23429":28,"22793":7,"22513":18,"22983":17,"23582":46,"23194":4,"23393":6,"22963":70,"22954":45,"23341":46,"23034":22,"22514":8,"23454":6,"23402":42,"23126":59,"23557":20,"22826":4,"22843":21,"23471":6,"23288":3,"23545":18,"22913":19,"22691":22,"23119":4,"23087":14,"23627":20,"23779":5,"23444":14,"23470":59,"23461":50,"22955":64,"22921":13,"23750":7,"23475":20,"23787":10,"22672":39,"23009":68,"23076":32,"23780":69,"23589":48,"23198":51,"23246":94,"23506":4,"23625":10,"23487":33,"23335":3,"23086":34,"23057":26,"22759":16,"22978":3,"23592":23,"23123":22,"23100":47,"22618":10,"23291":18,"23024":34,"23029":25,"23114":8,"22998":16,"22738":94,"23330":73,"22893":49,"22705":44,"23745":4,"23600":7,"22940":4,"23503":7,"22997":1,"23746":60,"23014":25,"22717":5,"23720":38,"23766":15,"23646":7,"23730":6,"22484":27,"22673":78,"22987":6,"23270":22,"23671":19,"22709":88,"23740":40,"23638":11,"22804":33,"22770":30,"23438":34,"23781":33,"23492":4,"23344":29,"23691":7,"23264":37,"22545":56,"23737":12,"22542":43,"22657":36,"23206":6,"23468":33,"23255":22,"23477":8,"23483":24,"22870":51,"23150":15,"22488":55,"23357":15,"23550":15,"23343":48,"22597":37,"23144":16,"23371":6,"22689":13,"22927":28,"23414":43,"22899":63,"23204":51,"23216":14,"23151":13,"22562":77,"22812":6,"22764":33,"23203":4,"23516":43,"23796":7,"23164":11,"23724":5,"22530":21,"22512":13,"23064":5,"23056":5,"23082":31,"22679":16,"22752":40,"23066":7,"22795":35,"23221":13,"23081":4,"23387":7,"23212":78,"23122":18,"23073":21,"23455":4,"22960":76,"23465":15,"23693":3,"23777":79,"23712":51,"23416":18,"22990":10,"23595":58,"23499":34,"23141":38,"22805":5,"23791":19,"23097":30,"23193":56,"23045":30,"23229":36,"23113":89,"23704":16,"23324":26,"22722":66,"22692":34,"22915":12,"23218":24,"23282":44,"23162":50,"22817":50,"23593":29,"23217":75,"22831":5,"23752":32,"23630":92,"22523":19,"23094":57,"23394":47,"22560":31,"23434":23,"23030":54,"23531":11,"23542":11,"22725":10,"23327":35,"22884":5,"22742":3,"22472":46,"22957":13,"22568":22,"23795":11,"22866":4,"23230":53,"23660":11,"23177":31,"22580":26,"23500":5,"23677":7,"23508":2,"23138":6,"22904":24,"23615":14,"23211":85,"23286":21,"22648":48,"23318":7,"23620":4,"23116":73,"23169":20,"23273":26,"22903":18,"23317":7,"22785":25,"23709":17,"23680":5,"23220":14,"22894":24,"22749":53,"22563":12,"23649":26,"23403":50,"23219":6,"22702":23,"22772":38,"23369":47,"22836":9,"23224":7,"23381":47,"22857":25,"23265":12,"22756":18,"22572":18,"23377":29,"22928":57,"23588":7,"23118":23,"23293":5,"23178":5,"23701":18,"22967":27,"22645":74,"23621":27,"22952":37,"23174":31,"22610":20,"23176":37,"23723":67,"23824":6,"23718":6,"23103":7,"23197":13,"23469":8,"23728":23,"23574":39,"22958":63,"22806":21,"22558":19,"22585":13,"22896":6,"23742":8,"23033":50,"22874":11,"23233":6,"23702":27,"22840":23,"23247":8,"23342":28,"22743":27,"23427":12,"22897":16,"23070":30,"22524":31,"23346":28,"23383":8,"23285":32,"23534":60,"22828":74,"23640":9,"22876":23,"23085":58,"23058":32,"23385":21,"22686":3,"23115":34,"22724":24,"22872":16,"22925":12,"23099":9,"22609":32,"23050":13,"23504":22,"22811":9,"23409":13,"23253":5,"23502":1,"22916":32,"22948":21,"23010":31,"23482":1,"22547":5,"23717":37,"23135":43,"22912":13,"23561":44,"23540":57,"23365":20,"23181":4,"23739":19,"23664":6,"23667":43,"22926":53,"23721":5,"23025":70,"22854":71,"22822":4,"23596":36,"22852":48,"23587":62,"23756":6,"22695":61,"22601":15,"23576":11,"22747":68,"23607":4,"23386":21,"22596":21,"23397":4,"22862":41,"23075":9,"23295":11,"23665":5,"22667":7,"23633":38,"23639":18,"22796":23,"23467":47,"23334":40,"22762":31,"22932":1,"23727":15,"22701":54,"23547":37,"23456":45,"23579":8,"23524":25,"22996":22,"22946":19,"22920":28,"22931":11,"23436":68,"23769":3,"23753":53,"23101":10,"23399":35,"23688":12,"22590":6,"22621":11,"22521":18,"23027":4,"23043":16,"22883":31,"23148":11,"23241":34,"22760":14,"23329":56,"23412":4,"23074":14,"22652":14,"23498":7,"23060":9,"22582":45,"23133":14,"23325":15,"23105":16,"23650":13,"23143":6,"23448":26,"23349":23,"23583":4,"23173":39,"23390":18,"23748":5,"23512":19,"22714":82,"23648":53,"23142":9,"22605":71,"23053":3,"22602":54,"23192":21,"23187":23,"22741":15,"23037":1,"22969":34,"22784":21,"22670":5,"23807":11,"23643":7,"23617":15,"23041":25,"23437":7,"22498":40,"22735":4,"22816":12,"23124":56,"22901":15,"23568":1,"23663":9,"23585":32,"22627":27,"22487":8,"22953":7,"22669":1,"23235":23,"22906":4,"22586":50,"23284":4,"23560":25,"23792":58,"23028":57,"23398":9,"23088":6,"23686":4,"22768":5,"22522":15,"22723":9,"23237":10,"23016":82,"22745":16,"23715":29,"23734":30,"22658":1,"22640":6,"22571":8,"23183":102,"22891":16,"23251":31,"23432":4,"23735":35,"23258":16,"23521":37,"23046":38,"23481":2,"23733":17,"23332":52,"23038":103,"23280":5,"23213":25,"23457":7,"22943":15,"22942":4}}