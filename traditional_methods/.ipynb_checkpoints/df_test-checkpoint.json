{"_id":{"24286":{"$oid":"6527b17999826ba7e58ebd4c"},"24372":{"$oid":"6527b2c499826ba7e592f60d"},"24726":{"$oid":"6527b1ea99826ba7e5900fe3"},"24716":{"$oid":"6527b2b199826ba7e592ab24"},"25001":{"$oid":"6527b18899826ba7e58edae0"},"24168":{"$oid":"6527b28799826ba7e59213f7"},"25019":{"$oid":"6527b23f99826ba7e59116e6"},"25030":{"$oid":"6527b1b399826ba7e58f4fec"},"24386":{"$oid":"6527b2ae99826ba7e592a060"},"24700":{"$oid":"6527b19599826ba7e58ef244"},"24181":{"$oid":"6527b17599826ba7e58eb623"},"24263":{"$oid":"6527b19399826ba7e58eee5f"},"24079":{"$oid":"6527b19799826ba7e58ef624"},"23839":{"$oid":"6527b2a899826ba7e5928647"},"24094":{"$oid":"6527b24a99826ba7e5913f6e"},"24334":{"$oid":"6527b23b99826ba7e59109e4"},"24469":{"$oid":"6527b1f699826ba7e5903419"},"24054":{"$oid":"6527b17a99826ba7e58ec38d"},"24115":{"$oid":"6527b18d99826ba7e58ee32d"},"24972":{"$oid":"6527b18699826ba7e58ed812"},"24542":{"$oid":"6527b2a699826ba7e5927a72"},"24492":{"$oid":"6527b17999826ba7e58ebef9"},"24018":{"$oid":"6527b18b99826ba7e58edd60"},"24935":{"$oid":"6527b2a599826ba7e59276bb"},"23850":{"$oid":"6527b20599826ba7e5906683"},"24766":{"$oid":"6527b25899826ba7e5916e33"},"24890":{"$oid":"6527b1a899826ba7e58f2e95"},"24322":{"$oid":"6527b1de99826ba7e58fe568"},"24656":{"$oid":"6527b23199826ba7e590ebb8"},"24304":{"$oid":"6527b23399826ba7e590f06c"},"24791":{"$oid":"6527b1fa99826ba7e590442b"},"23810":{"$oid":"6527b18f99826ba7e58ee4f6"},"25034":{"$oid":"6527b1e299826ba7e58ff25f"},"24147":{"$oid":"6527b19799826ba7e58ef46d"},"24657":{"$oid":"6527b24999826ba7e5913c23"},"24294":{"$oid":"6527b26099826ba7e5918e52"},"24669":{"$oid":"6527b2bc99826ba7e592d6fe"},"25014":{"$oid":"6527b2eb99826ba7e59381f4"},"24526":{"$oid":"6527b18899826ba7e58edb2d"},"24881":{"$oid":"6527b2e199826ba7e5936375"},"24361":{"$oid":"6527b19399826ba7e58eefa4"},"24830":{"$oid":"6527b19799826ba7e58ef643"},"23957":{"$oid":"6527b29399826ba7e5923b78"},"24977":{"$oid":"6527b18f99826ba7e58ee63f"},"23959":{"$oid":"6527b17599826ba7e58eb8f3"},"24601":{"$oid":"6527b17c99826ba7e58ec667"},"24853":{"$oid":"6527b18d99826ba7e58ee0e8"},"25008":{"$oid":"6527b29399826ba7e59239f9"},"24424":{"$oid":"6527b2b099826ba7e592a6a8"},"24443":{"$oid":"6527b18699826ba7e58ed7ce"},"25026":{"$oid":"6527b20f99826ba7e5908295"},"24360":{"$oid":"6527b17a99826ba7e58ec24d"},"24615":{"$oid":"6527b2ab99826ba7e5929425"},"25028":{"$oid":"6527b2b899826ba7e592c7e7"},"24130":{"$oid":"6527b1bc99826ba7e58f6e06"},"24060":{"$oid":"6527b1a499826ba7e58f222a"},"24275":{"$oid":"6527b2cf99826ba7e5931c82"},"24023":{"$oid":"6527b1e599826ba7e58ffe39"},"24996":{"$oid":"6527b29099826ba7e59231e9"},"24874":{"$oid":"6527b17399826ba7e58eb34f"},"24759":{"$oid":"6527b27b99826ba7e591ec9c"},"24172":{"$oid":"6527b18899826ba7e58edb18"},"24227":{"$oid":"6527b17399826ba7e58eb1ce"},"24765":{"$oid":"6527b19799826ba7e58ef4da"},"25012":{"$oid":"6527b18699826ba7e58ed78c"},"24110":{"$oid":"6527b2be99826ba7e592dd71"},"24341":{"$oid":"6527b1c099826ba7e58f7db1"},"24069":{"$oid":"6527b18d99826ba7e58ee0fe"},"24327":{"$oid":"6527b21599826ba7e590986d"},"24897":{"$oid":"6527b19199826ba7e58eea60"},"24406":{"$oid":"6527b1dc99826ba7e58fdaa6"},"24563":{"$oid":"6527b19799826ba7e58ef598"},"24423":{"$oid":"6527b1f699826ba7e5903567"},"24453":{"$oid":"6527b2bc99826ba7e592d332"},"24290":{"$oid":"6527b19399826ba7e58eef17"},"24461":{"$oid":"6527b18899826ba7e58ed901"},"24148":{"$oid":"6527b17799826ba7e58ebb9b"},"24950":{"$oid":"6527b19399826ba7e58eed75"},"24480":{"$oid":"6527b18d99826ba7e58ee117"},"23840":{"$oid":"6527b2f799826ba7e593aee2"},"23949":{"$oid":"6527b18899826ba7e58edc12"},"24007":{"$oid":"6527b25d99826ba7e59181af"},"24754":{"$oid":"6527b19199826ba7e58eea82"},"25046":{"$oid":"6527b17e99826ba7e58ecb36"},"24975":{"$oid":"6527b17c99826ba7e58ec57a"},"24507":{"$oid":"6527b17a99826ba7e58ec1af"},"24822":{"$oid":"6527b17a99826ba7e58ec1f7"},"24577":{"$oid":"6527b18d99826ba7e58ee16c"},"23997":{"$oid":"6527b17a99826ba7e58ec4ce"},"24188":{"$oid":"6527b23d99826ba7e59111e2"},"24536":{"$oid":"6527b21099826ba7e59087c8"},"25039":{"$oid":"6527b18f99826ba7e58ee52a"},"24589":{"$oid":"6527b19c99826ba7e58efca7"},"24122":{"$oid":"6527b1e599826ba7e58fff76"},"24625":{"$oid":"6527b17999826ba7e58ebebc"},"24506":{"$oid":"6527b2c899826ba7e5930240"},"24706":{"$oid":"6527b22b99826ba7e590dacd"},"24449":{"$oid":"6527b18699826ba7e58ed5c6"},"24723":{"$oid":"6527b17399826ba7e58eb387"},"24265":{"$oid":"6527b19199826ba7e58eebd4"},"23927":{"$oid":"6527b21999826ba7e590a4eb"},"24143":{"$oid":"6527b18d99826ba7e58ee1c0"},"25015":{"$oid":"6527b17e99826ba7e58ecb9d"},"24246":{"$oid":"6527b17399826ba7e58eb4ac"},"24141":{"$oid":"6527b1eb99826ba7e59014c2"},"24169":{"$oid":"6527b18399826ba7e58ed3b1"},"24555":{"$oid":"6527b17e99826ba7e58ecc17"},"24582":{"$oid":"6527b17c99826ba7e58ec88d"},"24253":{"$oid":"6527b1e899826ba7e59009fb"},"24408":{"$oid":"6527b18899826ba7e58edbae"},"24471":{"$oid":"6527b22599826ba7e590c5ab"},"25009":{"$oid":"6527b28b99826ba7e5921e07"},"23982":{"$oid":"6527b1e699826ba7e5900163"},"25018":{"$oid":"6527b17a99826ba7e58ec4d1"},"24629":{"$oid":"6527b17399826ba7e58eb21c"},"24427":{"$oid":"6527b17c99826ba7e58ec571"},"24325":{"$oid":"6527b2d699826ba7e593349d"},"24704":{"$oid":"6527b17e99826ba7e58ecc7e"},"24326":{"$oid":"6527b18399826ba7e58ed3fb"},"24514":{"$oid":"6527b1bf99826ba7e58f79e3"},"24056":{"$oid":"6527b19199826ba7e58ee853"},"24900":{"$oid":"6527b1d199826ba7e58fba44"},"24302":{"$oid":"6527b2e499826ba7e5936dd4"},"24556":{"$oid":"6527b24199826ba7e5912069"},"24134":{"$oid":"6527b18199826ba7e58ed093"},"23884":{"$oid":"6527b18d99826ba7e58ee366"},"24593":{"$oid":"6527b1a699826ba7e58f2733"},"24065":{"$oid":"6527b1cf99826ba7e58fb216"},"23901":{"$oid":"6527b28599826ba7e5920d21"},"23987":{"$oid":"6527b17399826ba7e58eb36e"},"24215":{"$oid":"6527b19399826ba7e58eedec"},"24006":{"$oid":"6527b20a99826ba7e5907413"},"24677":{"$oid":"6527b1a399826ba7e58f1db4"},"24245":{"$oid":"6527b1da99826ba7e58fd28b"},"25031":{"$oid":"6527b29f99826ba7e592665b"},"24123":{"$oid":"6527b2ee99826ba7e5938c46"},"23844":{"$oid":"6527b19199826ba7e58eeb07"},"24216":{"$oid":"6527b17a99826ba7e58ec4ca"},"24971":{"$oid":"6527b20599826ba7e59064ef"},"24856":{"$oid":"6527b25e99826ba7e5918772"},"24301":{"$oid":"6527b22f99826ba7e590e682"},"24276":{"$oid":"6527b18d99826ba7e58ee1d0"},"24316":{"$oid":"6527b22f99826ba7e590e7a6"},"24840":{"$oid":"6527b17599826ba7e58eb5dd"},"24725":{"$oid":"6527b18399826ba7e58ed0b3"},"25007":{"$oid":"6527b2a999826ba7e5928baa"},"23940":{"$oid":"6527b2c899826ba7e5930260"},"23806":{"$oid":"6527b18f99826ba7e58ee6f2"},"23857":{"$oid":"6527b19799826ba7e58ef642"},"24490":{"$oid":"6527b17399826ba7e58eb21e"},"24061":{"$oid":"6527b19799826ba7e58ef3cf"},"24001":{"$oid":"6527b1d799826ba7e58fcb6d"},"23905":{"$oid":"6527b1a799826ba7e58f2d35"},"24210":{"$oid":"6527b18399826ba7e58ed0ec"},"24584":{"$oid":"6527b17599826ba7e58eb874"},"24223":{"$oid":"6527b2bc99826ba7e592d02d"},"24599":{"$oid":"6527b2ef99826ba7e5939719"},"24298":{"$oid":"6527b2a199826ba7e5926d66"},"23915":{"$oid":"6527b19999826ba7e58efb1c"},"24951":{"$oid":"6527b26d99826ba7e591baff"},"23853":{"$oid":"6527b25799826ba7e59169a9"},"24812":{"$oid":"6527b2c899826ba7e5930035"},"24630":{"$oid":"6527b2c299826ba7e592ecb2"},"25038":{"$oid":"6527b2d799826ba7e59335b3"},"24162":{"$oid":"6527b17c99826ba7e58ec54a"},"24104":{"$oid":"6527b19599826ba7e58ef092"},"23973":{"$oid":"6527b18199826ba7e58ece71"},"24481":{"$oid":"6527b18199826ba7e58ecfb7"},"23992":{"$oid":"6527b18699826ba7e58ed833"},"24863":{"$oid":"6527b2aa99826ba7e5928f10"},"24777":{"$oid":"6527b1aa99826ba7e58f3918"},"24278":{"$oid":"6527b22299826ba7e590bffe"},"24182":{"$oid":"6527b18f99826ba7e58ee687"},"24829":{"$oid":"6527b19599826ba7e58ef1e6"},"24016":{"$oid":"6527b17a99826ba7e58ec2c6"},"24742":{"$oid":"6527b27e99826ba7e591f1c6"},"24179":{"$oid":"6527b24c99826ba7e59145b2"},"24234":{"$oid":"6527b18f99826ba7e58ee690"},"23943":{"$oid":"6527b1ae99826ba7e58f432f"},"24930":{"$oid":"6527b24499826ba7e59129bd"},"24098":{"$oid":"6527b19999826ba7e58ef9e4"},"24836":{"$oid":"6527b19599826ba7e58ef301"},"24463":{"$oid":"6527b25199826ba7e59155c7"},"24170":{"$oid":"6527b17799826ba7e58eb9fc"},"23999":{"$oid":"6527b17e99826ba7e58ecc3c"},"24554":{"$oid":"6527b2ab99826ba7e5929257"},"24026":{"$oid":"6527b2c699826ba7e592f7f5"},"24027":{"$oid":"6527b17999826ba7e58ebd69"},"24048":{"$oid":"6527b17399826ba7e58eb4e9"},"24588":{"$oid":"6527b23b99826ba7e5910774"},"24250":{"$oid":"6527b18f99826ba7e58ee4a2"},"24631":{"$oid":"6527b2ce99826ba7e5931a00"},"24938":{"$oid":"6527b17999826ba7e58ec09b"},"24992":{"$oid":"6527b18399826ba7e58ed2a3"},"25057":{"$oid":"6527b17799826ba7e58eba5e"},"24776":{"$oid":"6527b29899826ba7e5924bca"},"24433":{"$oid":"6527b2e199826ba7e593634f"},"24522":{"$oid":"6527b18199826ba7e58eccb5"},"24789":{"$oid":"6527b19999826ba7e58ef7ba"},"24697":{"$oid":"6527b21b99826ba7e590a9c0"},"24475":{"$oid":"6527b19399826ba7e58eedbf"},"24663":{"$oid":"6527b17e99826ba7e58ecc32"},"24769":{"$oid":"6527b19199826ba7e58eeafd"},"24470":{"$oid":"6527b19999826ba7e58efa4c"},"24540":{"$oid":"6527b18699826ba7e58ed763"},"24099":{"$oid":"6527b17999826ba7e58ebd83"},"24674":{"$oid":"6527b27499826ba7e591d5b8"},"23920":{"$oid":"6527b19199826ba7e58ee812"},"24477":{"$oid":"6527b17799826ba7e58eb94d"},"24462":{"$oid":"6527b17999826ba7e58ebf6d"},"25044":{"$oid":"6527b18f99826ba7e58ee7f4"},"24014":{"$oid":"6527b18899826ba7e58ed87b"},"24644":{"$oid":"6527b17599826ba7e58eb7dc"},"25000":{"$oid":"6527b17c99826ba7e58ec7bb"},"23888":{"$oid":"6527b18f99826ba7e58ee524"},"24397":{"$oid":"6527b26399826ba7e591980e"},"23815":{"$oid":"6527b18199826ba7e58ecf65"},"24627":{"$oid":"6527b22599826ba7e590c7a3"},"25045":{"$oid":"6527b29399826ba7e5923990"},"23922":{"$oid":"6527b1b599826ba7e58f5625"},"23923":{"$oid":"6527b18199826ba7e58ecfcb"},"24898":{"$oid":"6527b28e99826ba7e5922b52"},"24730":{"$oid":"6527b22b99826ba7e590d9fb"},"23828":{"$oid":"6527b24699826ba7e5912e5c"},"24268":{"$oid":"6527b2f899826ba7e593ba42"},"24346":{"$oid":"6527b25099826ba7e591540f"},"24032":{"$oid":"6527b18899826ba7e58edb72"},"24220":{"$oid":"6527b19199826ba7e58ee928"},"24870":{"$oid":"6527b18b99826ba7e58ee017"},"24041":{"$oid":"6527b19199826ba7e58eea2e"},"24009":{"$oid":"6527b1c099826ba7e58f7dbf"},"24944":{"$oid":"6527b19599826ba7e58ef021"},"24681":{"$oid":"6527b23499826ba7e590f6f9"},"24594":{"$oid":"6527b18d99826ba7e58ee1d6"},"24083":{"$oid":"6527b29f99826ba7e5926532"},"24292":{"$oid":"6527b17399826ba7e58eb51d"},"23951":{"$oid":"6527b18699826ba7e58ed55b"},"25022":{"$oid":"6527b25a99826ba7e591776a"},"24852":{"$oid":"6527b25299826ba7e5915943"},"23875":{"$oid":"6527b18699826ba7e58ed626"},"24736":{"$oid":"6527b2ad99826ba7e5929ce8"},"24578":{"$oid":"6527b2b699826ba7e592bcdd"},"24883":{"$oid":"6527b2f299826ba7e5939cad"},"24206":{"$oid":"6527b20e99826ba7e5907f9d"},"24183":{"$oid":"6527b18399826ba7e58ed32a"},"24078":{"$oid":"6527b2b399826ba7e592b1d2"},"24729":{"$oid":"6527b17599826ba7e58eb7b3"},"23879":{"$oid":"6527b19199826ba7e58eebcd"},"24597":{"$oid":"6527b25799826ba7e5916a11"},"24648":{"$oid":"6527b17999826ba7e58ebf07"},"24090":{"$oid":"6527b18699826ba7e58ed73c"},"24029":{"$oid":"6527b17a99826ba7e58ec4d4"},"24793":{"$oid":"6527b25e99826ba7e59187bd"},"24136":{"$oid":"6527b1eb99826ba7e59011e3"},"23970":{"$oid":"6527b19799826ba7e58ef42a"},"24814":{"$oid":"6527b21099826ba7e59086d3"},"24139":{"$oid":"6527b18d99826ba7e58ee3d1"},"24402":{"$oid":"6527b29799826ba7e592476f"},"23887":{"$oid":"6527b19399826ba7e58eef62"},"24695":{"$oid":"6527b18199826ba7e58ecff7"},"24512":{"$oid":"6527b18699826ba7e58ed683"},"24439":{"$oid":"6527b19999826ba7e58ef921"},"24920":{"$oid":"6527b25c99826ba7e5917c47"},"24678":{"$oid":"6527b18199826ba7e58ecffc"},"24185":{"$oid":"6527b24599826ba7e5912c6d"},"24366":{"$oid":"6527b17a99826ba7e58ec306"},"24860":{"$oid":"6527b17999826ba7e58ebf26"},"24000":{"$oid":"6527b18b99826ba7e58edd5c"},"24498":{"$oid":"6527b21a99826ba7e590a763"},"24487":{"$oid":"6527b2d799826ba7e5933897"},"24117":{"$oid":"6527b17a99826ba7e58ec16b"},"24384":{"$oid":"6527b27699826ba7e591d77a"},"24806":{"$oid":"6527b17a99826ba7e58ec42f"},"24980":{"$oid":"6527b20299826ba7e5905d87"},"24502":{"$oid":"6527b19999826ba7e58ef7e8"},"23968":{"$oid":"6527b18199826ba7e58ed081"},"24520":{"$oid":"6527b17c99826ba7e58ec574"},"24948":{"$oid":"6527b18d99826ba7e58ee0ac"},"23966":{"$oid":"6527b17c99826ba7e58ec4fb"},"24688":{"$oid":"6527b28b99826ba7e5921c87"},"24369":{"$oid":"6527b29399826ba7e5923e18"},"24532":{"$oid":"6527b17399826ba7e58eb263"},"24993":{"$oid":"6527b18199826ba7e58ece5e"},"24284":{"$oid":"6527b2dc99826ba7e59349a1"},"24468":{"$oid":"6527b17e99826ba7e58eca4f"},"24207":{"$oid":"6527b29899826ba7e5924cbf"},"24809":{"$oid":"6527b2ef99826ba7e59395f7"},"24429":{"$oid":"6527b20799826ba7e5906d91"},"25040":{"$oid":"6527b18b99826ba7e58edf93"},"24445":{"$oid":"6527b19399826ba7e58eeee5"},"24270":{"$oid":"6527b17a99826ba7e58ec465"},"24659":{"$oid":"6527b19e99826ba7e58f07d1"},"23938":{"$oid":"6527b17c99826ba7e58ec80e"},"24859":{"$oid":"6527b18699826ba7e58ed49a"},"24634":{"$oid":"6527b1db99826ba7e58fd8cc"},"24917":{"$oid":"6527b18b99826ba7e58edfb6"},"24459":{"$oid":"6527b17a99826ba7e58ec15b"},"24247":{"$oid":"6527b2f299826ba7e5939d2b"},"24926":{"$oid":"6527b1f799826ba7e590399c"},"24933":{"$oid":"6527b17599826ba7e58eb8ea"},"24008":{"$oid":"6527b18899826ba7e58ed8e3"},"25020":{"$oid":"6527b19599826ba7e58ef17c"},"24527":{"$oid":"6527b27499826ba7e591d4ee"},"24666":{"$oid":"6527b24199826ba7e5912235"},"24257":{"$oid":"6527b17a99826ba7e58ec20a"},"23909":{"$oid":"6527b29399826ba7e5923f43"},"24244":{"$oid":"6527b18b99826ba7e58edd9f"},"24825":{"$oid":"6527b17a99826ba7e58ec2eb"},"24854":{"$oid":"6527b18b99826ba7e58ede28"},"25053":{"$oid":"6527b21899826ba7e5909fd4"},"24904":{"$oid":"6527b1e799826ba7e590069e"},"24165":{"$oid":"6527b2e499826ba7e5936e68"},"24800":{"$oid":"6527b29e99826ba7e5926293"},"24692":{"$oid":"6527b25e99826ba7e5918657"},"24940":{"$oid":"6527b18199826ba7e58ecfec"},"24045":{"$oid":"6527b17a99826ba7e58ec3f3"},"23894":{"$oid":"6527b2bc99826ba7e592d5e4"},"25056":{"$oid":"6527b18f99826ba7e58ee4b9"},"24932":{"$oid":"6527b1b699826ba7e58f5ccd"},"25042":{"$oid":"6527b2ee99826ba7e5938e52"},"24796":{"$oid":"6527b17799826ba7e58eba58"},"23933":{"$oid":"6527b22999826ba7e590d7ea"},"23916":{"$oid":"6527b18f99826ba7e58ee79b"},"24684":{"$oid":"6527b22299826ba7e590bde3"},"24425":{"$oid":"6527b2a599826ba7e59279a2"},"23859":{"$oid":"6527b18199826ba7e58ed06d"},"24089":{"$oid":"6527b18899826ba7e58ed97f"},"24456":{"$oid":"6527b17a99826ba7e58ec282"},"24046":{"$oid":"6527b1ba99826ba7e58f6773"},"24368":{"$oid":"6527b1f299826ba7e5902a7a"},"23889":{"$oid":"6527b17e99826ba7e58ecaa1"},"24335":{"$oid":"6527b18f99826ba7e58ee7c8"},"24616":{"$oid":"6527b25c99826ba7e5917d31"},"24637":{"$oid":"6527b18899826ba7e58eda66"},"24956":{"$oid":"6527b1bb99826ba7e58f6b5d"},"24720":{"$oid":"6527b2ce99826ba7e593172b"},"24954":{"$oid":"6527b19399826ba7e58eec40"},"24307":{"$oid":"6527b17799826ba7e58eb981"},"23983":{"$oid":"6527b20699826ba7e5906738"},"24380":{"$oid":"6527b20999826ba7e5907185"},"24158":{"$oid":"6527b17c99826ba7e58ec71c"},"23876":{"$oid":"6527b19199826ba7e58eeb09"},"24379":{"$oid":"6527b18d99826ba7e58ee13e"},"24869":{"$oid":"6527b18899826ba7e58eda3a"},"24128":{"$oid":"6527b1d599826ba7e58fc6d7"},"24285":{"$oid":"6527b2d199826ba7e5932456"},"24473":{"$oid":"6527b2b699826ba7e592bcbd"},"24186":{"$oid":"6527b17999826ba7e58ebfd7"},"24344":{"$oid":"6527b1c999826ba7e58f9c75"},"24734":{"$oid":"6527b1bf99826ba7e58f7b00"},"24269":{"$oid":"6527b18399826ba7e58ed397"},"24167":{"$oid":"6527b29399826ba7e5923c9c"},"24946":{"$oid":"6527b2c299826ba7e592ecea"},"24321":{"$oid":"6527b2b399826ba7e592b23c"},"23890":{"$oid":"6527b2cb99826ba7e5930ba6"},"24444":{"$oid":"6527b17399826ba7e58eb522"},"23952":{"$oid":"6527b2f499826ba7e593a3ba"},"24356":{"$oid":"6527b17399826ba7e58eb1eb"},"24632":{"$oid":"6527b2d999826ba7e593412d"},"24039":{"$oid":"6527b18d99826ba7e58ee1b7"},"24495":{"$oid":"6527b1c399826ba7e58f88a0"},"24620":{"$oid":"6527b2d999826ba7e5933e33"},"24042":{"$oid":"6527b1d499826ba7e58fc634"},"24576":{"$oid":"6527b17999826ba7e58ebe3b"},"23974":{"$oid":"6527b1bf99826ba7e58f7900"},"24436":{"$oid":"6527b17599826ba7e58eb885"},"24901":{"$oid":"6527b17999826ba7e58ebd16"},"24040":{"$oid":"6527b18d99826ba7e58ee304"},"23969":{"$oid":"6527b18899826ba7e58edc18"},"24848":{"$oid":"6527b17399826ba7e58eb22a"},"25011":{"$oid":"6527b17799826ba7e58eb94a"},"24328":{"$oid":"6527b18399826ba7e58ed301"},"23998":{"$oid":"6527b17799826ba7e58ebc7e"},"24049":{"$oid":"6527b1e399826ba7e58ff95d"},"24015":{"$oid":"6527b2cd99826ba7e593157e"},"24199":{"$oid":"6527b17599826ba7e58eb880"},"24862":{"$oid":"6527b17799826ba7e58eba87"},"24342":{"$oid":"6527b1ef99826ba7e5901d2b"},"24817":{"$oid":"6527b24099826ba7e5911a8e"},"24077":{"$oid":"6527b1a699826ba7e58f294e"},"24024":{"$oid":"6527b2a799826ba7e59285c0"},"24377":{"$oid":"6527b18699826ba7e58ed604"},"24200":{"$oid":"6527b19999826ba7e58ef92f"},"24876":{"$oid":"6527b27b99826ba7e591eb24"},"24084":{"$oid":"6527b18399826ba7e58ed179"},"24296":{"$oid":"6527b18199826ba7e58ece66"},"23826":{"$oid":"6527b19199826ba7e58ee8ca"},"24511":{"$oid":"6527b1b499826ba7e58f53f6"},"23956":{"$oid":"6527b17799826ba7e58eba9f"},"24682":{"$oid":"6527b24a99826ba7e5914027"},"24731":{"$oid":"6527b18199826ba7e58ece8d"},"24786":{"$oid":"6527b17999826ba7e58ebe84"},"24919":{"$oid":"6527b1ba99826ba7e58f68dc"},"24673":{"$oid":"6527b17e99826ba7e58ecaee"},"24509":{"$oid":"6527b18f99826ba7e58ee7d0"},"24966":{"$oid":"6527b17c99826ba7e58ec717"},"24313":{"$oid":"6527b19999826ba7e58ef9ba"},"23914":{"$oid":"6527b25a99826ba7e5917744"},"24842":{"$oid":"6527b26299826ba7e5919624"},"24431":{"$oid":"6527b26299826ba7e5919752"},"24918":{"$oid":"6527b18899826ba7e58ed9e3"},"24761":{"$oid":"6527b2de99826ba7e593543e"},"24414":{"$oid":"6527b17599826ba7e58eb810"},"24912":{"$oid":"6527b19399826ba7e58eed5c"},"23924":{"$oid":"6527b19599826ba7e58ef34d"},"24983":{"$oid":"6527b25799826ba7e5916b29"},"23874":{"$oid":"6527b18f99826ba7e58ee7a2"},"24297":{"$oid":"6527b1cb99826ba7e58fa42f"},"24345":{"$oid":"6527b1a199826ba7e58f1079"},"24892":{"$oid":"6527b24799826ba7e591320f"},"23880":{"$oid":"6527b2c199826ba7e592eb24"},"24939":{"$oid":"6527b17a99826ba7e58ec180"},"24815":{"$oid":"6527b17999826ba7e58ec036"},"24771":{"$oid":"6527b17c99826ba7e58ec6e8"},"24091":{"$oid":"6527b17999826ba7e58ebef5"},"24163":{"$oid":"6527b20e99826ba7e59080f3"},"24320":{"$oid":"6527b17e99826ba7e58ecbf7"},"24082":{"$oid":"6527b25999826ba7e5917288"},"24317":{"$oid":"6527b1ee99826ba7e59019b1"},"24619":{"$oid":"6527b1a599826ba7e58f25f6"},"24516":{"$oid":"6527b25a99826ba7e59177bb"},"24405":{"$oid":"6527b19599826ba7e58ef2c2"},"23871":{"$oid":"6527b19599826ba7e58ef207"},"24073":{"$oid":"6527b29399826ba7e5923b64"},"24539":{"$oid":"6527b2cb99826ba7e5930c7a"},"24100":{"$oid":"6527b1c999826ba7e58f9d15"},"23895":{"$oid":"6527b2b799826ba7e592c1e4"},"23929":{"$oid":"6527b17799826ba7e58ebac0"},"24978":{"$oid":"6527b18b99826ba7e58edfad"},"24623":{"$oid":"6527b19999826ba7e58ef935"},"24175":{"$oid":"6527b17599826ba7e58eb85f"},"25036":{"$oid":"6527b2bf99826ba7e592e23e"},"24713":{"$oid":"6527b17999826ba7e58ebfda"},"24887":{"$oid":"6527b2fa99826ba7e593bb38"},"23913":{"$oid":"6527b17999826ba7e58ebfe4"},"24062":{"$oid":"6527b1dc99826ba7e58fda67"},"24324":{"$oid":"6527b17c99826ba7e58ec7f5"},"24960":{"$oid":"6527b1d799826ba7e58fcada"},"24696":{"$oid":"6527b29f99826ba7e59265cf"},"24997":{"$oid":"6527b1ba99826ba7e58f668a"},"24391":{"$oid":"6527b17a99826ba7e58ec287"},"25051":{"$oid":"6527b1d499826ba7e58fc490"},"24553":{"$oid":"6527b18d99826ba7e58ee3d6"},"23945":{"$oid":"6527b1f699826ba7e590352c"},"24679":{"$oid":"6527b18899826ba7e58edb27"},"24968":{"$oid":"6527b18199826ba7e58ecdbb"},"24850":{"$oid":"6527b17c99826ba7e58ec715"},"23881":{"$oid":"6527b1a599826ba7e58f2663"},"24085":{"$oid":"6527b23199826ba7e590ed0c"},"24209":{"$oid":"6527b2d799826ba7e5933647"},"24093":{"$oid":"6527b18d99826ba7e58ee3fb"},"23900":{"$oid":"6527b17999826ba7e58ec05b"},"24518":{"$oid":"6527b2d999826ba7e5933dd7"},"24651":{"$oid":"6527b1fa99826ba7e5904791"},"24004":{"$oid":"6527b2f799826ba7e593b27d"},"23954":{"$oid":"6527b23399826ba7e590efd3"},"23984":{"$oid":"6527b18899826ba7e58edaf7"},"24903":{"$oid":"6527b2ba99826ba7e592cc2e"},"24371":{"$oid":"6527b23199826ba7e590ed72"},"24559":{"$oid":"6527b19599826ba7e58ef2c3"},"24957":{"$oid":"6527b18699826ba7e58ed71c"},"24867":{"$oid":"6527b17599826ba7e58eb907"},"24152":{"$oid":"6527b17599826ba7e58eb616"},"24784":{"$oid":"6527b19599826ba7e58ef22f"},"24990":{"$oid":"6527b18699826ba7e58ed57a"},"24531":{"$oid":"6527b18399826ba7e58ed154"},"24340":{"$oid":"6527b2ec99826ba7e59384c3"},"24038":{"$oid":"6527b17599826ba7e58eb82a"},"24394":{"$oid":"6527b2b599826ba7e592bbf1"},"24988":{"$oid":"6527b2b899826ba7e592c549"},"25061":{"$oid":"6527b1f499826ba7e5902ea3"},"24010":{"$oid":"6527b18d99826ba7e58ee12b"},"23856":{"$oid":"6527b23099826ba7e590e886"},"24886":{"$oid":"6527b18199826ba7e58ecd76"},"24363":{"$oid":"6527b18399826ba7e58ed2b9"},"24412":{"$oid":"6527b18f99826ba7e58ee784"},"25004":{"$oid":"6527b2ed99826ba7e59389e1"},"24835":{"$oid":"6527b29e99826ba7e59261ae"},"23855":{"$oid":"6527b1fc99826ba7e590494f"},"24105":{"$oid":"6527b2a299826ba7e59270ca"},"23885":{"$oid":"6527b18f99826ba7e58ee7a3"},"24823":{"$oid":"6527b1bf99826ba7e58f7bcf"},"24066":{"$oid":"6527b26299826ba7e5919654"},"23950":{"$oid":"6527b29a99826ba7e5925652"},"25052":{"$oid":"6527b2f099826ba7e5939971"},"24068":{"$oid":"6527b29499826ba7e5923ffa"},"24103":{"$oid":"6527b17599826ba7e58eb660"},"24252":{"$oid":"6527b17799826ba7e58ebc5a"},"24211":{"$oid":"6527b19399826ba7e58eed8c"},"24984":{"$oid":"6527b17a99826ba7e58ec120"},"24961":{"$oid":"6527b18b99826ba7e58eddd0"},"23965":{"$oid":"6527b2f499826ba7e593a384"},"24937":{"$oid":"6527b19399826ba7e58eefb0"},"24813":{"$oid":"6527b19199826ba7e58ee9bd"},"24095":{"$oid":"6527b19399826ba7e58eeed7"},"23971":{"$oid":"6527b2bd99826ba7e592d871"},"23918":{"$oid":"6527b19399826ba7e58eec26"},"24150":{"$oid":"6527b1a199826ba7e58f1603"},"24144":{"$oid":"6527b2df99826ba7e59357a2"},"24053":{"$oid":"6527b21b99826ba7e590ac6f"},"24392":{"$oid":"6527b24499826ba7e59126e9"},"23867":{"$oid":"6527b17799826ba7e58ebae0"},"24804":{"$oid":"6527b29e99826ba7e59260b8"},"24403":{"$oid":"6527b18199826ba7e58ecfa1"},"24467":{"$oid":"6527b18399826ba7e58ed09f"},"24081":{"$oid":"6527b1ab99826ba7e58f3cb4"},"23925":{"$oid":"6527b1a399826ba7e58f1c40"},"24219":{"$oid":"6527b18d99826ba7e58ee18e"},"24055":{"$oid":"6527b19799826ba7e58ef64a"},"24299":{"$oid":"6527b19599826ba7e58ef2fd"},"24212":{"$oid":"6527b19799826ba7e58ef4e9"},"23814":{"$oid":"6527b18f99826ba7e58ee439"},"23886":{"$oid":"6527b17e99826ba7e58ecbd4"},"24248":{"$oid":"6527b19599826ba7e58ef38a"},"24382":{"$oid":"6527b2d799826ba7e5933676"},"24274":{"$oid":"6527b19599826ba7e58ef22a"},"23996":{"$oid":"6527b28c99826ba7e5922289"},"24131":{"$oid":"6527b1bb99826ba7e58f6af3"},"23870":{"$oid":"6527b21799826ba7e5909b5e"},"24037":{"$oid":"6527b2ce99826ba7e5931895"},"24180":{"$oid":"6527b17599826ba7e58eb5d6"},"24442":{"$oid":"6527b25a99826ba7e5917514"},"24795":{"$oid":"6527b23699826ba7e590fc04"},"24517":{"$oid":"6527b19599826ba7e58ef202"},"24756":{"$oid":"6527b19399826ba7e58eecd0"},"25023":{"$oid":"6527b18199826ba7e58ecd8e"},"24256":{"$oid":"6527b22699826ba7e590cb76"},"24022":{"$oid":"6527b28d99826ba7e592269e"},"24624":{"$oid":"6527b19599826ba7e58ef27a"},"23979":{"$oid":"6527b1f099826ba7e59021ed"},"24235":{"$oid":"6527b1bd99826ba7e58f7374"},"23834":{"$oid":"6527b2af99826ba7e592a247"},"24106":{"$oid":"6527b17399826ba7e58eb48e"},"24851":{"$oid":"6527b1ae99826ba7e58f424d"},"24611":{"$oid":"6527b2e099826ba7e5935fe0"},"24743":{"$oid":"6527b2d899826ba7e5933a70"},"24323":{"$oid":"6527b19999826ba7e58efa33"},"24035":{"$oid":"6527b2a599826ba7e59278a8"},"24499":{"$oid":"6527b18199826ba7e58ecdcc"},"24868":{"$oid":"6527b21499826ba7e5909430"},"24633":{"$oid":"6527b18699826ba7e58ed7c7"},"24587":{"$oid":"6527b29d99826ba7e5925e77"},"24063":{"$oid":"6527b17c99826ba7e58ec5b3"},"24108":{"$oid":"6527b19799826ba7e58ef3d5"},"24232":{"$oid":"6527b29799826ba7e5924a30"},"23841":{"$oid":"6527b19599826ba7e58ef282"},"23851":{"$oid":"6527b1a199826ba7e58f1211"},"24142":{"$oid":"6527b18199826ba7e58ecfef"},"23910":{"$oid":"6527b1d799826ba7e58fcbc3"},"24273":{"$oid":"6527b18199826ba7e58eccdd"},"24279":{"$oid":"6527b18d99826ba7e58ee158"},"23869":{"$oid":"6527b19999826ba7e58ef9bb"},"24699":{"$oid":"6527b19999826ba7e58efa1e"},"24192":{"$oid":"6527b2c099826ba7e592e5b7"},"24740":{"$oid":"6527b19799826ba7e58ef730"},"23877":{"$oid":"6527b2ac99826ba7e5929687"},"24906":{"$oid":"6527b19799826ba7e58ef450"},"24757":{"$oid":"6527b18699826ba7e58ed4ae"},"24762":{"$oid":"6527b27499826ba7e591d3b9"},"24156":{"$oid":"6527b18699826ba7e58ed4c6"},"25005":{"$oid":"6527b19199826ba7e58eea9a"},"24120":{"$oid":"6527b26499826ba7e5919f0f"},"24241":{"$oid":"6527b17e99826ba7e58ec96d"},"23852":{"$oid":"6527b1e399826ba7e58ff721"},"23866":{"$oid":"6527b19799826ba7e58ef645"},"24717":{"$oid":"6527b21999826ba7e590a3c2"},"25048":{"$oid":"6527b26d99826ba7e591bd00"},"23898":{"$oid":"6527b17599826ba7e58eb6f6"},"24092":{"$oid":"6527b18399826ba7e58ed180"},"24877":{"$oid":"6527b19199826ba7e58ee994"},"23830":{"$oid":"6527b1cf99826ba7e58fb3c3"},"24198":{"$oid":"6527b17599826ba7e58eb7af"},"24204":{"$oid":"6527b1ca99826ba7e58fa029"},"23991":{"$oid":"6527b28999826ba7e59219c2"},"25058":{"$oid":"6527b1c999826ba7e58f9d84"},"24838":{"$oid":"6527b2f399826ba7e593a15d"},"24653":{"$oid":"6527b1d199826ba7e58fb7ef"},"24146":{"$oid":"6527b22099826ba7e590b670"},"24833":{"$oid":"6527b2ee99826ba7e5938f31"},"24133":{"$oid":"6527b22099826ba7e590b70f"},"24476":{"$oid":"6527b19199826ba7e58ee874"},"24847":{"$oid":"6527b18899826ba7e58edb73"},"24636":{"$oid":"6527b24a99826ba7e5914111"},"23977":{"$oid":"6527b17799826ba7e58ebccd"},"24497":{"$oid":"6527b17399826ba7e58eb25d"},"24281":{"$oid":"6527b2b799826ba7e592c0cd"},"23899":{"$oid":"6527b24b99826ba7e59143fc"},"24465":{"$oid":"6527b17a99826ba7e58ec396"},"24670":{"$oid":"6527b19599826ba7e58ef00b"},"24595":{"$oid":"6527b22199826ba7e590bba5"},"25024":{"$oid":"6527b2da99826ba7e59343f8"},"24732":{"$oid":"6527b19999826ba7e58ef829"},"24401":{"$oid":"6527b18d99826ba7e58ee12e"},"24125":{"$oid":"6527b18899826ba7e58ed9e2"},"24293":{"$oid":"6527b18b99826ba7e58edea4"},"23975":{"$oid":"6527b18699826ba7e58ed71b"},"24710":{"$oid":"6527b19399826ba7e58eed39"},"24243":{"$oid":"6527b18d99826ba7e58ee213"},"23941":{"$oid":"6527b19999826ba7e58efa34"},"24751":{"$oid":"6527b2a999826ba7e59289b4"},"24076":{"$oid":"6527b18f99826ba7e58ee4a1"},"24349":{"$oid":"6527b17e99826ba7e58ecb0b"},"24515":{"$oid":"6527b20c99826ba7e59078df"},"24171":{"$oid":"6527b25999826ba7e5917417"},"24260":{"$oid":"6527b20a99826ba7e59072a0"},"23976":{"$oid":"6527b2d999826ba7e5933f37"},"24519":{"$oid":"6527b27999826ba7e591e279"},"23832":{"$oid":"6527b1fd99826ba7e5904ee9"},"24351":{"$oid":"6527b19199826ba7e58ee8c0"},"23809":{"$oid":"6527b17c99826ba7e58ec847"},"24831":{"$oid":"6527b29a99826ba7e592549b"},"25049":{"$oid":"6527b17799826ba7e58eba13"},"24834":{"$oid":"6527b1ac99826ba7e58f3e55"},"23793":{"$oid":"6527b17c99826ba7e58ec5bd"},"24728":{"$oid":"6527b2b899826ba7e592c4d3"},"24385":{"$oid":"6527b19199826ba7e58eea3d"},"24952":{"$oid":"6527b28299826ba7e5920195"},"24891":{"$oid":"6527b2d099826ba7e5931f5a"},"24428":{"$oid":"6527b27b99826ba7e591e9f6"},"24121":{"$oid":"6527b17599826ba7e58eb5bc"},"23805":{"$oid":"6527b19599826ba7e58ef2c8"},"24808":{"$oid":"6527b1c199826ba7e58f82b0"},"23789":{"$oid":"6527b19399826ba7e58eef20"},"24052":{"$oid":"6527b17999826ba7e58ebe10"},"24973":{"$oid":"6527b27799826ba7e591dc1d"},"23988":{"$oid":"6527b1d899826ba7e58fcecc"},"24849":{"$oid":"6527b17799826ba7e58ebc65"},"24718":{"$oid":"6527b18899826ba7e58ed8b2"},"24894":{"$oid":"6527b17399826ba7e58eb50c"},"24295":{"$oid":"6527b29e99826ba7e5925f1d"},"23863":{"$oid":"6527b18199826ba7e58ecd0f"},"24638":{"$oid":"6527b1fa99826ba7e59046cc"},"24287":{"$oid":"6527b2d999826ba7e5933ecb"},"23994":{"$oid":"6527b24c99826ba7e59148eb"},"24760":{"$oid":"6527b2b499826ba7e592b6e9"},"24941":{"$oid":"6527b1e699826ba7e59001dd"},"24746":{"$oid":"6527b17c99826ba7e58ec676"},"24910":{"$oid":"6527b20c99826ba7e5907768"},"23958":{"$oid":"6527b1cd99826ba7e58fae69"},"24916":{"$oid":"6527b17c99826ba7e58ec772"},"24839":{"$oid":"6527b1e299826ba7e58ff522"},"24981":{"$oid":"6527b2bc99826ba7e592d2b8"},"24550":{"$oid":"6527b2a899826ba7e592862d"},"24702":{"$oid":"6527b2bc99826ba7e592d15f"},"24693":{"$oid":"6527b1f299826ba7e5902863"},"24365":{"$oid":"6527b1cd99826ba7e58fac09"},"24410":{"$oid":"6527b1ca99826ba7e58fa2e4"},"23906":{"$oid":"6527b1dc99826ba7e58fdada"},"24797":{"$oid":"6527b17599826ba7e58eb6e9"},"24803":{"$oid":"6527b19199826ba7e58eeb4d"},"24785":{"$oid":"6527b19199826ba7e58ee819"},"25059":{"$oid":"6527b18f99826ba7e58ee452"},"23944":{"$oid":"6527b19599826ba7e58ef2b9"},"24404":{"$oid":"6527b17c99826ba7e58ec5bf"},"24357":{"$oid":"6527b2c899826ba7e592ffea"},"24096":{"$oid":"6527b22899826ba7e590d287"},"24031":{"$oid":"6527b1b599826ba7e58f5792"},"23937":{"$oid":"6527b18d99826ba7e58ee28e"},"23865":{"$oid":"6527b23399826ba7e590f08f"},"23804":{"$oid":"6527b19999826ba7e58ef974"},"23854":{"$oid":"6527b18f99826ba7e58ee6e0"},"23891":{"$oid":"6527b2af99826ba7e592a200"},"24773":{"$oid":"6527b18f99826ba7e58ee743"},"23825":{"$oid":"6527b17399826ba7e58eb4f9"},"24355":{"$oid":"6527b1a199826ba7e58f146a"},"24036":{"$oid":"6527b27899826ba7e591e107"},"24417":{"$oid":"6527b26a99826ba7e591b3c9"},"24608":{"$oid":"6527b1a199826ba7e58f15e6"},"24626":{"$oid":"6527b18899826ba7e58ed97e"},"24810":{"$oid":"6527b18399826ba7e58ed365"},"25016":{"$oid":"6527b19d99826ba7e58f018a"},"24546":{"$oid":"6527b1bf99826ba7e58f7aee"},"24264":{"$oid":"6527b1be99826ba7e58f77c3"},"24591":{"$oid":"6527b19799826ba7e58ef53c"},"24114":{"$oid":"6527b18899826ba7e58eda52"},"24057":{"$oid":"6527b18399826ba7e58ed1de"},"24482":{"$oid":"6527b1b999826ba7e58f6378"},"24758":{"$oid":"6527b17799826ba7e58eba5a"},"24166":{"$oid":"6527b2f299826ba7e5939e41"},"23883":{"$oid":"6527b19799826ba7e58ef484"},"24719":{"$oid":"6527b18699826ba7e58ed57f"},"24642":{"$oid":"6527b18899826ba7e58edb7f"},"24159":{"$oid":"6527b22c99826ba7e590dc42"},"24194":{"$oid":"6527b2d799826ba7e59338de"},"24641":{"$oid":"6527b18199826ba7e58eccda"},"24982":{"$oid":"6527b17c99826ba7e58ec586"},"24602":{"$oid":"6527b25f99826ba7e59187f0"},"24605":{"$oid":"6527b18b99826ba7e58ede96"},"24109":{"$oid":"6527b18699826ba7e58ed5ad"},"24741":{"$oid":"6527b18b99826ba7e58edc81"},"24709":{"$oid":"6527b19199826ba7e58ee9f8"},"24020":{"$oid":"6527b22d99826ba7e590e2d4"},"24157":{"$oid":"6527b19599826ba7e58ef1ce"},"23990":{"$oid":"6527b1dd99826ba7e58fde4c"},"24151":{"$oid":"6527b22999826ba7e590d654"},"24501":{"$oid":"6527b19999826ba7e58ef80a"},"24821":{"$oid":"6527b2ae99826ba7e592a03a"},"24586":{"$oid":"6527b18d99826ba7e58ee0b2"},"24419":{"$oid":"6527b27799826ba7e591dd30"},"24047":{"$oid":"6527b29f99826ba7e59264a6"},"24155":{"$oid":"6527b2c899826ba7e5930173"},"24311":{"$oid":"6527b17c99826ba7e58ec5a4"},"24254":{"$oid":"6527b18399826ba7e58ed144"},"24030":{"$oid":"6527b1f599826ba7e5903290"},"24455":{"$oid":"6527b17599826ba7e58eb5b0"},"24088":{"$oid":"6527b18d99826ba7e58ee2db"},"24802":{"$oid":"6527b19199826ba7e58ee9d0"},"24995":{"$oid":"6527b18199826ba7e58ecdb1"},"23845":{"$oid":"6527b1cf99826ba7e58fb2aa"},"24612":{"$oid":"6527b19599826ba7e58ef36e"},"24033":{"$oid":"6527b22899826ba7e590d3f5"},"24649":{"$oid":"6527b1bb99826ba7e58f6af4"},"24019":{"$oid":"6527b29399826ba7e5923d4d"},"23955":{"$oid":"6527b2bd99826ba7e592db8f"},"25006":{"$oid":"6527b1d399826ba7e58fc1ea"},"24652":{"$oid":"6527b18f99826ba7e58ee4c4"},"24478":{"$oid":"6527b18899826ba7e58ed9ad"},"24888":{"$oid":"6527b23f99826ba7e5911826"},"24233":{"$oid":"6527b22399826ba7e590c0d9"},"24694":{"$oid":"6527b2cf99826ba7e5931b19"},"23849":{"$oid":"6527b2e499826ba7e5936e07"},"24841":{"$oid":"6527b1ee99826ba7e5901b07"},"24197":{"$oid":"6527b17a99826ba7e58ec10e"},"24003":{"$oid":"6527b20199826ba7e59058a1"},"24943":{"$oid":"6527b29999826ba7e5924fa1"},"24783":{"$oid":"6527b17599826ba7e58eb6b4"},"24650":{"$oid":"6527b17e99826ba7e58eca55"},"23989":{"$oid":"6527b24799826ba7e5913362"},"24395":{"$oid":"6527b18899826ba7e58ed8cb"},"24958":{"$oid":"6527b19799826ba7e58ef552"},"24097":{"$oid":"6527b18899826ba7e58edb4b"},"24606":{"$oid":"6527b17399826ba7e58eb160"},"24913":{"$oid":"6527b20d99826ba7e5907b3e"},"24529":{"$oid":"6527b1a599826ba7e58f22e6"},"24315":{"$oid":"6527b17a99826ba7e58ec1c1"},"24549":{"$oid":"6527b2b899826ba7e592c46b"},"23980":{"$oid":"6527b1cf99826ba7e58fb0e8"},"24127":{"$oid":"6527b1ac99826ba7e58f3f42"},"23847":{"$oid":"6527b17999826ba7e58ec0f3"},"24882":{"$oid":"6527b18b99826ba7e58edf37"},"24610":{"$oid":"6527b17399826ba7e58eb286"},"24149":{"$oid":"6527b28299826ba7e59202bf"},"24618":{"$oid":"6527b22399826ba7e590c248"},"24370":{"$oid":"6527b1e499826ba7e58ffba2"},"24486":{"$oid":"6527b17a99826ba7e58ec3b9"},"24537":{"$oid":"6527b2f599826ba7e593a8d2"},"24021":{"$oid":"6527b19199826ba7e58eea00"},"24872":{"$oid":"6527b17c99826ba7e58ec671"},"24314":{"$oid":"6527b1c099826ba7e58f7e09"},"24914":{"$oid":"6527b17999826ba7e58ebd7a"},"23843":{"$oid":"6527b17599826ba7e58eb811"},"24929":{"$oid":"6527b17999826ba7e58ebd0c"},"24788":{"$oid":"6527b1f799826ba7e5903808"},"24609":{"$oid":"6527b17599826ba7e58eb82d"},"23873":{"$oid":"6527b20999826ba7e5906ed1"},"24855":{"$oid":"6527b1bc99826ba7e58f6f04"},"24820":{"$oid":"6527b2d899826ba7e5933c29"},"24187":{"$oid":"6527b1e899826ba7e5900bcf"},"25013":{"$oid":"6527b1f199826ba7e59027d7"},"23846":{"$oid":"6527b20c99826ba7e5907a1e"},"24496":{"$oid":"6527b1e399826ba7e58ff937"},"24153":{"$oid":"6527b2e999826ba7e5937eaa"},"24058":{"$oid":"6527b2c799826ba7e592fc09"},"24261":{"$oid":"6527b1fc99826ba7e5904a1b"},"23860":{"$oid":"6527b26f99826ba7e591c5a9"},"24566":{"$oid":"6527b17c99826ba7e58ec59d"},"24845":{"$oid":"6527b24c99826ba7e59146a0"},"24339":{"$oid":"6527b17399826ba7e58eb48a"},"24683":{"$oid":"6527b17399826ba7e58eb262"},"24145":{"$oid":"6527b1a699826ba7e58f29c5"},"24457":{"$oid":"6527b2c499826ba7e592f69a"},"24196":{"$oid":"6527b27799826ba7e591dd11"},"23963":{"$oid":"6527b17399826ba7e58eb3d0"},"24521":{"$oid":"6527b2e899826ba7e59379d9"},"24976":{"$oid":"6527b17a99826ba7e58ec249"},"24573":{"$oid":"6527b1d299826ba7e58fbcbd"},"24781":{"$oid":"6527b2d599826ba7e5933027"},"24488":{"$oid":"6527b2f099826ba7e5939952"},"24635":{"$oid":"6527b26a99826ba7e591afd1"},"24570":{"$oid":"6527b21a99826ba7e590a596"},"24660":{"$oid":"6527b18f99826ba7e58ee6cb"},"24654":{"$oid":"6527b18699826ba7e58ed509"},"24846":{"$oid":"6527b18899826ba7e58edb4d"},"24438":{"$oid":"6527b17399826ba7e58eb164"},"25043":{"$oid":"6527b2ce99826ba7e593186b"},"24538":{"$oid":"6527b27e99826ba7e591f521"},"24580":{"$oid":"6527b2a399826ba7e5927539"},"23995":{"$oid":"6527b17799826ba7e58ebc0a"},"24416":{"$oid":"6527b24599826ba7e5912be3"},"24787":{"$oid":"6527b1c099826ba7e58f7fd6"},"23964":{"$oid":"6527b27a99826ba7e591e5f9"},"23833":{"$oid":"6527b17a99826ba7e58ec2d4"},"24962":{"$oid":"6527b18699826ba7e58ed735"},"24289":{"$oid":"6527b18899826ba7e58edb83"},"24598":{"$oid":"6527b25599826ba7e5916449"},"24647":{"$oid":"6527b18f99826ba7e58ee671"},"24524":{"$oid":"6527b19799826ba7e58ef412"},"24331":{"$oid":"6527b27899826ba7e591deaa"},"24818":{"$oid":"6527b18699826ba7e58ed74c"},"24643":{"$oid":"6527b18b99826ba7e58edf4d"},"24466":{"$oid":"6527b20d99826ba7e5907ac5"},"24735":{"$oid":"6527b22099826ba7e590b7e4"},"23926":{"$oid":"6527b2b199826ba7e592a92a"},"24505":{"$oid":"6527b22b99826ba7e590d9c4"},"24420":{"$oid":"6527b19999826ba7e58efa3f"},"24249":{"$oid":"6527b2a699826ba7e5927a8f"},"24464":{"$oid":"6527b17e99826ba7e58ec965"},"24239":{"$oid":"6527b18399826ba7e58ed1db"},"24985":{"$oid":"6527b19199826ba7e58eeba7"},"24843":{"$oid":"6527b18f99826ba7e58ee5ef"},"24230":{"$oid":"6527b25e99826ba7e59184fe"},"24646":{"$oid":"6527b17799826ba7e58ebca9"},"25029":{"$oid":"6527b17799826ba7e58eb9a7"},"24690":{"$oid":"6527b19199826ba7e58eeb11"},"24059":{"$oid":"6527b2bc99826ba7e592d510"},"24947":{"$oid":"6527b18f99826ba7e58ee607"},"24160":{"$oid":"6527b19199826ba7e58eeb78"},"24011":{"$oid":"6527b29699826ba7e5924658"},"23907":{"$oid":"6527b2bf99826ba7e592e002"},"24530":{"$oid":"6527b17e99826ba7e58ec9ba"},"24873":{"$oid":"6527b2c899826ba7e5930069"},"24376":{"$oid":"6527b2ba99826ba7e592cefe"},"23972":{"$oid":"6527b28b99826ba7e5921d11"},"24581":{"$oid":"6527b19999826ba7e58ef96c"},"24208":{"$oid":"6527b24799826ba7e591334e"},"24025":{"$oid":"6527b1fe99826ba7e590519d"},"24715":{"$oid":"6527b2c199826ba7e592e838"},"24574":{"$oid":"6527b2b199826ba7e592aba2"},"24583":{"$oid":"6527b2ae99826ba7e5929fb9"},"24072":{"$oid":"6527b2db99826ba7e5934621"},"24071":{"$oid":"6527b23099826ba7e590ea50"},"25050":{"$oid":"6527b2b499826ba7e592b767"},"24970":{"$oid":"6527b26a99826ba7e591b023"},"24686":{"$oid":"6527b29499826ba7e59241e1"},"23878":{"$oid":"6527b18199826ba7e58ecf69"},"24687":{"$oid":"6527b1f999826ba7e590434c"},"24451":{"$oid":"6527b25799826ba7e5916bb7"},"24005":{"$oid":"6527b18b99826ba7e58edefe"},"24579":{"$oid":"6527b2aa99826ba7e5928fef"},"24945":{"$oid":"6527b17a99826ba7e58ec2bc"},"23919":{"$oid":"6527b1da99826ba7e58fd394"},"24585":{"$oid":"6527b21a99826ba7e590a810"},"24398":{"$oid":"6527b19c99826ba7e58efcbd"},"24454":{"$oid":"6527b18b99826ba7e58edf55"},"24902":{"$oid":"6527b18f99826ba7e58ee6a2"},"23912":{"$oid":"6527b19999826ba7e58ef7ca"},"24489":{"$oid":"6527b18899826ba7e58ed914"},"23978":{"$oid":"6527b1ab99826ba7e58f3ad9"},"24621":{"$oid":"6527b18899826ba7e58ed98b"},"24738":{"$oid":"6527b18b99826ba7e58eddf6"},"23862":{"$oid":"6527b26399826ba7e5919989"},"24303":{"$oid":"6527b18699826ba7e58ed85a"},"24132":{"$oid":"6527b23c99826ba7e5910dfb"},"24701":{"$oid":"6527b1aa99826ba7e58f39bf"},"24923":{"$oid":"6527b1d899826ba7e58fd143"},"24332":{"$oid":"6527b19999826ba7e58ef9f5"},"24763":{"$oid":"6527b28499826ba7e59209e5"},"24388":{"$oid":"6527b1be99826ba7e58f756d"},"24228":{"$oid":"6527b2c999826ba7e59309b6"},"24184":{"$oid":"6527b18899826ba7e58edc38"},"24399":{"$oid":"6527b23d99826ba7e5911270"},"24229":{"$oid":"6527b17e99826ba7e58ec958"},"24309":{"$oid":"6527b2f099826ba7e593998c"},"24525":{"$oid":"6527b19799826ba7e58ef606"},"24617":{"$oid":"6527b21b99826ba7e590aa04"},"24811":{"$oid":"6527b19999826ba7e58efa6e"},"24087":{"$oid":"6527b2ab99826ba7e5929407"},"24955":{"$oid":"6527b17c99826ba7e58ec5ea"},"24017":{"$oid":"6527b2c399826ba7e592f104"},"24893":{"$oid":"6527b1ff99826ba7e59056d8"},"24592":{"$oid":"6527b28c99826ba7e5922347"},"24737":{"$oid":"6527b19999826ba7e58ef7ee"},"24367":{"$oid":"6527b18f99826ba7e58ee45f"},"24879":{"$oid":"6527b1e599826ba7e58ffdd5"},"24907":{"$oid":"6527b26799826ba7e591a5ee"},"23794":{"$oid":"6527b19199826ba7e58ee807"},"23790":{"$oid":"6527b18399826ba7e58ed41c"},"24028":{"$oid":"6527b1f999826ba7e5904323"},"23820":{"$oid":"6527b18899826ba7e58edb05"},"23872":{"$oid":"6527b17999826ba7e58ebfcd"},"24824":{"$oid":"6527b18399826ba7e58ed1c7"},"24794":{"$oid":"6527b17399826ba7e58eb480"},"24865":{"$oid":"6527b18f99826ba7e58ee538"},"24411":{"$oid":"6527b2a299826ba7e5927031"},"24942":{"$oid":"6527b18d99826ba7e58ee2c0"},"24534":{"$oid":"6527b18699826ba7e58ed5b3"},"24421":{"$oid":"6527b17599826ba7e58eb5d0"},"24508":{"$oid":"6527b20199826ba7e59059e3"},"24548":{"$oid":"6527b26399826ba7e591986e"},"24600":{"$oid":"6527b17c99826ba7e58ec542"},"24312":{"$oid":"6527b2f699826ba7e593aaea"},"23882":{"$oid":"6527b1bb99826ba7e58f6b21"},"25041":{"$oid":"6527b20699826ba7e59067a6"},"24969":{"$oid":"6527b17a99826ba7e58ec232"},"23904":{"$oid":"6527b26799826ba7e591a650"},"24213":{"$oid":"6527b21e99826ba7e590b470"},"24953":{"$oid":"6527b1a299826ba7e58f17b6"},"24603":{"$oid":"6527b17c99826ba7e58ec627"},"24319":{"$oid":"6527b24f99826ba7e59150e2"},"25060":{"$oid":"6527b21899826ba7e5909e39"},"24350":{"$oid":"6527b20699826ba7e5906aa5"},"23827":{"$oid":"6527b21c99826ba7e590aec5"},"24979":{"$oid":"6527b18899826ba7e58ed8a1"},"23939":{"$oid":"6527b1aa99826ba7e58f375d"},"24409":{"$oid":"6527b18199826ba7e58ecde9"},"24628":{"$oid":"6527b17799826ba7e58ebcf4"},"24205":{"$oid":"6527b18699826ba7e58ed59c"},"24112":{"$oid":"6527b1de99826ba7e58fe36d"},"24875":{"$oid":"6527b18b99826ba7e58edcca"},"24568":{"$oid":"6527b18f99826ba7e58ee4db"},"23892":{"$oid":"6527b28b99826ba7e5921f97"},"24733":{"$oid":"6527b21e99826ba7e590b1fc"},"24708":{"$oid":"6527b18699826ba7e58ed710"},"24949":{"$oid":"6527b17399826ba7e58eb2c3"},"24884":{"$oid":"6527b19199826ba7e58eeafa"},"24959":{"$oid":"6527b2f399826ba7e593a109"},"24135":{"$oid":"6527b2b699826ba7e592c035"},"25017":{"$oid":"6527b24999826ba7e5913b79"},"23835":{"$oid":"6527b18699826ba7e58ed4be"},"24965":{"$oid":"6527b22799826ba7e590cedf"},"24819":{"$oid":"6527b1c599826ba7e58f9318"},"24222":{"$oid":"6527b2e799826ba7e5937760"},"24262":{"$oid":"6527b17a99826ba7e58ec328"},"24483":{"$oid":"6527b19399826ba7e58eec8e"},"23946":{"$oid":"6527b17999826ba7e58ec01c"},"24164":{"$oid":"6527b1d099826ba7e58fb68c"},"23947":{"$oid":"6527b25299826ba7e5915a83"},"23836":{"$oid":"6527b18899826ba7e58edc11"},"24396":{"$oid":"6527b25d99826ba7e59183c1"},"24703":{"$oid":"6527b17599826ba7e58eb5cc"},"24437":{"$oid":"6527b27399826ba7e591cf23"},"24535":{"$oid":"6527b18199826ba7e58ed01c"},"24111":{"$oid":"6527b2c199826ba7e592e9b2"},"24113":{"$oid":"6527b19599826ba7e58ef240"},"24999":{"$oid":"6527b17999826ba7e58ebfa0"},"23858":{"$oid":"6527b17599826ba7e58eb7c8"},"24662":{"$oid":"6527b2c999826ba7e5930962"},"24807":{"$oid":"6527b19399826ba7e58eebf7"},"24543":{"$oid":"6527b17a99826ba7e58ec300"},"25003":{"$oid":"6527b17c99826ba7e58ec66e"},"24827":{"$oid":"6527b18899826ba7e58ed8d8"},"24002":{"$oid":"6527b19599826ba7e58ef130"},"24413":{"$oid":"6527b20599826ba7e59063f1"},"23799":{"$oid":"6527b19199826ba7e58eeb8a"},"24596":{"$oid":"6527b2e299826ba7e5936823"},"24242":{"$oid":"6527b1f299826ba7e59029b8"},"24034":{"$oid":"6527b17999826ba7e58ebfe3"},"23932":{"$oid":"6527b18d99826ba7e58ee04f"},"24547":{"$oid":"6527b25199826ba7e591589a"},"24544":{"$oid":"6527b25899826ba7e5916dc0"},"25035":{"$oid":"6527b18f99826ba7e58ee44a"},"24805":{"$oid":"6527b19799826ba7e58ef64d"},"24373":{"$oid":"6527b19799826ba7e58ef423"},"24337":{"$oid":"6527b18399826ba7e58ed1ce"},"24362":{"$oid":"6527b19599826ba7e58ef075"},"24393":{"$oid":"6527b27899826ba7e591dffd"},"24500":{"$oid":"6527b17999826ba7e58ebdfd"},"23921":{"$oid":"6527b18899826ba7e58ed8f6"},"23829":{"$oid":"6527b18699826ba7e58ed744"},"24124":{"$oid":"6527b27f99826ba7e591fb0e"},"24792":{"$oid":"6527b20299826ba7e5905e14"},"24138":{"$oid":"6527b24499826ba7e5912736"},"24963":{"$oid":"6527b2ed99826ba7e5938984"},"24561":{"$oid":"6527b24f99826ba7e5914df9"},"24513":{"$oid":"6527b23e99826ba7e5911344"},"23986":{"$oid":"6527b21599826ba7e5909647"},"24921":{"$oid":"6527b19399826ba7e58eece2"},"24801":{"$oid":"6527b18199826ba7e58ecde7"},"24343":{"$oid":"6527b2a099826ba7e592682d"},"23911":{"$oid":"6527b17999826ba7e58ebe5c"},"24154":{"$oid":"6527b19799826ba7e58ef581"},"24775":{"$oid":"6527b2ba99826ba7e592cf12"},"24866":{"$oid":"6527b19999826ba7e58ef983"},"24432":{"$oid":"6527b18d99826ba7e58ee3b7"},"24714":{"$oid":"6527b20f99826ba7e590842b"},"24224":{"$oid":"6527b18699826ba7e58ed840"},"24318":{"$oid":"6527b2bf99826ba7e592e1c3"},"24622":{"$oid":"6527b19399826ba7e58eee50"},"24655":{"$oid":"6527b17a99826ba7e58ec27b"},"23961":{"$oid":"6527b23599826ba7e590f9ab"},"24878":{"$oid":"6527b2aa99826ba7e5928f37"},"24240":{"$oid":"6527b26399826ba7e5919a39"},"24772":{"$oid":"6527b19999826ba7e58ef902"},"24748":{"$oid":"6527b17c99826ba7e58ec6be"},"24458":{"$oid":"6527b1be99826ba7e58f7787"},"24640":{"$oid":"6527b17599826ba7e58eb6f4"},"24173":{"$oid":"6527b17399826ba7e58eb181"},"24353":{"$oid":"6527b19399826ba7e58eed73"},"24689":{"$oid":"6527b1a299826ba7e58f197a"},"24193":{"$oid":"6527b23e99826ba7e59112d6"},"24043":{"$oid":"6527b2f799826ba7e593b145"},"24905":{"$oid":"6527b19999826ba7e58ef83d"},"24931":{"$oid":"6527b29699826ba7e59243f0"},"24934":{"$oid":"6527b23499826ba7e590f4db"},"24494":{"$oid":"6527b18d99826ba7e58ee3fa"},"24195":{"$oid":"6527b17a99826ba7e58ec2d2"},"24348":{"$oid":"6527b1d599826ba7e58fc830"},"24504":{"$oid":"6527b2c099826ba7e592e4e5"},"24828":{"$oid":"6527b29899826ba7e5924dff"},"24545":{"$oid":"6527b17e99826ba7e58ecb6a"},"24214":{"$oid":"6527b1cc99826ba7e58fa88a"},"24178":{"$oid":"6527b17399826ba7e58eb3ce"},"24799":{"$oid":"6527b27e99826ba7e591f4c7"},"24101":{"$oid":"6527b28899826ba7e592173a"},"24282":{"$oid":"6527b17999826ba7e58ebdd3"},"23842":{"$oid":"6527b2f499826ba7e593a3da"},"24013":{"$oid":"6527b18699826ba7e58ed5fc"},"24745":{"$oid":"6527b2b399826ba7e592b310"},"23985":{"$oid":"6527b19799826ba7e58ef6f6"},"24503":{"$oid":"6527b2a199826ba7e5926d07"},"24986":{"$oid":"6527b19199826ba7e58ee968"},"24614":{"$oid":"6527b19999826ba7e58ef88f"},"25047":{"$oid":"6527b17999826ba7e58ebd4d"},"24558":{"$oid":"6527b17999826ba7e58ebfe1"},"24493":{"$oid":"6527b20799826ba7e5906e4a"},"23893":{"$oid":"6527b19399826ba7e58eed34"},"24358":{"$oid":"6527b17a99826ba7e58ec2f8"},"24129":{"$oid":"6527b18f99826ba7e58ee58c"},"24994":{"$oid":"6527b17e99826ba7e58ec94f"},"24798":{"$oid":"6527b17a99826ba7e58ec480"},"24668":{"$oid":"6527b18399826ba7e58ed2cd"},"24378":{"$oid":"6527b18699826ba7e58ed498"},"24176":{"$oid":"6527b17a99826ba7e58ec201"},"24201":{"$oid":"6527b27799826ba7e591db36"},"24698":{"$oid":"6527b1bd99826ba7e58f71f7"},"24221":{"$oid":"6527b2cc99826ba7e593123f"},"24991":{"$oid":"6527b19599826ba7e58ef132"},"24217":{"$oid":"6527b18399826ba7e58ed2de"},"24871":{"$oid":"6527b18b99826ba7e58edf8e"},"24400":{"$oid":"6527b21e99826ba7e590b14e"},"25010":{"$oid":"6527b17399826ba7e58eb3e1"},"24374":{"$oid":"6527b1a899826ba7e58f3211"},"24707":{"$oid":"6527b18d99826ba7e58ee2d4"},"24306":{"$oid":"6527b21a99826ba7e590a794"},"23928":{"$oid":"6527b1df99826ba7e58fe7b0"},"24922":{"$oid":"6527b17e99826ba7e58ecc97"},"24236":{"$oid":"6527b23c99826ba7e5910b5f"},"25025":{"$oid":"6527b2c899826ba7e592ff29"},"23917":{"$oid":"6527b2ad99826ba7e5929a7b"},"25021":{"$oid":"6527b19c99826ba7e58efde6"},"24064":{"$oid":"6527b18d99826ba7e58ee0b4"},"24658":{"$oid":"6527b18399826ba7e58ed3be"},"23848":{"$oid":"6527b17c99826ba7e58ec7ed"},"24755":{"$oid":"6527b1aa99826ba7e58f39bc"},"24202":{"$oid":"6527b2de99826ba7e5935353"},"24140":{"$oid":"6527b18d99826ba7e58ee035"},"24564":{"$oid":"6527b20299826ba7e5905bd9"},"23948":{"$oid":"6527b19999826ba7e58ef898"},"23817":{"$oid":"6527b18399826ba7e58ed17c"},"24925":{"$oid":"6527b18b99826ba7e58edd2f"},"23831":{"$oid":"6527b17599826ba7e58eb5b9"},"24231":{"$oid":"6527b2dc99826ba7e5934cb1"},"24238":{"$oid":"6527b19199826ba7e58ee937"},"23838":{"$oid":"6527b1f699826ba7e59037d2"},"24998":{"$oid":"6527b19199826ba7e58ee99a"},"24383":{"$oid":"6527b19999826ba7e58ef8e6"},"24826":{"$oid":"6527b17999826ba7e58ebfb3"},"24964":{"$oid":"6527b17799826ba7e58ebc59"},"24691":{"$oid":"6527b23f99826ba7e5911844"},"25054":{"$oid":"6527b19599826ba7e58ef344"},"23823":{"$oid":"6527b19599826ba7e58ef2d5"},"24575":{"$oid":"6527b29099826ba7e5923375"},"24858":{"$oid":"6527b17799826ba7e58ebaee"},"24752":{"$oid":"6527b17399826ba7e58eb31f"},"24924":{"$oid":"6527b19e99826ba7e58f0731"},"24909":{"$oid":"6527b26699826ba7e5919f85"},"24430":{"$oid":"6527b2fa99826ba7e593bafe"},"24774":{"$oid":"6527b1b099826ba7e58f4798"},"24336":{"$oid":"6527b19799826ba7e58ef56d"},"24645":{"$oid":"6527b18199826ba7e58ed015"},"24857":{"$oid":"6527b1a499826ba7e58f1f6d"},"24832":{"$oid":"6527b18699826ba7e58ed601"},"23934":{"$oid":"6527b18899826ba7e58ed997"},"24407":{"$oid":"6527b1a199826ba7e58f142c"},"24724":{"$oid":"6527b17799826ba7e58ebb6e"},"24267":{"$oid":"6527b18399826ba7e58ed1df"},"24528":{"$oid":"6527b2b999826ba7e592c851"},"24676":{"$oid":"6527b17799826ba7e58ebc9d"},"24665":{"$oid":"6527b17799826ba7e58ebc85"},"23861":{"$oid":"6527b18199826ba7e58ed08a"},"24450":{"$oid":"6527b1c799826ba7e58f997b"},"23903":{"$oid":"6527b19399826ba7e58eec37"},"24768":{"$oid":"6527b1e699826ba7e5900333"},"24375":{"$oid":"6527b2ae99826ba7e5929e10"},"24928":{"$oid":"6527b17a99826ba7e58ec12a"},"24387":{"$oid":"6527b19199826ba7e58ee8ee"},"24191":{"$oid":"6527b18b99826ba7e58eddd3"},"24075":{"$oid":"6527b17e99826ba7e58ec974"},"25027":{"$oid":"6527b2b199826ba7e592acce"},"23819":{"$oid":"6527b18b99826ba7e58edc74"},"24225":{"$oid":"6527b19199826ba7e58eeaa9"},"24523":{"$oid":"6527b17c99826ba7e58ec830"},"24911":{"$oid":"6527b1da99826ba7e58fd2ba"},"23935":{"$oid":"6527b17999826ba7e58ebe27"},"25037":{"$oid":"6527b18d99826ba7e58ee1fb"},"23896":{"$oid":"6527b24099826ba7e5911b42"},"24664":{"$oid":"6527b1a399826ba7e58f1c18"},"24837":{"$oid":"6527b2f299826ba7e5939c28"},"24044":{"$oid":"6527b29699826ba7e59246e6"},"24767":{"$oid":"6527b19999826ba7e58efaa0"},"24237":{"$oid":"6527b26a99826ba7e591b6a2"},"24661":{"$oid":"6527b19599826ba7e58ef288"},"23803":{"$oid":"6527b17e99826ba7e58eca25"},"23931":{"$oid":"6527b21c99826ba7e590adca"},"24967":{"$oid":"6527b17599826ba7e58eb732"},"24780":{"$oid":"6527b17399826ba7e58eb318"},"24448":{"$oid":"6527b29499826ba7e5923fb0"},"24671":{"$oid":"6527b18d99826ba7e58ee039"},"24560":{"$oid":"6527b28299826ba7e592047e"},"24080":{"$oid":"6527b19799826ba7e58ef5bc"},"24571":{"$oid":"6527b17c99826ba7e58ec4e5"},"24426":{"$oid":"6527b26399826ba7e59198e3"},"24434":{"$oid":"6527b1a799826ba7e58f2b65"},"24551":{"$oid":"6527b19399826ba7e58eefcc"},"24354":{"$oid":"6527b2e199826ba7e59360c7"},"24705":{"$oid":"6527b1d099826ba7e58fb636"},"24283":{"$oid":"6527b17999826ba7e58ebd4e"},"24272":{"$oid":"6527b17c99826ba7e58ec6ac"},"24747":{"$oid":"6527b24799826ba7e59134ea"},"24607":{"$oid":"6527b1b999826ba7e58f6211"},"24816":{"$oid":"6527b20799826ba7e5906c91"},"24604":{"$oid":"6527b19399826ba7e58eedee"},"23902":{"$oid":"6527b1ab99826ba7e58f3b4b"},"24051":{"$oid":"6527b17999826ba7e58ebe25"},"24987":{"$oid":"6527b19199826ba7e58ee9cb"},"24721":{"$oid":"6527b1d299826ba7e58fbebe"},"24485":{"$oid":"6527b19599826ba7e58ef088"},"24308":{"$oid":"6527b2de99826ba7e5935391"},"24712":{"$oid":"6527b1d799826ba7e58fcc72"},"24562":{"$oid":"6527b2e499826ba7e5936e72"},"24590":{"$oid":"6527b17c99826ba7e58ec708"},"24435":{"$oid":"6527b1d199826ba7e58fb7fc"},"24779":{"$oid":"6527b18699826ba7e58ed740"},"24552":{"$oid":"6527b28e99826ba7e5922b1a"},"24422":{"$oid":"6527b1f999826ba7e59040d1"},"24989":{"$oid":"6527b25a99826ba7e591750a"},"24271":{"$oid":"6527b1e699826ba7e59004b9"},"24389":{"$oid":"6527b1a299826ba7e58f16f4"},"24190":{"$oid":"6527b2f899826ba7e593b436"},"24889":{"$oid":"6527b2c399826ba7e592ef68"},"24446":{"$oid":"6527b17399826ba7e58eb1dd"},"25002":{"$oid":"6527b1f799826ba7e590396a"},"23868":{"$oid":"6527b2a599826ba7e5927800"},"24137":{"$oid":"6527b1da99826ba7e58fd405"},"24070":{"$oid":"6527b2df99826ba7e5935547"},"23981":{"$oid":"6527b2b699826ba7e592be0a"},"24782":{"$oid":"6527b2f599826ba7e593aa15"},"24613":{"$oid":"6527b19599826ba7e58ef1f2"},"24484":{"$oid":"6527b2af99826ba7e592a34b"},"24277":{"$oid":"6527b2e199826ba7e5936104"},"23837":{"$oid":"6527b2cc99826ba7e5930fea"},"24074":{"$oid":"6527b1a299826ba7e58f176a"},"24672":{"$oid":"6527b2bc99826ba7e592d253"},"24352":{"$oid":"6527b1ba99826ba7e58f6846"},"23897":{"$oid":"6527b1e499826ba7e58ffb4a"},"24338":{"$oid":"6527b18399826ba7e58ed47b"},"24012":{"$oid":"6527b18199826ba7e58ecf7e"},"24258":{"$oid":"6527b17399826ba7e58eb43c"},"24675":{"$oid":"6527b19999826ba7e58efa02"},"24329":{"$oid":"6527b18899826ba7e58edbcc"},"24908":{"$oid":"6527b17999826ba7e58ebfcf"},"24119":{"$oid":"6527b1f999826ba7e5904252"},"24764":{"$oid":"6527b19999826ba7e58ef972"},"24915":{"$oid":"6527b22b99826ba7e590dad5"},"24050":{"$oid":"6527b20599826ba7e590652c"},"24266":{"$oid":"6527b25c99826ba7e5917ca4"},"24126":{"$oid":"6527b19199826ba7e58eeb39"},"23942":{"$oid":"6527b19999826ba7e58ef7d8"},"24116":{"$oid":"6527b28399826ba7e59206bf"},"24447":{"$oid":"6527b2c899826ba7e5930336"},"23930":{"$oid":"6527b18399826ba7e58ed167"},"24479":{"$oid":"6527b17c99826ba7e58ec70b"},"24557":{"$oid":"6527b18399826ba7e58ed388"},"24300":{"$oid":"6527b18b99826ba7e58edf79"},"24440":{"$oid":"6527b19799826ba7e58ef47a"},"24778":{"$oid":"6527b18399826ba7e58ed230"},"24770":{"$oid":"6527b17a99826ba7e58ec1fc"},"23967":{"$oid":"6527b19199826ba7e58eeaa1"},"24418":{"$oid":"6527b23199826ba7e590ed0a"},"24305":{"$oid":"6527b19199826ba7e58eeb24"},"24161":{"$oid":"6527b17e99826ba7e58ec92b"},"24259":{"$oid":"6527b17999826ba7e58ebfc9"},"24533":{"$oid":"6527b1a199826ba7e58f0f7f"},"24347":{"$oid":"6527b27e99826ba7e591f1b4"},"24102":{"$oid":"6527b24099826ba7e5911c85"},"24189":{"$oid":"6527b1a899826ba7e58f2ff0"},"24390":{"$oid":"6527b19799826ba7e58ef72e"},"24472":{"$oid":"6527b18d99826ba7e58ee0cd"},"24711":{"$oid":"6527b24a99826ba7e5913ee2"},"24288":{"$oid":"6527b17c99826ba7e58ec54d"},"24885":{"$oid":"6527b19399826ba7e58eee10"},"23962":{"$oid":"6527b17399826ba7e58eb1fd"},"24685":{"$oid":"6527b17e99826ba7e58ec994"},"24452":{"$oid":"6527b28299826ba7e59204dd"},"24639":{"$oid":"6527b18d99826ba7e58ee1ef"},"24359":{"$oid":"6527b1ec99826ba7e59016a0"},"24680":{"$oid":"6527b26399826ba7e591989c"},"24569":{"$oid":"6527b1b399826ba7e58f5133"},"24844":{"$oid":"6527b18899826ba7e58ed9d5"},"23960":{"$oid":"6527b1a999826ba7e58f3279"},"24203":{"$oid":"6527b18f99826ba7e58ee508"},"24744":{"$oid":"6527b25599826ba7e59164af"},"24541":{"$oid":"6527b28b99826ba7e5921d68"},"24067":{"$oid":"6527b17399826ba7e58eb2a7"},"24936":{"$oid":"6527b26799826ba7e591a698"},"24474":{"$oid":"6527b19999826ba7e58ef9df"},"24364":{"$oid":"6527b2ce99826ba7e59318cf"},"24280":{"$oid":"6527b17c99826ba7e58ec80d"},"24291":{"$oid":"6527b2a199826ba7e5926bed"},"24565":{"$oid":"6527b25099826ba7e59153d1"},"24333":{"$oid":"6527b26e99826ba7e591bf71"},"24491":{"$oid":"6527b2c399826ba7e592ef7e"},"24739":{"$oid":"6527b19399826ba7e58eec66"},"24567":{"$oid":"6527b2d599826ba7e5933099"},"24415":{"$oid":"6527b1cc99826ba7e58fa847"},"24974":{"$oid":"6527b17799826ba7e58ebc63"},"24880":{"$oid":"6527b2c499826ba7e592f5f3"},"25032":{"$oid":"6527b20799826ba7e5906c52"},"24255":{"$oid":"6527b17c99826ba7e58ec802"},"24441":{"$oid":"6527b19399826ba7e58eed8b"},"24177":{"$oid":"6527b1b599826ba7e58f56c7"},"23993":{"$oid":"6527b18d99826ba7e58ee147"},"24749":{"$oid":"6527b1ab99826ba7e58f3a85"},"24226":{"$oid":"6527b1e399826ba7e58ff5de"},"24310":{"$oid":"6527b17399826ba7e58eb424"},"24460":{"$oid":"6527b19399826ba7e58eec27"},"24864":{"$oid":"6527b18399826ba7e58ed103"},"24727":{"$oid":"6527b25899826ba7e5916dc6"},"24118":{"$oid":"6527b21199826ba7e5908db5"},"24572":{"$oid":"6527b18199826ba7e58ecfbe"},"25055":{"$oid":"6527b18899826ba7e58ed9d2"},"24510":{"$oid":"6527b17e99826ba7e58ecbce"},"24667":{"$oid":"6527b17e99826ba7e58ecb85"},"24753":{"$oid":"6527b17799826ba7e58ebaf2"},"23908":{"$oid":"6527b18899826ba7e58eda34"},"23953":{"$oid":"6527b2a899826ba7e5928938"},"25033":{"$oid":"6527b24399826ba7e59125be"},"24174":{"$oid":"6527b17a99826ba7e58ec48b"},"24790":{"$oid":"6527b28799826ba7e592122c"},"24218":{"$oid":"6527b19799826ba7e58ef73b"},"24330":{"$oid":"6527b2cb99826ba7e5930b66"},"24899":{"$oid":"6527b2d699826ba7e593335c"},"24861":{"$oid":"6527b19e99826ba7e58f04df"},"23936":{"$oid":"6527b22b99826ba7e590d9f4"},"24381":{"$oid":"6527b29399826ba7e5923eff"},"24927":{"$oid":"6527b18b99826ba7e58eddf1"},"24896":{"$oid":"6527b18199826ba7e58ecd60"},"24722":{"$oid":"6527b17c99826ba7e58ec543"},"24251":{"$oid":"6527b1b499826ba7e58f51fb"},"24107":{"$oid":"6527b17999826ba7e58ebdff"},"24086":{"$oid":"6527b1e199826ba7e58ff171"},"24750":{"$oid":"6527b2b099826ba7e592a5fb"},"24895":{"$oid":"6527b18399826ba7e58ed3e9"},"23864":{"$oid":"6527b17999826ba7e58ebfee"}},"func":{"24286":"std::string get_wml_location(const std::string &filename, const std::string &current_dir)\n{\n\tDBG_FS << \"STR\" << std::endl;\n\n\tassert(game_config::path.empty() == false);\n\n\tstd::string result;\n\n\tif (filename.empty()) {\n\t\tLOG_FS << \"STR\" << std::endl;\n\t\treturn result;\n\t}\n\n\tif (filename.find(\"STR\") != std::string::npos) {\n\t\tERR_FS << \"STR\" << std::endl;\n\t\treturn result;\n\t}\n\n\tbool already_found = false;\n\n\tif (filename[0] == '~')\n\t{\n\t\t\n\t\tresult = get_user_data_dir() + \"STR\" + filename.substr(1);\n\t\tDBG_FS << \"STR\" << std::endl;\n\n\t\talready_found = file_exists(result) || is_directory(result);\n\t}\n\telse if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '\/')\n\t{\n\t\t\n\t\t\n\n\t\tif (!current_dir.empty())\n\t\t{\n\t\t\tresult = current_dir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = game_config::path;\n\t\t}\n\n\t\tresult += filename.substr(2);\n\t}\n\telse if (!game_config::path.empty())\n\t\tresult = game_config::path + \"STR\" + filename;\n\n\tDBG_FS << \"STR\" << std::endl;\n\n\tif (result.empty() ||\n\t    (!already_found && !file_exists(result) && !is_directory(result)))\n\t{\n\t\tDBG_FS << \"STR\" << std::endl;\n\t\tresult.clear();\n\t}\n\telse\n\t\tDBG_FS << \"STR\" << std::endl;\n\n\treturn result;\n}","24372":"Status RunRestore(const RunOptions& run_options, const string& export_dir,\n                  const StringPiece restore_op_name,\n                  const StringPiece variable_filename_const_op_name,\n                  const std::vector<AssetFileDef>& asset_file_defs,\n                  Session* session) {\n  LOG(INFO) << \"STR\";\n  \n  const string variables_directory =\n      io::JoinPath(export_dir, kSavedModelVariablesDirectory);\n  \n  \n  \n  const string variables_index_path = io::JoinPath(\n      variables_directory, MetaFilename(kSavedModelVariablesFilename));\n  if (!Env::Default()->FileExists(variables_index_path).ok()) {\n    LOG(INFO) << \"STR\"\n                 \"STR\"\n              << variables_index_path;\n    return Status::OK();\n  }\n  const string variables_path =\n      io::JoinPath(variables_directory, kSavedModelVariablesFilename);\n\n  \n  Tensor variables_path_tensor(DT_STRING, TensorShape({}));\n  variables_path_tensor.scalar<tstring>()() = variables_path;\n\n  std::vector<std::pair<string, Tensor>> inputs = {\n      {string(variable_filename_const_op_name), variables_path_tensor}};\n\n  AddAssetsTensorsToInputs(export_dir, asset_file_defs, &inputs);\n\n  RunMetadata run_metadata;\n  return RunOnce(run_options, inputs, {}, {string(restore_op_name)},\n                 nullptr , &run_metadata, session);\n}","24726":"gdIOCtx * gdNewDynamicCtxEx (int initialSize, void *data, int freeOKFlag)\n{\n\tdpIOCtx *ctx;\n\tdynamicPtr *dp;\n\n\tctx = (dpIOCtx *) gdMalloc (sizeof (dpIOCtx));\n\n\tdp = newDynamic(initialSize, data, freeOKFlag);\n\n\tctx->dp = dp;\n\n\tctx->ctx.getC = dynamicGetchar;\n\tctx->ctx.putC = dynamicPutchar;\n\n\tctx->ctx.getBuf = dynamicGetbuf;\n\tctx->ctx.putBuf = dynamicPutbuf;\n\n\tctx->ctx.seek = dynamicSeek;\n\tctx->ctx.tell = dynamicTell;\n\n\tctx->ctx.gd_free = gdFreeDynamicCtx;\n\n\treturn (gdIOCtx *) ctx;\n}","24716":"void gf_filter_check_output_reconfig(GF_Filter *filter)\n{\n\tu32 i, j;\n\t\n\tif (!filter->reconfigure_outputs) return;\n\tfilter->reconfigure_outputs = GF_FALSE;\n\t\n\tfor (i=0; i<filter->num_output_pids; i++) {\n\t\tGF_FilterPid *pid = gf_list_get(filter->output_pids, i);\n\t\tfor (j=0; j<pid->num_destinations; j++) {\n\t\t\tGF_FilterPidInst *pidi = gf_list_get(pid->destinations, j);\n\t\t\t\n\t\t\tif (pidi->reconfig_pid_props) {\n\t\t\t\tassert(pidi->props);\n\t\t\t\tif (pidi->props != pidi->reconfig_pid_props) {\n\t\t\t\t\t\n\t\t\t\t\tassert(pidi->props->reference_count);\n\t\t\t\t\tif (safe_int_dec(& pidi->props->reference_count) == 0) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tgf_mx_p(pidi->pid->filter->tasks_mx);\n\t\t\t\t\t\tgf_list_del_item(pidi->pid->properties, pidi->props);\n\t\t\t\t\t\tgf_mx_v(pidi->pid->filter->tasks_mx);\n\t\t\t\t\t\tgf_props_del(pidi->props);\n\t\t\t\t\t}\n\t\t\t\t\tpidi->props = pidi->reconfig_pid_props;\n\t\t\t\t\tsafe_int_inc( & pidi->props->reference_count );\n\t\t\t\t}\n\t\t\t\tpidi->reconfig_pid_props = NULL;\n\t\t\t\tgf_fs_post_task(filter->session, gf_filter_pid_reconfigure_task, pidi->filter, pid, \"STR\", NULL);\n\t\t\t}\n\t\t}\n\t}\n}","25001":"RoleName RoleName::parseFromBSON(const BSONElement& elem) {\n    auto obj = elem.embeddedObjectUserCheck();\n    std::array<BSONElement, 2> fields;\n    obj.getFields(\n        {AuthorizationManager::ROLE_NAME_FIELD_NAME, AuthorizationManager::ROLE_DB_FIELD_NAME},\n        &fields);\n    const auto& nameField = fields[0];\n    uassert(ErrorCodes::BadValue,\n            str::stream() << \"STR\"\n                          << AuthorizationManager::ROLE_NAME_FIELD_NAME,\n            nameField.type() == String);\n\n    const auto& dbField = fields[1];\n    uassert(ErrorCodes::BadValue,\n            str::stream() << \"STR\"\n                          << AuthorizationManager::ROLE_DB_FIELD_NAME,\n            nameField.type() == String);\n\n    return RoleName(nameField.valueStringData(), dbField.valueStringData());\n}","24168":"static int kvm_cpu_accept_dm_intr(struct kvm_vcpu *vcpu)\n{\n\t\n\tif (kvm_cpu_has_extint(vcpu))\n\t\treturn false;\n\n\t\n\treturn (!lapic_in_kernel(vcpu) ||\n\t\tkvm_apic_accept_pic_intr(vcpu));\n}","25019":"\nstatic int netdev_uevent(struct device *d, struct kobj_uevent_env *env)\n{\n\tstruct net_device *dev = to_net_dev(d);\n\tint retval;\n\n\t\n\tretval = add_uevent_var(env, \"STR\", dev->name);\n\tif (retval)\n\t\tgoto exit;\n\n\t\n\tretval = add_uevent_var(env, \"STR\", dev->ifindex);\n\nexit:\n\treturn retval;","25030":"strip_special_chars (std::string& str, char* special_chars, bool start)\n{\n  std::string::size_type idx;\n\n  unsigned i = 0;\n  while (i < strlen (special_chars)) {\n    idx = str.find_first_of (special_chars[i]);\n    if (idx != std::string::npos) {\n      if (start)\n        str = str.substr (idx+1);\n      else\n        str = str.substr (0, idx);\n    }\n    i++;\n  }\n}","24386":"static int vm_stat_get_per_vm_open(struct inode *inode, struct file *file)\n{\n\t__simple_attr_check_format(\"STR\", 0ull);\n\treturn kvm_debugfs_open(inode, file, vm_stat_get_per_vm,\n\t\t\t\tvm_stat_clear_per_vm, \"STR\");\n}","24700":"Pl_Count::write(unsigned char* buf, size_t len)\n{\n    if (len)\n    {\n\tthis->count += len;\n\tgetNext()->write(buf, len);\n\tthis->last_char = buf[len - 1];\n    }\n}","24181":"void qxl_render_update(PCIQXLDevice *qxl)\n{\n    VGACommonState *vga = &qxl->vga;\n    QXLRect dirty[32], update;\n    void *ptr;\n    int i;\n\n    if (qxl->guest_primary.resized) {\n        qxl->guest_primary.resized = 0;\n\n        if (qxl->guest_primary.flipped) {\n            qemu_free(qxl->guest_primary.flipped);\n            qxl->guest_primary.flipped = NULL;\n        }\n        qemu_free_displaysurface(vga->ds);\n\n        qxl->guest_primary.data = qemu_get_ram_ptr(qxl->vga.vram_offset);\n        if (qxl->guest_primary.stride < 0) {\n            \n            qxl->guest_primary.stride = -qxl->guest_primary.stride;\n            qxl->guest_primary.flipped = qemu_malloc(qxl->guest_primary.surface.width *\n                                                     qxl->guest_primary.stride);\n            ptr = qxl->guest_primary.flipped;\n        } else {\n            ptr = qxl->guest_primary.data;\n        }\n        dprint(qxl, 1, \"STR\",\n               __FUNCTION__,\n               qxl->guest_primary.surface.width,\n               qxl->guest_primary.surface.height,\n               qxl->guest_primary.stride,\n               qxl->guest_primary.bytes_pp,\n               qxl->guest_primary.bits_pp,\n               qxl->guest_primary.flipped ? \"STR\");\n        vga->ds->surface =\n            qemu_create_displaysurface_from(qxl->guest_primary.surface.width,\n                                            qxl->guest_primary.surface.height,\n                                            qxl->guest_primary.bits_pp,\n                                            qxl->guest_primary.stride,\n                                            ptr);\n        dpy_resize(vga->ds);\n    }\n\n    if (!qxl->guest_primary.commands) {\n        return;\n    }\n    qxl->guest_primary.commands = 0;\n\n    update.left   = 0;\n    update.right  = qxl->guest_primary.surface.width;\n    update.top    = 0;\n    update.bottom = qxl->guest_primary.surface.height;\n\n    memset(dirty, 0, sizeof(dirty));\n    qxl_spice_update_area(qxl, 0, &update,\n                          dirty, ARRAY_SIZE(dirty), 1);\n\n    for (i = 0; i < ARRAY_SIZE(dirty); i++) {\n        if (qemu_spice_rect_is_empty(dirty+i)) {\n            break;\n        }\n        if (qxl->guest_primary.flipped) {\n            qxl_flip(qxl, dirty+i);\n        }\n        dpy_update(vga->ds,\n                   dirty[i].left, dirty[i].top,\n                   dirty[i].right - dirty[i].left,\n                   dirty[i].bottom - dirty[i].top);\n    }\n}","24263":"static uint get_alen(char *arg, int default_len)\n{\n\tint\tj;\n\tint\talen;\n\n\talen = default_len;\n\tfor (j = 0; j < 8; j++) {\n\t\tif (arg[j] == '.') {\n\t\t\talen = arg[j+1] - '0';\n\t\t\tbreak;\n\t\t} else if (arg[j] == '\\0')\n\t\t\tbreak;\n\t}\n\treturn alen;\n}","24079":"rsvg_new_filter_primitive_turbulence (void)\n{\n    RsvgFilterPrimitiveTurbulence *filter;\n    filter = g_new (RsvgFilterPrimitiveTurbulence, 1);\n    _rsvg_node_init (&filter->super.super);\n    filter->super.in = g_string_new (\"STR\");\n    filter->super.result = g_string_new (\"STR\");\n    filter->super.x.factor = filter->super.y.factor = filter->super.width.factor =\n        filter->super.height.factor = 'n';\n    filter->fBaseFreqX = 0;\n    filter->fBaseFreqY = 0;\n    filter->nNumOctaves = 1;\n    filter->seed = 0;\n    filter->bDoStitching = 0;\n    filter->bFractalSum = 0;\n    feTurbulence_init (filter);\n    filter->super.render = &rsvg_filter_primitive_turbulence_render;\n    filter->super.super.free = &rsvg_filter_primitive_turbulence_free;\n    filter->super.super.set_atts = rsvg_filter_primitive_turbulence_set_atts;\n    return (RsvgNode *) filter;\n}","23839":"tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d) {\n  return d->m_prev_return_status;\n}","24094":"int sqlite3Fts3MsrOvfl(\n  Fts3Cursor *pCsr, \n  Fts3MultiSegReader *pMsr,\n  int *pnOvfl\n){\n  Fts3Table *p = (Fts3Table*)pCsr->base.pVtab;\n  int nOvfl = 0;\n  int ii;\n  int rc = SQLITE_OK;\n  int pgsz = p->nPgsz;\n\n  assert( p->bFts4 );\n  assert( pgsz>0 );\n\n  for(ii=0; rc==SQLITE_OK && ii<pMsr->nSegment; ii++){\n    Fts3SegReader *pReader = pMsr->apSegment[ii];\n    if( !fts3SegReaderIsPending(pReader) \n     && !fts3SegReaderIsRootOnly(pReader) \n    ){\n      sqlite3_int64 jj;\n      for(jj=pReader->iStartBlock; jj<=pReader->iLeafEndBlock; jj++){\n        int nBlob;\n        rc = sqlite3Fts3ReadBlock(p, jj, 0, &nBlob, 0);\n        if( rc!=SQLITE_OK ) break;\n        if( (nBlob+35)>pgsz ){\n          nOvfl += (nBlob + 34)\/pgsz;\n        }\n      }\n    }\n  }\n  *pnOvfl = nOvfl;\n  return rc;\n}","24334":"session_on_connection_window_update_received(nghttp2_session *session,\n                                             nghttp2_frame *frame) {\n  \n  if (frame->window_update.window_size_increment == 0) {\n    return session_handle_invalid_connection(\n        session, frame, NGHTTP2_ERR_PROTO,\n        \"STR\");\n  }\n\n  if (NGHTTP2_MAX_WINDOW_SIZE - frame->window_update.window_size_increment <\n      session->remote_window_size) {\n    return session_handle_invalid_connection(session, frame,\n                                             NGHTTP2_ERR_FLOW_CONTROL, NULL);\n  }\n  session->remote_window_size += frame->window_update.window_size_increment;\n\n  return session_call_on_frame_received(session, frame);\n}","24469":" *\/\nunsigned int skb_find_text(struct sk_buff *skb, unsigned int from,\n\t\t\t   unsigned int to, struct ts_config *config)\n{\n\tstruct ts_state state;\n\tunsigned int ret;\n\n\tconfig->get_next_block = skb_ts_get_next_block;\n\tconfig->finish = skb_ts_finish;\n\n\tskb_prepare_seq_read(skb, from, to, TS_SKB_CB(&state));\n\n\tret = textsearch_find(config, &state);\n\treturn (ret <= to - from ? ret : UINT_MAX);","24054":"int my_redel(const char *org_name, const char *tmp_name, myf MyFlags)\n{\n  int error=1;\n  DBUG_ENTER(\"STR\");\n  DBUG_PRINT(\"STR\",\n\t\t   org_name,tmp_name,MyFlags));\n\n  if (my_copystat(org_name,tmp_name,MyFlags) < 0)\n    goto end;\n  if (MyFlags & MY_REDEL_MAKE_BACKUP)\n  {\n    char name_buff[FN_REFLEN+20];    \n    char ext[20];\n    ext[0]='-';\n    get_date(ext+1,2+4,(time_t) 0);\n    strmov(strend(ext),REDEL_EXT);\n    if (my_rename(org_name, fn_format(name_buff, org_name, \"\", ext, 2),\n\t\t  MyFlags))\n      goto end;\n  }\n  else if (my_delete_allow_opened(org_name, MyFlags))\n      goto end;\n  if (my_rename(tmp_name,org_name,MyFlags))\n    goto end;\n\n  error=0;\nend:\n  DBUG_RETURN(error);\n} ","24115":"static ssize_t waiting_for_supplier_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tbool val;\n\n\tdevice_lock(dev);\n\tmutex_lock(&wfs_lock);\n\tval = !list_empty(&dev->links.needs_suppliers)\n\t      && dev->links.need_for_probe;\n\tmutex_unlock(&wfs_lock);\n\tdevice_unlock(dev);\n\treturn sprintf(buf, \"STR\", val);\n}","24972":"  virtual void initialize() {\n    http2OptionsFromTuple(client_http2_options_, client_settings_);\n    http2OptionsFromTuple(server_http2_options_, server_settings_);\n    client_ = std::make_unique<TestClientConnectionImpl>(\n        client_connection_, client_callbacks_, stats_store_, client_http2_options_,\n        max_request_headers_kb_, max_response_headers_count_, ProdNghttp2SessionFactory::get());\n    server_ = std::make_unique<TestServerConnectionImpl>(\n        server_connection_, server_callbacks_, stats_store_, server_http2_options_,\n        max_request_headers_kb_, max_request_headers_count_, headers_with_underscores_action_);\n\n    request_encoder_ = &client_->newStream(response_decoder_);\n    setupDefaultConnectionMocks();\n\n    EXPECT_CALL(server_callbacks_, newStream(_, _))\n        .WillRepeatedly(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoder& {\n          response_encoder_ = &encoder;\n          encoder.getStream().addCallbacks(server_stream_callbacks_);\n          return request_decoder_;\n        }));\n  }","24542":"static void superres_params(GF_BitStream *bs, AV1State *state)\n{\n\tu32 SuperresDenom;\n\tBool use_superres;\n\n\tif (state->enable_superres) {\n\t\tuse_superres = gf_bs_read_int_log(bs, 1, \"STR\");\n\t}\n\telse {\n\t\tuse_superres = GF_FALSE;\n\t}\n\tif (use_superres) {\n\t\tu8 coded_denom = gf_bs_read_int_log(bs, AV1_SUPERRES_DENOM_BITS, \"STR\");\n\t\tSuperresDenom = coded_denom + AV1_SUPERRES_DENOM_MIN;\n\t}\n\telse {\n\t\tSuperresDenom = AV1_SUPERRES_NUM;\n\t}\n\tstate->UpscaledWidth = state->width;\n\tstate->width = (state->UpscaledWidth * AV1_SUPERRES_NUM + (SuperresDenom \/ 2)) \/ SuperresDenom;\n}","24492":"send_display_mode (GdmSession *self,\n                   GdmSessionConversation *conversation)\n{\n        GdmSessionDisplayMode mode;\n\n        mode = gdm_session_get_display_mode (self);\n        gdm_dbus_worker_call_set_session_display_mode (conversation->worker_proxy,\n                                                       gdm_session_display_mode_to_string (mode),\n                                                       NULL, NULL, NULL);\n}","24018":"static int fuse_xattr_get(const struct xattr_handler *handler,\n\t\t\t struct dentry *dentry, struct inode *inode,\n\t\t\t const char *name, void *value, size_t size)\n{\n\treturn fuse_getxattr(inode, name, value, size);\n}","24935":"static int afiucv_hs_callback_syn(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct sock *nsk;\n\tstruct iucv_sock *iucv, *niucv;\n\tstruct af_iucv_trans_hdr *trans_hdr;\n\tint err;\n\n\tiucv = iucv_sk(sk);\n\ttrans_hdr = (struct af_iucv_trans_hdr *)skb->data;\n\tif (!iucv) {\n\t\t\n\t\tafiucv_swap_src_dest(skb);\n\t\ttrans_hdr->flags = AF_IUCV_FLAG_SYN | AF_IUCV_FLAG_FIN;\n\t\terr = dev_queue_xmit(skb);\n\t\tgoto out;\n\t}\n\n\tnsk = iucv_sock_alloc(NULL, sk->sk_type, GFP_ATOMIC);\n\tbh_lock_sock(sk);\n\tif ((sk->sk_state != IUCV_LISTEN) ||\n\t    sk_acceptq_is_full(sk) ||\n\t    !nsk) {\n\t\t\n\t\tif (nsk)\n\t\t\tsk_free(nsk);\n\t\tafiucv_swap_src_dest(skb);\n\t\ttrans_hdr->flags = AF_IUCV_FLAG_SYN | AF_IUCV_FLAG_FIN;\n\t\terr = dev_queue_xmit(skb);\n\t\tbh_unlock_sock(sk);\n\t\tgoto out;\n\t}\n\n\tniucv = iucv_sk(nsk);\n\tiucv_sock_init(nsk, sk);\n\tniucv->transport = AF_IUCV_TRANS_HIPER;\n\tniucv->msglimit = iucv->msglimit;\n\tif (!trans_hdr->window)\n\t\tniucv->msglimit_peer = IUCV_HIPER_MSGLIM_DEFAULT;\n\telse\n\t\tniucv->msglimit_peer = trans_hdr->window;\n\tmemcpy(niucv->dst_name, trans_hdr->srcAppName, 8);\n\tmemcpy(niucv->dst_user_id, trans_hdr->srcUserID, 8);\n\tmemcpy(niucv->src_name, iucv->src_name, 8);\n\tmemcpy(niucv->src_user_id, iucv->src_user_id, 8);\n\tnsk->sk_bound_dev_if = sk->sk_bound_dev_if;\n\tniucv->hs_dev = iucv->hs_dev;\n\tdev_hold(niucv->hs_dev);\n\tafiucv_swap_src_dest(skb);\n\ttrans_hdr->flags = AF_IUCV_FLAG_SYN | AF_IUCV_FLAG_ACK;\n\ttrans_hdr->window = niucv->msglimit;\n\t\n\terr = dev_queue_xmit(skb);\n\tif (!err) {\n\t\tiucv_accept_enqueue(sk, nsk);\n\t\tnsk->sk_state = IUCV_CONNECTED;\n\t\tsk->sk_data_ready(sk, 1);\n\t} else\n\t\tiucv_sock_kill(nsk);\n\tbh_unlock_sock(sk);\n\nout:\n\treturn NET_RX_SUCCESS;\n}","23850":"aspath_key_make (void *p)\n{\n  struct aspath *aspath = (struct aspath *) p;\n  unsigned int key = 0;\n\n  if (!aspath->str)\n    aspath_str_update (aspath);\n\n  key = jhash (aspath->str, aspath->str_len, 2334325);\n\n  return key;\n}","24766":"f_libcallnr(typval_T *argvars, typval_T *rettv)\n{\n    libcall_common(argvars, rettv, VAR_NUMBER);\n}","24890":"struct page *agp_generic_alloc_page(struct agp_bridge_data *bridge)\n{\n\tstruct page * page;\n\n\tpage = alloc_page(GFP_KERNEL | GFP_DMA32 | __GFP_ZERO);\n\tif (page == NULL)\n\t\treturn NULL;\n\n\tmap_page_into_agp(page);\n\n\tget_page(page);\n\tatomic_inc(&agp_bridge->current_memory_agp);\n\treturn page;\n}","24322":"static int ati_remote2_urb_init(struct ati_remote2 *ar2)\n{\n\tstruct usb_device *udev = ar2->udev;\n\tint i, pipe, maxp;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tar2->buf[i] = usb_alloc_coherent(udev, 4, GFP_KERNEL, &ar2->buf_dma[i]);\n\t\tif (!ar2->buf[i])\n\t\t\treturn -ENOMEM;\n\n\t\tar2->urb[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!ar2->urb[i])\n\t\t\treturn -ENOMEM;\n\n\t\tpipe = usb_rcvintpipe(udev, ar2->ep[i]->bEndpointAddress);\n\t\tmaxp = usb_maxpacket(udev, pipe, usb_pipeout(pipe));\n\t\tmaxp = maxp > 4 ? 4 : maxp;\n\n\t\tusb_fill_int_urb(ar2->urb[i], udev, pipe, ar2->buf[i], maxp,\n\t\t\t\t i ? ati_remote2_complete_key : ati_remote2_complete_mouse,\n\t\t\t\t ar2, ar2->ep[i]->bInterval);\n\t\tar2->urb[i]->transfer_dma = ar2->buf_dma[i];\n\t\tar2->urb[i]->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t}\n\n\treturn 0;\n}","24656":"find_locale (void)\n{\n\tconst char *encoding = nl_langinfo(CODESET);\n\n\tif (!encoding || !*encoding)\n\t\treturn xstrdup(\"STR\");\n\n   return xstrdup(encoding);\n}","24304":"virDomainShutdownFlags(virDomainPtr domain, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"STR\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainShutdownFlags) {\n        int ret;\n        ret = conn->driver->domainShutdownFlags(domain, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}","24791":"static USBEndpoint *xhci_epid_to_usbep(XHCIEPContext *epctx)\n{\n    USBPort *uport;\n    uint32_t token;\n\n    if (!epctx) {\n        return NULL;\n    }\n    uport = epctx->xhci->slots[epctx->slotid - 1].uport;\n    token = (epctx->epid & 1) ? USB_TOKEN_IN : USB_TOKEN_OUT;\n    if (!uport) {\n        return NULL;\n    }\n    return usb_ep_get(uport->dev, token, epctx->epid >> 1);\n}","23810":"void dmar_free_irte(const struct intr_source *intr_src, uint16_t index)\n{\n\tstruct dmar_drhd_rt *dmar_unit;\n\tunion dmar_ir_entry *ir_table, *ir_entry;\n\tunion pci_bdf sid;\n\n\tif (intr_src->is_msi) {\n\t\tdmar_unit = device_to_dmaru((uint8_t)intr_src->src.msi.bits.b, intr_src->src.msi.fields.devfun);\n\t} else {\n\t\tdmar_unit = ioapic_to_dmaru(intr_src->src.ioapic_id, &sid);\n\t}\n\n\tif (is_dmar_unit_valid(dmar_unit, sid)) {\n\t\tir_table = (union dmar_ir_entry *)hpa2hva(dmar_unit->ir_table_addr);\n\t\tir_entry = ir_table + index;\n\t\tir_entry->bits.remap.present = 0x0UL;\n\n\t\tiommu_flush_cache(ir_entry, sizeof(union dmar_ir_entry));\n\t\tdmar_invalid_iec(dmar_unit, index, 0U, false);\n\n\t\tif (!is_irte_reserved(dmar_unit, index)) {\n\t\t\tspinlock_obtain(&dmar_unit->lock);\n\t\t\tbitmap_clear_nolock(index & 0x3FU, &dmar_unit->irte_alloc_bitmap[index >> 6U]);\n\t\t\tspinlock_release(&dmar_unit->lock);\n\t\t}\n\t}\n\n}","25034":"xmlSchemaPValAttrNodeValue(xmlSchemaParserCtxtPtr pctxt,\n\t\t\t   xmlSchemaBasicItemPtr ownerItem,\n\t\t\t   xmlAttrPtr attr,\n\t\t\t   const xmlChar *value,\n\t\t\t   xmlSchemaTypePtr type)\n{\n\n    int ret = 0;\n\n    \n    if ((pctxt == NULL) || (type == NULL) || (attr == NULL))\n\treturn (-1);\n    if (type->type != XML_SCHEMA_TYPE_BASIC) {\n\tPERROR_INT(\"STR\",\n\t    \"STR\");\n\treturn (-1);\n    }\n    switch (type->builtInType) {\n\tcase XML_SCHEMAS_NCNAME:\n\tcase XML_SCHEMAS_QNAME:\n\tcase XML_SCHEMAS_ANYURI:\n\tcase XML_SCHEMAS_TOKEN:\n\tcase XML_SCHEMAS_LANGUAGE:\n\t    ret = xmlSchemaValPredefTypeNode(type, value, NULL,\n\t\t(xmlNodePtr) attr);\n\t    break;\n\tdefault: {\n\t    PERROR_INT(\"STR\",\n\t\t\"STR\"\n\t\t\"STR\");\n\t    return (-1);\n\t}\n    }\n    \n    if (ret < 0) {\n\tPERROR_INT(\"STR\",\n\t    \"STR\");\n\treturn (-1);\n    } else if (ret > 0) {\n\tif (WXS_IS_LIST(type))\n\t    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2;\n\telse\n\t    ret = XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1;\n\txmlSchemaPSimpleTypeErr(pctxt,\n\t    ret, ownerItem, (xmlNodePtr) attr,\n\t    type, NULL, value, NULL, NULL, NULL);\n    }\n    return (ret);\n}","24147":"DefragIPv4TooLargeTest(void)\n{\n    DefragContext *dc = NULL;\n    Packet *p = NULL;\n    int ret = 0;\n\n    DefragInit();\n\n    dc = DefragContextNew();\n    if (dc == NULL)\n        goto end;\n\n    \n    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n    if (p == NULL)\n        goto end;\n\n    \n    if (Defrag(NULL, NULL, p, NULL) != NULL)\n        goto end;\n    if (!ENGINE_ISSET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE))\n        goto end;\n\n    \n    if (dc->frag_pool->outstanding != 0)\n        return 0;\n\n    ret = 1;\nend:\n    if (dc != NULL)\n        DefragContextDestroy(dc);\n    if (p != NULL)\n        SCFree(p);\n\n    DefragDestroy();\n    return ret;\n}","24657":"re_match(regex_t* reg, const char* str, int size, int pos,\n\t struct re_registers* regs)\n{\n  return onig_match(reg, (UChar* )str, (UChar* )(str + size),\n\t\t    (UChar* )(str + pos), regs, ONIG_OPTION_NONE);\n}","24294":"HttpHeader::getList(Http::HdrType id, String *s) const\n{\n    debugs(55, 9, this << \"STR\" << id);\n    \n    assert(Http::HeaderLookupTable.lookup(id).list);\n\n    if (!CBIT_TEST(mask, id))\n        return false;\n\n    for (auto e: entries) {\n        if (e && e->id == id)\n            strListAdd(s, e->value.termedBuf(), ',');\n    }\n\n    \n    \n    if (!s->size())\n        debugs(55, 3, \"STR\");\n    else\n        debugs(55, 6, this << \"STR\" << s);\n\n    return true;\n}","24669":"void mg_http_serve_ssi(struct mg_connection *c, const char *root,\n                       const char *fullpath) {\n  mg_http_reply(c, 501, NULL, \"STR\");\n  (void) root, (void) fullpath;\n}","25014":"}\n\nvoid dynstr_append_sorted(DYNAMIC_STRING* ds, DYNAMIC_STRING *ds_input,\n                          bool keep_header)\n{\n  unsigned i;\n  char *start= ds_input->str;\n  DYNAMIC_ARRAY lines;\n  DBUG_ENTER(\"STR\");\n\n  if (!*start)\n    DBUG_VOID_RETURN;  \n\n  my_init_dynamic_array(&lines, sizeof(const char*), 32, 32);\n\n  if (keep_header)\n  {\n    \n    while (*start && *start != '\\n')\n      start++;\n    start++; \n    dynstr_append_mem(ds, ds_input->str, start - ds_input->str);\n  }\n\n  \n  while (*start)\n  {\n    char* line_end= (char*)start;\n\n    \n    while (*line_end && *line_end != '\\n')\n      line_end++;\n    *line_end= 0;\n\n    \n    if (insert_dynamic(&lines, (uchar*) &start))\n      die(\"STR\");\n\n    start= line_end+1;\n  }\n\n  \n  qsort(lines.buffer, lines.elements,\n        sizeof(char**), (qsort_cmp)comp_lines);\n\n  \n  for (i= 0; i < lines.elements ; i++)\n  {\n    const char **line= dynamic_element(&lines, i, const char**);\n    dynstr_append(ds, *line);\n    dynstr_append(ds, \"STR\");\n  }\n\n  delete_dynamic(&lines);","24526":"void ring_buffer_reset_online_cpus(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tint cpu;\n\n\tfor_each_online_buffer_cpu(buffer, cpu) {\n\t\tcpu_buffer = buffer->buffers[cpu];\n\n\t\tatomic_inc(&cpu_buffer->resize_disabled);\n\t\tatomic_inc(&cpu_buffer->record_disabled);\n\t}\n\n\t\n\tsynchronize_rcu();\n\n\tfor_each_online_buffer_cpu(buffer, cpu) {\n\t\tcpu_buffer = buffer->buffers[cpu];\n\n\t\treset_disabled_cpu_buffer(cpu_buffer);\n\n\t\tatomic_dec(&cpu_buffer->record_disabled);\n\t\tatomic_dec(&cpu_buffer->resize_disabled);\n\t}\n}","24881":"static int iw_conn_req_handler(struct iw_cm_id *cm_id,\n\t\t\t       struct iw_cm_event *iw_event)\n{\n\tstruct rdma_cm_id *new_cm_id;\n\tstruct rdma_id_private *listen_id, *conn_id;\n\tstruct rdma_cm_event event;\n\tint ret;\n\tstruct ib_device_attr attr;\n\tstruct sockaddr *laddr = (struct sockaddr *)&iw_event->local_addr;\n\tstruct sockaddr *raddr = (struct sockaddr *)&iw_event->remote_addr;\n\n\tlisten_id = cm_id->context;\n\tif (cma_disable_callback(listen_id, RDMA_CM_LISTEN))\n\t\treturn -ECONNABORTED;\n\n\t\n\tnew_cm_id = rdma_create_id(listen_id->id.event_handler,\n\t\t\t\t   listen_id->id.context,\n\t\t\t\t   RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(new_cm_id)) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tconn_id = container_of(new_cm_id, struct rdma_id_private, id);\n\tmutex_lock_nested(&conn_id->handler_mutex, SINGLE_DEPTH_NESTING);\n\tconn_id->state = RDMA_CM_CONNECT;\n\n\tret = rdma_translate_ip(laddr, &conn_id->id.route.addr.dev_addr, NULL);\n\tif (ret) {\n\t\tmutex_unlock(&conn_id->handler_mutex);\n\t\trdma_destroy_id(new_cm_id);\n\t\tgoto out;\n\t}\n\n\tret = cma_acquire_dev(conn_id, listen_id);\n\tif (ret) {\n\t\tmutex_unlock(&conn_id->handler_mutex);\n\t\trdma_destroy_id(new_cm_id);\n\t\tgoto out;\n\t}\n\n\tconn_id->cm_id.iw = cm_id;\n\tcm_id->context = conn_id;\n\tcm_id->cm_handler = cma_iw_handler;\n\n\tmemcpy(cma_src_addr(conn_id), laddr, rdma_addr_size(laddr));\n\tmemcpy(cma_dst_addr(conn_id), raddr, rdma_addr_size(raddr));\n\n\tret = ib_query_device(conn_id->id.device, &attr);\n\tif (ret) {\n\t\tmutex_unlock(&conn_id->handler_mutex);\n\t\trdma_destroy_id(new_cm_id);\n\t\tgoto out;\n\t}\n\n\tmemset(&event, 0, sizeof event);\n\tevent.event = RDMA_CM_EVENT_CONNECT_REQUEST;\n\tevent.param.conn.private_data = iw_event->private_data;\n\tevent.param.conn.private_data_len = iw_event->private_data_len;\n\tevent.param.conn.initiator_depth = iw_event->ird;\n\tevent.param.conn.responder_resources = iw_event->ord;\n\n\t\n\tatomic_inc(&conn_id->refcount);\n\tret = conn_id->id.event_handler(&conn_id->id, &event);\n\tif (ret) {\n\t\t\n\t\tconn_id->cm_id.iw = NULL;\n\t\tcma_exch(conn_id, RDMA_CM_DESTROYING);\n\t\tmutex_unlock(&conn_id->handler_mutex);\n\t\tcma_deref_id(conn_id);\n\t\trdma_destroy_id(&conn_id->id);\n\t\tgoto out;\n\t}\n\n\tmutex_unlock(&conn_id->handler_mutex);\n\tcma_deref_id(conn_id);\n\nout:\n\tmutex_unlock(&listen_id->handler_mutex);\n\treturn ret;\n}","24361":"TfLiteStatus Relu1Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  const ReluOpData* data = reinterpret_cast<ReluOpData*>(node->user_data);\n  switch (input->type) {\n    case kTfLiteFloat32: {\n      optimized_ops::Relu1(GetTensorShape(input), GetTensorData<float>(input),\n                           GetTensorShape(output),\n                           GetTensorData<float>(output));\n      return kTfLiteOk;\n    } break;\n    case kTfLiteUInt8: {\n      QuantizedReluX<uint8_t>(-1.0f, 1.0f, input, output, data);\n      return kTfLiteOk;\n    } break;\n    case kTfLiteInt8: {\n      QuantizedReluX<int8_t>(-1, 1, input, output, data);\n      return kTfLiteOk;\n    } break;\n    default:\n      TF_LITE_KERNEL_LOG(context,\n                         \"STR\"\n                         \"STR\",\n                         TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n}","24830":"_rsvg_node_finalize (RsvgNode * self)\n{\n    if (self->state != NULL) {\n        rsvg_state_finalize (self->state);\n        g_free (self->state);\n    }\n    if (self->children != NULL)\n        g_ptr_array_free (self->children, TRUE);\n    if (self->type != NULL)\n        g_string_free (self->type, TRUE);\n}","23957":"    CImg<T>& _load_ascii(std::FILE *const file, const char *const filename) {\n      if (!file && !filename)\n        throw CImgArgumentException(_cimg_instance\n                                    \"STR\",\n                                    cimg_instance);\n\n      std::FILE *const nfile = file?file:cimg::fopen(filename,\"STR\");\n      CImg<charT> line(256); *line = 0;\n      int err = std::fscanf(nfile,\"STR\",line._data);\n      unsigned int dx = 0, dy = 1, dz = 1, dc = 1;\n      cimg_sscanf(line,\"STR\",&dx,&dy,&dz,&dc);\n      err = std::fscanf(nfile,\"STR\");\n      if (!dx || !dy || !dz || !dc) {\n        if (!file) cimg::fclose(nfile);\n        throw CImgIOException(_cimg_instance\n                              \"STR\"\n                              \"STR\",\n                              cimg_instance,\n                              filename?filename:\"STR\",dx,dy,dz,dc);\n      }\n      assign(dx,dy,dz,dc);\n      const ulongT siz = size();\n      ulongT off = 0;\n      double val;\n      T *ptr = _data;\n      for (err = 1, off = 0; off<siz && err==1; ++off) {\n        err = std::fscanf(nfile,\"STR\",&val);\n        *(ptr++) = (T)val;\n      }\n      if (err!=1)\n        cimg::warn(_cimg_instance\n                   \"STR\",\n                   cimg_instance,\n                   off - 1,siz,filename?filename:\"STR\");\n\n      if (!file) cimg::fclose(nfile);\n      return *this;\n    }","24977":"file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size)\n{\n\tbee_t *bee = ic->bee;\n\tbee_user_t *bu = bee_user_by_handle(bee, ic, handle);\n\n\tif (bee->ui->ft_in_start) {\n\t\treturn bee->ui->ft_in_start(bee, bu, file_name, file_size);\n\t} else {\n\t\treturn NULL;\n\t}\n}","23959":"int nfs_updatepage(struct file *file, struct page *page,\n\t\tunsigned int offset, unsigned int count)\n{\n\tstruct nfs_open_context *ctx = nfs_file_open_context(file);\n\tstruct inode\t*inode = page_file_mapping(page)->host;\n\tint\t\tstatus = 0;\n\n\tnfs_inc_stats(inode, NFSIOS_VFSUPDATEPAGE);\n\n\tdprintk(\"STR\",\n\t\tfile->f_path.dentry->d_parent->d_name.name,\n\t\tfile->f_path.dentry->d_name.name, count,\n\t\t(long long)(page_file_offset(page) + offset));\n\n\t\n\tif (nfs_write_pageuptodate(page, inode) &&\n\t\t\tinode->i_flock == NULL &&\n\t\t\t!(file->f_flags & O_DSYNC)) {\n\t\tcount = max(count + offset, nfs_page_length(page));\n\t\toffset = 0;\n\t}\n\n\tstatus = nfs_writepage_setup(ctx, page, offset, count);\n\tif (status < 0)\n\t\tnfs_set_pageerror(page);\n\telse\n\t\t__set_page_dirty_nobuffers(page);\n\n\tdprintk(\"STR\",\n\t\t\tstatus, (long long)i_size_read(inode));\n\treturn status;\n}","24601":"static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}","24853":"R_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAnnotation *annotation = NULL;\n\tRBinJavaElementValuePair *evps = NULL;\n\tut64 offset = 0;\n\tannotation = R_NEW0 (RBinJavaAnnotation);\n\tif (!annotation) {\n\t\treturn NULL;\n\t}\n\t\n\tannotation->type_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\t\n\tannotation->num_element_value_pairs = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tannotation->element_value_pairs = r_list_newf (r_bin_java_element_pair_free);\n\t\n\tfor (i = 0; i < annotation->num_element_value_pairs; i++) {\n\t\tif (offset > sz) {\n\t\t\tbreak;\n\t\t}\n\t\tevps = r_bin_java_element_pair_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (evps) {\n\t\t\toffset += evps->size;\n\t\t\tr_list_append (annotation->element_value_pairs, (void *) evps);\n\t\t}\n\t}\n\tannotation->size = offset;\n\treturn annotation;\n}","25008":"    CImg<T>& min(const CImg<t>& img) {\n      const ulongT siz = size(), isiz = img.size();\n      if (siz && isiz) {\n        if (is_overlapped(img)) return min(+img);\n        T *ptrd = _data, *const ptre = _data + siz;\n        if (siz>isiz) for (ulongT n = siz\/isiz; n; --n)\n          for (const t *ptrs = img._data, *ptrs_end = ptrs + isiz; ptrs<ptrs_end; ++ptrd)\n            *ptrd = std::min((T)*(ptrs++),*ptrd);\n        for (const t *ptrs = img._data; ptrd<ptre; ++ptrd) *ptrd = std::min((T)*(ptrs++),*ptrd);\n      }\n      return *this;\n    }","24424":"fbstring IOBuf::moveToFbString() {\n  \n  \n  bool useHeapFullStorage = false;\n  SharedInfoObserverEntryBase* observerListHead = nullptr;\n  \n  \n  if (!sharedInfo() || \n      sharedInfo()->freeFn || \n      headroom() != 0 || \n      tailroom() == 0 || \n      isShared() || \n      isChained()) { \n    \n    \n    coalesceAndReallocate(0, computeChainDataLength(), this, 1);\n  } else {\n    auto info = sharedInfo();\n    if (info) {\n      \n      \n      \n      useHeapFullStorage = info->useHeapFullStorage;\n      \n      \n      \n      \n      observerListHead = info->observerListHead;\n      info->observerListHead = nullptr;\n    }\n  }\n\n  \n  *writableTail() = 0;\n  fbstring str(\n      reinterpret_cast<char*>(writableData()),\n      length(),\n      capacity(),\n      AcquireMallocatedString());\n\n  if (io_buf_free_cb && sharedInfo() && sharedInfo()->userData) {\n    io_buf_free_cb(\n        writableData(), reinterpret_cast<size_t>(sharedInfo()->userData));\n  }\n\n  SharedInfo::invokeAndDeleteEachObserver(\n      observerListHead, [](auto& entry) { entry.afterReleaseExtBuffer(); });\n\n  if (flags() & kFlagFreeSharedInfo) {\n    delete sharedInfo();\n  } else {\n    if (useHeapFullStorage) {\n      SharedInfo::releaseStorage(sharedInfo());\n    }\n  }\n\n  \n  flagsAndSharedInfo_ = 0;\n  buf_ = nullptr;\n  clear();\n  return str;\n}","24443":"static int multipart_buffer_read(multipart_buffer *self, char *buf, size_t bytes, int *end)\n{\n\tsize_t len, max;\n\tchar *bound;\n\n\t\n\tif (bytes > (size_t)self->bytes_in_buffer) {\n\t\tfill_buffer(self);\n\t}\n\n\t\n\tif ((bound = php_ap_memstr(self->buf_begin, self->bytes_in_buffer, self->boundary_next, self->boundary_next_len, 1))) {\n\t\tmax = bound - self->buf_begin;\n\t\tif (end && php_ap_memstr(self->buf_begin, self->bytes_in_buffer, self->boundary_next, self->boundary_next_len, 0)) {\n\t\t\t*end = 1;\n\t\t}\n\t} else {\n\t\tmax = self->bytes_in_buffer;\n\t}\n\n\t\n\tlen = max < bytes-1 ? max : bytes-1;\n\n\t\n\tif (len > 0) {\n\n\t\t\n\t\tmemcpy(buf, self->buf_begin, len);\n\t\tbuf[len] = 0;\n\n\t\tif (bound && len > 0 && buf[len-1] == '\\r') {\n\t\t\tbuf[--len] = 0;\n\t\t}\n\n\t\t\n\t\tself->bytes_in_buffer -= (int)len;\n\t\tself->buf_begin += len;\n\t}\n\n\treturn (int)len;\n}","25026":"validate_xargs(krb5_context context,\n               krb5_ldap_server_handle *ldap_server_handle,\n               const xargs_t *xargs, const char *standalone_dn,\n               char *const *subtrees, unsigned int ntrees)\n{\n    krb5_error_code st;\n\n    if (xargs->dn != NULL) {\n        \n        st = check_dn_in_container(context, xargs->dn, subtrees, ntrees);\n        if (st)\n            return st;\n        \n        st = check_dn_exists(context, ldap_server_handle, xargs->dn, TRUE);\n        if (st)\n            return st;\n    }\n\n    if (xargs->linkdn != NULL) {\n        \n        st = check_dn_in_container(context, xargs->linkdn, subtrees, ntrees);\n        if (st)\n            return st;\n        \n        st = check_dn_exists(context, ldap_server_handle, xargs->linkdn,\n                             FALSE);\n        if (st)\n            return st;\n    }\n\n    if (xargs->containerdn != NULL && standalone_dn != NULL) {\n        \n        st = check_dn_in_container(context, standalone_dn, subtrees, ntrees);\n        if (st)\n            return st;\n    }\n\n    return 0;\n}","24360":"SPL_METHOD(SplFileObject, fgets)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);\n} ","24615":"static void stream_set_pending_open(struct avdtp_stream *stream, GIOChannel *io)\n{\n\tstream->open_acp = TRUE;\n\tstream->session->pending_open = stream;\n\tstream->session->pending_open_io = io;\n\tstream_set_timer(stream, REQ_TIMEOUT, stream_open_timeout);\n}","25028":"static int ext4_ext_grow_indepth(handle_t *handle, struct inode *inode,\n\t\t\t\t\tstruct ext4_ext_path *path,\n\t\t\t\t\tstruct ext4_extent *newext)\n{\n\tstruct ext4_ext_path *curp = path;\n\tstruct ext4_extent_header *neh;\n\tstruct buffer_head *bh;\n\text4_fsblk_t newblock;\n\tint err = 0;\n\n\tnewblock = ext4_ext_new_meta_block(handle, inode, path, newext, &err);\n\tif (newblock == 0)\n\t\treturn err;\n\n\tbh = sb_getblk(inode->i_sb, newblock);\n\tif (!bh) {\n\t\terr = -EIO;\n\t\text4_std_error(inode->i_sb, err);\n\t\treturn err;\n\t}\n\tlock_buffer(bh);\n\n\terr = ext4_journal_get_create_access(handle, bh);\n\tif (err) {\n\t\tunlock_buffer(bh);\n\t\tgoto out;\n\t}\n\n\t\n\tmemmove(bh->b_data, curp->p_hdr, sizeof(EXT4_I(inode)->i_data));\n\n\t\n\tneh = ext_block_hdr(bh);\n\t\n\tif (ext_depth(inode))\n\t\tneh->eh_max = cpu_to_le16(ext4_ext_space_block_idx(inode, 0));\n\telse\n\t\tneh->eh_max = cpu_to_le16(ext4_ext_space_block(inode, 0));\n\tneh->eh_magic = EXT4_EXT_MAGIC;\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\n\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\tif (err)\n\t\tgoto out;\n\n\t\n\terr = ext4_ext_get_access(handle, inode, curp);\n\tif (err)\n\t\tgoto out;\n\n\tcurp->p_hdr->eh_magic = EXT4_EXT_MAGIC;\n\tcurp->p_hdr->eh_max = cpu_to_le16(ext4_ext_space_root_idx(inode, 0));\n\tcurp->p_hdr->eh_entries = cpu_to_le16(1);\n\tcurp->p_idx = EXT_FIRST_INDEX(curp->p_hdr);\n\n\tif (path[0].p_hdr->eh_depth)\n\t\tcurp->p_idx->ei_block =\n\t\t\tEXT_FIRST_INDEX(path[0].p_hdr)->ei_block;\n\telse\n\t\tcurp->p_idx->ei_block =\n\t\t\tEXT_FIRST_EXTENT(path[0].p_hdr)->ee_block;\n\text4_idx_store_pblock(curp->p_idx, newblock);\n\n\tneh = ext_inode_hdr(inode);\n\text_debug(\"STR\",\n\t\t  le16_to_cpu(neh->eh_entries), le16_to_cpu(neh->eh_max),\n\t\t  le32_to_cpu(EXT_FIRST_INDEX(neh)->ei_block),\n\t\t  ext4_idx_pblock(EXT_FIRST_INDEX(neh)));\n\n\tneh->eh_depth = cpu_to_le16(path->p_depth + 1);\n\terr = ext4_ext_dirty(handle, inode, curp);\nout:\n\tbrelse(bh);\n\n\treturn err;\n}","24130":"static void schedule_async_open(struct timeval request_time,\n\t\t\t\tstruct smb_request *req)\n{\n\tstruct deferred_open_record state;\n\tstruct timeval timeout;\n\n\ttimeout = timeval_set(20, 0);\n\n\tZERO_STRUCT(state);\n\tstate.delayed_for_oplocks = false;\n\tstate.async_open = true;\n\n\tif (!request_timed_out(request_time, timeout)) {\n\t\tdefer_open(NULL, request_time, timeout, req, &state);\n\t}\n}","24060":"xmlPointerListAddSize(xmlPointerListPtr list,\n\t\t       void *item,\n\t\t       int initialSize)\n{\n    if (list->items == NULL) {\n\tif (initialSize <= 0)\n\t    initialSize = 1;\n\tlist->items = (void **) xmlMalloc(\n\t    initialSize * sizeof(void *));\n\tif (list->items == NULL) {\n\t    xmlXPathErrMemory(NULL,\n\t\t\"STR\");\n\t    return(-1);\n\t}\n\tlist->number = 0;\n\tlist->size = initialSize;\n    } else if (list->size <= list->number) {\n\tlist->size *= 2;\n\tlist->items = (void **) xmlRealloc(list->items,\n\t    list->size * sizeof(void *));\n\tif (list->items == NULL) {\n\t    xmlXPathErrMemory(NULL,\n\t\t\"STR\");\n\t    list->size = 0;\n\t    return(-1);\n\t}\n    }\n    list->items[list->number++] = item;\n    return(0);\n}","24275":"static WC_INLINE int wc_ecc_alloc_mpint(ecc_key* key, mp_int** mp)\n{\n   if (key == NULL || mp == NULL)\n      return BAD_FUNC_ARG;\n   if (*mp == NULL) {\n      *mp = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_BIGINT);\n      if (*mp == NULL) {\n         return MEMORY_E;\n      }\n      XMEMSET(*mp, 0, sizeof(mp_int));\n   }\n   return 0;\n}","24023":"static u32 udp_ehashfn(const struct net *net, const __be32 laddr,\n\t\t       const __u16 lport, const __be32 faddr,\n\t\t       const __be16 fport)\n{\n\tstatic u32 udp_ehash_secret __read_mostly;\n\n\tnet_get_random_once(&udp_ehash_secret, sizeof(udp_ehash_secret));\n\n\treturn __inet_ehashfn(laddr, lport, faddr, fport,\n\t\t\t      udp_ehash_secret + net_hash_mix(net));\n}","24996":"R_API RList *r_anal_function_get_var_fields(RAnalFunction *fcn, int kind) {\n\tif (!fcn) {\n\t\treturn NULL;\n\t}\n\tRList *list = r_list_newf ((RListFree)var_field_free);\n\tif (kind < 1) {\n\t\tkind = R_ANAL_VAR_KIND_BPV; \n\t}\n\tvoid **it;\n\tr_pvector_foreach (&fcn->vars, it) {\n\t\tRAnalVar *var = *it;\n\t\tif (var->kind != kind) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (var_add_structure_fields_to_list (fcn->anal, var, list)) {\n\t\t\t\n\t\t\tcontinue;\n\t\t}\n\t\tRAnalVarField *field = R_NEW0 (RAnalVarField);\n\t\tif (!field) {\n\t\t\tbreak;\n\t\t}\n\t\tfield->name = strdup (var->name);\n\t\tif (!field->name) {\n\t\t\tvar_field_free (field);\n\t\t\tbreak;\n\t\t}\n\t\tfield->delta = var->delta;\n\t\tr_list_push (list, field);\n\t}\n\treturn list;\n}","24874":"ephy_embed_single_initialize (EphyEmbedSingle *single)\n{\n  SoupSession *session;\n  SoupCookieJar *jar;\n  char *filename;\n  char *cookie_policy;\n\n  \n  if (g_file_test (NSPLUGINWRAPPER_SETUP, G_FILE_TEST_EXISTS) != FALSE)\n    g_spawn_command_line_sync (NSPLUGINWRAPPER_SETUP, NULL, NULL, NULL, NULL);\n\n  ephy_embed_prefs_init ();\n\n  session = webkit_get_default_session ();\n\n  \n  filename = g_build_filename (ephy_dot_dir (), \"STR\", NULL);\n  jar = soup_cookie_jar_sqlite_new (filename, FALSE);\n  g_free (filename);\n  cookie_policy = eel_gconf_get_string (CONF_SECURITY_COOKIES_ACCEPT);\n  ephy_embed_prefs_set_cookie_jar_policy (jar, cookie_policy);\n  g_free (cookie_policy);\n\n  soup_session_add_feature (session, SOUP_SESSION_FEATURE (jar));\n  g_object_unref (jar);\n\n  \n  soup_session_add_feature_by_type (session, SOUP_TYPE_PROXY_RESOLVER_GNOME);\n\n#ifdef SOUP_TYPE_PASSWORD_MANAGER\n  \n  if (ephy_has_private_profile () == FALSE)\n    soup_session_add_feature_by_type (session, SOUP_TYPE_PASSWORD_MANAGER_GNOME);\n#endif\n\n  return TRUE;\n}","24759":"static inline void xfrm_audit_state_replay_overflow(struct xfrm_state *x,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n}","24172":"detach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma,\n\tstruct vm_area_struct *prev, unsigned long end)\n{\n\tstruct vm_area_struct **insertion_point;\n\tstruct vm_area_struct *tail_vma = NULL;\n\n\tinsertion_point = (prev ? &prev->vm_next : &mm->mmap);\n\tvma->vm_prev = NULL;\n\tdo {\n\t\tvma_rb_erase(vma, &mm->mm_rb);\n\t\tmm->map_count--;\n\t\ttail_vma = vma;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\n\t*insertion_point = vma;\n\tif (vma) {\n\t\tvma->vm_prev = prev;\n\t\tvma_gap_update(vma);\n\t} else\n\t\tmm->highest_vm_end = prev ? vm_end_gap(prev) : 0;\n\ttail_vma->vm_next = NULL;\n\n\t\n\tvmacache_invalidate(mm);\n}","24227":"static void file_change(struct diff_options *options,\n\t\t unsigned old_mode, unsigned new_mode,\n\t\t const unsigned char *old_sha1,\n\t\t const unsigned char *new_sha1,\n\t\t const char *base, const char *path)\n{\n\ttree_difference = REV_TREE_DIFFERENT;\n\tDIFF_OPT_SET(options, HAS_CHANGES);\n}","24765":"njs_function_prototype_apply(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t         i, length;\n    njs_int_t       ret;\n    njs_frame_t     *frame;\n    njs_value_t     *this, *arr_like;\n    njs_array_t     *arr;\n    njs_function_t  *func;\n\n    if (!njs_is_function(njs_argument(args, 0))) {\n        njs_type_error(vm, \"STR\");\n        return NJS_ERROR;\n    }\n\n    func = njs_function(njs_argument(args, 0));\n    this = njs_arg(args, nargs, 1);\n    arr_like = njs_arg(args, nargs, 2);\n\n    if (njs_is_null_or_undefined(arr_like)) {\n        length = 0;\n\n        goto activate;\n\n    } else if (njs_is_array(arr_like)) {\n        arr = arr_like->data.u.array;\n\n        args = arr->start;\n        length = arr->length;\n\n        goto activate;\n\n    } else if (njs_slow_path(!njs_is_object(arr_like))) {\n        njs_type_error(vm, \"STR\");\n        return NJS_ERROR;\n    }\n\n    ret = njs_object_length(vm, arr_like, &length);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    arr = njs_array_alloc(vm, 1, length, NJS_ARRAY_SPARE);\n    if (njs_slow_path(arr == NULL)) {\n        return NJS_ERROR;\n    }\n\n    args = arr->start;\n\n    for (i = 0; i < length; i++) {\n        ret = njs_value_property_i64(vm, arr_like, i, &args[i]);\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return ret;\n        }\n    }\n\nactivate:\n\n    \n    vm->top_frame->skip = 1;\n\n    frame = (njs_frame_t *) vm->top_frame;\n\n    ret = njs_function_frame(vm, func, this, args, length, 0);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_function_frame_invoke(vm, frame->native.retval);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    return NJS_DECLINED;\n}","25012":"static BOOL rdp_read_font_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length > 4)\n\t\tStream_Seek_UINT16(s); \n\n\tif (length > 6)\n\t\tStream_Seek_UINT16(s); \n\n\treturn TRUE;\n}","24110":"static void mailbox_index_update_counts(struct mailbox *mailbox,\n                                        const struct index_record *record,\n                                        int is_add)\n{\n    mailbox_quota_dirty(mailbox);\n    mailbox_index_dirty(mailbox);\n    header_update_counts(&mailbox->i, record, is_add);\n\n    mailbox->i.synccrcs.basic ^= crc_basic(mailbox, record);\n    mailbox->i.synccrcs.annot ^= crc_virtannot(mailbox, record);\n}","24341":"NIAddAffix(IspellDict *Conf, int flag, char flagflags, const char *mask, const char *find, const char *repl, int type)\n{\n\tAFFIX\t   *Affix;\n\n\tif (Conf->naffixes >= Conf->maffixes)\n\t{\n\t\tif (Conf->maffixes)\n\t\t{\n\t\t\tConf->maffixes *= 2;\n\t\t\tConf->Affix = (AFFIX *) repalloc((void *) Conf->Affix, Conf->maffixes * sizeof(AFFIX));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tConf->maffixes = 16;\n\t\t\tConf->Affix = (AFFIX *) palloc(Conf->maffixes * sizeof(AFFIX));\n\t\t}\n\t}\n\n\tAffix = Conf->Affix + Conf->naffixes;\n\n\tif (strcmp(mask, \"STR\") == 0)\n\t{\n\t\tAffix->issimple = 1;\n\t\tAffix->isregis = 0;\n\t}\n\telse if (RS_isRegis(mask))\n\t{\n\t\tAffix->issimple = 0;\n\t\tAffix->isregis = 1;\n\t\tRS_compile(&(Affix->reg.regis), (type == FF_SUFFIX) ? true : false,\n\t\t\t\t   (mask && *mask) ? mask : VoidString);\n\t}\n\telse\n\t{\n\t\tint\t\t\tmasklen;\n\t\tint\t\t\twmasklen;\n\t\tint\t\t\terr;\n\t\tpg_wchar   *wmask;\n\t\tchar\t   *tmask;\n\n\t\tAffix->issimple = 0;\n\t\tAffix->isregis = 0;\n\t\ttmask = (char *) tmpalloc(strlen(mask) + 3);\n\t\tif (type == FF_SUFFIX)\n\t\t\tsprintf(tmask, \"STR\", mask);\n\t\telse\n\t\t\tsprintf(tmask, \"STR\", mask);\n\n\t\tmasklen = strlen(tmask);\n\t\twmask = (pg_wchar *) tmpalloc((masklen + 1) * sizeof(pg_wchar));\n\t\twmasklen = pg_mb2wchar_with_len(tmask, wmask, masklen);\n\n\t\terr = pg_regcomp(&(Affix->reg.regex), wmask, wmasklen,\n\t\t\t\t\t\t REG_ADVANCED | REG_NOSUB,\n\t\t\t\t\t\t DEFAULT_COLLATION_OID);\n\t\tif (err)\n\t\t{\n\t\t\tchar\t\terrstr[100];\n\n\t\t\tpg_regerror(err, &(Affix->reg.regex), errstr, sizeof(errstr));\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_REGULAR_EXPRESSION),\n\t\t\t\t\t errmsg(\"STR\", errstr)));\n\t\t}\n\t}\n\n\tAffix->flagflags = flagflags;\n\tif ((Affix->flagflags & FF_COMPOUNDONLY) || (Affix->flagflags & FF_COMPOUNDPERMITFLAG))\n\t{\n\t\tif ((Affix->flagflags & FF_COMPOUNDFLAG) == 0)\n\t\t\tAffix->flagflags |= FF_COMPOUNDFLAG;\n\t}\n\tAffix->flag = flag;\n\tAffix->type = type;\n\n\tAffix->find = (find && *find) ? cpstrdup(Conf, find) : VoidString;\n\tif ((Affix->replen = strlen(repl)) > 0)\n\t\tAffix->repl = cpstrdup(Conf, repl);\n\telse\n\t\tAffix->repl = VoidString;\n\tConf->naffixes++;\n}","24069":"storeRawNames(XML_Parser parser) {\n  TAG *tag = parser->m_tagStack;\n  while (tag) {\n    int bufSize;\n    int nameLen = sizeof(XML_Char) * (tag->name.strLen + 1);\n    char *rawNameBuf = tag->buf + nameLen;\n    \n    if (tag->rawName == rawNameBuf)\n      break;\n    \n    bufSize = nameLen + ROUND_UP(tag->rawNameLength, sizeof(XML_Char));\n    if (bufSize > tag->bufEnd - tag->buf) {\n      char *temp = (char *)REALLOC(parser, tag->buf, bufSize);\n      if (temp == NULL)\n        return XML_FALSE;\n      \n      if (tag->name.str == (XML_Char *)tag->buf)\n        tag->name.str = (XML_Char *)temp;\n      \n      if (tag->name.localPart)\n        tag->name.localPart\n            = (XML_Char *)temp + (tag->name.localPart - (XML_Char *)tag->buf);\n      tag->buf = temp;\n      tag->bufEnd = temp + bufSize;\n      rawNameBuf = temp + nameLen;\n    }\n    memcpy(rawNameBuf, tag->rawName, tag->rawNameLength);\n    tag->rawName = rawNameBuf;\n    tag = tag->parent;\n  }\n  return XML_TRUE;\n}","24327":"void Monitor::send_command(const entity_inst_t& inst,\n\t\t\t   const vector<string>& com)\n{\n  dout(10) << \"STR\" << com << dendl;\n  MMonCommand *c = new MMonCommand(monmap->fsid);\n  c->cmd = com;\n  try_send_message(c, inst);\n}","24897":"static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\n\t\n\tnode->sgprivate->num_instances = 2;\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}","24406":"void ServerHello::Process(input_buffer& input, SSL& ssl)\n{\n    if (input.get_error()) {\n        ssl.SetError(bad_input);\n        return;\n    }\n\n    if (ssl.GetMultiProtocol()) {   \n        if (ssl.isTLS() && server_version_.minor_ < 1)\n            \n            ssl.useSecurity().use_connection().TurnOffTLS();\n        else if (ssl.isTLSv1_1() && server_version_.minor_ == 1)\n            \n            ssl.useSecurity().use_connection().TurnOffTLS1_1();\n    }\n    else if (ssl.isTLSv1_1() && server_version_.minor_ < 2) {\n        ssl.SetError(badVersion_error);\n        return;\n    }\n    else if (ssl.isTLS() && server_version_.minor_ < 1) {\n        ssl.SetError(badVersion_error);\n        return;\n    }\n    else if (!ssl.isTLS() && (server_version_.major_ == 3 &&\n                              server_version_.minor_ >= 1)) {\n        ssl.SetError(badVersion_error);\n        return;\n    }\n    ssl.set_pending(cipher_suite_[1]);\n    ssl.set_random(random_, server_end);\n    if (id_len_)\n        ssl.set_sessionID(session_id_);\n    else\n        ssl.useSecurity().use_connection().sessionID_Set_ = false;\n\n    if (ssl.getSecurity().get_resuming()) {\n        if (memcmp(session_id_, ssl.getSecurity().get_resume().GetID(),\n                   ID_LEN) == 0) {\n            ssl.set_masterSecret(ssl.getSecurity().get_resume().GetSecret());\n            if (ssl.isTLS())\n                ssl.deriveTLSKeys();\n            else\n                ssl.deriveKeys();\n            ssl.useStates().useClient() = serverHelloDoneComplete;\n            return;\n        }\n        else {\n            ssl.useSecurity().set_resuming(false);\n            ssl.useLog().Trace(\"STR\");\n        }\n    }\n\n    if (ssl.CompressionOn() && !compression_method_)\n        ssl.UnSetCompression(); \n\n    ssl.useStates().useClient() = serverHelloComplete;\n}","24563":"TfLiteStatus EvalHybridPerChannel(TfLiteContext* context, TfLiteNode* node,\n                                  TfLiteDepthwiseConvParams* params,\n                                  OpData* data, const TfLiteTensor* input,\n                                  const TfLiteTensor* filter,\n                                  const TfLiteTensor* bias,\n                                  TfLiteTensor* output) {\n  float output_activation_min, output_activation_max;\n  CalculateActivationRange(params->activation, &output_activation_min,\n                           &output_activation_max);\n  const int input_size = NumElements(input) \/ SizeOfDimension(input, 0);\n  const int batch_size = SizeOfDimension(input, 0);\n  TfLiteTensor* input_quantized;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data->input_quantized_index,\n                                     &input_quantized));\n  int8_t* quantized_input_ptr_batch = input_quantized->data.int8;\n  TfLiteTensor* scaling_factors_tensor;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data->scaling_factors_index,\n                                     &scaling_factors_tensor));\n  float* scaling_factors_ptr = GetTensorData<float>(scaling_factors_tensor);\n  TfLiteTensor* input_offset_tensor;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, data->input_offset_index,\n                                     &input_offset_tensor));\n  int32_t* input_offset_ptr = GetTensorData<int32_t>(input_offset_tensor);\n\n  for (int b = 0; b < batch_size; ++b) {\n    const int offset = b * input_size;\n    tensor_utils::AsymmetricQuantizeFloats(\n        GetTensorData<float>(input) + offset, input_size,\n        quantized_input_ptr_batch + offset, &scaling_factors_ptr[b],\n        &input_offset_ptr[b]);\n  }\n\n  DepthwiseParams op_params;\n  op_params.padding_type = PaddingType::kSame;\n  op_params.padding_values.width = data->padding.width;\n  op_params.padding_values.height = data->padding.height;\n  op_params.stride_width = params->stride_width;\n  op_params.stride_height = params->stride_height;\n  op_params.dilation_width_factor = params->dilation_width_factor;\n  op_params.dilation_height_factor = params->dilation_height_factor;\n  op_params.depth_multiplier = params->depth_multiplier;\n\n  op_params.weights_offset = 0;\n  op_params.float_activation_min = output_activation_min;\n  op_params.float_activation_max = output_activation_max;\n  const auto* affine_quantization =\n      reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params);\n  if (kernel_type == kReference) {\n    reference_integer_ops::DepthwiseConvHybridPerChannel(\n        op_params, scaling_factors_ptr, GetTensorShape(input),\n        quantized_input_ptr_batch, GetTensorShape(filter),\n        GetTensorData<int8>(filter), GetTensorShape(bias),\n        GetTensorData<float>(bias), GetTensorShape(output),\n        GetTensorData<float>(output), affine_quantization->scale->data,\n        input_offset_ptr);\n  } else {\n    optimized_integer_ops::DepthwiseConvHybridPerChannel(\n        op_params, scaling_factors_ptr, GetTensorShape(input),\n        quantized_input_ptr_batch, GetTensorShape(filter),\n        GetTensorData<int8>(filter), GetTensorShape(bias),\n        GetTensorData<float>(bias), GetTensorShape(output),\n        GetTensorData<float>(output), affine_quantization->scale->data,\n        input_offset_ptr, CpuBackendContext::GetFromContext(context));\n  }\n\n  return kTfLiteOk;\n}","24423":"archive_string_default_conversion_for_read(struct archive *a)\n{\n\t(void)a; \n\treturn (NULL);\n}","24453":"static void qeth_update_from_chp_desc(struct qeth_card *card)\n{\n\tstruct ccw_device *ccwdev;\n\tstruct channelPath_dsc {\n\t\tu8 flags;\n\t\tu8 lsn;\n\t\tu8 desc;\n\t\tu8 chpid;\n\t\tu8 swla;\n\t\tu8 zeroes;\n\t\tu8 chla;\n\t\tu8 chpp;\n\t} *chp_dsc;\n\n\tQETH_DBF_TEXT(SETUP, 2, \"STR\");\n\n\tccwdev = card->data.ccwdev;\n\tchp_dsc = ccw_device_get_chp_desc(ccwdev, 0);\n\tif (!chp_dsc)\n\t\tgoto out;\n\n\tcard->info.func_level = 0x4100 + chp_dsc->desc;\n\tif (card->info.type == QETH_CARD_TYPE_IQD)\n\t\tgoto out;\n\n\t\n\tif ((chp_dsc->chpp & 0x02) == 0x02)\n\t\tqeth_set_single_write_queues(card);\n\telse\n\t\tqeth_set_multiple_write_queues(card);\nout:\n\tkfree(chp_dsc);\n\tQETH_DBF_TEXT_(SETUP, 2, \"STR\", card->qdio.no_out_queues);\n\tQETH_DBF_TEXT_(SETUP, 2, \"STR\", card->info.func_level);\n}","24290":"TfLiteStatus NotEqualEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  bool requires_broadcast = !HaveSameShapes(input1, input2);\n  switch (input1->type) {\n    case kTfLiteBool:\n      Comparison<bool, reference_ops::NotEqualFn>(input1, input2, output,\n                                                  requires_broadcast);\n      break;\n    case kTfLiteFloat32:\n      Comparison<float, reference_ops::NotEqualFn>(input1, input2, output,\n                                                   requires_broadcast);\n      break;\n    case kTfLiteInt32:\n      Comparison<int32_t, reference_ops::NotEqualFn>(input1, input2, output,\n                                                     requires_broadcast);\n      break;\n    case kTfLiteInt64:\n      Comparison<int64_t, reference_ops::NotEqualFn>(input1, input2, output,\n                                                     requires_broadcast);\n      break;\n    case kTfLiteUInt8:\n      ComparisonQuantized<uint8_t, reference_ops::NotEqualFn>(\n          input1, input2, output, requires_broadcast);\n      break;\n    case kTfLiteInt8:\n      ComparisonQuantized<int8_t, reference_ops::NotEqualFn>(\n          input1, input2, output, requires_broadcast);\n      break;\n    case kTfLiteString:\n      ComparisonString(reference_ops::StringRefNotEqualFn, input1, input2,\n                       output, requires_broadcast);\n      break;\n    default:\n      context->ReportError(\n          context,\n          \"STR\",\n          input1->type);\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}","24461":"static void iriap_getvaluebyclass_indication(struct iriap_cb *self,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ias_object *obj;\n\tstruct ias_attrib *attrib;\n\tint name_len;\n\tint attr_len;\n\tchar name[IAS_MAX_CLASSNAME + 1];\t\n\tchar attr[IAS_MAX_ATTRIBNAME + 1];\t\n\t__u8 *fp;\n\tint n;\n\n\tIRDA_DEBUG(4, \"STR\", __func__);\n\n\tIRDA_ASSERT(self != NULL, return;);\n\tIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\n\tIRDA_ASSERT(skb != NULL, return;);\n\n\tfp = skb->data;\n\tn = 1;\n\n\tname_len = fp[n++];\n\tmemcpy(name, fp+n, name_len); n+=name_len;\n\tname[name_len] = '\\0';\n\n\tattr_len = fp[n++];\n\tmemcpy(attr, fp+n, attr_len); n+=attr_len;\n\tattr[attr_len] = '\\0';\n\n\tIRDA_DEBUG(4, \"STR\", name, attr);\n\tobj = irias_find_object(name);\n\n\tif (obj == NULL) {\n\t\tIRDA_DEBUG(2, \"STR\", name);\n\t\tiriap_getvaluebyclass_response(self, 0x1235, IAS_CLASS_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\tIRDA_DEBUG(4, \"STR\", obj->name, obj->id);\n\n\tattrib = irias_find_attrib(obj, attr);\n\tif (attrib == NULL) {\n\t\tIRDA_DEBUG(2, \"STR\", attr);\n\t\tiriap_getvaluebyclass_response(self, obj->id,\n\t\t\t\t\t       IAS_ATTRIB_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\n\t\n\tiriap_getvaluebyclass_response(self, obj->id, IAS_SUCCESS,\n\t\t\t\t       attrib->value);\n}","24148":"get32 (const byte *buffer)\n{\n  ulong a;\n  a =  *buffer << 24;\n  a |= buffer[1] << 16;\n  a |= buffer[2] << 8;\n  a |= buffer[3];\n  return a;\n}","24950":"static ssize_t _consolefs_readv(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n\n    if (!file || !iov || iovcnt < 0 || iovcnt > OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    \n    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    \n    if (oe_syscall_readv_ocall(&ret, file->host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    \n    if (oe_iov_sync(iov, iovcnt, buf, buf_size) != 0)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}","24480":"static RList *symbols(RBinFile *bf) {\n\tRList *res = r_list_newf ((RListFree)r_bin_symbol_free);\n\tr_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tHtUU *hash = ht_uu_new0 ();\n\tif (!hash) {\n\t\treturn res;\n\t}\n\tbool found = false;\n\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\tRCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n\t\tht_uu_find (hash, sym->paddr, &found);\n\t\tif (found) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\tif (s) {\n\t\t\tr_list_append (res, s);\n\t\t\tht_uu_insert (hash, sym->paddr, 1);\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &element->symbols[i];\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t}\n\t\t}\n\t}\n\tht_uu_free (hash);\n\treturn res;\n}","23840":"  String *val_str(String*) { return &str_value; }","23949":"void main_cleanup() {\n#ifdef USE_OS_THREADS\n    CLI *c;\n    unsigned i, threads;\n    THREAD_ID *thread_list;\n\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_THREAD_LIST]);\n    threads=0;\n    for(c=thread_head; c; c=c->thread_next) \n        threads++;\n    thread_list=str_alloc((threads+1)*sizeof(THREAD_ID));\n    i=0;\n    for(c=thread_head; c; c=c->thread_next) { \n        thread_list[i++]=c->thread_id;\n        s_log(LOG_DEBUG, \"STR\", c->opt->servname);\n    }\n    if(cron_thread_id) { \n        thread_list[threads++]=cron_thread_id;\n        s_log(LOG_DEBUG, \"STR\");\n    }\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_THREAD_LIST]);\n\n    if(threads) {\n        s_log(LOG_NOTICE, \"STR\", threads);\n        writesocket(terminate_pipe[1], \"\", 1);\n        for(i=0; i<threads; ++i) { \n#ifdef USE_PTHREAD\n            if(pthread_join(thread_list[i], NULL))\n                s_log(LOG_ERR, \"STR\");\n#endif\n#ifdef USE_WIN32\n            if(WaitForSingleObject(thread_list[i], INFINITE)==WAIT_FAILED)\n                ioerror(\"STR\");\n            if(!CloseHandle(thread_list[i]))\n                ioerror(\"STR\");\n#endif\n        }\n        s_log(LOG_NOTICE, \"STR\");\n    }\n\n    str_free(thread_list);\n#endif \n\n    unbind_ports();\n    s_poll_free(fds);\n    fds=NULL;\n#if 0\n    str_stats(); \n#endif\n    log_flush(LOG_MODE_ERROR);\n    log_close(SINK_SYSLOG|SINK_OUTFILE);\n}","24007":"TRIO_PUBLIC_STRING int trio_xstring_match_case TRIO_ARGS2((self, other), trio_string_t* self,\n                                                          TRIO_CONST char* other)\n{\n\tassert(self);\n\tassert(other);\n\n\treturn trio_match_case(self->content, other);\n}","24754":"static void hugetlbfs_put_super(struct super_block *sb)\n{\n\tstruct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);\n\n\tif (sbi) {\n\t\tsb->s_fs_info = NULL;\n\t\tkfree(sbi);\n\t}\n}","25046":"zzip_mem_disk_findfirst(ZZIP_MEM_DISK* dir) {\n    return zzip_disk_findfirst(dir->disk); }","24975":"static int megasas_handle_dcmd(MegasasState *s, MegasasCmd *cmd)\n{\n    int opcode, len;\n    int retval = 0;\n    const struct dcmd_cmd_tbl_t *cmdptr = dcmd_cmd_tbl;\n\n    opcode = le32_to_cpu(cmd->frame->dcmd.opcode);\n    trace_megasas_handle_dcmd(cmd->index, opcode);\n    len = megasas_map_dcmd(s, cmd);\n    if (len < 0) {\n        return MFI_STAT_MEMORY_NOT_AVAILABLE;\n    }\n    while (cmdptr->opcode != -1 && cmdptr->opcode != opcode) {\n        cmdptr++;\n    }\n    if (cmdptr->opcode == -1) {\n        trace_megasas_dcmd_unhandled(cmd->index, opcode, len);\n        retval = megasas_dcmd_dummy(s, cmd);\n    } else {\n        trace_megasas_dcmd_enter(cmd->index, cmdptr->desc, len);\n        retval = cmdptr->func(s, cmd);\n    }\n    if (retval != MFI_STAT_INVALID_STATUS) {\n        megasas_finish_dcmd(cmd, len);\n    }\n    return retval;\n}","24507":"static void _DESTRUCTOR lib_deinit(void)\n{\n\tconst char *e;\n\n\tif (_gnutls_global_init_skip() != 0)\n\t\treturn;\n\n\te = getenv(\"STR\");\n\tif (e != NULL) {\n\t\tint ret = atoi(e);\n\t\tif (ret == 1)\n\t\t\treturn;\n\t}\n\n\t_gnutls_global_deinit(1);\n}","24822":"check_entry(const struct ip6t_entry *e, const char *name)\n{\n\tconst struct xt_entry_target *t;\n\n\tif (!ip6_checkentry(&e->ipv6)) {\n\t\tduprintf(\"STR\", e, name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->target_offset + sizeof(struct xt_entry_target) >\n\t    e->next_offset)\n\t\treturn -EINVAL;\n\n\tt = ip6t_get_target_c(e);\n\tif (e->target_offset + t->u.target_size > e->next_offset)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}","24577":"static int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,\n\t\t\t    bool host)\n{\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\n\tif (!synic->active && !host)\n\t\treturn 1;\n\n\ttrace_kvm_hv_stimer_set_count(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t      stimer->index, count, host);\n\n\tstimer_cleanup(stimer);\n\tstimer->count = count;\n\tif (stimer->count == 0)\n\t\tstimer->config.enable = 0;\n\telse if (stimer->config.auto_enable)\n\t\tstimer->config.enable = 1;\n\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\n\treturn 0;\n}","23997":"static inline void csrhci_fifo_wake(struct csrhci_s *s)\n{\n    if (!s->enable || !s->out_len)\n        return;\n\n    \n    if (s->chr.chr_can_read && s->chr.chr_can_read(s->chr.handler_opaque) &&\n                    s->chr.chr_read) {\n        s->chr.chr_read(s->chr.handler_opaque,\n                        s->outfifo + s->out_start ++, 1);\n        s->out_len --;\n        if (s->out_start >= s->out_size) {\n            s->out_start = 0;\n            s->out_size = FIFO_LEN;\n        }\n    }\n\n    if (s->out_len)\n        timer_mod(s->out_tm, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + s->baud_delay);\n}","24188":"    static void addUser(OperationContext* opCtx,\n                        AuthorizationManager* authzManager,\n                        StringData db,\n                        bool update,\n                        stdx::unordered_set<UserName>* usersToDrop,\n                        const BSONObj& userObj) {\n        UserName userName = extractUserNameFromBSON(userObj);\n        if (!db.empty() && userName.getDB() != db) {\n            return;\n        }\n\n        if (update && usersToDrop->count(userName)) {\n            auditCreateOrUpdateUser(userObj, false);\n            Status status = updatePrivilegeDocument(opCtx, userName, userObj);\n            if (!status.isOK()) {\n                \n                warning() << \"STR\" << userName\n                          << \"STR\" << redact(status);\n            }\n        } else {\n            auditCreateOrUpdateUser(userObj, true);\n            Status status = insertPrivilegeDocument(opCtx, userObj);\n            if (!status.isOK()) {\n                \n                warning() << \"STR\" << userName\n                          << \"STR\" << redact(status);\n            }\n        }\n        usersToDrop->erase(userName);\n    }","24536":"\n    void _init_fullscreen() {\n      if (!_is_fullscreen || _is_closed) return;\n      Display *const dpy = cimg::X11_attr().display;\n      _background_window = 0;\n\n#ifdef cimg_use_xrandr\n      int foo;\n      if (XRRQueryExtension(dpy,&foo,&foo)) {\n        XRRRotations(dpy,DefaultScreen(dpy),&cimg::X11_attr().curr_rotation);\n        if (!cimg::X11_attr().resolutions) {\n          cimg::X11_attr().resolutions = XRRSizes(dpy,DefaultScreen(dpy),&foo);\n          cimg::X11_attr().nb_resolutions = (unsigned int)foo;\n        }\n        if (cimg::X11_attr().resolutions) {\n          cimg::X11_attr().curr_resolution = 0;\n          for (unsigned int i = 0; i<cimg::X11_attr().nb_resolutions; ++i) {\n            const unsigned int\n              nw = (unsigned int)(cimg::X11_attr().resolutions[i].width),\n              nh = (unsigned int)(cimg::X11_attr().resolutions[i].height);\n            if (nw>=_width && nh>=_height &&\n                nw<=(unsigned int)(cimg::X11_attr().resolutions[cimg::X11_attr().curr_resolution].width) &&\n                nh<=(unsigned int)(cimg::X11_attr().resolutions[cimg::X11_attr().curr_resolution].height))\n              cimg::X11_attr().curr_resolution = i;\n          }\n          if (cimg::X11_attr().curr_resolution>0) {\n            XRRScreenConfiguration *config = XRRGetScreenInfo(dpy,DefaultRootWindow(dpy));\n            XRRSetScreenConfig(dpy,config,DefaultRootWindow(dpy),\n                               cimg::X11_attr().curr_resolution,cimg::X11_attr().curr_rotation,CurrentTime);\n            XRRFreeScreenConfigInfo(config);\n            XSync(dpy,0);\n          }\n        }\n      }\n      if (!cimg::X11_attr().resolutions)\n        cimg::warn(_cimgdisplay_instance\n                   \"STR\",\n                   cimgdisplay_instance);\n#endif\n\n      const unsigned int sx = screen_width(), sy = screen_height();\n      if (sx==_width && sy==_height) return;\n      XSetWindowAttributes winattr;\n      winattr.override_redirect = 1;\n      _background_window = XCreateWindow(dpy,DefaultRootWindow(dpy),0,0,sx,sy,0,0,\n                                         InputOutput,CopyFromParent,CWOverrideRedirect,&winattr);\n      const cimg_ulong buf_size = (cimg_ulong)sx*sy*(cimg::X11_attr().nb_bits==8?1:\n                                                     (cimg::X11_attr().nb_bits==16?2:4));\n      void *background_data = std::malloc(buf_size);\n      std::memset(background_data,0,buf_size);\n      XImage *background_image = XCreateImage(dpy,DefaultVisual(dpy,DefaultScreen(dpy)),cimg::X11_attr().nb_bits,\n                                              ZPixmap,0,(char*)background_data,sx,sy,8,0);\n      XEvent event;\n      XSelectInput(dpy,_background_window,StructureNotifyMask);\n      XMapRaised(dpy,_background_window);\n      do XWindowEvent(dpy,_background_window,StructureNotifyMask,&event);\n      while (event.type!=MapNotify);\n      GC gc = DefaultGC(dpy,DefaultScreen(dpy));\n#ifdef cimg_use_xshm\n      if (_shminfo) XShmPutImage(dpy,_background_window,gc,background_image,0,0,0,0,sx,sy,0);\n      else XPutImage(dpy,_background_window,gc,background_image,0,0,0,0,sx,sy);\n#else\n      XPutImage(dpy,_background_window,gc,background_image,0,0,0,0,sx,sy);\n#endif\n      XWindowAttributes attr;\n      XGetWindowAttributes(dpy,_background_window,&attr);\n      while (attr.map_state!=IsViewable) XSync(dpy,0);\n      XDestroyImage(background_image);","25039":"static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)\n{\n\text4_fsblk_t block = ext4_ext_pblock(ext);\n\tint len = ext4_ext_get_actual_len(ext);\n\text4_lblk_t lblock = le32_to_cpu(ext->ee_block);\n\n\t\n\tif (lblock + len <= lblock)\n\t\treturn 0;\n\treturn ext4_data_block_valid(EXT4_SB(inode->i_sb), block, len);\n}","24589":"static void syscall_trace(struct pt_regs *regs)\n{\n\n#if 0\n\tprintk(\"STR\",\n\t       current->comm,\n\t       regs->rip, regs->rsp, regs->rax, regs->orig_rax, __builtin_return_address(0),\n\t       current_thread_info()->flags, current->ptrace); \n#endif\n\n\tptrace_notify(SIGTRAP | ((current->ptrace & PT_TRACESYSGOOD)\n\t\t\t\t? 0x80 : 0));\n\t\n\tif (current->exit_code) {\n\t\tsend_sig(current->exit_code, current, 1);\n\t\tcurrent->exit_code = 0;\n\t}\n}","24122":"SYSCALL_DEFINE4(fallocate, int, fd, int, mode, loff_t, offset, loff_t, len)\n{\n\tstruct fd f = fdget(fd);\n\tint error = -EBADF;\n\n\tif (f.file) {\n\t\terror = vfs_fallocate(f.file, mode, offset, len);\n\t\tfdput(f);\n\t}\n\treturn error;\n}","24625":"spnego_gss_wrap_iov(OM_uint32 *minor_status,\n\t\t    gss_ctx_id_t context_handle,\n\t\t    int conf_req_flag,\n\t\t    gss_qop_t qop_req,\n\t\t    int *conf_state,\n\t\t    gss_iov_buffer_desc *iov,\n\t\t    int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov(minor_status,\n\t\t\t   context_handle,\n\t\t\t   conf_req_flag,\n\t\t\t   qop_req,\n\t\t\t   conf_state,\n\t\t\t   iov,\n\t\t\t   iov_count);\n\treturn (ret);\n}","24506":"httpd_compress(isc_httpd_t *httpd) {\n\tz_stream zstr;\n\tisc_region_t r;\n\tint ret;\n\tint inputlen;\n\n\tinputlen = isc_buffer_usedlength(&httpd->bodybuffer);\n\talloc_compspace(httpd, inputlen);\n\tisc_buffer_region(&httpd->compbuffer, &r);\n\n\t\n\tmemset(&zstr, 0, sizeof(zstr));\n\tzstr.total_in = zstr.avail_in = zstr.total_out = zstr.avail_out =\n\t\tinputlen;\n\n\tzstr.next_in = isc_buffer_base(&httpd->bodybuffer);\n\tzstr.next_out = r.base;\n\n\tret = deflateInit(&zstr, Z_DEFAULT_COMPRESSION);\n\tif (ret == Z_OK) {\n\t\tret = deflate(&zstr, Z_FINISH);\n\t}\n\tdeflateEnd(&zstr);\n\tif (ret == Z_STREAM_END) {\n\t\tisc_buffer_add(&httpd->compbuffer, inputlen - zstr.avail_out);\n\t\treturn (ISC_R_SUCCESS);\n\t} else {\n\t\treturn (ISC_R_FAILURE);\n\t}\n}","24706":"static inline struct dma_async_tx_descriptor *dmaengine_prep_slave_single(\n\tstruct dma_chan *chan, dma_addr_t buf, size_t len,\n\tenum dma_transfer_direction dir, unsigned long flags)\n{\n\tstruct scatterlist sg;\n\tsg_init_table(&sg, 1);\n\tsg_dma_address(&sg) = buf;\n\tsg_dma_len(&sg) = len;\n\n\treturn chan->device->device_prep_slave_sg(chan, &sg, 1,\n\t\t\t\t\t\t  dir, flags, NULL);\n}","24449":"Magick_png_write_raw_profile(const ImageInfo *image_info,png_struct *ping,\n   png_info *ping_info, unsigned char *profile_type, unsigned char\n   *profile_description, unsigned char *profile_data, png_uint_32 length)\n{\n   png_textp\n     text;\n\n   register ssize_t\n     i;\n\n   unsigned char\n     *sp;\n\n   png_charp\n     dp;\n\n   png_uint_32\n     allocated_length,\n     description_length;\n\n   unsigned char\n     hex[16]={'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};\n\n   if (LocaleNCompare((char *) profile_type+1, \"STR\",9) == 0)\n      return;\n\n   if (image_info->verbose)\n     {\n       (void) printf(\"STR\",\n         (char *) profile_type, (double) length);\n     }\n\n#if PNG_LIBPNG_VER >= 10400\n   text=(png_textp) png_malloc(ping,(png_alloc_size_t) sizeof(png_text));\n#else\n   text=(png_textp) png_malloc(ping,(png_size_t) sizeof(png_text));\n#endif\n   description_length=(png_uint_32) strlen((const char *) profile_description);\n   allocated_length=(png_uint_32) (length*2 + (length >> 5) + 20\n      + description_length);\n#if PNG_LIBPNG_VER >= 10400\n   text[0].text=(png_charp) png_malloc(ping,\n      (png_alloc_size_t) allocated_length);\n   text[0].key=(png_charp) png_malloc(ping, (png_alloc_size_t) 80);\n#else\n   text[0].text=(png_charp) png_malloc(ping, (png_size_t) allocated_length);\n   text[0].key=(png_charp) png_malloc(ping, (png_size_t) 80);\n#endif\n   text[0].key[0]='\\0';\n   (void) ConcatenateMagickString(text[0].key,\n      \"STR\",MagickPathExtent);\n   (void) ConcatenateMagickString(text[0].key,(const char *) profile_type,62);\n   sp=profile_data;\n   dp=text[0].text;\n   *dp++='\\n';\n   (void) CopyMagickString(dp,(const char *) profile_description,\n     allocated_length);\n   dp+=description_length;\n   *dp++='\\n';\n   (void) FormatLocaleString(dp,allocated_length-\n     (png_size_t) (dp-text[0].text),\"STR\",(unsigned long) length);\n   dp+=8;\n\n   for (i=0; i < (ssize_t) length; i++)\n   {\n     if (i%36 == 0)\n       *dp++='\\n';\n     *(dp++)=(char) hex[((*sp >> 4) & 0x0f)];\n     *(dp++)=(char) hex[((*sp++ ) & 0x0f)];\n   }\n\n   *dp++='\\n';\n   *dp='\\0';\n   text[0].text_length=(png_size_t) (dp-text[0].text);\n   text[0].compression=image_info->compression == NoCompression ||\n     (image_info->compression == UndefinedCompression &&\n     text[0].text_length < 128) ? -1 : 0;\n\n   if (text[0].text_length <= allocated_length)\n     png_set_text(ping,ping_info,text,1);\n\n   png_free(ping,text[0].text);\n   png_free(ping,text[0].key);\n   png_free(ping,text);\n}","24723":"_hb_buffer_add_output_glyphs( HB_Buffer  buffer,\n\t\t\t      HB_UShort  num_in,\n\t\t\t      HB_UShort  num_out,\n\t\t\t      HB_UShort *glyph_data,\n\t\t\t      HB_UShort  component,\n\t\t\t      HB_UShort  ligID )\n{\n  HB_Error  error;\n  HB_UShort i;\n  HB_UInt properties;\n  HB_UInt cluster;\n\n  error = hb_buffer_ensure( buffer, buffer->out_pos + num_out );\n  if ( error )\n    return error;\n\n  if ( !buffer->separate_out )\n    {\n      error = hb_buffer_duplicate_out_buffer( buffer );\n      if ( error )\n\treturn error;\n    }\n\n  properties = buffer->in_string[buffer->in_pos].properties;\n  cluster = buffer->in_string[buffer->in_pos].cluster;\n  if ( component == 0xFFFF )\n    component = buffer->in_string[buffer->in_pos].component;\n  if ( ligID == 0xFFFF )\n    ligID = buffer->in_string[buffer->in_pos].ligID;\n\n  for ( i = 0; i < num_out; i++ )\n  {\n    HB_GlyphItem item = &buffer->out_string[buffer->out_pos + i];\n\n    item->gindex = glyph_data[i];\n    item->properties = properties;\n    item->cluster = cluster;\n    item->component = component;\n    item->ligID = ligID;\n    item->gproperty = HB_GLYPH_PROPERTY_UNKNOWN;\n  }\n\n  buffer->in_pos  += num_in;\n  buffer->out_pos += num_out;\n\n  buffer->out_length = buffer->out_pos;\n\n  return HB_Err_Ok;\n}","24265":"static __u8 *kye_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tswitch (hdev->product) {\n\tcase USB_DEVICE_ID_KYE_ERGO_525V:\n\t\t\n\t\tif (*rsize >= 74 &&\n\t\t\trdesc[61] == 0x05 && rdesc[62] == 0x08 &&\n\t\t\trdesc[63] == 0x19 && rdesc[64] == 0x08 &&\n\t\t\trdesc[65] == 0x29 && rdesc[66] == 0x0f &&\n\t\t\trdesc[71] == 0x75 && rdesc[72] == 0x08 &&\n\t\t\trdesc[73] == 0x95 && rdesc[74] == 0x01) {\n\t\t\thid_info(hdev,\n\t\t\t\t \"STR\"\n\t\t\t\t \"STR\");\n\t\t\trdesc[62] = 0x09;\n\t\t\trdesc[64] = 0x04;\n\t\t\trdesc[66] = 0x07;\n\t\t\trdesc[72] = 0x01;\n\t\t\trdesc[74] = 0x08;\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_KYE_EASYPEN_I405X:\n\t\tif (*rsize == EASYPEN_I405X_RDESC_ORIG_SIZE) {\n\t\t\trdesc = easypen_i405x_rdesc_fixed;\n\t\t\t*rsize = sizeof(easypen_i405x_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_KYE_MOUSEPEN_I608X:\n\t\tif (*rsize == MOUSEPEN_I608X_RDESC_ORIG_SIZE) {\n\t\t\trdesc = mousepen_i608x_rdesc_fixed;\n\t\t\t*rsize = sizeof(mousepen_i608x_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_KYE_EASYPEN_M610X:\n\t\tif (*rsize == EASYPEN_M610X_RDESC_ORIG_SIZE) {\n\t\t\trdesc = easypen_m610x_rdesc_fixed;\n\t\t\t*rsize = sizeof(easypen_m610x_rdesc_fixed);\n\t\t}\n\t\tbreak;\n\tcase USB_DEVICE_ID_GENIUS_GILA_GAMING_MOUSE:\n\t\trdesc = kye_consumer_control_fixup(hdev, rdesc, rsize, 104,\n\t\t\t\t\t\"STR\");\n\t\tbreak;\n\tcase USB_DEVICE_ID_GENIUS_GX_IMPERATOR:\n\t\trdesc = kye_consumer_control_fixup(hdev, rdesc, rsize, 83,\n\t\t\t\t\t\"STR\");\n\t\tbreak;\n\tcase USB_DEVICE_ID_GENIUS_MANTICORE:\n\t\trdesc = kye_consumer_control_fixup(hdev, rdesc, rsize, 104,\n\t\t\t\t\t\"STR\");\n\t\tbreak;\n\t}\n\treturn rdesc;\n}","23927":"static void ept_set_mmio_spte_mask(void)\n{\n\t\n\tkvm_mmu_set_mmio_spte_mask(VMX_EPT_RWX_MASK,\n\t\t\t\t   VMX_EPT_MISCONFIG_WX_VALUE);\n}","24143":"static void mutt_decode_uuencoded (STATE *s, LOFF_T len, int istext, iconv_t cd)\n{\n  char tmps[SHORT_STRING];\n  char linelen, c, l, out;\n  char *pt;\n  char bufi[BUFI_SIZE];\n  size_t k = 0;\n\n  if (istext)\n    state_set_prefix(s);\n\n  while (len > 0)\n  {\n    if ((fgets(tmps, sizeof(tmps), s->fpin)) == NULL)\n      return;\n    len -= mutt_strlen(tmps);\n    if ((!mutt_strncmp (tmps, \"STR\", 5)) && ISSPACE (tmps[5]))\n      break;\n  }\n  while (len > 0)\n  {\n    if ((fgets(tmps, sizeof(tmps), s->fpin)) == NULL)\n      return;\n    len -= mutt_strlen(tmps);\n    if (!mutt_strncmp (tmps, \"STR\", 3))\n      break;\n    pt = tmps;\n    linelen = decode_byte (*pt);\n    pt++;\n    for (c = 0; c < linelen;)\n    {\n      for (l = 2; l <= 6; l += 2)\n      {\n\tout = decode_byte (*pt) << l;\n\tpt++;\n\tout |= (decode_byte (*pt) >> (6 - l));\n\tbufi[k++] = out;\n\tc++;\n\tif (c == linelen)\n\t  break;\n      }\n      mutt_convert_to_state (cd, bufi, &k, s);\n      pt++;\n    }\n  }\n\n  mutt_convert_to_state (cd, bufi, &k, s);\n  mutt_convert_to_state (cd, 0, 0, s);\n\n  state_reset_prefix(s);\n}","25015":"static int hi3660_stub_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tunsigned int i;\n\tint ret;\n\n\t\n\tstub_clk_chan.cl.dev = dev;\n\tstub_clk_chan.cl.tx_done = NULL;\n\tstub_clk_chan.cl.tx_block = false;\n\tstub_clk_chan.cl.knows_txdone = false;\n\n\t\n\tstub_clk_chan.mbox = mbox_request_channel(&stub_clk_chan.cl, 0);\n\tif (IS_ERR(stub_clk_chan.mbox))\n\t\treturn PTR_ERR(stub_clk_chan.mbox);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tfreq_reg = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!freq_reg)\n\t\treturn -ENOMEM;\n\n\tfreq_reg += HI3660_STUB_CLOCK_DATA;\n\n\tfor (i = 0; i < HI3660_CLK_STUB_NUM; i++) {\n\t\tret = devm_clk_hw_register(&pdev->dev, &hi3660_stub_clks[i].hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, hi3660_stub_clk_hw_get,\n\t\t\t\t\t   hi3660_stub_clks);\n}","24246":"void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  \n  \n\n  int pos = 0;\n\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n\n  \n\n  int commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n\n  for(int i = 0; i < commentFields; i++) {\n\n    \n    \n\n    int commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n\n    int commentSeparatorPosition = comment.find(\"STR\");\n\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n\n    addField(key, value, false);\n  }\n}","24141":"void GC_log_printf(const char *format, ...)\n{\n    char buf[BUFSZ + 1];\n\n    GC_PRINTF_FILLBUF(buf, format);\n#   ifdef NACL\n      (void)WRITE(GC_log, buf, strlen(buf));\n#   else\n      if (WRITE(GC_log, buf, strlen(buf)) < 0)\n        ABORT(\"STR\");\n#   endif\n}","24169":"rpl_dao_print(netdissect_options *ndo,\n              const u_char *bp, u_int length)\n{\n        const struct nd_rpl_dao *dao = (const struct nd_rpl_dao *)bp;\n        const char *dagid_str = \"STR\";\n\n        ND_TCHECK(*dao);\n        if (length < ND_RPL_DAO_MIN_LEN)\n        \tgoto tooshort;\n\n        bp += ND_RPL_DAO_MIN_LEN;\n        length -= ND_RPL_DAO_MIN_LEN;\n        if(RPL_DAO_D(dao->rpl_flags)) {\n                ND_TCHECK2(dao->rpl_dagid, DAGID_LEN);\n                if (length < DAGID_LEN)\n                \tgoto tooshort;\n                dagid_str = ip6addr_string (ndo, dao->rpl_dagid);\n                bp += DAGID_LEN;\n                length -= DAGID_LEN;\n        }\n\n        ND_PRINT((ndo, \"STR\",\n                  dagid_str,\n                  dao->rpl_daoseq,\n                  dao->rpl_instanceid,\n                  RPL_DAO_K(dao->rpl_flags) ? \"STR\",\n                  RPL_DAO_D(dao->rpl_flags) ? \"STR\",\n                  dao->rpl_flags));\n\n        if(ndo->ndo_vflag > 1) {\n                const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)bp;\n                rpl_dio_printopt(ndo, opt, length);\n        }\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo,\"STR\"));\n\treturn;\n\ntooshort:\n\tND_PRINT((ndo,\"STR\"));\n\treturn;\n}","24555":"struct bus_id_priv *get_busid_priv(const char *busid)\n{\n\tint idx;\n\tstruct bus_id_priv *bid = NULL;\n\n\tspin_lock(&busid_table_lock);\n\tidx = get_busid_idx(busid);\n\tif (idx >= 0)\n\t\tbid = &(busid_table[idx]);\n\tspin_unlock(&busid_table_lock);\n\n\treturn bid;\n}","24582":"static bool syn_check_config(const char *cfgstring, char **reason)\n{\n\ttcmu_dbg(\"STR\");\n\tif (strcmp(cfgstring, \"STR\")) {\n\t\tasprintf(reason, \"STR\");\n\t\treturn false;\n\t}\n\treturn true;\n}","24253":"int manager_ref_uid(Manager *m, uid_t uid, bool clean_ipc) {\n        return manager_ref_uid_internal(m, &m->uid_refs, uid, clean_ipc);\n}","24408":"MagickPrivate double GenerateDifferentialNoise(RandomInfo *random_info,\n  const Quantum pixel,const NoiseType noise_type,const double attenuate)\n{\n\n\n\n\n\n\n\n\n\n  double\n    alpha,\n    beta,\n    noise,\n    sigma;\n\n  alpha=GetPseudoRandomValue(random_info);\n  switch (noise_type)\n  {\n    case UniformNoise:\n    default:\n    {\n      noise=(double) (pixel+QuantumRange*SigmaUniform*(alpha-0.5));\n      break;\n    }\n    case GaussianNoise:\n    {\n      double\n        gamma,\n        tau;\n\n      if (fabs(alpha) < MagickEpsilon)\n        alpha=1.0;\n      beta=GetPseudoRandomValue(random_info);\n      gamma=sqrt(-2.0*log(alpha));\n      sigma=gamma*cos((double) (2.0*MagickPI*beta));\n      tau=gamma*sin((double) (2.0*MagickPI*beta));\n      noise=(double) (pixel+sqrt((double) pixel)*SigmaGaussian*sigma+\n        QuantumRange*TauGaussian*tau);\n      break;\n    }\n    case ImpulseNoise:\n    {\n      if (alpha < (SigmaImpulse\/2.0))\n        noise=0.0;\n      else\n        if (alpha >= (1.0-(SigmaImpulse\/2.0)))\n          noise=(double) QuantumRange;\n        else\n          noise=(double) pixel;\n      break;\n    }\n    case LaplacianNoise:\n    {\n      if (alpha <= 0.5)\n        {\n          if (alpha <= MagickEpsilon)\n            noise=(double) (pixel-QuantumRange);\n          else\n            noise=(double) (pixel+QuantumRange*SigmaLaplacian*log(2.0*alpha)+\n              0.5);\n          break;\n        }\n      beta=1.0-alpha;\n      if (beta <= (0.5*MagickEpsilon))\n        noise=(double) (pixel+QuantumRange);\n      else\n        noise=(double) (pixel-QuantumRange*SigmaLaplacian*log(2.0*beta)+0.5);\n      break;\n    }\n    case MultiplicativeGaussianNoise:\n    {\n      sigma=1.0;\n      if (alpha > MagickEpsilon)\n        sigma=sqrt(-2.0*log(alpha));\n      beta=GetPseudoRandomValue(random_info);\n      noise=(double) (pixel+pixel*SigmaMultiplicativeGaussian*sigma*\n        cos((double) (2.0*MagickPI*beta))\/2.0);\n      break;\n    }\n    case PoissonNoise:\n    {\n      double\n        poisson;\n\n      ssize_t\n        i;\n\n      poisson=exp(-SigmaPoisson*QuantumScale*pixel);\n      for (i=0; alpha > poisson; i++)\n      {\n        beta=GetPseudoRandomValue(random_info);\n        alpha*=beta;\n      }\n      noise=(double) (QuantumRange*i\/SigmaPoisson);\n      break;\n    }\n    case RandomNoise:\n    {\n      noise=(double) (QuantumRange*SigmaRandom*alpha);\n      break;\n    }\n  }\n  return(noise);\n}","24471":"window_add_pane(struct window *w, struct window_pane *other, int before,\n    int full_size, u_int hlimit)\n{\n\tstruct window_pane\t*wp;\n\n\tif (other == NULL)\n\t\tother = w->active;\n\n\twp = window_pane_create(w, w->sx, w->sy, hlimit);\n\tif (TAILQ_EMPTY(&w->panes)) {\n\t\tlog_debug(\"STR\", __func__, w->id);\n\t\tTAILQ_INSERT_HEAD(&w->panes, wp, entry);\n\t} else if (before) {\n\t\tlog_debug(\"STR\", __func__, w->id, wp->id);\n\t\tif (full_size)\n\t\t\tTAILQ_INSERT_HEAD(&w->panes, wp, entry);\n\t\telse\n\t\t\tTAILQ_INSERT_BEFORE(other, wp, entry);\n\t} else {\n\t\tlog_debug(\"STR\", __func__, w->id, wp->id);\n\t\tif (full_size)\n\t\t\tTAILQ_INSERT_TAIL(&w->panes, wp, entry);\n\t\telse\n\t\t\tTAILQ_INSERT_AFTER(&w->panes, other, wp, entry);\n\t}\n\treturn (wp);\n}","25009":"static void sev_unlock_two_vms(struct kvm *dst_kvm, struct kvm *src_kvm)\n{\n\tstruct kvm_sev_info *dst_sev = &to_kvm_svm(dst_kvm)->sev_info;\n\tstruct kvm_sev_info *src_sev = &to_kvm_svm(src_kvm)->sev_info;\n\n\tmutex_unlock(&dst_kvm->lock);\n\tmutex_unlock(&src_kvm->lock);\n\tatomic_set_release(&dst_sev->migration_in_progress, 0);\n\tatomic_set_release(&src_sev->migration_in_progress, 0);\n}","23982":"gdImagePtr gdImageScaleNearestNeighbour(gdImagePtr im, const unsigned int width, const unsigned int height)\n{\n\tconst unsigned long new_width = MAX(1, width);\n\tconst unsigned long new_height = MAX(1, height);\n\tconst float dx = (float)im->sx \/ (float)new_width;\n\tconst float dy = (float)im->sy \/ (float)new_height;\n\tconst gdFixed f_dx = gd_ftofx(dx);\n\tconst gdFixed f_dy = gd_ftofx(dy);\n\n\tgdImagePtr dst_img;\n\tunsigned long  dst_offset_x;\n\tunsigned long  dst_offset_y = 0;\n\tunsigned int i;\n\n\tif (new_width == 0 || new_height == 0) {\n\t\treturn NULL;\n\t}\n\n\tdst_img = gdImageCreateTrueColor(new_width, new_height);\n\n\tif (dst_img == NULL) {\n\t\treturn NULL;\n\t}\n\n\tfor (i=0; i<new_height; i++) {\n\t\tunsigned int j;\n\t\tdst_offset_x = 0;\n\t\tif (im->trueColor) {\n\t\t\tfor (j=0; j<new_width; j++) {\n\t\t\t\tconst gdFixed f_i = gd_itofx(i);\n\t\t\t\tconst gdFixed f_j = gd_itofx(j);\n\t\t\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\t\t\tconst gdFixed f_b = gd_mulfx(f_j, f_dx);\n\t\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\t\tconst long n = gd_fxtoi(f_b);\n\n\t\t\t\tdst_img->tpixels[dst_offset_y][dst_offset_x++] = im->tpixels[m][n];\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j=0; j<new_width; j++) {\n\t\t\t\tconst gdFixed f_i = gd_itofx(i);\n\t\t\t\tconst gdFixed f_j = gd_itofx(j);\n\t\t\t\tconst gdFixed f_a = gd_mulfx(f_i, f_dy);\n\t\t\t\tconst gdFixed f_b = gd_mulfx(f_j, f_dx);\n\t\t\t\tconst long m = gd_fxtoi(f_a);\n\t\t\t\tconst long n = gd_fxtoi(f_b);\n\n\t\t\t\tdst_img->tpixels[dst_offset_y][dst_offset_x++] = colorIndex2RGBA(im->pixels[m][n]);\n\t\t\t}\n\t\t}\n\t\tdst_offset_y++;\n\t}\n\treturn dst_img;\n}","25018":"static void mux_chr_read(void *opaque, const uint8_t *buf, int size)\n{\n    CharDriverState *chr = opaque;\n    MuxDriver *d = chr->opaque;\n    int m = d->focus;\n    int i;\n\n    mux_chr_accept_input (opaque);\n\n    for(i = 0; i < size; i++)\n        if (mux_proc_byte(chr, d, buf[i])) {\n            if (d->prod[m] == d->cons[m] &&\n                d->chr_can_read[m] &&\n                d->chr_can_read[m](d->ext_opaque[m]))\n                d->chr_read[m](d->ext_opaque[m], &buf[i], 1);\n            else\n                d->buffer[m][d->prod[m]++ & MUX_BUFFER_MASK] = buf[i];\n        }\n}","24629":"jas_matrix_t *jas_matrix_create(int numrows, int numcols)\n{\n\tjas_matrix_t *matrix;\n\tint i;\n\n\tif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\n\t\treturn 0;\n\t}\n\tmatrix->flags_ = 0;\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\tmatrix->rows_ = 0;\n\tmatrix->maxrows_ = numrows;\n\tmatrix->data_ = 0;\n\tmatrix->datasize_ = numrows * numcols;\n\n\tif (matrix->maxrows_ > 0) {\n\t\tif (!(matrix->rows_ = jas_malloc(matrix->maxrows_ *\n\t\t  sizeof(jas_seqent_t *)))) {\n\t\t\tjas_matrix_destroy(matrix);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (matrix->datasize_ > 0) {\n\t\tif (!(matrix->data_ = jas_malloc(matrix->datasize_ *\n\t\t  sizeof(jas_seqent_t)))) {\n\t\t\tjas_matrix_destroy(matrix);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < numrows; ++i) {\n\t\tmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];\n\t}\n\n\tfor (i = 0; i < matrix->datasize_; ++i) {\n\t\tmatrix->data_[i] = 0;\n\t}\n\n\tmatrix->xstart_ = 0;\n\tmatrix->ystart_ = 0;\n\tmatrix->xend_ = matrix->numcols_;\n\tmatrix->yend_ = matrix->numrows_;\n\n\treturn matrix;\n}","24427":"main(int argc, char *argv[])\n{\n  int cnt,rc,cc;\n  char cmnd[255];\n\n  strcpy(cmnd, CMD);\n\n  if (argc > 1)\n  {\n    for (cnt = 1; cnt < argc; cnt++)\n    {\n      strcat(cmnd, \"STR\");\n      strcat(cmnd, argv[cnt]);\n    }\n  }\n  else\n  {\n    fprintf(stderr, \"STR\", argv[0], rc, cc);\n    return 255;\n  }\n\n  cc = setuid(UID);\n  rc = system(cmnd);\n\n  if ((rc != 0) || (cc != 0))\n  {\n    fprintf(stderr, \"STR\", argv[0], rc, cc);\n    return 1;\n  }\n\n  return 0;\n}","24325":"static av_cold int lag_decode_init(AVCodecContext *avctx)\n{\n    LagarithContext *l = avctx->priv_data;\n    l->avctx = avctx;\n\n    ff_dsputil_init(&l->dsp, avctx);\n\n    return 0;\n}","24704":"void RemoteDevicePropertiesWidget::checkSaveable()\n{\n    RemoteFsDevice::Details det=details();\n    modified=det!=orig;\n    saveable=!det.isEmpty();\n    if (saveable && Type_SambaAvahi==type->itemData(type->currentIndex()).toInt()) {\n        saveable=!smbAvahiName->text().trimmed().isEmpty();\n    }\n    emit updated();\n}","24326":"static git_commit_list_node **alloc_parents(\n\tgit_revwalk *walk, git_commit_list_node *commit, size_t n_parents)\n{\n\tif (n_parents <= PARENTS_PER_COMMIT)\n\t\treturn (git_commit_list_node **)((char *)commit + sizeof(git_commit_list_node));\n\n\treturn (git_commit_list_node **)git_pool_malloc(\n\t\t&walk->commit_pool, (uint32_t)(n_parents * sizeof(git_commit_list_node *)));\n}","24514":"_equalCurrentOfExpr(const CurrentOfExpr *a, const CurrentOfExpr *b)\n{\n\tCOMPARE_SCALAR_FIELD(cvarno);\n\tCOMPARE_STRING_FIELD(cursor_name);\n\tCOMPARE_SCALAR_FIELD(cursor_param);\n\n\treturn true;\n}","24056":"uint64_t ThreadCommand::pc() const {\n  uint64_t entry = 0;\n  switch(architecture_) {\n    case CPU_TYPES::CPU_TYPE_X86:\n      {\n        entry = reinterpret_cast<const details::x86_thread_state_t*>(state_.data())->eip;\n        break;\n      }\n\n    case CPU_TYPES::CPU_TYPE_X86_64:\n      {\n        entry = reinterpret_cast<const details::x86_thread_state64_t*>(state_.data())->rip;\n        break;\n      }\n\n    case CPU_TYPES::CPU_TYPE_ARM:\n      {\n        entry = reinterpret_cast<const details::arm_thread_state_t*>(state_.data())->r15;\n        break;\n      }\n\n    case CPU_TYPES::CPU_TYPE_ARM64:\n      {\n        entry = reinterpret_cast<const details::arm_thread_state64_t*>(state_.data())->pc;\n        break;\n      }\n    default:\n      {\n        LIEF_ERR(\"STR\");\n      }\n  }\n  return entry;\n}","24900":"generate_primary_key_list(MYSQL *mysql, option_string *engine_stmt)\n{\n  MYSQL_RES *result;\n  MYSQL_ROW row;\n  unsigned long long counter;\n  DBUG_ENTER(\"STR\");\n\n  \n  if (opt_only_print || (engine_stmt && \n                         strstr(engine_stmt->string, \"STR\")))\n  {\n    primary_keys_number_of= 1;\n    primary_keys= (char **)my_malloc((uint)(sizeof(char *) * \n                                            primary_keys_number_of), \n                                    MYF(MY_ZEROFILL|MY_FAE|MY_WME));\n    \n    primary_keys[0]= my_strdup(\"STR\", MYF(0)); \n  }\n  else\n  {\n    if (run_query(mysql, \"STR\")))\n    {\n      fprintf(stderr,\"STR\", my_progname,\n              mysql_error(mysql));\n      exit(1);\n    }\n\n    if (!(result= mysql_store_result(mysql)))\n    {\n      fprintf(stderr, \"STR\",\n              my_progname, mysql_errno(mysql), mysql_error(mysql));\n      exit(1);\n    }\n    primary_keys_number_of= mysql_num_rows(result);\n\n    \n    if (primary_keys_number_of)\n    {\n      \n      primary_keys= (char **)my_malloc((uint)(sizeof(char *) * \n                                              primary_keys_number_of), \n                                       MYF(MY_ZEROFILL|MY_FAE|MY_WME));\n      row= mysql_fetch_row(result);\n      for (counter= 0; counter < primary_keys_number_of; \n           counter++, row= mysql_fetch_row(result))\n        primary_keys[counter]= my_strdup(row[0], MYF(0));\n    }\n\n    mysql_free_result(result);\n  }\n\n  DBUG_RETURN(0);\n}","24302":"int ssl3_setup_buffers(SSL *s)\n\t{\n\tif (!ssl3_setup_read_buffer(s))\n\t\treturn 0;\n\tif (!ssl3_setup_write_buffer(s))\n\t\treturn 0;\n\treturn 1;\n\t}","24556":"int set_thread_tidr(struct task_struct *t)\n{\n\tif (!cpu_has_feature(CPU_FTR_P9_TIDR))\n\t\treturn -EINVAL;\n\n\tif (t != current)\n\t\treturn -EINVAL;\n\n\tif (t->thread.tidr)\n\t\treturn 0;\n\n\tt->thread.tidr = (u16)task_pid_nr(t);\n\tmtspr(SPRN_TIDR, t->thread.tidr);\n\n\treturn 0;\n}","24134":"static struct db_arg_chain_tree *_db_node_get(struct db_arg_chain_tree *node)\n{\n\tnode->refcnt++;\n\treturn node;\n}","23884":"ssize_t device_show_ulong(struct device *dev,\n\t\t\t  struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct dev_ext_attribute *ea = to_ext_attr(attr);\n\treturn snprintf(buf, PAGE_SIZE, \"STR\", *(unsigned long *)(ea->var));\n}","24593":"mono_custom_attrs_from_index (MonoImage *image, guint32 idx)\n{\n\tguint32 mtoken, i, len;\n\tguint32 cols [MONO_CUSTOM_ATTR_SIZE];\n\tMonoTableInfo *ca;\n\tMonoCustomAttrInfo *ainfo;\n\tGList *tmp, *list = NULL;\n\tconst char *data;\n\n\tca = &image->tables [MONO_TABLE_CUSTOMATTRIBUTE];\n\n\ti = mono_metadata_custom_attrs_from_index (image, idx);\n\tif (!i)\n\t\treturn NULL;\n\ti --;\n\twhile (i < ca->rows) {\n\t\tif (mono_metadata_decode_row_col (ca, i, MONO_CUSTOM_ATTR_PARENT) != idx)\n\t\t\tbreak;\n\t\tlist = g_list_prepend (list, GUINT_TO_POINTER (i));\n\t\t++i;\n\t}\n\tlen = g_list_length (list);\n\tif (!len)\n\t\treturn NULL;\n\tainfo = g_malloc0 (MONO_SIZEOF_CUSTOM_ATTR_INFO + sizeof (MonoCustomAttrEntry) * len);\n\tainfo->num_attrs = len;\n\tainfo->image = image;\n\tfor (i = 0, tmp = list; i < len; ++i, tmp = tmp->next) {\n\t\tmono_metadata_decode_row (ca, GPOINTER_TO_UINT (tmp->data), cols, MONO_CUSTOM_ATTR_SIZE);\n\t\tmtoken = cols [MONO_CUSTOM_ATTR_TYPE] >> MONO_CUSTOM_ATTR_TYPE_BITS;\n\t\tswitch (cols [MONO_CUSTOM_ATTR_TYPE] & MONO_CUSTOM_ATTR_TYPE_MASK) {\n\t\tcase MONO_CUSTOM_ATTR_TYPE_METHODDEF:\n\t\t\tmtoken |= MONO_TOKEN_METHOD_DEF;\n\t\t\tbreak;\n\t\tcase MONO_CUSTOM_ATTR_TYPE_MEMBERREF:\n\t\t\tmtoken |= MONO_TOKEN_MEMBER_REF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tg_error (\"STR\", cols [MONO_CUSTOM_ATTR_TYPE]);\n\t\t\tbreak;\n\t\t}\n\t\tainfo->attrs [i].ctor = mono_get_method (image, mtoken, NULL);\n\t\tif (!ainfo->attrs [i].ctor) {\n\t\t\tg_warning (\"STR\", image->name, mtoken);\n\t\t\tg_list_free (list);\n\t\t\tg_free (ainfo);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (!mono_verifier_verify_cattr_blob (image, cols [MONO_CUSTOM_ATTR_VALUE], NULL)) {\n\t\t\t\n\t\t\tg_warning (\"STR\", image->name, idx);\n\t\t\tg_list_free (list);\n\t\t\tg_free (ainfo);\n\t\t\treturn NULL;\n\t\t}\n\t\tdata = mono_metadata_blob_heap (image, cols [MONO_CUSTOM_ATTR_VALUE]);\n\t\tainfo->attrs [i].data_size = mono_metadata_decode_value (data, &data);\n\t\tainfo->attrs [i].data = (guchar*)data;\n\t}\n\tg_list_free (list);\n\n\treturn ainfo;\n}","24065":"prefix_uli(uint8_t *data, size_t size)\n{\n\tsize_t i = 0;\n\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\tif (i < size && data[i] == ' ') i++;\n\n\tif (i + 1 >= size ||\n\t\t(data[i] != '*' && data[i] != '+' && data[i] != '-') ||\n\t\tdata[i + 1] != ' ')\n\t\treturn 0;\n\n\tif (is_next_headerline(data + i, size - i))\n\t\treturn 0;\n\n\treturn i + 2;\n}","23901":"static int tab_is_tree(struct libmnt_table *tb)\n{\n\tstruct libmnt_fs *fs = NULL;\n\tstruct libmnt_iter *itr;\n\tint rc = 0;\n\n\titr = mnt_new_iter(MNT_ITER_BACKWARD);\n\tif (!itr)\n\t\treturn 0;\n\n\trc = (mnt_table_next_fs(tb, itr, &fs) == 0 &&\n\t      mnt_fs_is_kernel(fs) &&\n\t      mnt_fs_get_root(fs));\n\n\tmnt_free_iter(itr);\n\treturn rc;\n}","23987":"MonoReflectionMethod*\nmono_reflection_bind_generic_method_parameters (MonoReflectionMethod *rmethod, MonoArray *types)\n{\n\tMonoClass *klass;\n\tMonoMethod *method, *inflated;\n\tMonoMethodInflated *imethod;\n\tMonoGenericContext tmp_context;\n\tMonoGenericInst *ginst;\n\tMonoType **type_argv;\n\tint count, i;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\t\n\tif (!strcmp (rmethod->object.vtable->klass->name, \"STR\")) {\n#ifndef DISABLE_REFLECTION_EMIT\n\t\tMonoReflectionMethodBuilder *mb = NULL;\n\t\tMonoReflectionTypeBuilder *tb;\n\t\tMonoClass *klass;\n\n\t\tmb = (MonoReflectionMethodBuilder *) rmethod;\n\t\ttb = (MonoReflectionTypeBuilder *) mb->type;\n\t\tklass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\n\t\tmethod = methodbuilder_to_mono_method (klass, mb);\n#else\n\t\tg_assert_not_reached ();\n\t\tmethod = NULL;\n#endif\n\t} else {\n\t\tmethod = rmethod->method;\n\t}\n\n\tklass = method->klass;\n\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\n\tcount = mono_method_signature (method)->generic_param_count;\n\tif (count != mono_array_length (types))\n\t\treturn NULL;\n\n\ttype_argv = g_new0 (MonoType *, count);\n\tfor (i = 0; i < count; i++) {\n\t\tMonoReflectionType *garg = mono_array_get (types, gpointer, i);\n\t\ttype_argv [i] = mono_reflection_type_get_handle (garg);\n\t}\n\tginst = mono_metadata_get_generic_inst (count, type_argv);\n\tg_free (type_argv);\n\n\ttmp_context.class_inst = klass->generic_class ? klass->generic_class->context.class_inst : NULL;\n\ttmp_context.method_inst = ginst;\n\n\tinflated = mono_class_inflate_generic_method (method, &tmp_context);\n\timethod = (MonoMethodInflated *) inflated;\n\n\t\n\tif (method->klass->image->dynamic) {\n\t\tMonoDynamicImage *image = (MonoDynamicImage*)method->klass->image;\n\t\t\n\t\tmono_loader_lock ();\n\t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, rmethod);\n\t\tmono_loader_unlock ();\n\t}\n\t\n\treturn mono_method_get_object (mono_object_domain (rmethod), inflated, NULL);","24215":"static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx)\n{\n\tstruct xenvif *vif;\n\tstruct pending_tx_info *pending_tx_info;\n\tpending_ring_idx_t index;\n\n\t\n\tif (netbk->mmap_pages[pending_idx] == NULL)\n\t\treturn;\n\n\tpending_tx_info = &netbk->pending_tx_info[pending_idx];\n\n\tvif = pending_tx_info->vif;\n\n\tmake_tx_response(vif, &pending_tx_info->req, XEN_NETIF_RSP_OKAY);\n\n\tindex = pending_index(netbk->pending_prod++);\n\tnetbk->pending_ring[index] = pending_idx;\n\n\txenvif_put(vif);\n\n\tnetbk->mmap_pages[pending_idx]->mapping = 0;\n\tput_page(netbk->mmap_pages[pending_idx]);\n\tnetbk->mmap_pages[pending_idx] = NULL;\n}","24006":"static ssize_t loop_attr_sizelimit_show(struct loop_device *lo, char *buf)\n{\n\treturn sprintf(buf, \"STR\", (unsigned long long)lo->lo_sizelimit);\n}","24677":"static int find_stream_bounds(const char *start, off_t bytesleft, off_t bytesleft2, off_t *stream, off_t *endstream)\n{\n    const char *q2, *q;\n    if ((q2 = cli_memstr(start, bytesleft, \"STR\", 6))) {\n\tq2 += 6;\n\tif (q2[0] == '\\xd' && q2[1] == '\\xa')\n\t    q2 += 2;\n\tif (q2[0] == '\\xa')\n\t    q2++;\n\t*stream = q2 - start;\n\tbytesleft2 -= q2 - start;\n\tq = q2;\n\tq2 = cli_memstr(q, bytesleft2, \"STR\", 9);\n\tif (!q2)\n\t    return 0;\n\t*endstream = q2 - start;\n\treturn 1;\n    }\n    return 0;\n}","24245":"bool ber_read_OID_String(TALLOC_CTX *mem_ctx, DATA_BLOB blob, char **OID)\n{\n\tsize_t bytes_eaten;\n\n\tif (!_ber_read_OID_String_impl(mem_ctx, blob, OID, &bytes_eaten))\n\t\treturn false;\n\n\treturn (bytes_eaten == blob.length);\n}","25031":"OFCondition WlmActivityManager::HandleEchoSCP( T_ASC_Association *assoc, T_DIMSE_C_EchoRQ *req, T_ASC_PresentationContextID presId )\n\n\n\n\n\n\n\n\n\n{\n  OFString temp_str;\n\n  \n  DCMWLM_INFO(\"STR\");\n  DCMWLM_DEBUG(DIMSE_dumpMessage(temp_str, *req, DIMSE_INCOMING, NULL, presId));\n\n  \n  OFCondition cond = DIMSE_sendEchoResponse( assoc, presId, req, STATUS_Success, NULL );\n  if( cond.bad() )\n    DCMWLM_ERROR(\"STR\" << DimseCondition::dump(temp_str, cond));\n\n  \n  return cond;\n}","24123":"gst_rtsp_connection_next_timeout (GstRTSPConnection * conn, GTimeVal * timeout)\n{\n  gdouble elapsed;\n  glong sec;\n  gulong usec;\n  gint ctimeout;\n\n  g_return_val_if_fail (conn != NULL, GST_RTSP_EINVAL);\n  g_return_val_if_fail (timeout != NULL, GST_RTSP_EINVAL);\n\n  ctimeout = conn->timeout;\n  if (ctimeout >= 20) {\n    \n    ctimeout -= 5;\n  } else if (ctimeout >= 5) {\n    \n    ctimeout -= ctimeout \/ 5;\n  } else if (ctimeout >= 1) {\n    \n    ctimeout -= 1;\n  }\n\n  elapsed = g_timer_elapsed (conn->timer, &usec);\n  if (elapsed >= ctimeout) {\n    sec = 0;\n    usec = 0;\n  } else {\n    sec = ctimeout - elapsed;\n    if (usec <= G_USEC_PER_SEC)\n      usec = G_USEC_PER_SEC - usec;\n    else\n      usec = 0;\n  }\n\n  timeout->tv_sec = sec;\n  timeout->tv_usec = usec;\n\n  return GST_RTSP_OK;\n}","23844":"int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n        return AVERROR(ENOMEM);\n    hdr = *phdr;\n\n    init_get_bits8(&gb, buf, size);\n    err = ff_ac3_parse_header(&gb, hdr);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n\n    return get_bits_count(&gb);\n}","24216":"static void mux_chr_update_read_handler(CharDriverState *chr,\n                                        GMainContext *context,\n                                        int tag)\n{\n    MuxDriver *d = chr->opaque;\n\n    assert(tag >= 0);\n    assert(tag < d->mux_cnt);\n\n    d->ext_opaque[tag] = chr->handler_opaque;\n    d->chr_can_read[tag] = chr->chr_can_read;\n    d->chr_read[tag] = chr->chr_read;\n    d->chr_event[tag] = chr->chr_event;\n}","24971":"get_key(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n        char *filename, const char *fsname, EVP_PKEY **retkey,\n        const char *password)\n{\n    EVP_PKEY *pkey = NULL;\n    BIO *tmp = NULL;\n    struct get_key_cb_data cb_data;\n    int code;\n    krb5_error_code retval;\n\n    if (filename == NULL || retkey == NULL)\n        return EINVAL;\n\n    tmp = BIO_new(BIO_s_file());\n    if (tmp == NULL)\n        return ENOMEM;\n\n    code = BIO_read_filename(tmp, filename);\n    if (code == 0) {\n        retval = errno;\n        goto cleanup;\n    }\n    cb_data.context = context;\n    cb_data.id_cryptoctx = id_cryptoctx;\n    cb_data.filename = filename;\n    cb_data.fsname = fsname;\n    cb_data.password = password;\n    pkey = PEM_read_bio_PrivateKey(tmp, NULL, get_key_cb, &cb_data);\n    if (pkey == NULL && !id_cryptoctx->defer_id_prompt) {\n        retval = EIO;\n        pkiDebug(\"STR\", filename);\n        goto cleanup;\n    }\n    *retkey = pkey;\n    retval = 0;\ncleanup:\n    if (tmp != NULL)\n        BIO_free(tmp);\n    return retval;\n}","24856":"tossObjectIdentifier(FILE * fp)\n{\n    int             type;\n    char            token[MAXTOKEN];\n    int             bracketcount = 1;\n\n    type = get_token(fp, token, MAXTOKEN);\n\n    if (type != LEFTBRACKET)\n        return 0;\n    while ((type != RIGHTBRACKET || bracketcount > 0) && type != ENDOFFILE) {\n        type = get_token(fp, token, MAXTOKEN);\n        if (type == LEFTBRACKET)\n            bracketcount++;\n        else if (type == RIGHTBRACKET)\n            bracketcount--;\n    }\n\n    if (type == RIGHTBRACKET)\n        return OBJID;\n    else\n        return 0;\n}","24301":"static inline void rgb2hsv_default(int r, int g, int b,\n                                   int *hue, int *sat, int *val)\n{\n    int min, max, delta;\n\n    min = r; max = r;\n    if(min > g) min = g; if(max < g) max = g;\n    if(min > b) min = b; if(max < b) max = b;\n\n    delta = max - min; \n    *val = max; \n\n    if(delta)\n    {\n        *sat = 0xfff * delta \/ max; \n\n        \n        if( r == max )\n            *hue = 0x1000 + 0x1000 * (g - b) \/ delta;\n        else if( g == max )\n            *hue = 0x3000 + 0x1000 * (b - r) \/ delta;\n        else\n            *hue = 0x5000 + 0x1000 * (r - g) \/ delta;\n    }\n    else\n    {\n        *sat = 0;\n        *hue = 0;\n    }\n}","24276":"\t\t\t\t     bool poll_only)\n\t__must_hold(&ctx->completion_lock)\n{\n\tstruct hlist_head *list;\n\tstruct io_kiocb *req;\n\n\tlist = &ctx->cancel_hash[hash_long(sqe_addr, ctx->cancel_hash_bits)];\n\thlist_for_each_entry(req, list, hash_node) {\n\t\tif (sqe_addr != req->user_data)\n\t\t\tcontinue;\n\t\tif (poll_only && req->opcode != IORING_OP_POLL_ADD)\n\t\t\tcontinue;\n\t\treturn req;\n\t}\n\treturn NULL;","24316":"static void free_domain_mem(void *vaddr)\n{\n\tkmem_cache_free(iommu_domain_cache, vaddr);\n}","24840":"cib_timeout_handler(gpointer data)\n{\n    struct timer_rec_s *timer = data;\n\n    timer_expired = TRUE;\n    crm_err(\"STR\", timer->call_id, timer->timeout);\n\n    \n    return TRUE;\n}","24725":"int idr_get_new_above(struct idr *idp, void *ptr, int starting_id, int *id)\n{\n\tstruct idr_layer *pa[MAX_IDR_LEVEL];\n\tint rv;\n\n\trv = idr_get_empty_slot(idp, starting_id, pa, 0, idp);\n\tif (rv < 0)\n\t\treturn rv == -ENOMEM ? -EAGAIN : rv;\n\n\tidr_fill_slot(ptr, rv, pa);\n\t*id = rv;\n\treturn 0;\n}","25007":"static void finish_object(struct object *obj, const char *name, void *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tif (obj->type == OBJ_BLOB && !has_object_file(&obj->oid))\n\t\tdie(\"STR\", oid_to_hex(&obj->oid));\n\tif (info->revs->verify_objects && !obj->parsed && obj->type != OBJ_COMMIT)\n\t\tparse_object(obj->oid.hash);\n}","23940":"inline void SparseMatMul<TL, TR>::SliceMatrix(\n    const MatrixR& mat, const int num_rows, const int num_slices,\n    std::vector<typename SparseMatMul<TL, TR>::ConstMatrixMapR*>* slices) {\n  slices->resize(num_slices);\n  DSizes d(num_rows, mat.dimension(1));\n  DCHECK_LE(num_rows * num_slices, mat.dimension(0));\n  for (int i = 0; i < num_slices; ++i) {\n    (*slices)[i] = new ConstMatrixMapR(&mat(i * num_rows, 0), d);\n  }\n}","23806":"AsyncSocket::WriteResult AsyncSSLSocket::interpretSSLError(int rc, int error) {\n  if (error == SSL_ERROR_WANT_READ) {\n    \n    \n    \n    LOG(ERROR) << \"STR\" << int(state_)\n               << \"STR\" << eventFlags_\n               << \"STR\"\n               << \"STR\";\n    return WriteResult(\n        WRITE_ERROR,\n        std::make_unique<SSLException>(SSLError::INVALID_RENEGOTIATION));\n  } else {\n    if (zero_return(error, rc, errno)) {\n      return WriteResult(0);\n    }\n    auto errError = ERR_get_error();\n    VLOG(3) << \"STR\" << int(state_)\n            << \"STR\"\n            << \"STR\" << errno\n            << \"STR\" << ERR_func_error_string(errError)\n            << \"STR\" << ERR_reason_error_string(errError);\n    return WriteResult(\n        WRITE_ERROR,\n        std::make_unique<SSLException>(error, errError, rc, errno));\n  }\n}","23857":"rsvg_new_filter_primitive_image (void)\n{\n    RsvgFilterPrimitiveImage *filter;\n    filter = g_new (RsvgFilterPrimitiveImage, 1);\n    _rsvg_node_init (&filter->super.super);\n    filter->super.in = g_string_new (\"STR\");\n    filter->super.result = g_string_new (\"STR\");\n    filter->super.x.factor = filter->super.y.factor = filter->super.width.factor =\n        filter->super.height.factor = 'n';\n    filter->super.render = &rsvg_filter_primitive_image_render;\n    filter->super.super.free = &rsvg_filter_primitive_image_free;\n    filter->super.super.set_atts = rsvg_filter_primitive_image_set_atts;\n    return (RsvgNode *) filter;\n}","24490":"char *jas_strdup(const char *s)\n{\n\tint n;\n\tchar *p;\n\tn = strlen(s) + 1;\n\tif (!(p = jas_malloc(n * sizeof(char)))) {\n\t\treturn 0;\n\t}\n\tstrcpy(p, s);\n\treturn p;\n}","24061":"static char *print_string( cJSON *item )\n{\n\treturn print_string_ptr( item->valuestring );\n}","24001":"do_resaddflags(\n\tsockaddr_u *srcadr,\n\tendpt *inter,\n\tstruct req_pkt *inpkt\n\t)\n{\n\tdo_restrict(srcadr, inter, inpkt, RESTRICT_FLAGS);\n}","23905":"method_nonpublic (MonoMethod* method, gboolean start_klass)\n{\n\tswitch (method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) {\n\t\tcase METHOD_ATTRIBUTE_ASSEM:\n\t\t\treturn (start_klass || mono_defaults.generic_ilist_class);\n\t\tcase METHOD_ATTRIBUTE_PRIVATE:\n\t\t\treturn start_klass;\n\t\tcase METHOD_ATTRIBUTE_PUBLIC:\n\t\t\treturn FALSE;\n\t\tdefault:\n\t\t\treturn TRUE;\n\t}\n}","24210":"DnDCreateRootStagingDirectory(void)\n{\n   const char *root;\n\n   \n   root = DnD_GetFileRoot();\n   if (!root) {\n      return NULL;\n   }\n\n   if (File_Exists(root)) {\n      if (!DnDRootDirUsable(root) &&\n          !DnDSetPermissionsOnRootDir(root)) {\n         \n         return NULL;\n      }\n   } else {\n      if (!File_CreateDirectory(root) ||\n          !DnDSetPermissionsOnRootDir(root)) {\n         \n         return NULL;\n      }\n   }\n\n   return root;\n}","24584":"getFileTypeNoFollowSymlinks(const StaticString &filename) {\n\tstruct stat buf;\n\tint ret;\n\t\n\tret = lstat(filename.c_str(), &buf);\n\tif (ret == 0) {\n\t\tif (S_ISREG(buf.st_mode)) {\n\t\t\treturn FT_REGULAR;\n\t\t} else if (S_ISDIR(buf.st_mode)) {\n\t\t\treturn FT_DIRECTORY;\n\t\t} else if (S_ISLNK(buf.st_mode)) {\n\t\t\treturn FT_SYMLINK;\n\t\t} else {\n\t\t\treturn FT_OTHER;\n\t\t}\n\t} else {\n\t\tif (errno == ENOENT) {\n\t\t\treturn FT_NONEXISTANT;\n\t\t} else {\n\t\t\tint e = errno;\n\t\t\tstring message(\"STR\");\n\t\t\tmessage.append(filename);\n\t\t\tmessage.append(\"STR\");\n\t\t\tthrow FileSystemException(message, e, filename);\n\t\t}\n\t}\n}","24223":"GF_Err tfhd_Size(GF_Box *s)\n{\n\tGF_TrackFragmentHeaderBox *ptr = (GF_TrackFragmentHeaderBox *)s;\n\tptr->size += 4;\n\n\t\n\tif (ptr->flags & GF_ISOM_TRAF_BASE_OFFSET) ptr->size += 8;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DESC) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_DUR) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ptr->size += 4;\n\tif (ptr->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ptr->size += 4;\n\treturn GF_OK;\n}","24599":"MaybeLocal<Value> StreamBase::CallJSOnreadMethod(ssize_t nread,\n                                                 Local<ArrayBuffer> ab,\n                                                 size_t offset,\n                                                 StreamBaseJSChecks checks) {\n  Environment* env = env_;\n\n  DCHECK_EQ(static_cast<int32_t>(nread), nread);\n  DCHECK_LE(offset, INT32_MAX);\n\n  if (checks == DONT_SKIP_NREAD_CHECKS) {\n    if (ab.IsEmpty()) {\n      DCHECK_EQ(offset, 0);\n      DCHECK_LE(nread, 0);\n    } else {\n      DCHECK_GE(nread, 0);\n    }\n  }\n\n  env->stream_base_state()[kReadBytesOrError] = nread;\n  env->stream_base_state()[kArrayBufferOffset] = offset;\n\n  Local<Value> argv[] = {\n    ab.IsEmpty() ? Undefined(env->isolate()).As<Value>() : ab.As<Value>()\n  };\n\n  AsyncWrap* wrap = GetAsyncWrap();\n  CHECK_NOT_NULL(wrap);\n  Local<Value> onread = wrap->object()->GetInternalField(\n      StreamBase::kOnReadFunctionField);\n  CHECK(onread->IsFunction());\n  return wrap->MakeCallback(onread.As<Function>(), arraysize(argv), argv);\n}","24298":"static int ext4_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t       bool excl)\n{\n\thandle_t *handle;\n\tstruct inode *inode;\n\tint err, retries = 0;\n\n\tdquot_initialize(dir);\n\nretry:\n\thandle = ext4_journal_start(dir, EXT4_DATA_TRANS_BLOCKS(dir->i_sb) +\n\t\t\t\t\tEXT4_INDEX_EXTRA_TRANS_BLOCKS + 3 +\n\t\t\t\t\tEXT4_MAXQUOTAS_INIT_BLOCKS(dir->i_sb));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tif (IS_DIRSYNC(dir))\n\t\text4_handle_sync(handle);\n\n\tinode = ext4_new_inode(handle, dir, mode, &dentry->d_name, 0, NULL);\n\terr = PTR_ERR(inode);\n\tif (!IS_ERR(inode)) {\n\t\tinode->i_op = &ext4_file_inode_operations;\n\t\tinode->i_fop = &ext4_file_operations;\n\t\text4_set_aops(inode);\n\t\terr = ext4_add_nondir(handle, dentry, inode);\n\t}\n\text4_journal_stop(handle);\n\tif (err == -ENOSPC && ext4_should_retry_alloc(dir->i_sb, &retries))\n\t\tgoto retry;\n\treturn err;\n}","23915":"create_worker_threads(uint n)\n{\n\tcomp_thread_ctxt_t\t*threads;\n\tuint \t\t\ti;\n\n\tthreads = (comp_thread_ctxt_t *)\n\t\tmy_malloc(sizeof(comp_thread_ctxt_t) * n, MYF(MY_FAE));\n\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\n\t\tthd->num = i + 1;\n\t\tthd->started = FALSE;\n\t\tthd->cancelled = FALSE;\n\t\tthd->data_avail = FALSE;\n\n\t\tthd->to = (char *) my_malloc(COMPRESS_CHUNK_SIZE +\n\t\t\t\t\t\t   MY_QLZ_COMPRESS_OVERHEAD,\n\t\t\t\t\t\t   MYF(MY_FAE));\n\n\t\t\n\t\tif (pthread_mutex_init(&thd->ctrl_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->ctrl_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\n\t\t\n\t\tif (pthread_mutex_init(&thd->data_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->data_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\n\t\tpthread_mutex_lock(&thd->ctrl_mutex);\n\n\t\tif (pthread_create(&thd->id, NULL, compress_worker_thread_func,\n\t\t\t\t   thd)) {\n\t\t\tmsg(\"STR\"\n\t\t\t    \"STR\", errno);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\n\t\twhile (thd->started == FALSE)\n\t\t\tpthread_cond_wait(&thd->ctrl_cond, &thd->ctrl_mutex);\n\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t}\n\n\treturn threads;\n\nerr:\n\tmy_free(threads);\n\treturn NULL;\n}","24951":"MagickPrivate void ConvertHCLToRGB(const double hue,const double chroma,\n  const double luma,double *red,double *green,double *blue)\n{\n  double\n    b,\n    c,\n    g,\n    h,\n    m,\n    r,\n    x;\n\n  \n  assert(red != (double *) NULL);\n  assert(green != (double *) NULL);\n  assert(blue != (double *) NULL);\n  h=6.0*hue;\n  c=chroma;\n  x=c*(1.0-fabs(fmod(h,2.0)-1.0));\n  r=0.0;\n  g=0.0;\n  b=0.0;\n  if ((0.0 <= h) && (h < 1.0))\n    {\n      r=c;\n      g=x;\n    }\n  else\n    if ((1.0 <= h) && (h < 2.0))\n      {\n        r=x;\n        g=c;\n      }\n    else\n      if ((2.0 <= h) && (h < 3.0))\n        {\n          g=c;\n          b=x;\n        }\n      else\n        if ((3.0 <= h) && (h < 4.0))\n          {\n            g=x;\n            b=c;\n          }\n        else\n          if ((4.0 <= h) && (h < 5.0))\n            {\n              r=x;\n              b=c;\n            }\n          else\n            if ((5.0 <= h) && (h < 6.0))\n              {\n                r=c;\n                b=x;\n              }\n  m=luma-(0.298839*r+0.586811*g+0.114350*b);\n  *red=QuantumRange*(r+m);\n  *green=QuantumRange*(g+m);\n  *blue=QuantumRange*(b+m);\n}","23853":"static void use_numeric_locale(struct locale_context* context, char const* locale_name)\n{\n#ifdef HAVE_USELOCALE\n\n    context->new_locale = newlocale(LC_NUMERIC_MASK, locale_name, NULL);\n    context->old_locale = uselocale(context->new_locale);\n\n#else\n\n#if defined(HAVE__CONFIGTHREADLOCALE) && defined(_ENABLE_PER_THREAD_LOCALE)\n    context->old_thread_config = _configthreadlocale(_ENABLE_PER_THREAD_LOCALE);\n#endif\n\n    context->category = LC_NUMERIC;\n    tr_strlcpy(context->old_locale, setlocale(context->category, NULL), sizeof(context->old_locale));\n    setlocale(context->category, locale_name);\n\n#endif\n}","24812":"static GF_Err gf_m4v_parse_frame_mpeg4(GF_M4VParser *m4v, GF_M4VDecSpecInfo dsi, u8 *frame_type, u32 *time_inc, u64 *size, u64 *start, Bool *is_coded)\n{\n\tu8 go, hasVOP, firstObj, secs;\n\ts32 o_type;\n\tu32 vop_inc = 0;\n\n\tif (!m4v || !size || !start || !frame_type) return GF_BAD_PARAM;\n\n\t*size = 0;\n\tfirstObj = 1;\n\thasVOP = 0;\n\t*is_coded = 0;\n\tm4v->current_object_type = (u32) -1;\n\t*frame_type = 0;\n\n\tM4V_Reset(m4v, m4v->current_object_start);\n\tgo = 1;\n\twhile (go) {\n\t\to_type = M4V_LoadObject(m4v);\n\t\tswitch (o_type) {\n\t\tcase M4V_VOP_START_CODE:\n\t\t\t\n\t\t\tif (hasVOP) {\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\thasVOP = 1;\n\n\t\t\t\n\t\t\t*frame_type = gf_bs_read_int(m4v->bs, 2);\n\t\t\t\n\t\t\tsecs = 0;\n\t\t\twhile (gf_bs_read_int(m4v->bs, 1) != 0)\n\t\t\t\tsecs ++;\n\t\t\t\n\t\t\tsecs += (dsi.enh_layer || *frame_type!=2) ? m4v->tc_dec : m4v->tc_disp;\n\t\t\t\n\t\t\tgf_bs_read_int(m4v->bs, 1);\n\t\t\t\n\t\t\tif (dsi.NumBitsTimeIncrement)\n\t\t\t\tvop_inc = gf_bs_read_int(m4v->bs, dsi.NumBitsTimeIncrement);\n\n\t\t\tm4v->prev_tc_dec = m4v->tc_dec;\n\t\t\tm4v->prev_tc_disp = m4v->tc_disp;\n\t\t\tif (dsi.enh_layer || *frame_type!=2) {\n\t\t\t\tm4v->tc_disp = m4v->tc_dec;\n\t\t\t\tm4v->tc_dec = secs;\n\t\t\t}\n\t\t\t*time_inc = secs * dsi.clock_rate + vop_inc;\n\t\t\t\n\t\t\tgf_bs_read_int(m4v->bs, 1);\n\t\t\t\n\t\t\t*is_coded = gf_bs_read_int(m4v->bs, 1);\n\t\t\tgf_bs_align(m4v->bs);\n\t\t\tbreak;\n\t\tcase M4V_GOV_START_CODE:\n\t\t\tif (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\tif (hasVOP) go = 0;\n\t\t\tbreak;\n\n\t\tcase M4V_VOS_START_CODE:\n\t\tcase M4V_VOL_START_CODE:\n\t\t\tif (hasVOP) {\n\t\t\t\tgo = 0;\n\t\t\t} else if (firstObj) {\n\t\t\t\t*start = m4v->current_object_start;\n\t\t\t\tfirstObj = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase M4V_VO_START_CODE:\n\t\tdefault:\n\t\t\tbreak;\n\n\t\tcase -1:\n\t\t\t*size = gf_bs_get_position(m4v->bs) - *start;\n\t\t\treturn GF_EOS;\n\t\t}\n\t}\n\t*size = m4v->current_object_start - *start;\n\treturn GF_OK;\n}","24630":"static int gfs2_close(struct inode *inode, struct file *file)\n{\n\tstruct gfs2_sbd *sdp = inode->i_sb->s_fs_info;\n\tstruct gfs2_file *fp;\n\n\tfp = file->private_data;\n\tfile->private_data = NULL;\n\n\tif (gfs2_assert_warn(sdp, fp))\n\t\treturn -EIO;\n\n\tkfree(fp);\n\n\treturn 0;\n}","25038":"TEST_F(RouterTest, ConnectExplicitTcpUpstream) {\n  \n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_ =\n      absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>();\n  envoy::extensions::upstreams::http::tcp::v3::TcpConnectionPoolProto tcp_config;\n  cm_.thread_local_cluster_.cluster_.info_->upstream_config_.value()\n      .mutable_typed_config()\n      ->PackFrom(tcp_config);\n  callbacks_.route_->route_entry_.connect_config_ =\n      absl::make_optional<RouteEntry::ConnectConfig>();\n\n  \n  EXPECT_CALL(cm_.thread_local_cluster_.tcp_conn_pool_, newConnection(_));\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.setMethod(\"STR\");\n  headers.removePath();\n  router_.decodeHeaders(headers, false);\n\n  router_.onDestroy();\n}","24162":"    if (!NIL_P(ret)) {\n        \n        thr_crit_bup = rb_thread_critical;\n        rb_thread_critical = Qtrue;\n\n        ret = TkStringValue(ret);\n        DUMP1(\"STR\");\n        Tcl_AppendResult(interp, RSTRING_PTR(ret), (char *)NULL);\n\n        rb_thread_critical = thr_crit_bup;\n    }","24104":"\tswitch (yych) {\n\t\tcase 'a': goto yy45;\n\t\tdefault: goto yy41;\n\t}","23973":"format_cb_session_group_list(struct format_tree *ft, struct format_entry *fe)\n{\n\tstruct session\t\t*s = ft->s;\n\tstruct session_group\t*sg;\n\tstruct session\t\t*loop;\n\tstruct evbuffer\t\t*buffer;\n\tint\t\t\t size;\n\n\tif (s == NULL)\n\t\treturn;\n\tsg = session_group_contains(s);\n\tif (sg == NULL)\n\t\treturn;\n\n\tbuffer = evbuffer_new();\n\tTAILQ_FOREACH(loop, &sg->sessions, gentry) {\n\t\tif (EVBUFFER_LENGTH(buffer) > 0)\n\t\t\tevbuffer_add(buffer, \"STR\", 1);\n\t\tevbuffer_add_printf(buffer, \"STR\", loop->name);\n\t}\n\tif ((size = EVBUFFER_LENGTH(buffer)) != 0)\n\t\txasprintf(&fe->value, \"STR\", size, EVBUFFER_DATA(buffer));\n\tevbuffer_free(buffer);\n}","24481":"mail_parser_run (EMailParser *parser,\n                 EMailPartList *part_list,\n                 GCancellable *cancellable)\n{\n\tEMailExtensionRegistry *reg;\n\tCamelMimeMessage *message;\n\tEMailPart *mail_part;\n\tGQueue *parsers;\n\tGQueue mail_part_queue = G_QUEUE_INIT;\n\tGList *iter;\n\tGString *part_id;\n\n\tif (cancellable)\n\t\tg_object_ref (cancellable);\n\telse\n\t\tcancellable = g_cancellable_new ();\n\n\tg_mutex_lock (&parser->priv->mutex);\n\tg_hash_table_insert (parser->priv->ongoing_part_lists, cancellable, part_list);\n\tg_mutex_unlock (&parser->priv->mutex);\n\n\tmessage = e_mail_part_list_get_message (part_list);\n\n\treg = e_mail_parser_get_extension_registry (parser);\n\n\tparsers = e_mail_extension_registry_get_for_mime_type (\n\t\treg, \"STR\");\n\n\tif (parsers == NULL)\n\t\tparsers = e_mail_extension_registry_get_for_mime_type (\n\t\t\treg, \"STR\");\n\n\t\n\tg_return_if_fail (parsers != NULL);\n\n\tpart_id = g_string_new (\"STR\");\n\n\tmail_part = e_mail_part_new (CAMEL_MIME_PART (message), \"STR\");\n\te_mail_part_list_add_part (part_list, mail_part);\n\tg_object_unref (mail_part);\n\n\tfor (iter = parsers->head; iter; iter = iter->next) {\n\t\tEMailParserExtension *extension;\n\t\tgboolean message_handled;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\textension = iter->data;\n\t\tif (!extension)\n\t\t\tcontinue;\n\n\t\tmessage_handled = e_mail_parser_extension_parse (\n\t\t\textension, parser,\n\t\t\tCAMEL_MIME_PART (message),\n\t\t\tpart_id, cancellable, &mail_part_queue);\n\n\t\tif (message_handled)\n\t\t\tbreak;\n\t}\n\n\twhile (!g_queue_is_empty (&mail_part_queue)) {\n\t\tmail_part = g_queue_pop_head (&mail_part_queue);\n\t\te_mail_part_list_add_part (part_list, mail_part);\n\t\tg_object_unref (mail_part);\n\t}\n\n\tg_mutex_lock (&parser->priv->mutex);\n\tg_hash_table_remove (parser->priv->ongoing_part_lists, cancellable);\n\tg_mutex_unlock (&parser->priv->mutex);\n\n\tg_clear_object (&cancellable);\n\tg_string_free (part_id, TRUE);\n}","23992":"TEST_P(Http2CodecImplTest, ResponseHeadersFlood) {\n  initialize();\n\n  TestRequestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, false));\n  request_encoder_->encodeHeaders(request_headers, false);\n\n  int frame_count = 0;\n  Buffer::OwnedImpl buffer;\n  ON_CALL(server_connection_, write(_, _))\n      .WillByDefault(Invoke([&buffer, &frame_count](Buffer::Instance& frame, bool) {\n        ++frame_count;\n        buffer.move(frame);\n      }));\n\n  TestResponseHeaderMapImpl response_headers{{\"STR\"}};\n  for (uint32_t i = 0; i < CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES + 1; ++i) {\n    EXPECT_NO_THROW(response_encoder_->encodeHeaders(response_headers, false));\n  }\n  \n  \n  EXPECT_EQ(0, nghttp2_submit_ping(client_->session(), NGHTTP2_FLAG_NONE, nullptr));\n  EXPECT_THROW(client_->sendPendingFrames(), ServerCodecError);\n\n  EXPECT_EQ(frame_count, CommonUtility::OptionsLimits::DEFAULT_MAX_OUTBOUND_FRAMES + 1);\n  EXPECT_EQ(1, stats_store_.counter(\"STR\").value());\n}","24863":"static void rss_data_to_rss_config(struct VirtioNetRssData *data,\n                                   struct EBPFRSSConfig *config)\n{\n    config->redirect = data->redirect;\n    config->populate_hash = data->populate_hash;\n    config->hash_types = data->hash_types;\n    config->indirections_len = data->indirections_len;\n    config->default_queue = data->default_queue;\n}","24777":"static int filter_generate(struct tree *xfm, const char *root,\n                           int *nmatches, char ***matches) {\n    glob_t globbuf;\n    int gl_flags = glob_flags;\n    int r;\n    int ret = 0;\n    char **pathv = NULL;\n    int pathc = 0;\n    int root_prefix = strlen(root) - 1;\n\n    *nmatches = 0;\n    *matches = NULL;\n    MEMZERO(&globbuf, 1);\n\n    list_for_each(f, xfm->children) {\n        char *globpat = NULL;\n        if (! is_incl(f))\n            continue;\n        pathjoin(&globpat, 2, root, f->value);\n        r = glob(globpat, gl_flags, NULL, &globbuf);\n        free(globpat);\n\n        if (r != 0 && r != GLOB_NOMATCH)\n            goto error;\n        gl_flags |= GLOB_APPEND;\n    }\n\n    pathc = globbuf.gl_pathc;\n    int pathind = 0;\n\n    if (ALLOC_N(pathv, pathc) < 0)\n        goto error;\n\n    for (int i=0; i < pathc; i++) {\n        const char *path = globbuf.gl_pathv[i] + root_prefix;\n        bool include = true;\n\n        list_for_each(e, xfm->children) {\n            if (! is_excl(e))\n                continue;\n\n            if (strchr(e->value, SEP) == NULL)\n                path = pathbase(path);\n            if ((r = fnmatch(e->value, path, fnm_flags)) == 0) {\n                include = false;\n            }\n        }\n\n        if (include)\n            include = is_regular_file(globbuf.gl_pathv[i]);\n\n        if (include) {\n            pathv[pathind] = strdup(globbuf.gl_pathv[i]);\n            if (pathv[pathind] == NULL)\n                goto error;\n            pathind += 1;\n        }\n    }\n    pathc = pathind;\n\n    if (REALLOC_N(pathv, pathc) == -1)\n        goto error;\n\n    *matches = pathv;\n    *nmatches = pathc;\n done:\n    globfree(&globbuf);\n    return ret;\n error:\n    if (pathv != NULL)\n        for (int i=0; i < pathc; i++)\n            free(pathv[i]);\n    free(pathv);\n    ret = -1;\n    goto done;\n}","24278":"void DecimalQuantity::shiftLeft(int32_t numDigits) {\n    if (!usingBytes && precision + numDigits > 16) {\n        switchStorage();\n    }\n    if (usingBytes) {\n        ensureCapacity(precision + numDigits);\n        int i = precision + numDigits - 1;\n        for (; i >= numDigits; i--) {\n            fBCD.bcdBytes.ptr[i] = fBCD.bcdBytes.ptr[i - numDigits];\n        }\n        for (; i >= 0; i--) {\n            fBCD.bcdBytes.ptr[i] = 0;\n        }\n    } else {\n        fBCD.bcdLong <<= (numDigits * 4);\n    }\n    scale -= numDigits;\n    precision += numDigits;\n}","24182":"l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat)\n{\n\tND_PRINT((ndo, \"STR\", (EXTRACT_16BITS(dat) >> 8),\n\t    (EXTRACT_16BITS(dat) & 0xff)));\n}","24829":"static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n\n    \n    if( (*p) > end - 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"STR\"\n                                    \"STR\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    len = (*p)[0] << 8 | (*p)[1];\n    *p += 2;\n\n    if( (*p) + len > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"STR\"\n                                    \"STR\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n\n    \n    *p += len;\n    ret = 0;\n\n    return( ret );\n}","24016":"PS_SERIALIZER_DECODE_FUNC(php_serialize) \n{\n\tconst char *endptr = val + vallen;\n\tzval *session_vars;\n\tphp_unserialize_data_t var_hash;\n\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tALLOC_INIT_ZVAL(session_vars);\n\tif (php_var_unserialize(&session_vars, &val, endptr, &var_hash TSRMLS_CC)) {\n\t\tvar_push_dtor(&var_hash, &session_vars);\n\t}\n\t\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tif (PS(http_session_vars)) {\n\t\tzval_ptr_dtor(&PS(http_session_vars));\n\t}\n\tif (Z_TYPE_P(session_vars) == IS_NULL) {\n\t\tarray_init(session_vars);\n\t}\n\tPS(http_session_vars) = session_vars;\n\tZEND_SET_GLOBAL_VAR_WITH_LENGTH(\"STR\"), PS(http_session_vars), Z_REFCOUNT_P(PS(http_session_vars)) + 1, 1);\n\treturn SUCCESS;\n}","24742":"static char *next_string(char *string, unsigned long *secsize)\n{\n\t\n\twhile (string[0]) {\n\t\tstring++;\n\t\tif ((*secsize)-- <= 1)\n\t\t\treturn NULL;\n\t}\n\n\t\n\twhile (!string[0]) {\n\t\tstring++;\n\t\tif ((*secsize)-- <= 1)\n\t\t\treturn NULL;\n\t}\n\treturn string;\n}","24179":"long Segment::Load() {\n  if (m_clusters != NULL || m_clusterSize != 0 || m_clusterCount != 0)\n    return E_PARSE_FAILED;\n\n  \n  \n  \n\n  const long long header_status = ParseHeaders();\n\n  if (header_status < 0)  \n    return static_cast<long>(header_status);\n\n  if (header_status > 0)  \n    return E_BUFFER_NOT_FULL;\n\n  if (m_pInfo == NULL || m_pTracks == NULL)\n    return E_FILE_FORMAT_INVALID;\n\n  for (;;) {\n    const long status = LoadCluster();\n\n    if (status < 0)  \n      return status;\n\n    if (status >= 1)  \n      return 0;\n  }\n}","24234":"l2tp_proxy_auth_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tND_PRINT((ndo, \"STR\", tok2str(l2tp_authentype2str,\n\t\t\t     \"STR\", EXTRACT_16BITS(ptr))));\n}","23943":"static int selinux_socket_getpeersec_stream(struct socket *sock, char __user *optval,\n\t\t\t\t\t    int __user *optlen, unsigned len)\n{\n\tint err = 0;\n\tchar *scontext;\n\tu32 scontext_len;\n\tstruct sk_security_struct *ssec;\n\tstruct inode_security_struct *isec;\n\tu32 peer_sid = SECSID_NULL;\n\n\tisec = SOCK_INODE(sock)->i_security;\n\n\tif (isec->sclass == SECCLASS_UNIX_STREAM_SOCKET ||\n\t    isec->sclass == SECCLASS_TCP_SOCKET) {\n\t\tssec = sock->sk->sk_security;\n\t\tpeer_sid = ssec->peer_sid;\n\t}\n\tif (peer_sid == SECSID_NULL) {\n\t\terr = -ENOPROTOOPT;\n\t\tgoto out;\n\t}\n\n\terr = security_sid_to_context(peer_sid, &scontext, &scontext_len);\n\n\tif (err)\n\t\tgoto out;\n\n\tif (scontext_len > len) {\n\t\terr = -ERANGE;\n\t\tgoto out_len;\n\t}\n\n\tif (copy_to_user(optval, scontext, scontext_len))\n\t\terr = -EFAULT;\n\nout_len:\n\tif (put_user(scontext_len, optlen))\n\t\terr = -EFAULT;\n\n\tkfree(scontext);\nout:\n\treturn err;\n}","24930":"onig_foreach_name(regex_t* reg,\n  int (*func)(const UChar*, const UChar*,int,int*,regex_t*,void*), void* arg)\n{\n  int i, r;\n  NameEntry* e;\n  NameTable* t = (NameTable* )reg->name_table;\n\n  if (IS_NOT_NULL(t)) {\n    for (i = 0; i < t->num; i++) {\n      e = &(t->e[i]);\n      r = (*func)(e->name, e->name + e->name_len, e->back_num,\n\t\t  (e->back_num > 1 ? e->back_refs : &(e->back_ref1)),\n\t\t  reg, arg);\n      if (r != 0) return r;\n    }\n  }\n  return 0;\n}","24098":"int ssh_scp_push_file64(ssh_scp scp, const char *filename, uint64_t size,\n                        int mode)\n{\n    char buffer[1024] = {0};\n    int rc;\n    char *file = NULL;\n    char *perms = NULL;\n    uint8_t code;\n\n    if (scp == NULL) {\n        return SSH_ERROR;\n    }\n\n    if (scp->state != SSH_SCP_WRITE_INITED) {\n        ssh_set_error(scp->session, SSH_FATAL,\n                      \"STR\");\n        return SSH_ERROR;\n    }\n\n    file = ssh_basename(filename);\n    perms = ssh_scp_string_mode(mode);\n    SSH_LOG(SSH_LOG_PROTOCOL,\n            \"STR\",\n            file, size, perms);\n    snprintf(buffer, sizeof(buffer), \"STR\", perms, size, file);\n    SAFE_FREE(file);\n    SAFE_FREE(perms);\n\n    rc = ssh_channel_write(scp->channel, buffer, strlen(buffer));\n    if (rc == SSH_ERROR) {\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n\n    rc = ssh_channel_read(scp->channel, &code, 1, 0);\n    if (rc <= 0) {\n        ssh_set_error(scp->session, SSH_FATAL,\n                      \"STR\",\n                      ssh_get_error(scp->session));\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n\n    if (code != 0) {\n        ssh_set_error(scp->session, SSH_FATAL,\n                      \"STR\", code);\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n\n    scp->filelen = size;\n    scp->processed = 0;\n    scp->state = SSH_SCP_WRITE_WRITING;\n\n    return SSH_OK;\n}","24836":"int fit_image_verify(const void *fit, int image_noffset)\n{\n\tconst void\t*data;\n\tsize_t\t\tsize;\n\tint\t\tnoffset = 0;\n\tchar\t\t*err_msg = \"\";\n\n\t\n\tif (fit_image_get_data_and_size(fit, image_noffset, &data, &size)) {\n\t\terr_msg = \"STR\";\n\t\tprintf(\"STR\",\n\t\t       err_msg, fit_get_name(fit, noffset, NULL),\n\t\t       fit_get_name(fit, image_noffset, NULL));\n\t\treturn 0;\n\t}\n\n\treturn fit_image_verify_with_data(fit, image_noffset, data, size);\n}","24463":"static inline uint8_t *get_hwc_address(SM501State *state, int crt)\n{\n    uint32_t addr = crt ? state->dc_crt_hwc_addr : state->dc_panel_hwc_addr;\n    return state->local_mem + (addr & 0x03FFFFF0);\n}","24170":"\t}\n}\n\nstatic TIDY_DOC_METHOD(parseFile)\n{\n\tchar *inputfile, *enc = NULL;\n\tint input_len, enc_len = 0, contents_len = 0;\n\tzend_bool use_include_path = 0;\n\tchar *contents;\n\tzval **options = NULL;\n\tPHPTidyObj *obj;\n\n\tTIDY_SET_CONTEXT;\n\n\tobj = (PHPTidyObj *)zend_object_store_get_object(object TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"STR\", &inputfile, &input_len,\n\t\t\t\t\t\t\t  &options, &enc, &enc_len, &use_include_path) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\t\n\tif (!(contents = php_tidy_file_to_mem(inputfile, use_include_path, &contents_len TSRMLS_CC))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"STR\");\n\t\tRETURN_FALSE;\n\t}\n\n\tTIDY_APPLY_CONFIG_ZVAL(obj->ptdoc->doc, options);\n\n\tif(php_tidy_parse_string(obj, contents, contents_len, enc TSRMLS_CC) == FAILURE) {\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tRETVAL_TRUE;\n\t}","23999":"void sock_release(struct socket *sock)\n{\n\tif (sock->ops) {\n\t\tstruct module *owner = sock->ops->owner;\n\n\t\tsock->ops->release(sock);\n\t\tsock->ops = NULL;\n\t\tmodule_put(owner);\n\t}\n\n\tif (rcu_dereference_protected(sock->wq, 1)->fasync_list)\n\t\tpr_err(\"STR\", __func__);\n\n\tif (!sock->file) {\n\t\tiput(SOCK_INODE(sock));\n\t\treturn;\n\t}\n\tsock->file = NULL;\n}","24554":"static int64_t update_size(AVIOContext *pb, int64_t pos)\n{\n    int64_t curpos = avio_tell(pb);\n    avio_seek(pb, pos, SEEK_SET);\n    avio_wb32(pb, curpos - pos); \n    avio_seek(pb, curpos, SEEK_SET);\n\n    return curpos - pos;\n}","24026":"GF_Err gf_isom_hevc_set_inband_config(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, Bool keep_xps)\n{\n\treturn gf_isom_hevc_config_update_ex(the_file, trackNumber, DescriptionIndex, NULL, GF_ISOM_HVCC_SET_INBAND, keep_xps);\n}","24027":"static struct file *path_openat(int dfd, struct filename *pathname,\n\t\tstruct nameidata *nd, const struct open_flags *op, int flags)\n{\n\tstruct file *file;\n\tstruct path path;\n\tint opened = 0;\n\tint error;\n\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tfile->f_flags = op->open_flag;\n\n\tif (unlikely(file->f_flags & __O_TMPFILE)) {\n\t\terror = do_tmpfile(dfd, pathname, nd, flags, op, file, &opened);\n\t\tgoto out;\n\t}\n\n\terror = path_init(dfd, pathname, flags, nd);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\terror = do_last(nd, &path, file, op, &opened, pathname);\n\twhile (unlikely(error > 0)) { \n\t\tstruct path link = path;\n\t\tvoid *cookie;\n\t\tif (!(nd->flags & LOOKUP_FOLLOW)) {\n\t\t\tpath_put_conditional(&path, nd);\n\t\t\tpath_put(&nd->path);\n\t\t\terror = -ELOOP;\n\t\t\tbreak;\n\t\t}\n\t\terror = may_follow_link(&link, nd);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\tnd->flags |= LOOKUP_PARENT;\n\t\tnd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);\n\t\terror = follow_link(&link, nd, &cookie);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\terror = do_last(nd, &path, file, op, &opened, pathname);\n\t\tput_link(nd, &link, cookie);\n\t}\nout:\n\tpath_cleanup(nd);\n\tif (!(opened & FILE_OPENED)) {\n\t\tBUG_ON(!error);\n\t\tput_filp(file);\n\t}\n\tif (unlikely(error)) {\n\t\tif (error == -EOPENSTALE) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\terror = -ECHILD;\n\t\t\telse\n\t\t\t\terror = -ESTALE;\n\t\t}\n\t\tfile = ERR_PTR(error);\n\t}\n\treturn file;\n}","24048":"int hfsplus_rename_cat(u32 cnid,\n\t\t       struct inode *src_dir, struct qstr *src_name,\n\t\t       struct inode *dst_dir, struct qstr *dst_name)\n{\n\tstruct super_block *sb = src_dir->i_sb;\n\tstruct hfs_find_data src_fd, dst_fd;\n\thfsplus_cat_entry entry;\n\tint entry_size, type;\n\tint err;\n\n\tdprint(DBG_CAT_MOD, \"STR\",\n\t\tcnid, src_dir->i_ino, src_name->name,\n\t\tdst_dir->i_ino, dst_name->name);\n\terr = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &src_fd);\n\tif (err)\n\t\treturn err;\n\tdst_fd = src_fd;\n\n\t\n\thfsplus_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n\t\t\t\tsrc_fd.entrylength);\n\n\t\n\thfsplus_cat_build_key(sb, dst_fd.search_key, dst_dir->i_ino, dst_name);\n\terr = hfs_brec_find(&dst_fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\n\terr = hfs_brec_insert(&dst_fd, &entry, src_fd.entrylength);\n\tif (err)\n\t\tgoto out;\n\tdst_dir->i_size++;\n\tdst_dir->i_mtime = dst_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t\n\thfsplus_cat_build_key(sb, src_fd.search_key, src_dir->i_ino, src_name);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\tsrc_dir->i_size--;\n\tsrc_dir->i_mtime = src_dir->i_ctime = CURRENT_TIME_SEC;\n\n\t\n\thfsplus_cat_build_key(sb, src_fd.search_key, cnid, NULL);\n\terr = hfs_brec_find(&src_fd);\n\tif (err)\n\t\tgoto out;\n\ttype = hfs_bnode_read_u16(src_fd.bnode, src_fd.entryoffset);\n\terr = hfs_brec_remove(&src_fd);\n\tif (err)\n\t\tgoto out;\n\n\t\n\thfsplus_cat_build_key(sb, dst_fd.search_key, cnid, NULL);\n\tentry_size = hfsplus_fill_cat_thread(sb, &entry, type,\n\t\tdst_dir->i_ino, dst_name);\n\terr = hfs_brec_find(&dst_fd);\n\tif (err != -ENOENT) {\n\t\tif (!err)\n\t\t\terr = -EEXIST;\n\t\tgoto out;\n\t}\n\terr = hfs_brec_insert(&dst_fd, &entry, entry_size);\n\n\thfsplus_mark_inode_dirty(dst_dir, HFSPLUS_I_CAT_DIRTY);\n\thfsplus_mark_inode_dirty(src_dir, HFSPLUS_I_CAT_DIRTY);\nout:\n\thfs_bnode_put(dst_fd.bnode);\n\thfs_find_exit(&src_fd);\n\treturn err;\n}","24588":"      \n      CImg<uintT> get_level(CImg<charT>& _expr) const {\n        bool is_escaped = false, next_is_escaped = false;\n        unsigned int mode = 0, next_mode = 0; \n        CImg<uintT> res(_expr._width - 1);\n        unsigned int *pd = res._data;\n        int _level = 0;\n        for (const char *ps = _expr._data; *ps && _level>=0; ++ps) {\n          if (!is_escaped && !next_is_escaped && *ps=='\\\\') next_is_escaped = true;\n          if (!is_escaped && *ps=='\\'') { \n            if (!mode && ps>_expr._data && *(ps - 1)=='[') next_mode = mode = 2; \n            else if (mode==2 && *(ps + 1)==']') next_mode = !mode; \n            else if (mode<2) next_mode = mode?(mode = 0):1; \n          }\n          *(pd++) = (unsigned int)(mode>=1 || is_escaped?_level + (mode==1):\n                                   *ps=='(' || *ps=='['?_level++:\n                                   *ps==')' || *ps==']'?--_level:\n                                   _level);\n          mode = next_mode;\n          is_escaped = next_is_escaped;\n          next_is_escaped = false;\n        }\n        if (mode) {\n          cimg::strellipsize(_expr,64);\n          throw CImgArgumentException(\"STR\"\n                                      \"STR\",\n                                      pixel_type(),_cimg_mp_calling_function,\n                                      _expr._data);\n        }\n        if (_level) {\n          cimg::strellipsize(_expr,64);\n          throw CImgArgumentException(\"STR\"\n                                      \"STR\",\n                                      pixel_type(),_cimg_mp_calling_function,\n                                      _expr._data);\n        }\n        return res;","24250":"u_char *_our_safe_pcap_next(pcap_t *pcap,  struct pcap_pkthdr *pkthdr,\n        const char *funcname, const int line, const char *file)\n{\n    u_char *pktdata = (u_char *)pcap_next(pcap, pkthdr);\n\n    if (pktdata) {\n        if (pkthdr->len > MAXPACKET) {\n            fprintf(stderr, \"STR\",\n                    file, funcname, line, pkthdr->len, MAXPACKET);\n            exit(-1);\n        }\n\n        if (pkthdr->len < pkthdr->caplen) {\n            fprintf(stderr, \"STR\",\n                    file, funcname, line, pkthdr->len, pkthdr->caplen);\n            exit(-1);\n        }\n    }\n\n    return pktdata;\n}","24631":"void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tkvm_arm_set_running_vcpu(NULL);\n}","24938":"PHP_METHOD(Phar, loadPhar)\n{\n\tchar *fname, *alias = NULL, *error;\n\tsize_t fname_len, alias_len = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"STR\", &fname, &fname_len, &alias, &alias_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tphar_request_initialize();\n\n\tRETVAL_BOOL(phar_open_from_filename(fname, fname_len, alias, alias_len, REPORT_ERRORS, NULL, &error) == SUCCESS);\n\n\tif (error) {\n\t\tzend_throw_exception_ex(phar_ce_PharException, 0, \"STR\", error);\n\t\tefree(error);\n\t}\n} ","24992":"static void stream_joined(h2_mplx *m, h2_stream *stream)\n{\n    ap_assert(!stream->task || stream->task->worker_done);\n    \n    h2_ihash_remove(m->shold, stream->id);\n    h2_ihash_add(m->spurge, stream);\n}","25057":"evbuffer_prepend(struct evbuffer *buf, const void *data, size_t datlen)\n{\n\tstruct evbuffer_chain *chain, *tmp;\n\tint result = -1;\n\n\tEVBUFFER_LOCK(buf);\n\n\tif (buf->freeze_start) {\n\t\tgoto done;\n\t}\n\n\tchain = buf->first;\n\n\tif (chain == NULL) {\n\t\tchain = evbuffer_chain_new(datlen);\n\t\tif (!chain)\n\t\t\tgoto done;\n\t\tevbuffer_chain_insert(buf, chain);\n\t}\n\n\t\n\tif ((chain->flags & EVBUFFER_IMMUTABLE) == 0) {\n\t\t\n\t\tif (chain->off == 0)\n\t\t\tchain->misalign = chain->buffer_len;\n\n\t\tif ((size_t)chain->misalign >= datlen) {\n\t\t\t\n\t\t\tmemcpy(chain->buffer + chain->misalign - datlen,\n\t\t\t    data, datlen);\n\t\t\tchain->off += datlen;\n\t\t\tchain->misalign -= datlen;\n\t\t\tbuf->total_len += datlen;\n\t\t\tbuf->n_add_for_cb += datlen;\n\t\t\tgoto out;\n\t\t} else if (chain->misalign) {\n\t\t\t\n\t\t\tmemcpy(chain->buffer,\n\t\t\t    (char*)data + datlen - chain->misalign,\n\t\t\t    (size_t)chain->misalign);\n\t\t\tchain->off += (size_t)chain->misalign;\n\t\t\tbuf->total_len += (size_t)chain->misalign;\n\t\t\tbuf->n_add_for_cb += (size_t)chain->misalign;\n\t\t\tdatlen -= (size_t)chain->misalign;\n\t\t\tchain->misalign = 0;\n\t\t}\n\t}\n\n\t\n\tif ((tmp = evbuffer_chain_new(datlen)) == NULL)\n\t\tgoto done;\n\tbuf->first = tmp;\n\tif (buf->last_with_datap == &buf->first)\n\t\tbuf->last_with_datap = &tmp->next;\n\n\ttmp->next = chain;\n\n\ttmp->off = datlen;\n\ttmp->misalign = tmp->buffer_len - datlen;\n\n\tmemcpy(tmp->buffer + tmp->misalign, data, datlen);\n\tbuf->total_len += datlen;\n\tbuf->n_add_for_cb += (size_t)chain->misalign;\n\nout:\n\tevbuffer_invoke_callbacks_(buf);\n\tresult = 0;\ndone:\n\tEVBUFFER_UNLOCK(buf);\n\treturn result;\n}","24776":"static MemoryRegionSection address_space_translate_iommu(IOMMUMemoryRegion *iommu_mr,\n                                                         hwaddr *xlat,\n                                                         hwaddr *plen_out,\n                                                         hwaddr *page_mask_out,\n                                                         bool is_write,\n                                                         bool is_mmio,\n                                                         AddressSpace **target_as,\n                                                         MemTxAttrs attrs)\n{\n    MemoryRegionSection *section;\n    hwaddr page_mask = (hwaddr)-1;\n    MemoryRegion *mr = MEMORY_REGION(iommu_mr);\n\n    do {\n        hwaddr addr = *xlat;\n        IOMMUMemoryRegionClass *imrc = memory_region_get_iommu_class_nocheck(iommu_mr);\n        int iommu_idx = 0;\n        IOMMUTLBEntry iotlb;\n\n        if (imrc->attrs_to_index) {\n            iommu_idx = imrc->attrs_to_index(iommu_mr, attrs);\n        }\n\n        iotlb = imrc->translate(iommu_mr, addr, is_write ?\n                                IOMMU_WO : IOMMU_RO, iommu_idx);\n\n        if (!(iotlb.perm & (1 << is_write))) {\n            goto unassigned;\n        }\n\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n                | (addr & iotlb.addr_mask));\n        page_mask &= iotlb.addr_mask;\n        *plen_out = MIN(*plen_out, (addr | iotlb.addr_mask) - addr + 1);\n        *target_as = iotlb.target_as;\n\n        section = address_space_translate_internal(\n                address_space_to_dispatch(iotlb.target_as), addr, xlat,\n                plen_out, is_mmio);\n\n        iommu_mr = memory_region_get_iommu(section->mr);\n    } while (unlikely(iommu_mr));\n\n    if (page_mask_out) {\n        *page_mask_out = page_mask;\n    }\n    return *section;\n\nunassigned:\n    return (MemoryRegionSection) { .mr = &(mr->uc->io_mem_unassigned) };\n}","24433":"static inline int cma_loopback_addr(struct sockaddr *addr)\n{\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\treturn ipv4_is_loopback(((struct sockaddr_in *) addr)->sin_addr.s_addr);\n\tcase AF_INET6:\n\t\treturn ipv6_addr_loopback(&((struct sockaddr_in6 *) addr)->sin6_addr);\n\tcase AF_IB:\n\t\treturn ib_addr_loopback(&((struct sockaddr_ib *) addr)->sib_addr);\n\tdefault:\n\t\treturn 0;\n\t}\n}","24522":"void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}","24789":"dns_check_entry(u8_t i)\n{\n  err_t err;\n  struct dns_table_entry *entry = &dns_table[i];\n\n  LWIP_ASSERT(\"STR\", i < DNS_TABLE_SIZE);\n\n  switch (entry->state) {\n\n    case DNS_STATE_NEW: {\n      u16_t txid;\n      \n      txid = dns_create_txid();\n      entry->txid = txid;\n      entry->state   = DNS_STATE_ASKING;\n      entry->numdns  = 0;\n      entry->tmr     = 1;\n      entry->retries = 0;\n\n      \n      err = dns_send(entry->numdns, entry->name, txid);\n      if (err != ERR_OK) {\n        LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,\n                    (\"STR\", lwip_strerr(err)));\n      }\n      break;\n    }\n\n    case DNS_STATE_ASKING:\n      if (--entry->tmr == 0) {\n        if (++entry->retries == DNS_MAX_RETRIES) {\n          if ((entry->numdns+1<DNS_MAX_SERVERS) && !ip_addr_isany(&dns_servers[entry->numdns+1])) {\n            \n            entry->numdns++;\n            entry->tmr     = 1;\n            entry->retries = 0;\n            break;\n          } else {\n            LWIP_DEBUGF(DNS_DEBUG, (\"STR\", entry->name));\n            \n            dns_call_found(i, NULL);\n            \n            entry->state   = DNS_STATE_UNUSED;\n            break;\n          }\n        }\n\n        \n        entry->tmr = entry->retries;\n\n        \n        err = dns_send(entry->numdns, entry->name, entry->txid);\n        if (err != ERR_OK) {\n          LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,\n                      (\"STR\", lwip_strerr(err)));\n        }\n      }\n      break;\n    case DNS_STATE_DONE:\n      \n      if ((entry->ttl == 0) || (--entry->ttl == 0)) {\n        LWIP_DEBUGF(DNS_DEBUG, (\"STR\", entry->name));\n        \n        entry->state = DNS_STATE_UNUSED;\n      }\n      break;\n    case DNS_STATE_UNUSED:\n      \n      break;\n    default:\n      LWIP_ASSERT(\"STR\", 0);\n      break;\n  }\n}","24697":"int TDStretch::seekBestOverlapPosition(const SAMPLETYPE *refPos)\r\n{\r\n    if (bQuickSeek) \r\n    {\r\n        return seekBestOverlapPositionQuick(refPos);\r\n    }\r\n    else \r\n    {\r\n        return seekBestOverlapPositionFull(refPos);\r\n    }\r\n}\r","24475":"hash_new_from_values(mrb_state *mrb, mrb_int argc, mrb_value *regs)\n{\n  mrb_value hash = mrb_hash_new_capa(mrb, argc);\n  while (argc--) {\n    mrb_hash_set(mrb, hash, regs[0], regs[1]);\n    regs += 2;\n  }\n  return hash;\n}","24663":"static size_t optsize (lua_State *L, char opt, const char **fmt) {\n  switch (opt) {\n    case 'B': case 'b': return sizeof(char);\n    case 'H': case 'h': return sizeof(short);\n    case 'L': case 'l': return sizeof(long);\n    case 'T': return sizeof(size_t);\n    case 'f':  return sizeof(float);\n    case 'd':  return sizeof(double);\n    case 'x': return 1;\n    case 'c': return getnum(L, fmt, 1);\n    case 'i': case 'I': {\n      int sz = getnum(L, fmt, sizeof(int));\n      if (sz > MAXINTSIZE)\n        luaL_error(L, \"STR\",\n                       sz, MAXINTSIZE);\n      return sz;\n    }\n    default: return 0;  \n  }\n}","24769":"static int mailbox_commit_header(struct mailbox *mailbox)\n{\n    int fd;\n    int r = 0;\n    const char *newfname;\n    struct iovec iov[10];\n    int niov;\n\n    if (!mailbox->header_dirty)\n        return 0; \n\n    \n    assert(mailbox_index_islocked(mailbox, 1));\n\n    newfname = mailbox_meta_newfname(mailbox, META_HEADER);\n\n    fd = open(newfname, O_CREAT | O_TRUNC | O_RDWR, 0666);\n    if (fd == -1) {\n        xsyslog(LOG_ERR, \"STR\",\n                         \"STR\",\n                         newfname);\n        return IMAP_IOERROR;\n    }\n\n    \n    r = write(fd, MAILBOX_HEADER_MAGIC,\n              sizeof(MAILBOX_HEADER_MAGIC) - 1);\n\n    if (r != -1) {\n        char *data = mailbox_header_data_cstring(mailbox);\n        niov = 0;\n        WRITEV_ADDSTR_TO_IOVEC(iov, niov, data);\n        WRITEV_ADD_TO_IOVEC(iov, niov, \"STR\", 1);\n        r = retry_writev(fd, iov, niov);\n        free(data);\n    }\n\n    if (r == -1 || fsync(fd)) {\n        xsyslog(LOG_ERR, \"STR\",\n                         \"STR\",\n                         newfname);\n        close(fd);\n        unlink(newfname);\n        return IMAP_IOERROR;\n    }\n\n    close(fd);\n\n    \n    r = mailbox_meta_rename(mailbox, META_HEADER);\n    if (r) return r;\n    mailbox->header_dirty = 0; \n\n    \n    r = mailbox_read_header(mailbox);\n    if (r) return r;\n\n    \n    mailbox->i.header_file_crc = mailbox->header_file_crc;\n    mailbox_index_dirty(mailbox);\n\n    return 0;\n}","24470":"static int test_alt_chains_cert_forgery(void)\n{\n    int ret = 0;\n    int i;\n    X509 *x = NULL;\n    STACK_OF(X509) *untrusted = NULL;\n    BIO *bio = NULL;\n    X509_STORE_CTX *sctx = NULL;\n    X509_STORE *store = NULL;\n    X509_LOOKUP *lookup = NULL;\n\n    store = X509_STORE_new();\n    if (store == NULL)\n        goto err;\n\n    lookup = X509_STORE_add_lookup(store, X509_LOOKUP_file());\n    if (lookup == NULL)\n        goto err;\n    if (!X509_LOOKUP_load_file(lookup, roots_f, X509_FILETYPE_PEM))\n        goto err;\n\n    untrusted = load_certs_from_file(untrusted_f);\n\n    if ((bio = BIO_new_file(bad_f, \"STR\")) == NULL)\n        goto err;\n\n    if ((x = PEM_read_bio_X509(bio, NULL, 0, NULL)) == NULL)\n        goto err;\n\n    sctx = X509_STORE_CTX_new();\n    if (sctx == NULL)\n        goto err;\n\n    if (!X509_STORE_CTX_init(sctx, store, x, untrusted))\n        goto err;\n\n    i = X509_verify_cert(sctx);\n\n    if (i == 0 && X509_STORE_CTX_get_error(sctx) == X509_V_ERR_INVALID_CA) {\n        \n        ret = 1;\n    }\n err:\n    X509_STORE_CTX_free(sctx);\n    X509_free(x);\n    BIO_free(bio);\n    sk_X509_pop_free(untrusted, X509_free);\n    X509_STORE_free(store);\n    return ret;\n}","24540":"static void hci_auth_complete_evt(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_ev_auth_complete *ev = (void *) skb->data;\n\tstruct hci_conn *conn;\n\n\tBT_DBG(\"STR\", hdev->name, ev->status);\n\n\thci_dev_lock(hdev);\n\n\tconn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));\n\tif (!conn)\n\t\tgoto unlock;\n\n\tif (!ev->status) {\n\t\tclear_bit(HCI_CONN_AUTH_FAILURE, &conn->flags);\n\n\t\tif (!hci_conn_ssp_enabled(conn) &&\n\t\t    test_bit(HCI_CONN_REAUTH_PEND, &conn->flags)) {\n\t\t\tbt_dev_info(hdev, \"STR\");\n\t\t} else {\n\t\t\tset_bit(HCI_CONN_AUTH, &conn->flags);\n\t\t\tconn->sec_level = conn->pending_sec_level;\n\t\t}\n\t} else {\n\t\tif (ev->status == HCI_ERROR_PIN_OR_KEY_MISSING)\n\t\t\tset_bit(HCI_CONN_AUTH_FAILURE, &conn->flags);\n\n\t\tmgmt_auth_failed(conn, ev->status);\n\t}\n\n\tclear_bit(HCI_CONN_AUTH_PEND, &conn->flags);\n\tclear_bit(HCI_CONN_REAUTH_PEND, &conn->flags);\n\n\tif (conn->state == BT_CONFIG) {\n\t\tif (!ev->status && hci_conn_ssp_enabled(conn)) {\n\t\t\tstruct hci_cp_set_conn_encrypt cp;\n\t\t\tcp.handle  = ev->handle;\n\t\t\tcp.encrypt = 0x01;\n\t\t\thci_send_cmd(hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),\n\t\t\t\t     &cp);\n\t\t} else {\n\t\t\tconn->state = BT_CONNECTED;\n\t\t\thci_connect_cfm(conn, ev->status);\n\t\t\thci_conn_drop(conn);\n\t\t}\n\t} else {\n\t\thci_auth_cfm(conn, ev->status);\n\n\t\thci_conn_hold(conn);\n\t\tconn->disc_timeout = HCI_DISCONN_TIMEOUT;\n\t\thci_conn_drop(conn);\n\t}\n\n\tif (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags)) {\n\t\tif (!ev->status) {\n\t\t\tstruct hci_cp_set_conn_encrypt cp;\n\t\t\tcp.handle  = ev->handle;\n\t\t\tcp.encrypt = 0x01;\n\t\t\thci_send_cmd(hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),\n\t\t\t\t     &cp);\n\t\t} else {\n\t\t\tclear_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);\n\t\t\thci_encrypt_cfm(conn, ev->status, 0x00);\n\t\t}\n\t}\n\nunlock:\n\thci_dev_unlock(hdev);\n}","24099":"static void pointer_event(VncState *vs, int button_mask, int x, int y)\n{\n    static uint32_t bmap[INPUT_BUTTON_MAX] = {\n        [INPUT_BUTTON_LEFT]       = 0x01,\n        [INPUT_BUTTON_MIDDLE]     = 0x02,\n        [INPUT_BUTTON_RIGHT]      = 0x04,\n        [INPUT_BUTTON_WHEEL_UP]   = 0x08,\n        [INPUT_BUTTON_WHEEL_DOWN] = 0x10,\n    };\n    QemuConsole *con = vs->vd->dcl.con;\n    int width = surface_width(vs->vd->ds);\n    int height = surface_height(vs->vd->ds);\n\n    if (vs->last_bmask != button_mask) {\n        qemu_input_update_buttons(con, bmap, vs->last_bmask, button_mask);\n        vs->last_bmask = button_mask;\n    }\n\n    if (vs->absolute) {\n        qemu_input_queue_abs(con, INPUT_AXIS_X, x, width);\n        qemu_input_queue_abs(con, INPUT_AXIS_Y, y, height);\n    } else if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE)) {\n        qemu_input_queue_rel(con, INPUT_AXIS_X, x - 0x7FFF);\n        qemu_input_queue_rel(con, INPUT_AXIS_Y, y - 0x7FFF);\n    } else {\n        if (vs->last_x != -1) {\n            qemu_input_queue_rel(con, INPUT_AXIS_X, x - vs->last_x);\n            qemu_input_queue_rel(con, INPUT_AXIS_Y, y - vs->last_y);\n        }\n        vs->last_x = x;\n        vs->last_y = y;\n    }\n    qemu_input_event_sync();\n}","24674":"get_max_rate_vht_160_ss3(int mcs)\n{\n    switch (mcs) {\n    case 0:\n        return 175500000;\n    case 1:\n        return 351000000;\n    case 2:\n        return 526500000;\n    case 3:\n        return 702000000;\n    case 4:\n        return 1053000000;\n    case 5:\n        return 1404000000;\n    case 6:\n        return 1579500000;\n    case 7:\n        return 1755000000;\n    case 8:\n        return 2106000000;\n    case 9:\n        return 0;\n    }\n    return 0;\n}","23920":"static uint8_t excluded_channels(bitfile *ld, drc_info *drc)\n{\n    uint8_t i, n = 0;\n    uint8_t num_excl_chan = 7;\n\n    for (i = 0; i < 7; i++)\n    {\n        drc->exclude_mask[i] = faad_get1bit(ld\n            DEBUGVAR(1,103,\"STR\"));\n    }\n    n++;\n\n    while ((drc->additional_excluded_chns[n-1] = faad_get1bit(ld\n        DEBUGVAR(1,104,\"STR\"))) == 1)\n    {\n        for (i = num_excl_chan; i < num_excl_chan+7; i++)\n        {\n            drc->exclude_mask[i] = faad_get1bit(ld\n                DEBUGVAR(1,105,\"STR\"));\n        }\n        n++;\n        num_excl_chan += 7;\n    }\n\n    return n;\n}","24477":"int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)\n{\n\tflush_fp_to_thread(src);\n\tflush_altivec_to_thread(src);\n\tflush_vsx_to_thread(src);\n\tflush_spe_to_thread(src);\n\n\t*dst = *src;\n\n\tclear_task_ebb(dst);\n\n\treturn 0;\n}","24462":"gdImagePtr gdImageRotateInterpolated(const gdImagePtr src, const float angle, int bgcolor)\n{\n\tconst int angle_rounded = (int)floor(angle * 100);\n\n\tif (bgcolor < 0) {\n\t\treturn NULL;\n\t}\n\n\t\n\tif (src->trueColor == 0) {\n\t\tif (bgcolor >= 0) {\n\t\t\tbgcolor =  gdTrueColorAlpha(src->red[bgcolor], src->green[bgcolor], src->blue[bgcolor], src->alpha[bgcolor]);\n\t\t}\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\t\n\tswitch (angle_rounded) {\n\t\tcase 9000:\n\t\t\treturn gdImageRotate90(src, 0);\n\t\tcase 18000:\n\t\t\treturn gdImageRotate180(src, 0);\n\t\tcase 27000:\n\t\t\treturn gdImageRotate270(src, 0);\n\t}\n\n\tif (src == NULL || src->interpolation_id < 1 || src->interpolation_id > GD_METHOD_COUNT) {\n\t\treturn NULL;\n\t}\n\n\tswitch (src->interpolation_id) {\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\t\treturn gdImageRotateNearestNeighbour(src, angle, bgcolor);\n\t\t\tbreak;\n\n\t\tcase GD_BILINEAR_FIXED:\n\t\t\treturn gdImageRotateBilinear(src, angle, bgcolor);\n\t\t\tbreak;\n\n\t\tcase GD_BICUBIC_FIXED:\n\t\t\treturn gdImageRotateBicubicFixed(src, angle, bgcolor);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn gdImageRotateGeneric(src, angle, bgcolor);\n\t}\n\treturn NULL;\n}","25044":"sixel_allocator_malloc(\n    sixel_allocator_t    *allocator,  \n    size_t               n)           \n{\n    \n    assert(allocator);\n    assert(allocator->fn_malloc);\n\n    if (n == 0) {\n        sixel_helper_set_additional_message(\n            \"STR\");\n        return NULL;\n    }\n    return allocator->fn_malloc(n);\n}","24014":"Status RoleGraph::getBSONForRole(RoleGraph* graph,\n                                 const RoleName& roleName,\n                                 mutablebson::Element result) try {\n    if (!graph->roleExists(roleName)) {\n        return Status(ErrorCodes::RoleNotFound,\n                      mongoutils::str::stream() << roleName.getFullName()\n                                                << \"STR\");\n    }\n    std::string id = mongoutils::str::stream() << roleName.getDB() << \"STR\" << roleName.getRole();\n    uassertStatusOK(result.appendString(\"STR\", id));\n    uassertStatusOK(\n        result.appendString(AuthorizationManager::ROLE_NAME_FIELD_NAME, roleName.getRole()));\n    uassertStatusOK(\n        result.appendString(AuthorizationManager::ROLE_DB_FIELD_NAME, roleName.getDB()));\n\n    \n    mutablebson::Element privilegesArrayElement =\n        result.getDocument().makeElementArray(\"STR\");\n    uassertStatusOK(result.pushBack(privilegesArrayElement));\n    const PrivilegeVector& privileges = graph->getDirectPrivileges(roleName);\n    uassertStatusOK(Privilege::getBSONForPrivileges(privileges, privilegesArrayElement));\n\n    \n    mutablebson::Element rolesArrayElement = result.getDocument().makeElementArray(\"STR\");\n    uassertStatusOK(result.pushBack(rolesArrayElement));\n    for (RoleNameIterator roles = graph->getDirectSubordinates(roleName); roles.more();\n         roles.next()) {\n        const RoleName& subRole = roles.get();\n        mutablebson::Element roleObj = result.getDocument().makeElementObject(\"\");\n        uassertStatusOK(\n            roleObj.appendString(AuthorizationManager::ROLE_NAME_FIELD_NAME, subRole.getRole()));\n        uassertStatusOK(\n            roleObj.appendString(AuthorizationManager::ROLE_DB_FIELD_NAME, subRole.getDB()));\n        uassertStatusOK(rolesArrayElement.pushBack(roleObj));\n    }\n\n    return Status::OK();\n} catch (...) {","24644":"void* ipc_rcu_alloc(int size)\n{\n\tvoid* out;\n\t\n\tif (rcu_use_vmalloc(size)) {\n\t\tout = vmalloc(HDRLEN_VMALLOC + size);\n\t\tif (out) {\n\t\t\tout += HDRLEN_VMALLOC;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n\t\t}\n\t} else {\n\t\tout = kmalloc(HDRLEN_KMALLOC + size, GFP_KERNEL);\n\t\tif (out) {\n\t\t\tout += HDRLEN_KMALLOC;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n\t\t}\n\t}\n\n\treturn out;\n}","25000":"  TProtocol(boost::shared_ptr<TTransport> ptrans)\n    : ptrans_(ptrans), recursion_depth_(0), recursion_limit_(DEFAULT_RECURSION_LIMIT) {}","23888":"__read_extent_tree_block(const char *function, unsigned int line,\n\t\t\t struct inode *inode, ext4_fsblk_t pblk, int depth,\n\t\t\t int flags)\n{\n\tstruct buffer_head\t\t*bh;\n\tint\t\t\t\terr;\n\tgfp_t\t\t\t\tgfp_flags = __GFP_MOVABLE | GFP_NOFS;\n\n\tif (flags & EXT4_EX_NOFAIL)\n\t\tgfp_flags |= __GFP_NOFAIL;\n\n\tbh = sb_getblk_gfp(inode->i_sb, pblk, gfp_flags);\n\tif (unlikely(!bh))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!bh_uptodate_or_lock(bh)) {\n\t\ttrace_ext4_ext_load_extent(inode, pblk, _RET_IP_);\n\t\terr = bh_submit_read(bh);\n\t\tif (err < 0)\n\t\t\tgoto errout;\n\t}\n\tif (buffer_verified(bh) && !(flags & EXT4_EX_FORCE_CACHE))\n\t\treturn bh;\n\tif (!ext4_has_feature_journal(inode->i_sb) ||\n\t    (inode->i_ino !=\n\t     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum))) {\n\t\terr = __ext4_ext_check(function, line, inode,\n\t\t\t\t       ext_block_hdr(bh), depth, pblk);\n\t\tif (err)\n\t\t\tgoto errout;\n\t}\n\tset_buffer_verified(bh);\n\t\n\tif (!(flags & EXT4_EX_NOCACHE) && depth == 0) {\n\t\tstruct ext4_extent_header *eh = ext_block_hdr(bh);\n\t\text4_cache_extents(inode, eh);\n\t}\n\treturn bh;\nerrout:\n\tput_bh(bh);\n\treturn ERR_PTR(err);\n\n}","24397":"static ssize_t rbd_cluster_fsid_show(struct device *dev,\n\t\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct rbd_device *rbd_dev = dev_to_rbd_dev(dev);\n\n\treturn sprintf(buf, \"STR\", &rbd_dev->rbd_client->client->fsid);\n}","23815":"BOOL nsc_process_message(NSC_CONTEXT* context, UINT16 bpp,\n                         UINT32 width, UINT32 height,\n                         const BYTE* data, UINT32 length,\n                         BYTE* pDstData, UINT32 DstFormat,\n                         UINT32 nDstStride,\n                         UINT32 nXDst, UINT32 nYDst, UINT32 nWidth,\n                         UINT32 nHeight, UINT32 flip)\n{\n\twStream* s;\n\tBOOL ret;\n\ts = Stream_New((BYTE*)data, length);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (nDstStride == 0)\n\t\tnDstStride = nWidth * GetBytesPerPixel(DstFormat);\n\n\tswitch (bpp)\n\t{\n\t\tcase 32:\n\t\t\tcontext->format = PIXEL_FORMAT_BGRA32;\n\t\t\tbreak;\n\n\t\tcase 24:\n\t\t\tcontext->format = PIXEL_FORMAT_BGR24;\n\t\t\tbreak;\n\n\t\tcase 16:\n\t\t\tcontext->format = PIXEL_FORMAT_BGR16;\n\t\t\tbreak;\n\n\t\tcase 8:\n\t\t\tcontext->format = PIXEL_FORMAT_RGB8;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tcontext->format = PIXEL_FORMAT_A4;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tStream_Free(s, TRUE);\n\t\t\treturn FALSE;\n\t}\n\n\tcontext->width = width;\n\tcontext->height = height;\n\tret = nsc_context_initialize(context, s);\n\tStream_Free(s, FALSE);\n\n\tif (!ret)\n\t\treturn FALSE;\n\n\t\n\tPROFILER_ENTER(context->priv->prof_nsc_rle_decompress_data)\n\tnsc_rle_decompress_data(context);\n\tPROFILER_EXIT(context->priv->prof_nsc_rle_decompress_data)\n\t\n\tPROFILER_ENTER(context->priv->prof_nsc_decode)\n\tcontext->decode(context);\n\tPROFILER_EXIT(context->priv->prof_nsc_decode)\n\n\tif (!freerdp_image_copy(pDstData, DstFormat, nDstStride, nXDst, nYDst,\n\t                        width, height, context->BitmapData,\n\t                        PIXEL_FORMAT_BGRA32, 0, 0, 0, NULL, flip))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}","24627":"static void fake_fatal(const char *err, va_list params)\n{\n\tvreportf(\"STR\", err, params);\n}","25045":"  inline CImg<_cimg_Tfloat> invert(const CImg<T>& instance, const bool use_LU=true) {\n    return instance.get_invert(use_LU);\n  }","23922":"static inline pte_t pte_mkexec(pte_t pte)\n{\n\treturn pte_clear_flags(pte, _PAGE_NX);\n}","23923":"e_ews_connection_get_oal_list (EEwsConnection *cnc,\n                               GCancellable *cancellable,\n                               GAsyncReadyCallback callback,\n                               gpointer user_data)\n{\n\tGSimpleAsyncResult *simple;\n\tSoupMessage *soup_message;\n\tstruct _oal_req_data *data;\n\tGError *error = NULL;\n\n\tg_return_if_fail (E_IS_EWS_CONNECTION (cnc));\n\n\tsoup_message = e_ews_get_msg_for_url (cnc->priv->settings, cnc->priv->uri, NULL, &error);\n\n\tsimple = g_simple_async_result_new (\n\t\tG_OBJECT (cnc), callback, user_data,\n\t\te_ews_connection_get_oal_list);\n\n\tif (!soup_message) {\n\t\tg_simple_async_result_take_error (simple, error);\n\t\tg_simple_async_result_complete_in_idle (simple);\n\t\treturn;\n\t}\n\n\tdata = g_slice_new0 (struct _oal_req_data);\n\tdata->cnc = g_object_ref (cnc);\n\tdata->soup_message = soup_message;  \n\n\tif (G_IS_CANCELLABLE (cancellable)) {\n\t\tdata->cancellable = g_object_ref (cancellable);\n\t\tdata->cancel_id = g_cancellable_connect (\n\t\t\tdata->cancellable,\n\t\t\tG_CALLBACK (ews_cancel_msg),\n\t\t\tdata, (GDestroyNotify) NULL);\n\t}\n\n\tg_simple_async_result_set_op_res_gpointer (\n\t\tsimple, data, (GDestroyNotify) oal_req_data_free);\n\n\tews_connection_schedule_queue_message (cnc, soup_message, oal_response_cb, simple);\n}","24898":"f_assert_inrange(typval_T *argvars, typval_T *rettv)\n{\n    if (check_for_float_or_nr_arg(argvars, 0) == FAIL\n\t    || check_for_float_or_nr_arg(argvars, 1) == FAIL\n\t    || check_for_float_or_nr_arg(argvars, 2) == FAIL\n\t    || check_for_opt_string_arg(argvars, 3) == FAIL)\n\treturn;\n\n    rettv->vval.v_number = assert_inrange(argvars);\n}","24730":"unref_object_in_thread (gpointer ptr)\n{\n\tGObject *object = ptr;\n\n\tg_return_val_if_fail (object != NULL, NULL);\n\n\tg_object_unref (object);\n\n\treturn NULL;\n}","23828":"void ath9k_fatal_work(struct work_struct *work)\n{\n\tstruct ath9k_htc_priv *priv = container_of(work, struct ath9k_htc_priv,\n\t\t\t\t\t\t   fatal_work);\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\n\tath_dbg(common, FATAL, \"STR\");\n\tath9k_htc_reset(priv);\n}","24268":"bool SELECT_LEX_UNIT::set_lock_to_the_last_select(Lex_select_lock l)\n{\n  if (l.defined_lock)\n  {\n    SELECT_LEX *sel= first_select();\n    while (sel->next_select())\n      sel= sel->next_select();\n    if (sel->braces)\n    {\n      my_error(ER_WRONG_USAGE, MYF(0), \"STR\",\n               \"STR\");\n      return TRUE;\n    }\n    l.set_to(sel);\n  }\n  return FALSE;\n}","24346":"get_current_codepage(void)\n{\n\tchar *locale, *p;\n\tunsigned cp;\n\n\tlocale = setlocale(LC_CTYPE, NULL);\n\tif (locale == NULL)\n\t\treturn (GetACP());\n\tif (locale[0] == 'C' && locale[1] == '\\0')\n\t\treturn (CP_C_LOCALE);\n\tp = strrchr(locale, '.');\n\tif (p == NULL)\n\t\treturn (GetACP());\n\tif (strcmp(p+1, \"STR\") == 0)\n\t\treturn CP_UTF8;\n\tcp = my_atoi(p+1);\n\tif ((int)cp <= 0)\n\t\treturn (GetACP());\n\treturn (cp);\n}","24032":"ipv6_sanity_check(const struct ovs_16aligned_ip6_hdr *nh, size_t size)\n{\n    uint16_t plen;\n\n    if (OVS_UNLIKELY(size < sizeof *nh)) {\n        return false;\n    }\n\n    plen = ntohs(nh->ip6_plen);\n    if (OVS_UNLIKELY(plen + IPV6_HEADER_LEN > size)) {\n        return false;\n    }\n    \n    if (OVS_UNLIKELY(size - (plen + IPV6_HEADER_LEN) > UINT8_MAX)) {\n        return false;\n    }\n\n    return true;\n}","24220":"static void bond_setup(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\t\n\trwlock_init(&bond->lock);\n\trwlock_init(&bond->curr_slave_lock);\n\n\tbond->params = bonding_defaults;\n\n\t\n\tbond->dev = bond_dev;\n\tINIT_LIST_HEAD(&bond->vlan_list);\n\n\t\n\tether_setup(bond_dev);\n\tbond_dev->netdev_ops = &bond_netdev_ops;\n\tbond_dev->ethtool_ops = &bond_ethtool_ops;\n\tbond_set_mode_ops(bond, bond->params.mode);\n\n\tbond_dev->destructor = bond_destructor;\n\n\t\n\tbond_dev->tx_queue_len = 0;\n\tbond_dev->flags |= IFF_MASTER|IFF_MULTICAST;\n\tbond_dev->priv_flags |= IFF_BONDING;\n\tbond_dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\n\t\n\tbond_dev->features |= NETIF_F_VLAN_CHALLENGED;\n\n\t\n\tbond_dev->features |= NETIF_F_LLTX;\n\n\t\n\n\tbond_dev->hw_features = BOND_VLAN_FEATURES |\n\t\t\t\tNETIF_F_HW_VLAN_TX |\n\t\t\t\tNETIF_F_HW_VLAN_RX |\n\t\t\t\tNETIF_F_HW_VLAN_FILTER;\n\n\tbond_dev->hw_features &= ~(NETIF_F_ALL_CSUM & ~NETIF_F_NO_CSUM);\n\tbond_dev->features |= bond_dev->hw_features;\n}","24870":"int LUKS2_config_get_requirements(struct crypt_device *cd, struct luks2_hdr *hdr, uint32_t *reqs)\n{\n\tjson_object *jobj_config, *jobj_requirements, *jobj_mandatory, *jobj;\n\tint i, len;\n\tuint32_t req;\n\n\tassert(hdr);\n\tif (!hdr || !reqs)\n\t\treturn -EINVAL;\n\n\t*reqs = 0;\n\n\tif (!json_object_object_get_ex(hdr->jobj, \"STR\", &jobj_config))\n\t\treturn 0;\n\n\tif (!json_object_object_get_ex(jobj_config, \"STR\", &jobj_requirements))\n\t\treturn 0;\n\n\tif (!json_object_object_get_ex(jobj_requirements, \"STR\", &jobj_mandatory))\n\t\treturn 0;\n\n\tlen = (int) json_object_array_length(jobj_mandatory);\n\tif (len <= 0)\n\t\treturn 0;\n\n\tlog_dbg(cd, \"STR\");\n\n\tfor (i = 0; i < len; i++) {\n\t\tjobj = json_object_array_get_idx(jobj_mandatory, i);\n\t\treq = get_requirement_by_name(json_object_get_string(jobj));\n\t\tlog_dbg(cd, \"STR\", json_object_get_string(jobj),\n\t\t\t\t        reqs_unknown(req) ? \"STR\");\n\t\t*reqs |= req;\n\t}\n\n\treturn 0;\n}","24041":"bool DISOpticalFlowImpl::ocl_calc(InputArray I0, InputArray I1, InputOutputArray flow)\n{\n    UMat I0Mat = I0.getUMat();\n    UMat I1Mat = I1.getUMat();\n    bool use_input_flow = false;\n    if (flow.sameSize(I0) && flow.depth() == CV_32F && flow.channels() == 2)\n        use_input_flow = true;\n    else\n        flow.create(I1Mat.size(), CV_32FC2);\n    UMat &u_flowMat = flow.getUMatRef();\n    coarsest_scale = min((int)(log(max(I0Mat.cols, I0Mat.rows) \/ (4.0 * patch_size)) \/ log(2.0) + 0.5), \n                         (int)(log(min(I0Mat.cols, I0Mat.rows) \/ patch_size) \/ log(2.0)));              \n\n    ocl_prepareBuffers(I0Mat, I1Mat, u_flowMat, use_input_flow);\n    u_Ux[coarsest_scale].setTo(0.0f);\n    u_Uy[coarsest_scale].setTo(0.0f);\n\n    for (int i = coarsest_scale; i >= finest_scale; i--)\n    {\n        w = u_I0s[i].cols;\n        h = u_I0s[i].rows;\n        ws = 1 + (w - patch_size) \/ patch_stride;\n        hs = 1 + (h - patch_size) \/ patch_stride;\n\n        if (!ocl_precomputeStructureTensor(u_I0xx_buf, u_I0yy_buf, u_I0xy_buf,\n                                           u_I0x_buf, u_I0y_buf, u_I0xs[i], u_I0ys[i]))\n            return false;\n\n        if (!ocl_PatchInverseSearch(u_Ux[i], u_Uy[i], u_I0s[i], u_I1s_ext[i], u_I0xs[i], u_I0ys[i], 2, i))\n            return false;\n\n        if (!ocl_Densification(u_Ux[i], u_Uy[i], u_Sx, u_Sy, u_I0s[i], u_I1s[i]))\n            return false;\n\n        if (variational_refinement_iter > 0)\n            variational_refinement_processors[i]->calcUV(u_I0s[i], u_I1s[i],\n                                                         u_Ux[i].getMat(ACCESS_WRITE), u_Uy[i].getMat(ACCESS_WRITE));\n\n        if (i > finest_scale)\n        {\n            resize(u_Ux[i], u_Ux[i - 1], u_Ux[i - 1].size());\n            resize(u_Uy[i], u_Uy[i - 1], u_Uy[i - 1].size());\n            multiply(u_Ux[i - 1], 2, u_Ux[i - 1]);\n            multiply(u_Uy[i - 1], 2, u_Uy[i - 1]);\n        }\n    }\n    vector<UMat> uxy(2);\n    uxy[0] = u_Ux[finest_scale];\n    uxy[1] = u_Uy[finest_scale];\n    merge(uxy, u_U);\n    resize(u_U, u_flowMat, u_flowMat.size());\n    multiply(u_flowMat, 1 << finest_scale, u_flowMat);\n\n    return true;\n}","24009":"GetCurrentDateTime(struct pg_tm * tm)\n{\n\tint\t\t\ttz;\n\tfsec_t\t\tfsec;\n\n\ttimestamp2tm(GetCurrentTransactionStartTimestamp(), &tz, tm, &fsec,\n\t\t\t\t NULL, NULL);\n\t\n}","24944":"static int wc_ecc_gen_k(WC_RNG* rng, int size, mp_int* k, mp_int* order)\n{\n    int err;\n#ifdef WOLFSSL_SMALL_STACK\n    byte* buf;\n#else\n    byte  buf[ECC_MAXSIZE_GEN];\n#endif\n\n#ifdef WOLFSSL_SMALL_STACK\n    buf = (byte*)XMALLOC(ECC_MAXSIZE_GEN, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n    if (buf == NULL)\n        return MEMORY_E;\n#endif\n\n    \n    \n    size += 8;\n\n    \n    err = wc_RNG_GenerateBlock(rng, buf, size);\n\n    \n    if (err == 0)\n        err = mp_read_unsigned_bin(k, (byte*)buf, size);\n\n    \n    if (err == MP_OKAY) {\n        if (mp_iszero(k) == MP_YES)\n          err = MP_ZERO_E;\n    }\n\n    \n    if (err == MP_OKAY) {\n        if (mp_cmp(k, order) != MP_LT) {\n            err = mp_mod(k, order, k);\n        }\n    }\n\n    ForceZero(buf, ECC_MAXSIZE);\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(buf, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n\n    return err;\n}","24681":"static void tun_set_sndbuf(struct tun_struct *tun)\n{\n\tstruct tun_file *tfile;\n\tint i;\n\n\tfor (i = 0; i < tun->numqueues; i++) {\n\t\ttfile = rtnl_dereference(tun->tfiles[i]);\n\t\ttfile->socket.sk->sk_sndbuf = tun->sndbuf;\n\t}\n}","24594":"R_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaBootStrapMethod *bsm = NULL;\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR;\n\t\tattr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.bootstrap_methods_attr.bootstrap_methods = r_list_newf (r_bin_java_bootstrap_method_free);\n\t\tfor (i = 0; i < attr->info.bootstrap_methods_attr.num_bootstrap_methods; i++) {\n\t\t\t\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbsm = r_bin_java_bootstrap_method_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (bsm) {\n\t\t\t\toffset += bsm->size;\n\t\t\t\tr_list_append (attr->info.bootstrap_methods_attr.bootstrap_methods, (void *) bsm);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}","24083":"int mnt_update_set_filename(struct libmnt_update *upd, const char *filename,\n\t\t\t    int userspace_only)\n{\n\tconst char *path = NULL;\n\tint rw = 0;\n\n\tassert(upd);\n\n\t\n\tif (filename) {\n\t\tchar *p = strdup(filename);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\n\t\tupd->userspace_only = userspace_only;\n\t\tfree(upd->filename);\n\t\tupd->filename = p;\n\t}\n\n\tif (upd->filename)\n\t\treturn 0;\n\n\t\n\tmnt_has_regular_mtab(&path, &rw);\n\tif (!rw) {\n\t\tpath = NULL;\n\t\tmnt_has_regular_utab(&path, &rw);\n\t\tif (!rw)\n\t\t\treturn -EACCES;\n\t\tupd->userspace_only = TRUE;\n\t}\n\tupd->filename = strdup(path);\n\tif (!upd->filename)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}","24292":"xmlEncodeSpecialChars(xmlDocPtr doc ATTRIBUTE_UNUSED, const xmlChar *input) {\n    const xmlChar *cur = input;\n    xmlChar *buffer = NULL;\n    xmlChar *out = NULL;\n    int buffer_size = 0;\n    if (input == NULL) return(NULL);\n\n    \n    buffer_size = 1000;\n    buffer = (xmlChar *) xmlMalloc(buffer_size * sizeof(xmlChar));\n    if (buffer == NULL) {\n        xmlEntitiesErrMemory(\"STR\");\n\treturn(NULL);\n    }\n    out = buffer;\n\n    while (*cur != '\\0') {\n        if (out - buffer > buffer_size - 10) {\n\t    int indx = out - buffer;\n\n\t    growBufferReentrant();\n\t    out = &buffer[indx];\n\t}\n\n\t\n\tif (*cur == '<') {\n\t    *out++ = '&';\n\t    *out++ = 'l';\n\t    *out++ = 't';\n\t    *out++ = ';';\n\t} else if (*cur == '>') {\n\t    *out++ = '&';\n\t    *out++ = 'g';\n\t    *out++ = 't';\n\t    *out++ = ';';\n\t} else if (*cur == '&') {\n\t    *out++ = '&';\n\t    *out++ = 'a';\n\t    *out++ = 'm';\n\t    *out++ = 'p';\n\t    *out++ = ';';\n\t} else if (*cur == '\"') {\n\t    *out++ = '&';\n\t    *out++ = 'q';\n\t    *out++ = 'u';\n\t    *out++ = 'o';\n\t    *out++ = 't';\n\t    *out++ = ';';\n\t} else if (*cur == '\\r') {\n\t    *out++ = '&';\n\t    *out++ = '#';\n\t    *out++ = '1';\n\t    *out++ = '3';\n\t    *out++ = ';';\n\t} else {\n\t    \n\t    *out++ = *cur;\n\t}\n\tcur++;\n    }\n    *out = 0;\n    return(buffer);\n}","23951":"static void ext4_clamp_want_extra_isize(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\n\t\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    sbi->s_want_extra_isize == 0) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\t\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO,\n\t\t\t \"STR\");\n\t}\n}","25022":"  void set_allow_unexpected_disconnects(bool value) { allow_unexpected_disconnects_ = value; }","24852":"translate_newlines(const char *s, int exec_input, struct tok_state *tok) {\n    int skip_next_lf = 0;\n    size_t needed_length = strlen(s) + 2, final_length;\n    char *buf, *current;\n    char c = '\\0';\n    buf = PyMem_MALLOC(needed_length);\n    if (buf == NULL) {\n        tok->done = E_NOMEM;\n        return NULL;\n    }\n    for (current = buf; *s; s++, current++) {\n        c = *s;\n        if (skip_next_lf) {\n            skip_next_lf = 0;\n            if (c == '\\n') {\n                c = *++s;\n                if (!c)\n                    break;\n            }\n        }\n        if (c == '\\r') {\n            skip_next_lf = 1;\n            c = '\\n';\n        }\n        *current = c;\n    }\n    \n    if (exec_input && c != '\\n') {\n        *current = '\\n';\n        current++;\n    }\n    *current = '\\0';\n    final_length = current - buf + 1;\n    if (final_length < needed_length && final_length)\n        \n        buf = PyMem_REALLOC(buf, final_length);\n    return buf;\n}","23875":"ipmi_fru_print(struct ipmi_intf * intf, struct sdr_record_fru_locator * fru)\n{\n\tchar desc[17];\n\tuint8_t  bridged_request = 0;\n\tuint32_t save_addr;\n\tuint32_t save_channel;\n\tint rc = 0;\n\n\tif (!fru)\n\t\treturn __ipmi_fru_print(intf, 0);\n\n\t\n\tif (fru->dev_type != 0x10 &&\n\t\t(fru->dev_type_modifier != 0x02 ||\n\t\tfru->dev_type < 0x08 || fru->dev_type > 0x0f))\n\t\treturn -1;\n\n\tif (fru->dev_slave_addr == IPMI_BMC_SLAVE_ADDR &&\n\t\tfru->device_id == 0)\n\t\treturn 0;\n\n\tmemset(desc, 0, sizeof(desc));\n\tmemcpy(desc, fru->id_string, fru->id_code & 0x01f);\n\tdesc[fru->id_code & 0x01f] = 0;\n\tprintf(\"STR\", desc, fru->device_id);\n\n\tswitch (fru->dev_type_modifier) {\n\tcase 0x00:\n\tcase 0x02:\n\t\tif (BRIDGE_TO_SENSOR(intf, fru->dev_slave_addr,\n\t\t\t\t\t   fru->channel_num)) {\n\t\t\tbridged_request = 1;\n\t\t\tsave_addr = intf->target_addr;\n\t\t\tintf->target_addr = fru->dev_slave_addr;\n\t\t\tsave_channel = intf->target_channel;\n\t\t\tintf->target_channel = fru->channel_num;\n\t\t}\n\t\t\n\t\trc = __ipmi_fru_print(intf, fru->device_id);\n\t\tif (bridged_request) {\n\t\t\tintf->target_addr = save_addr;\n\t\t\tintf->target_channel = save_channel;\n\t\t}\n\t\tbreak;\n\tcase 0x01:\n\t\trc = ipmi_spd_print_fru(intf, fru->device_id);\n\t\tbreak;\n\tdefault:\n\t\tif (verbose)\n\t\t\tprintf(\"STR\"\n\t\t\t\t\t\"STR\",\n\t\t\t\t\tfru->device_id, fru->dev_type,\n\t\t\t\t\tfru->dev_type_modifier);\n\t\telse\n\t\t\tprintf(\"STR\");\n\t}\n\tprintf(\"STR\");\n\n\treturn rc;\n}","24736":"void jsB_initnumber(js_State *J)\n{\n\tJ->Number_prototype->u.number = 0;\n\n\tjs_pushobject(J, J->Number_prototype);\n\t{\n\t\tjsB_propf(J, \"STR\", Np_valueOf, 0);\n\t\tjsB_propf(J, \"STR\", Np_toString, 1);\n\t\tjsB_propf(J, \"STR\", Np_toString, 0);\n\t\tjsB_propf(J, \"STR\", Np_toFixed, 1);\n\t\tjsB_propf(J, \"STR\", Np_toExponential, 1);\n\t\tjsB_propf(J, \"STR\", Np_toPrecision, 1);\n\t}\n\tjs_newcconstructor(J, jsB_Number, jsB_new_Number, \"STR\", 0); \n\t{\n\t\tjsB_propn(J, \"STR\", 1.7976931348623157e+308);\n\t\tjsB_propn(J, \"STR\", 5e-324);\n\t\tjsB_propn(J, \"STR\", NAN);\n\t\tjsB_propn(J, \"STR\", -INFINITY);\n\t\tjsB_propn(J, \"STR\", INFINITY);\n\t}\n\tjs_defglobal(J, \"STR\", JS_DONTENUM);\n}","24578":"Signer* MakeSigner(void* heap)\n{\n    Signer* signer = (Signer*) XMALLOC(sizeof(Signer), heap,\n                                       DYNAMIC_TYPE_SIGNER);\n    if (signer) {\n        XMEMSET(signer, 0, sizeof(Signer));\n    }\n    (void)heap;\n\n    return signer;\n}","24883":"const char* llhttp_get_error_pos(const llhttp_t* parser) {\n  return parser->error_pos;\n}","24206":"void themes_deinit(void)\n{\n\twhile (themes != NULL)\n\t\ttheme_destroy(themes->data);\n\n\tg_hash_table_destroy(default_formats);\n\tdefault_formats = NULL;\n\n\tcommand_unbind(\"STR\", (SIGNAL_FUNC) cmd_format);\n\tcommand_unbind(\"STR\", (SIGNAL_FUNC) cmd_save);\n\tsignal_remove(\"STR\", (SIGNAL_FUNC) sig_complete_format);\n\tsignal_remove(\"STR\", (SIGNAL_FUNC) sig_print_errors);\n        signal_remove(\"STR\", (SIGNAL_FUNC) read_settings);\n        signal_remove(\"STR\", (SIGNAL_FUNC) themes_read);\n}","24183":"bool LBPEvaluator::Feature :: read(const FileNode& node )\n{\n    FileNode rnode = node[CC_RECT];\n    FileNodeIterator it = rnode.begin();\n    it >> rect.x >> rect.y >> rect.width >> rect.height;\n    return true;\n}","24078":"cifs_write(struct cifsFileInfo *open_file, __u32 pid, const char *write_data,\n\t   size_t write_size, loff_t *offset)\n{\n\tint rc = 0;\n\tunsigned int bytes_written = 0;\n\tunsigned int total_written;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tunsigned int xid;\n\tstruct dentry *dentry = open_file->dentry;\n\tstruct cifsInodeInfo *cifsi = CIFS_I(dentry->d_inode);\n\tstruct cifs_io_parms io_parms;\n\n\tcifs_sb = CIFS_SB(dentry->d_sb);\n\n\tcifs_dbg(FYI, \"STR\",\n\t\t write_size, *offset, dentry->d_name.name);\n\n\ttcon = tlink_tcon(open_file->tlink);\n\tserver = tcon->ses->server;\n\n\tif (!server->ops->sync_write)\n\t\treturn -ENOSYS;\n\n\txid = get_xid();\n\n\tfor (total_written = 0; write_size > total_written;\n\t     total_written += bytes_written) {\n\t\trc = -EAGAIN;\n\t\twhile (rc == -EAGAIN) {\n\t\t\tstruct kvec iov[2];\n\t\t\tunsigned int len;\n\n\t\t\tif (open_file->invalidHandle) {\n\t\t\t\t\n\t\t\t\trc = cifs_reopen_file(open_file, false);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlen = min((size_t)cifs_sb->wsize,\n\t\t\t\t  write_size - total_written);\n\t\t\t\n\t\t\tiov[1].iov_base = (char *)write_data + total_written;\n\t\t\tiov[1].iov_len = len;\n\t\t\tio_parms.pid = pid;\n\t\t\tio_parms.tcon = tcon;\n\t\t\tio_parms.offset = *offset;\n\t\t\tio_parms.length = len;\n\t\t\trc = server->ops->sync_write(xid, open_file, &io_parms,\n\t\t\t\t\t\t     &bytes_written, iov, 1);\n\t\t}\n\t\tif (rc || (bytes_written == 0)) {\n\t\t\tif (total_written)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tfree_xid(xid);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\tspin_lock(&dentry->d_inode->i_lock);\n\t\t\tcifs_update_eof(cifsi, *offset, bytes_written);\n\t\t\tspin_unlock(&dentry->d_inode->i_lock);\n\t\t\t*offset += bytes_written;\n\t\t}\n\t}\n\n\tcifs_stats_bytes_written(tcon, total_written);\n\n\tif (total_written > 0) {\n\t\tspin_lock(&dentry->d_inode->i_lock);\n\t\tif (*offset > dentry->d_inode->i_size)\n\t\t\ti_size_write(dentry->d_inode, *offset);\n\t\tspin_unlock(&dentry->d_inode->i_lock);\n\t}\n\tmark_inode_dirty_sync(dentry->d_inode);\n\tfree_xid(xid);\n\treturn total_written;\n}","24729":"static int myrand( void *rng_state, unsigned char *output, size_t len )\n{\n    size_t i;\n\n    if( rng_state != NULL )\n        rng_state  = NULL;\n\n    for( i = 0; i < len; ++i )\n        output[i] = rand();\n    \n    return( 0 );\n}","23879":"TPMS_PCR_SELECTION_Unmarshal(TPMS_PCR_SELECTION *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n    \n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPMI_ALG_HASH_Unmarshal(&target->hash, buffer, size, NO);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\trc = UINT8_Unmarshal(&target->sizeofSelect, buffer, size);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif ((target->sizeofSelect < PCR_SELECT_MIN) ||\n\t    (target->sizeofSelect > PCR_SELECT_MAX)) {\n\t    rc = TPM_RC_VALUE;\n\t}\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\trc = Array_Unmarshal(target->pcrSelect, target->sizeofSelect, buffer, size);\n    }\n    return rc;\n}","24597":"prime_root(struct module_qstate* qstate, struct iter_qstate* iq, int id,\n\tuint16_t qclass)\n{\n\tstruct delegpt* dp;\n\tstruct module_qstate* subq;\n\tverbose(VERB_DETAIL, \"STR\", \n\t\tsldns_lookup_by_id(sldns_rr_classes, (int)qclass)?\n\t\tsldns_lookup_by_id(sldns_rr_classes, (int)qclass)->name:\"STR\");\n\tdp = hints_lookup_root(qstate->env->hints, qclass);\n\tif(!dp) {\n\t\tverbose(VERB_ALGO, \"STR\");\n\t\treturn 0;\n\t}\n\t\n\tif(!generate_sub_request((uint8_t*)\"STR\", 1, LDNS_RR_TYPE_NS, \n\t\tqclass, qstate, id, iq, QUERYTARGETS_STATE, PRIME_RESP_STATE,\n\t\t&subq, 0, 0)) {\n\t\tverbose(VERB_ALGO, \"STR\");\n\t\treturn 0;\n\t}\n\tif(subq) {\n\t\tstruct iter_qstate* subiq = \n\t\t\t(struct iter_qstate*)subq->minfo[id];\n\t\t\n\t\tsubiq->dp = delegpt_copy(dp, subq->region);\n\t\tif(!subiq->dp) {\n\t\t\tlog_err(\"STR\");\n\t\t\tfptr_ok(fptr_whitelist_modenv_kill_sub(\n\t\t\t\tqstate->env->kill_sub));\n\t\t\t(*qstate->env->kill_sub)(subq);\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tsubiq->num_target_queries = 0; \n\t\tsubiq->dnssec_expected = iter_indicates_dnssec(\n\t\t\tqstate->env, subiq->dp, NULL, subq->qinfo.qclass);\n\t}\n\t\n\t\n\tqstate->ext_state[id] = module_wait_subquery;\n\treturn 1;\n}","24648":"gdm_session_start_reauthentication (GdmSession *session,\n                                    GPid        pid_of_caller,\n                                    uid_t       uid_of_caller)\n{\n        GdmSessionConversation *conversation = session->priv->session_conversation;\n\n        g_return_if_fail (conversation != NULL);\n\n        conversation->reauth_pid_of_caller = pid_of_caller;\n\n        gdm_dbus_worker_call_start_reauthentication (conversation->worker_proxy,\n                                                     (int) pid_of_caller,\n                                                     (int) uid_of_caller,\n                                                     NULL,\n                                                     (GAsyncReadyCallback) on_reauthentication_started_cb,\n                                                     conversation);\n}","24090":"ScanLineInputFile::ScanLineInputFile(InputPartData* part)\n{\n    if (part->header.type() != SCANLINEIMAGE)\n        throw IEX_NAMESPACE::ArgExc(\"STR\");\n\n    _data = new Data(part->numThreads);\n    _streamData = part->mutex;\n    _data->memoryMapped = _streamData->is->isMemoryMapped();\n\n    _data->version = part->version;\n\n    initialize(part->header);\n\n    _data->lineOffsets = part->chunkOffsets;\n\n    _data->partNumber = part->partNumber;\n    \n    \n    \n    \n    _data->fileIsComplete = true;\n}","24029":"void kbd_put_keysym_console(QemuConsole *s, int keysym)\n{\n    uint8_t buf[16], *q;\n    int c;\n\n    if (!s || (s->console_type == GRAPHIC_CONSOLE))\n        return;\n\n    switch(keysym) {\n    case QEMU_KEY_CTRL_UP:\n        console_scroll(s, -1);\n        break;\n    case QEMU_KEY_CTRL_DOWN:\n        console_scroll(s, 1);\n        break;\n    case QEMU_KEY_CTRL_PAGEUP:\n        console_scroll(s, -10);\n        break;\n    case QEMU_KEY_CTRL_PAGEDOWN:\n        console_scroll(s, 10);\n        break;\n    default:\n        \n        q = buf;\n        if (keysym >= 0xe100 && keysym <= 0xe11f) {\n            *q++ = '\\033';\n            *q++ = '[';\n            c = keysym - 0xe100;\n            if (c >= 10)\n                *q++ = '0' + (c \/ 10);\n            *q++ = '0' + (c % 10);\n            *q++ = '~';\n        } else if (keysym >= 0xe120 && keysym <= 0xe17f) {\n            *q++ = '\\033';\n            *q++ = '[';\n            *q++ = keysym & 0xff;\n        } else if (s->echo && (keysym == '\\r' || keysym == '\\n')) {\n            console_puts(s->chr, (const uint8_t *) \"STR\", 1);\n            *q++ = '\\n';\n        } else {\n            *q++ = keysym;\n        }\n        if (s->echo) {\n            console_puts(s->chr, buf, q - buf);\n        }\n        if (s->chr->chr_read) {\n            qemu_fifo_write(&s->out_fifo, buf, q - buf);\n            kbd_send_chars(s);\n        }\n        break;\n    }\n}","24793":"netsnmp_unload_module(const char *name)\n{\n    struct module  *mp;\n    int             modID = -1;\n\n    for (mp = module_head; mp; mp = mp->next)\n        if (!label_compare(mp->name, name)) {\n            modID = mp->modid;\n            break;\n        }\n\n    if (modID == -1) {\n        DEBUGMSGTL((\"STR\",\n                    name));\n        return MODULE_NOT_FOUND;\n    }\n    unload_module_by_ID(modID, tree_head);\n    mp->no_imports = -1;        \n    return MODULE_LOADED_OK;    \n}","24136":"int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n{\n\tint n;\n\tint c;\n\tchar *bufptr;\n\n\tJAS_DBGLOG(100, (\"STR\", stream, buf, cnt));\n\n\tif (cnt < 0) {\n\t\tjas_deprecated(\"STR\");\n\t}\n\n\tbufptr = buf;\n\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t*bufptr++ = c;\n\t\t++n;\n\t}\n\n\treturn n;\n}","23970":"GF_Err tenc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"STR\", trace);\n\n\tfprintf(trace, \"STR\", ptr->isProtected);\n\tif (ptr->Per_Sample_IV_Size)\n\t\tfprintf(trace, \"STR\", ptr->Per_Sample_IV_Size);\n\telse {\n\t\tfprintf(trace, \"STR\", ptr->constant_IV_size);\n\t\tdump_data_hex(trace, (char *) ptr->constant_IV, ptr->constant_IV_size);\n\t\tfprintf(trace, \"STR\");\n\t}\n\tdump_data_hex(trace, (char *) ptr->KID, 16);\n\tif (ptr->version) \n\t\tfprintf(trace, \"STR\", ptr->crypt_byte_block, ptr->skip_byte_block);\n\tfprintf(trace, \"STR\");\n\tgf_isom_box_dump_done(\"STR\", a, trace);\n\treturn GF_OK;\n}","24814":"\n    static int screen_width() {\n      DEVMODE mode;\n      mode.dmSize = sizeof(DEVMODE);\n      mode.dmDriverExtra = 0;\n      EnumDisplaySettings(0,ENUM_CURRENT_SETTINGS,&mode);\n      return (int)mode.dmPelsWidth;","24139":"mountopts_check(const char *opts)\n{\n   char buf[64];\n   const char *p;\n   char *end;\n   unsigned long muid;\n   Eina_Bool nosuid, nodev, noexec, nuid;\n\n   nosuid = nodev = noexec = nuid = EINA_FALSE;\n\n   \n   if (eina_strlcpy(buf, opts, sizeof(buf)) >= sizeof(buf)) return EINA_FALSE;\n   for (p = buf; p && p[1]; p = strchr(p + 1, ','))\n     {\n        if (p[0] == ',') p++;\n\n  if (!strncmp(p, OPT, sizeof(OPT) - 1))\n\n        CMP(\"STR\")\n        {\n           nosuid = EINA_TRUE;\n           continue;\n        }\n        CMP(\"STR\")\n        {\n           nodev = EINA_TRUE;\n           continue;\n        }\n        CMP(\"STR\")\n        {\n           noexec = EINA_TRUE;\n           continue;\n        }\n        CMP(\"STR\") continue;\n        CMP(\"STR\") continue;\n        CMP(\"STR\") continue;\n        CMP(\"STR\") continue;\n        CMP(\"STR\")\n        {\n           p += 4;\n           errno = 0;\n           muid = strtoul(p, &end, 10);\n           if (muid == ULONG_MAX) return EINA_FALSE;\n           if (errno) return EINA_FALSE;\n           if (end[0] != ',') return EINA_FALSE;\n           if (muid != uid) return EINA_FALSE;\n           nuid = EINA_TRUE;\n           continue;\n        }\n        return EINA_FALSE;\n     }\n   if ((!nosuid) || (!nodev) || (!noexec) || (!nuid)) return EINA_FALSE;\n   return EINA_TRUE;\n}","24402":"static int u32_set_parms(struct net *net, struct tcf_proto *tp,\n\t\t\t unsigned long base,\n\t\t\t struct tc_u_knode *n, struct nlattr **tb,\n\t\t\t struct nlattr *est, u32 flags, u32 fl_flags,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\terr = tcf_exts_validate_ex(net, tp, tb, est, &n->exts, flags,\n\t\t\t\t   fl_flags, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (tb[TCA_U32_LINK]) {\n\t\tu32 handle = nla_get_u32(tb[TCA_U32_LINK]);\n\t\tstruct tc_u_hnode *ht_down = NULL, *ht_old;\n\n\t\tif (TC_U32_KEY(handle)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"STR\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (handle) {\n\t\t\tht_down = u32_lookup_ht(tp->data, handle);\n\n\t\t\tif (!ht_down) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"STR\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (ht_down->is_root) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"STR\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tht_down->refcnt++;\n\t\t}\n\n\t\tht_old = rtnl_dereference(n->ht_down);\n\t\trcu_assign_pointer(n->ht_down, ht_down);\n\n\t\tif (ht_old)\n\t\t\tht_old->refcnt--;\n\t}\n\tif (tb[TCA_U32_CLASSID]) {\n\t\tn->res.classid = nla_get_u32(tb[TCA_U32_CLASSID]);\n\t\ttcf_bind_filter(tp, &n->res, base);\n\t}\n\n\tif (tb[TCA_U32_INDEV]) {\n\t\tint ret;\n\t\tret = tcf_change_indev(net, tb[TCA_U32_INDEV], extack);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\t\tn->ifindex = ret;\n\t}\n\treturn 0;\n}","23887":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteTensor* output_values = GetOutput(context, node, kOutputValues);\n  TfLiteTensor* output_indexes = GetOutput(context, node, kOutputIndexes);\n  if (IsDynamicTensor(output_values)) {\n    TF_LITE_ENSURE_OK(context, ResizeOutput(context, node));\n  }\n  const TfLiteTensor* top_k = GetInput(context, node, kInputTopK);\n  const int32 k = top_k->data.i32[0];\n  \n  \n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const int32 row_size = input->dims->data[input->dims->size - 1];\n  int32 num_rows = 1;\n  for (int i = 0; i < input->dims->size - 1; ++i) {\n    num_rows *= input->dims->data[i];\n  }\n  switch (output_values->type) {\n    case kTfLiteFloat32:\n      TopK(row_size, num_rows, GetTensorData<float>(input), k,\n           output_indexes->data.i32, GetTensorData<float>(output_values));\n      break;\n    case kTfLiteUInt8:\n      TopK(row_size, num_rows, input->data.uint8, k, output_indexes->data.i32,\n           output_values->data.uint8);\n      break;\n    case kTfLiteInt8:\n      TopK(row_size, num_rows, input->data.int8, k, output_indexes->data.i32,\n           output_values->data.int8);\n      break;\n    case kTfLiteInt32:\n      TopK(row_size, num_rows, input->data.i32, k, output_indexes->data.i32,\n           output_values->data.i32);\n      break;\n    case kTfLiteInt64:\n      TopK(row_size, num_rows, input->data.i64, k, output_indexes->data.i32,\n           output_values->data.i64);\n      break;\n    default:\n      TF_LITE_KERNEL_LOG(context, \"STR\",\n                         TfLiteTypeGetName(output_values->type));\n      return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}","24695":"static int __dev_close_many(struct list_head *head)\n{\n\tstruct net_device *dev;\n\n\tASSERT_RTNL();\n\tmight_sleep();\n\n\tlist_for_each_entry(dev, head, close_list) {\n\t\tcall_netdevice_notifiers(NETDEV_GOING_DOWN, dev);\n\n\t\tclear_bit(__LINK_STATE_START, &dev->state);\n\n\t\t\n\t\tsmp_mb__after_clear_bit(); \n\t}\n\n\tdev_deactivate_many(head);\n\n\tlist_for_each_entry(dev, head, close_list) {\n\t\tconst struct net_device_ops *ops = dev->netdev_ops;\n\n\t\t\n\t\tif (ops->ndo_stop)\n\t\t\tops->ndo_stop(dev);\n\n\t\tdev->flags &= ~IFF_UP;\n\t\tnet_dmaengine_put();\n\t}\n\n\treturn 0;\n}","24512":"static void vnc_tight_start(VncState *vs)\n{\n    buffer_reset(&vs->tight.tight);\n\n    \n    vs->tight.tmp = vs->output;\n    vs->output = vs->tight.tight;\n}","24439":"gx_begin_image1(gx_device * dev,\n                const gs_gstate * pgs, const gs_matrix * pmat,\n                const gs_image_common_t * pic, const gs_int_rect * prect,\n                const gx_drawing_color * pdcolor, const gx_clip_path * pcpath,\n                gs_memory_t * mem, gx_image_enum_common_t ** pinfo)\n{\n    gx_image_enum *penum;\n    const gs_image_t *pim = (const gs_image_t *)pic;\n    int code = gx_image_enum_alloc(pic, prect, mem, &penum);\n\n    if (code < 0)\n        return code;\n    memset(penum, 0, sizeof(gx_image_enum));\t\n    penum->alpha = pim->Alpha;\n    penum->use_mask_color = false;\n    penum->image_parent_type = pim->image_parent_type;\n    penum->masked = pim->ImageMask;\n    penum->adjust =\n        (pim->ImageMask && pim->adjust ? float2fixed(0.25) : fixed_0);\n    code = gx_image_enum_begin(dev, pgs, pmat, pic, pdcolor, pcpath, mem,\n                               penum);\n    if (code >= 0)\n        *pinfo = (gx_image_enum_common_t *)penum;\n    return code;\n}","24920":"virDomainHostdevSubsysSCSIHostDefParseXML(xmlNodePtr sourcenode,\n                                          virDomainHostdevSubsysSCSIPtr scsisrc)\n{\n    bool got_address = false, got_adapter = false;\n    xmlNodePtr cur;\n    virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n    g_autofree char *bus = NULL;\n    g_autofree char *target = NULL;\n    g_autofree char *unit = NULL;\n\n    cur = sourcenode->children;\n    while (cur != NULL) {\n        if (cur->type == XML_ELEMENT_NODE) {\n            if (virXMLNodeNameEqual(cur, \"STR\")) {\n                if (got_address) {\n                    virReportError(VIR_ERR_XML_ERROR, \"STR\",\n                                   _(\"STR\"\n                                     \"STR\"));\n                    return -1;\n                }\n\n                if (!(bus = virXMLPropString(cur, \"STR\")) ||\n                    !(target = virXMLPropString(cur, \"STR\")) ||\n                    !(unit = virXMLPropString(cur, \"STR\"))) {\n                    virReportError(VIR_ERR_XML_ERROR, \"STR\",\n                                   _(\"STR\"\n                                     \"STR\"));\n                    return -1;\n                }\n\n                if (virStrToLong_uip(bus, NULL, 0, &scsihostsrc->bus) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"STR\"), bus);\n                    return -1;\n                }\n\n                if (virStrToLong_uip(target, NULL, 0,\n                                    &scsihostsrc->target) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"STR\"), target);\n                    return -1;\n                }\n\n                if (virStrToLong_ullp(unit, NULL, 0, &scsihostsrc->unit) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"STR\"), unit);\n                    return -1;\n                }\n\n                got_address = true;\n            } else if (virXMLNodeNameEqual(cur, \"STR\")) {\n                if (got_adapter) {\n                    virReportError(VIR_ERR_XML_ERROR, \"STR\",\n                                   _(\"STR\"\n                                     \"STR\"));\n                    return -1;\n                }\n                if (!(scsihostsrc->adapter = virXMLPropString(cur, \"STR\"))) {\n                    virReportError(VIR_ERR_XML_ERROR, \"STR\",\n                                   _(\"STR\"));\n                    return -1;\n                }\n\n                got_adapter = true;\n            } else {\n                virReportError(VIR_ERR_XML_ERROR,\n                               _(\"STR\"),\n                               cur->name);\n                return -1;\n            }\n        }\n        cur = cur->next;\n    }\n\n    if (!got_address || !got_adapter) {\n        virReportError(VIR_ERR_XML_ERROR, \"STR\",\n                       _(\"STR\"\n                         \"STR\"));\n        return -1;\n    }\n\n    return 0;\n}","24678":"static inline void tcp_prequeue_init(struct tcp_sock *tp)\n{\n\ttp->ucopy.task = NULL;\n\ttp->ucopy.len = 0;\n\ttp->ucopy.memory = 0;\n\tskb_queue_head_init(&tp->ucopy.prequeue);\n#ifdef CONFIG_NET_DMA\n\ttp->ucopy.dma_chan = NULL;\n\ttp->ucopy.wakeup = 0;\n\ttp->ucopy.pinned_list = NULL;\n\ttp->ucopy.dma_cookie = 0;\n#endif\n}","24185":"static int lang_run_file(RCore *core, RLang *lang, const char *file) {\n\tr_core_sysenv_begin (core, NULL);\n\treturn r_lang_run_file (core->lang, file);\n}","24366":"static long ioctl_file_dedupe_range(struct file *file, void __user *arg)\n{\n\tstruct file_dedupe_range __user *argp = arg;\n\tstruct file_dedupe_range *same = NULL;\n\tint ret;\n\tunsigned long size;\n\tu16 count;\n\n\tif (get_user(count, &argp->dest_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tsize = offsetof(struct file_dedupe_range __user, info[count]);\n\n\tsame = memdup_user(argp, size);\n\tif (IS_ERR(same)) {\n\t\tret = PTR_ERR(same);\n\t\tsame = NULL;\n\t\tgoto out;\n\t}\n\n\tret = vfs_dedupe_file_range(file, same);\n\tif (ret)\n\t\tgoto out;\n\n\tret = copy_to_user(argp, same, size);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tkfree(same);\n\treturn ret;\n}","24860":"NTSTATUS asn1_full_tag(DATA_BLOB blob, uint8_t tag, size_t *packet_size)\n{\n\tstruct asn1_data *asn1 = asn1_init(NULL);\n\tint size;\n\n\tNT_STATUS_HAVE_NO_MEMORY(asn1);\n\n\tasn1->data = blob.data;\n\tasn1->length = blob.length;\n\tasn1_start_tag(asn1, tag);\n\tif (asn1->has_error) {\n\t\ttalloc_free(asn1);\n\t\treturn STATUS_MORE_ENTRIES;\n\t}\n\tsize = asn1_tag_remaining(asn1) + asn1->ofs;\n\n\ttalloc_free(asn1);\n\n\tif (size > blob.length) {\n\t\treturn STATUS_MORE_ENTRIES;\n\t}\n\n\t*packet_size = size;\n\treturn NT_STATUS_OK;\n}","24000":"static int fuse_rename2(struct inode *olddir, struct dentry *oldent,\n\t\t\tstruct inode *newdir, struct dentry *newent,\n\t\t\tunsigned int flags)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(olddir);\n\tint err;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))\n\t\treturn -EINVAL;\n\n\tif (flags) {\n\t\tif (fc->no_rename2 || fc->minor < 23)\n\t\t\treturn -EINVAL;\n\n\t\terr = fuse_rename_common(olddir, oldent, newdir, newent, flags,\n\t\t\t\t\t FUSE_RENAME2,\n\t\t\t\t\t sizeof(struct fuse_rename2_in));\n\t\tif (err == -ENOSYS) {\n\t\t\tfc->no_rename2 = 1;\n\t\t\terr = -EINVAL;\n\t\t}\n\t} else {\n\t\terr = fuse_rename_common(olddir, oldent, newdir, newent, 0,\n\t\t\t\t\t FUSE_RENAME,\n\t\t\t\t\t sizeof(struct fuse_rename_in));\n\t}\n\n\treturn err;\n}","24498":"static void sub_reserved_credits(journal_t *journal, int blocks)\n{\n\tatomic_sub(blocks, &journal->j_reserved_credits);\n\twake_up(&journal->j_wait_reserved);\n}","24487":"static void FVMenuMMInfo(GWindow gw, struct gmenuitem *UNUSED(mi), GEvent *UNUSED(e)) {\n    FontView *fv = (FontView *) GDrawGetUserData(gw);\n    MMSet *mm = fv->b.sf->mm;\n\n    if ( mm==NULL )\nreturn;\n    MMWizard(mm);\n}","24117":"static void array_cleanup( char* arr[] , int arr_size)\n{\n\tint i=0;\n\tfor( i=0; i< arr_size; i++ ){ \n\t\tif( arr[i*2] ){\n\t\t\tefree( arr[i*2]);\n\t\t}\n\t}\n\tefree(arr);\n}","24384":"void bpf_prog_free_id(struct bpf_prog *prog, bool do_idr_lock)\n{\n\t\n\tif (!prog->aux->id)\n\t\treturn;\n\n\tif (do_idr_lock)\n\t\tspin_lock_bh(&prog_idr_lock);\n\telse\n\t\t__acquire(&prog_idr_lock);\n\n\tidr_remove(&prog_idr, prog->aux->id);\n\tprog->aux->id = 0;\n\n\tif (do_idr_lock)\n\t\tspin_unlock_bh(&prog_idr_lock);\n\telse\n\t\t__release(&prog_idr_lock);\n}","24806":"int mif_validate(jas_stream_t *in)\n{\n\tuchar buf[MIF_MAGICLEN];\n\tuint_fast32_t magic;\n\tint i;\n\tint n;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);\n\n\t\n\tif ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {\n\t\treturn -1;\n\t}\n\n\t\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t\n\tif (n < MIF_MAGICLEN) {\n\t\treturn -1;\n\t}\n\n\t\n\tmagic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |\n\t  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |\n\t  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |\n\t  buf[3];\n\n\t\n\tif (magic != MIF_MAGIC) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}","24980":"next_CE(struct read_ce_queue *heap)\n{\n\tuint64_t a_offset, b_offset, c_offset;\n\tint a, b, c;\n\tstruct read_ce_req tmp;\n\n\tif (heap->cnt < 1)\n\t\treturn;\n\n\t\n\theap->reqs[0] = heap->reqs[--(heap->cnt)];\n\n\t\n\ta = 0; \n\ta_offset = heap->reqs[a].offset;\n\tfor (;;) {\n\t\tb = a + a + 1; \n\t\tif (b >= heap->cnt)\n\t\t\treturn;\n\t\tb_offset = heap->reqs[b].offset;\n\t\tc = b + 1; \n\t\tif (c < heap->cnt) {\n\t\t\tc_offset = heap->reqs[c].offset;\n\t\t\tif (c_offset < b_offset) {\n\t\t\t\tb = c;\n\t\t\t\tb_offset = c_offset;\n\t\t\t}\n\t\t}\n\t\tif (a_offset <= b_offset)\n\t\t\treturn;\n\t\ttmp = heap->reqs[a];\n\t\theap->reqs[a] = heap->reqs[b];\n\t\theap->reqs[b] = tmp;\n\t\ta = b;\n\t}\n}","24502":"void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n\t{\n#ifdef BN_LLONG\n\tBN_ULLONG t,tt;\n#else\n\tBN_ULONG bl,bh;\n#endif\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tsqr_add_c(a,0,c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tsqr_add_c2(a,1,0,c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tsqr_add_c(a,1,c3,c1,c2);\n\tsqr_add_c2(a,2,0,c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tsqr_add_c2(a,3,0,c1,c2,c3);\n\tsqr_add_c2(a,2,1,c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tsqr_add_c(a,2,c2,c3,c1);\n\tsqr_add_c2(a,3,1,c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tsqr_add_c2(a,3,2,c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tsqr_add_c(a,3,c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}","23968":"g_socket_client_connect_async (GSocketClient       *client,\n\t\t\t       GSocketConnectable  *connectable,\n\t\t\t       GCancellable        *cancellable,\n\t\t\t       GAsyncReadyCallback  callback,\n\t\t\t       gpointer             user_data)\n{\n  GSocketClientAsyncConnectData *data;\n\n  g_return_if_fail (G_IS_SOCKET_CLIENT (client));\n\n  data = g_slice_new0 (GSocketClientAsyncConnectData);\n  data->client = client;\n  data->connectable = g_object_ref (connectable);\n\n  if (can_use_proxy (client))\n    {\n      data->enumerator = g_socket_connectable_proxy_enumerate (connectable);\n      if (client->priv->proxy_resolver &&\n          G_IS_PROXY_ADDRESS_ENUMERATOR (data->enumerator))\n        {\n          g_object_set (G_OBJECT (data->enumerator),\n                        \"STR\", client->priv->proxy_resolver,\n                        NULL);\n        }\n    }\n  else\n    data->enumerator = g_socket_connectable_enumerate (connectable);\n\n  data->task = g_task_new (client, cancellable, callback, user_data);\n  g_task_set_source_tag (data->task, g_socket_client_connect_async);\n  g_task_set_task_data (data->task, data, (GDestroyNotify)g_socket_client_async_connect_data_free);\n\n  enumerator_next_async (data);\n}","24520":"BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\n\treturn rv;\n}","24948":"file_asynch_read (struct rw *rw,\n                  struct command *command,\n                  nbd_completion_callback cb)\n{\n  int dummy = 0;\n\n  file_synch_read (rw, slice_ptr (command->slice),\n                   command->slice.len, command->offset);\n  if (cb.callback (cb.user_data, &dummy) == -1) {\n    perror (rw->name);\n    exit (EXIT_FAILURE);\n  }\n}","23966":"PHP_FUNCTION(unserialize)\n{\n\tchar *buf = NULL;\n\tsize_t buf_len;\n\tconst unsigned char *p;\n\tphp_unserialize_data_t var_hash;\n\tzval *options = NULL, *classes = NULL;\n\tHashTable *class_hash = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"STR\", &buf, &buf_len, &options) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (buf_len == 0) {\n\t\tRETURN_FALSE;\n\t}\n\n\tp = (const unsigned char*) buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tif(options != NULL) {\n\t\tclasses = zend_hash_str_find(Z_ARRVAL_P(options), \"STR\")-1);\n\t\tif(classes && (Z_TYPE_P(classes) == IS_ARRAY || !zend_is_true(classes))) {\n\t\t\tALLOC_HASHTABLE(class_hash);\n\t\t\tzend_hash_init(class_hash, (Z_TYPE_P(classes) == IS_ARRAY)?zend_hash_num_elements(Z_ARRVAL_P(classes)):0, NULL, NULL, 0);\n\t\t}\n\t\tif(class_hash && Z_TYPE_P(classes) == IS_ARRAY) {\n\t\t\tzval *entry;\n\t\t\tzend_string *lcname;\n\n\t\t\tZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(classes), entry) {\n\t\t\t\tconvert_to_string_ex(entry);\n\t\t\t\tlcname = zend_string_tolower(Z_STR_P(entry));\n\t\t\t\tzend_hash_add_empty_element(class_hash, lcname);\n\t\t        zend_string_release(lcname);\n\t\t\t} ZEND_HASH_FOREACH_END();\n\t\t}\n\t}\n\n\tif (!php_var_unserialize_ex(return_value, &p, p + buf_len, &var_hash, class_hash)) {\n\t\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\t\tif (class_hash) {\n\t\t\tzend_hash_destroy(class_hash);\n\t\t\tFREE_HASHTABLE(class_hash);\n\t\t}\n\t\tzval_ptr_dtor(return_value);\n\t\tif (!EG(exception)) {\n\t\t\tphp_error_docref(NULL, E_NOTICE, \"STR\",\n\t\t\t\t(zend_long)((char*)p - buf), buf_len);\n\t\t}\n\t\tRETURN_FALSE;\n\t}\n\t\n\tvar_push_dtor(&var_hash, return_value);\n\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tif (class_hash) {\n\t\tzend_hash_destroy(class_hash);\n\t\tFREE_HASHTABLE(class_hash);\n\t}\n}","24688":"\nstruct page *gfn_to_page(struct kvm *kvm, gfn_t gfn)\n{\n\tkvm_pfn_t pfn;\n\n\tpfn = gfn_to_pfn(kvm, gfn);\n\n\treturn kvm_pfn_to_page(pfn);","24369":"    inline void syev(char &JOB, char &UPLO, int &N, T *lapA, T *lapW, T *WORK, int &LWORK, int &INFO) {\n      dsyev_(&JOB,&UPLO,&N,lapA,&N,lapW,WORK,&LWORK,&INFO);\n    }","24532":"static void destroy_watch(struct inotify_watch *watch)\n{\n\tstruct audit_chunk *chunk = container_of(watch, struct audit_chunk, watch);\n\tfree_chunk(chunk);\n}","24993":"checker_terminate_phase2(void)\n{\n\tstruct rusage usage;\n\n\t\n\tnotify_fifo_close(&global_data->notify_fifo, &global_data->lvs_notify_fifo);\n\n\t\n\tchecker_dispatcher_release();\n\tthread_destroy_master(master);\n\tmaster = NULL;\n\tfree_checkers_queue();\n\tfree_ssl();\n\n\tipvs_stop();\n#ifdef _WITH_SNMP_CHECKER_\n\tif (global_data && global_data->enable_snmp_checker)\n\t\tcheck_snmp_agent_close();\n#endif\n\n\t\n\tpidfile_rm(checkers_pidfile);\n\n\t\n\tif (global_data)\n\t\tfree_global_data(global_data);\n\tif (check_data)\n\t\tfree_check_data(check_data);\n\tfree_parent_mallocs_exit();\n\n\t\n\tif (__test_bit(LOG_DETAIL_BIT, &debug)) {\n\t\tgetrusage(RUSAGE_SELF, &usage);\n\t\tlog_message(LOG_INFO, \"STR\", usage.ru_utime.tv_sec, usage.ru_utime.tv_usec, usage.ru_stime.tv_sec, usage.ru_stime.tv_usec);\n\t}\n\telse\n\t\tlog_message(LOG_INFO, \"STR\");\n\n\tif (log_file_name)\n\t\tclose_log_file();\n\tcloselog();\n\n#ifndef _MEM_CHECK_LOG_\n\tFREE_PTR(check_syslog_ident);\n#else\n\tif (check_syslog_ident)\n\t\tfree(check_syslog_ident);\n#endif\n\tclose_std_fd();\n\n\treturn 0;\n}","24284":"std::string Magick::Image::fontFamily(void) const\n{\n  return(constOptions()->fontFamily());\n}","24468":"static js_Ast *bitor(js_State *J, int notin)\n{\n\tjs_Ast *a = bitxor(J, notin);\n\twhile (jsP_accept(J, '|'))\n\t\ta = EXP2(BITOR, a, bitxor(J, notin));\n\treturn a;\n}","24207":"void caps_set(uint64_t caps) {\n\tif (arg_debug)\n\t\tprintf(\"STR\", (unsigned long long) caps);\n\n\tunsigned long i;\n\tuint64_t mask = 1LLU;\n\tfor (i = 0; i < 64; i++, mask <<= 1) {\n\t\tif ((mask & caps) == 0) {\n\t\t\tint code = prctl(PR_CAPBSET_DROP, i, 0, 0, 0);\n\t\t\tif (code == -1 && errno != EINVAL)\n\t\t\t\terrExit(\"STR\");\n\t\t}\n\t}\n}","24809":"int TLSWrap::SelectSNIContextCallback(SSL* s, int* ad, void* arg) {\n  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));\n  Environment* env = p->env();\n\n  const char* servername = SSL_get_servername(s, TLSEXT_NAMETYPE_host_name);\n\n  if (servername == nullptr)\n    return SSL_TLSEXT_ERR_OK;\n\n  HandleScope handle_scope(env->isolate());\n  Context::Scope context_scope(env->context());\n\n  \n  Local<Object> object = p->object();\n  Local<Value> ctx;\n\n  if (!object->Get(env->context(), env->sni_context_string()).ToLocal(&ctx))\n    return SSL_TLSEXT_ERR_NOACK;\n\n  \n  if (!ctx->IsObject())\n    return SSL_TLSEXT_ERR_NOACK;\n\n  Local<FunctionTemplate> cons = env->secure_context_constructor_template();\n  if (!cons->HasInstance(ctx)) {\n    \n    Local<Value> err = Exception::TypeError(env->sni_context_err_string());\n    p->MakeCallback(env->onerror_string(), 1, &err);\n    return SSL_TLSEXT_ERR_NOACK;\n  }\n\n  p->sni_context_.Reset(env->isolate(), ctx);\n\n  SecureContext* sc = Unwrap<SecureContext>(ctx.As<Object>());\n  CHECK_NOT_NULL(sc);\n  p->SetSNIContext(sc);\n  return SSL_TLSEXT_ERR_OK;\n}","24429":"void uprobe_copy_process(struct task_struct *t, unsigned long flags)\n{\n\tstruct uprobe_task *utask = current->utask;\n\tstruct mm_struct *mm = current->mm;\n\tstruct xol_area *area;\n\n\tt->utask = NULL;\n\n\tif (!utask || !utask->return_instances)\n\t\treturn;\n\n\tif (mm == t->mm && !(flags & CLONE_VFORK))\n\t\treturn;\n\n\tif (dup_utask(t, utask))\n\t\treturn uprobe_warn(t, \"STR\");\n\n\t\n\tarea = mm->uprobes_state.xol_area;\n\tif (!area)\n\t\treturn uprobe_warn(t, \"STR\");\n\n\tif (mm == t->mm)\n\t\treturn;\n\n\tt->utask->dup_xol_addr = area->vaddr;\n\tinit_task_work(&t->utask->dup_xol_work, dup_xol_work);\n\ttask_work_add(t, &t->utask->dup_xol_work, true);\n}","25040":"static struct pending_op *acquire_write(struct external_chrc *chrc,\n\t\t\t\t\tstruct btd_device *device,\n\t\t\t\t\tstruct gatt_db_attribute *attrib,\n\t\t\t\t\tunsigned int id,\n\t\t\t\t\tconst uint8_t *value, size_t len,\n\t\t\t\t\tuint8_t link_type)\n{\n\tstruct pending_op *op;\n\tbool acquiring = !queue_isempty(chrc->pending_writes);\n\n\top = pending_write_new(device, chrc->pending_writes, attrib, id, value,\n\t\t\t\tlen, 0, link_type, false, false);\n\n\tif (acquiring)\n\t\treturn op;\n\n\tif (g_dbus_proxy_method_call(chrc->proxy, \"STR\",\n\t\t\t\t\tacquire_write_setup,\n\t\t\t\t\tacquire_write_reply,\n\t\t\t\t\top, NULL))\n\t\treturn op;\n\n\tpending_op_free(op);\n\n\treturn NULL;\n}","24445":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* fft_length = GetInput(context, node, kFftLengthTensor);\n  const int32_t* fft_length_data = GetTensorData<int32_t>(fft_length);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (output->type != kTfLiteComplex64) {\n    context->ReportError(context,\n                         \"STR\",\n                         TfLiteTypeGetName(output->type));\n    return kTfLiteError;\n  }\n\n  \n  \n  if (!IsConstantTensor(fft_length)) {\n    TF_LITE_ENSURE_STATUS(ResizeOutputandTemporaryTensors(context, node));\n  } else {\n    int num_dims_output = NumDimensions(output);\n    const RuntimeShape output_shape = GetTensorShape(output);\n    TF_LITE_ENSURE_EQ(context, num_dims_output, NumDimensions(input));\n    TF_LITE_ENSURE(context, num_dims_output >= 2);\n    TF_LITE_ENSURE_EQ(context, output_shape.Dims(num_dims_output - 2),\n                      fft_length_data[0]);\n    TF_LITE_ENSURE_EQ(context, output_shape.Dims(num_dims_output - 1),\n                      fft_length_data[1] \/ 2 + 1);\n  }\n\n  return Rfft2dHelper(context, node);\n}","24270":"formList_addInput(struct form_list *fl, struct parsed_tag *tag)\n{\n    struct form_item_list *item;\n    char *p;\n    int i;\n\n    \n    if (fl == NULL)\n\treturn NULL;\n\n    item = New(struct form_item_list);\n    item->type = FORM_UNKNOWN;\n    item->size = -1;\n    item->rows = 0;\n    item->checked = item->init_checked = 0;\n    item->accept = 0;\n    item->name = NULL;\n    item->value = item->init_value = NULL;\n    item->readonly = 0;\n    if (parsedtag_get_value(tag, ATTR_TYPE, &p)) {\n\titem->type = formtype(p);\n\tif (item->size < 0 &&\n\t    (item->type == FORM_INPUT_TEXT ||\n\t     item->type == FORM_INPUT_FILE ||\n\t     item->type == FORM_INPUT_PASSWORD))\n\t    item->size = FORM_I_TEXT_DEFAULT_SIZE;\n    }\n    if (parsedtag_get_value(tag, ATTR_NAME, &p))\n\titem->name = Strnew_charp(p);\n    if (parsedtag_get_value(tag, ATTR_VALUE, &p))\n\titem->value = item->init_value = Strnew_charp(p);\n    item->checked = item->init_checked = parsedtag_exists(tag, ATTR_CHECKED);\n    item->accept = parsedtag_exists(tag, ATTR_ACCEPT);\n    parsedtag_get_value(tag, ATTR_SIZE, &item->size);\n    parsedtag_get_value(tag, ATTR_MAXLENGTH, &item->maxlength);\n    item->readonly = parsedtag_exists(tag, ATTR_READONLY);\n    if (parsedtag_get_value(tag, ATTR_TEXTAREANUMBER, &i))\n\titem->value = item->init_value = textarea_str[i];\n#ifdef MENU_SELECT\n    if (parsedtag_get_value(tag, ATTR_SELECTNUMBER, &i))\n\titem->select_option = select_option[i].first;\n#endif\t\t\t\t\n    if (parsedtag_get_value(tag, ATTR_ROWS, &p))\n\titem->rows = atoi(p);\n    if (item->type == FORM_UNKNOWN) {\n\t\n\treturn NULL;\n    }\n#ifdef MENU_SELECT\n    if (item->type == FORM_SELECT) {\n\tchooseSelectOption(item, item->select_option);\n\titem->init_selected = item->selected;\n\titem->init_value = item->value;\n\titem->init_label = item->label;\n    }\n#endif\t\t\t\t\n    if (item->type == FORM_INPUT_FILE && item->value && item->value->length) {\n\t\n\treturn NULL;\n    }\n    item->parent = fl;\n    item->next = NULL;\n    if (fl->item == NULL) {\n\tfl->item = fl->lastitem = item;\n    }\n    else {\n\tfl->lastitem->next = item;\n\tfl->lastitem = item;\n    }\n    if (item->type == FORM_INPUT_HIDDEN)\n\treturn NULL;\n    fl->nitems++;\n    return item;\n}","24659":"jas_matrix_t *jas_seq2d_input(FILE *in)\n{\n\tjas_matrix_t *matrix;\n\tint i;\n\tint j;\n\tlong x;\n\tint numrows;\n\tint numcols;\n\tint xoff;\n\tint yoff;\n\n\tif (fscanf(in, \"STR\", &xoff, &yoff) != 2)\n\t\treturn 0;\n\tif (fscanf(in, \"STR\", &numcols, &numrows) != 2)\n\t\treturn 0;\n\tif (!(matrix = jas_seq2d_create(xoff, yoff, xoff + numcols, yoff + numrows)))\n\t\treturn 0;\n\n\tif (jas_matrix_numrows(matrix) != numrows || jas_matrix_numcols(matrix) != numcols) {\n\t\tabort();\n\t}\n\n\t\n\tfor (i = 0; i < jas_matrix_numrows(matrix); i++) {\n\t\tfor (j = 0; j < jas_matrix_numcols(matrix); j++) {\n\t\t\tif (fscanf(in, \"STR\", &x) != 1) {\n\t\t\t\tjas_matrix_destroy(matrix);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tjas_matrix_set(matrix, i, j, JAS_CAST(jas_seqent_t, x));\n\t\t}\n\t}\n\n\treturn matrix;\n}","23938":"static int nbd_negotiate_send_rep_list(QIOChannel *ioc, NBDExport *exp)\n{\n    size_t name_len, desc_len;\n    uint32_t len;\n    const char *name = exp->name ? exp->name : \"\";\n    const char *desc = exp->description ? exp->description : \"\";\n    int rc;\n\n    TRACE(\"STR\", name, desc);\n    name_len = strlen(name);\n    desc_len = strlen(desc);\n    len = name_len + desc_len + sizeof(len);\n    rc = nbd_negotiate_send_rep_len(ioc, NBD_REP_SERVER, NBD_OPT_LIST, len);\n    if (rc < 0) {\n        return rc;\n    }\n\n    len = cpu_to_be32(name_len);\n    if (nbd_negotiate_write(ioc, &len, sizeof(len)) < 0) {\n        LOG(\"STR\");\n        return -EINVAL;\n    }\n    if (nbd_negotiate_write(ioc, name, name_len) < 0) {\n        LOG(\"STR\");\n        return -EINVAL;\n    }\n    if (nbd_negotiate_write(ioc, desc, desc_len) < 0) {\n        LOG(\"STR\");\n        return -EINVAL;\n    }\n    return 0;\n}","24859":"static int htc_setup_complete(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_comp_msg *comp_msg;\n\tint ret = 0;\n\tunsigned long time_left;\n\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"STR\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\n\tcomp_msg = skb_put(skb, sizeof(struct htc_comp_msg));\n\tcomp_msg->msg_id = cpu_to_be16(HTC_MSG_SETUP_COMPLETE_ID);\n\n\ttarget->htc_flags |= HTC_OP_START_WAIT;\n\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"STR\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}","24634":"save_and_apply_config_tree(int input_from_file)\n{\n\tconfig_tree *ptree;\n#ifndef SAVECONFIG\n\tconfig_tree *punlinked;\n#endif\n\n\t\n\tptree = emalloc(sizeof(*ptree));\n\tmemcpy(ptree, &cfgt, sizeof(*ptree));\n\tZERO(cfgt);\n\n\tLINK_TAIL_SLIST(cfg_tree_history, ptree, link, config_tree);\n\n#ifdef SAVECONFIG\n\tif (HAVE_OPT( SAVECONFIGQUIT )) {\n\t\tFILE *dumpfile;\n\t\tint err;\n\t\tint dumpfailed;\n\n\t\tdumpfile = fopen(OPT_ARG( SAVECONFIGQUIT ), \"STR\");\n\t\tif (NULL == dumpfile) {\n\t\t\terr = errno;\n\t\t\tmfprintf(stderr,\n\t\t\t\t \"STR\",\n\t\t\t\t OPT_ARG(SAVECONFIGQUIT), err);\n\t\t\texit(err);\n\t\t}\n\n\t\tdumpfailed = dump_all_config_trees(dumpfile, 0);\n\t\tif (dumpfailed)\n\t\t\tfprintf(stderr,\n\t\t\t\t\"STR\",\n\t\t\t\tOPT_ARG( SAVECONFIGQUIT ),\n\t\t\t\tdumpfailed);\n\t\telse\n\t\t\tfprintf(stderr,\n\t\t\t\t\"STR\",\n\t\t\t\tOPT_ARG( SAVECONFIGQUIT ));\n\n\t\texit(dumpfailed);\n\t}\n#endif\t\n\n\t\n\n#ifndef SIM\n\tconfig_ntpd(ptree, input_from_file);\n#else\n\tconfig_ntpdsim(ptree);\n#endif\n\n\t\n#ifndef SAVECONFIG\n\tUNLINK_SLIST(punlinked, cfg_tree_history, ptree, link,\n\t\t     config_tree);\n\tINSIST(punlinked == ptree);\n\tfree_config_tree(ptree);\n#endif\n}","24917":"archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\n\t(void)mode;\t\n\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"STR\");\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\treturn (ret);\n\t\t}\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"STR\");\n\n\t\t\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"STR\");\n\t}\n#endif\n\treturn (ret);\n}","24459":"xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) {\n    int len = 0, l;\n    int c;\n    int count = 0;\n    const xmlChar *end; \n\n#ifdef DEBUG\n    nbParseNCNameComplex++;\n#endif\n\n    \n    GROW;\n    end = ctxt->input->cur;\n    c = CUR_CHAR(l);\n    if ((c == ' ') || (c == '>') || (c == '\/') || \n\t(!xmlIsNameStartChar(ctxt, c) || (c == ':'))) {\n\treturn(NULL);\n    }\n\n    while ((c != ' ') && (c != '>') && (c != '\/') && \n\t   (xmlIsNameChar(ctxt, c) && (c != ':'))) {\n\tif (count++ > XML_PARSER_CHUNK_SIZE) {\n            if ((len > XML_MAX_NAME_LENGTH) &&\n                ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"STR\");\n                return(NULL);\n            }\n\t    count = 0;\n\t    GROW;\n            if (ctxt->instate == XML_PARSER_EOF)\n                return(NULL);\n\t}\n\tlen += l;\n\tNEXTL(l);\n\tend = ctxt->input->cur;\n\tc = CUR_CHAR(l);\n\tif (c == 0) {\n\t    count = 0;\n\t    \n\t    ctxt->input->cur -= l;\n\t    GROW;\n\t    ctxt->input->cur += l;\n            if (ctxt->instate == XML_PARSER_EOF)\n                return(NULL);\n\t    end = ctxt->input->cur;\n\t    c = CUR_CHAR(l);\n\t}\n    }\n    if ((len > XML_MAX_NAME_LENGTH) &&\n        ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"STR\");\n        return(NULL);\n    }\n    return(xmlDictLookup(ctxt->dict, end - len, len));\n}","24247":"void SSL_set_client_CA_list(SSL *s, STACK_OF(X509_NAME) *name_list)\n{\n    set0_CA_list(&s->client_ca_names, name_list);\n}","24926":"static sci_t make_sci(u8 *addr, __be16 port)\n{\n\tsci_t sci;\n\n\tmemcpy(&sci, addr, ETH_ALEN);\n\tmemcpy(((char *)&sci) + ETH_ALEN, &port, sizeof(port));\n\n\treturn sci;\n}","24933":"static void *virtio_scsi_load_request(QEMUFile *f, SCSIRequest *sreq)\n{\n    SCSIBus *bus = sreq->bus;\n    VirtIOSCSI *s = container_of(bus, VirtIOSCSI, bus);\n    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(s);\n    VirtIOSCSIReq *req;\n    uint32_t n;\n\n    req = g_malloc(sizeof(*req));\n    qemu_get_be32s(f, &n);\n    assert(n < vs->conf.num_queues);\n    qemu_get_buffer(f, (unsigned char *)&req->elem, sizeof(req->elem));\n    virtio_scsi_parse_req(s, vs->cmd_vqs[n], req);\n\n    scsi_req_ref(sreq);\n    req->sreq = sreq;\n    if (req->sreq->cmd.mode != SCSI_XFER_NONE) {\n        int req_mode =\n            (req->elem.in_num > 1 ? SCSI_XFER_FROM_DEV : SCSI_XFER_TO_DEV);\n\n        assert(req->sreq->cmd.mode == req_mode);\n    }\n    return req;\n}","24008":"static struct kobject *cdev_get(struct cdev *p)\n{\n\tstruct module *owner = p->owner;\n\tstruct kobject *kobj;\n\n\tif (owner && !try_module_get(owner))\n\t\treturn NULL;\n\tkobj = kobject_get(&p->kobj);\n\tif (!kobj)\n\t\tmodule_put(owner);\n\treturn kobj;\n}","25020":"int secure_check(void *data)\n{\n\tconst at91_secure_header_t *header;\n\tvoid *file;\n\n\tif (secure_decrypt(data, sizeof(*header), 0))\n\t\treturn -1;\n\n\theader = (const at91_secure_header_t *)data;\n\tif (header->magic != AT91_SECURE_MAGIC)\n\t\treturn -1;\n\n\tfile = (unsigned char *)data + sizeof(*header);\n\treturn secure_decrypt(file, header->file_size, 1);\n}","24527":"struct btf *bpf_get_btf_vmlinux(void)\n{\n\tif (!btf_vmlinux && IS_ENABLED(CONFIG_DEBUG_INFO_BTF)) {\n\t\tmutex_lock(&bpf_verifier_lock);\n\t\tif (!btf_vmlinux)\n\t\t\tbtf_vmlinux = btf_parse_vmlinux();\n\t\tmutex_unlock(&bpf_verifier_lock);\n\t}\n\treturn btf_vmlinux;\n}","24666":"static void iwl_trans_pcie_write_prph(struct iwl_trans *trans, u32 addr,\n\t\t\t\t      u32 val)\n{\n\tu32 mask = iwl_trans_pcie_prph_msk(trans);\n\n\tiwl_trans_pcie_write32(trans, HBUS_TARG_PRPH_WADDR,\n\t\t\t       ((addr & mask) | (3 << 24)));\n\tiwl_trans_pcie_write32(trans, HBUS_TARG_PRPH_WDAT, val);\n}","24257":"MagickExport MagickBooleanType SetImageProfile(Image *image,const char *name,\n  const StringInfo *profile,ExceptionInfo *exception)\n{\n  char\n    key[MaxTextExtent],\n    property[MaxTextExtent];\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"STR\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    image->profiles=NewSplayTree(CompareSplayTreeString,RelinquishMagickMemory,\n      DestroyProfile);\n  (void) CopyMagickString(key,name,MaxTextExtent);\n  status=AddValueToSplayTree((SplayTreeInfo *) image->profiles,\n    ConstantString(key),CloneStringInfo(profile));\n  if ((status != MagickFalse) &&\n      ((LocaleCompare(name,\"STR\") == 0)))\n    (void) GetProfilesFromResourceBlock(image,profile,exception);\n  \n  (void) FormatLocaleString(property,MaxTextExtent,\"STR\",name);\n  (void) GetImageProperty(image,property,exception);\n  return(status);\n}","23909":"evdev_pointer_notify_button(struct evdev_device *device,\n\t\t\t    uint64_t time,\n\t\t\t    unsigned int button,\n\t\t\t    enum libinput_button_state state)\n{\n\tif (device->scroll.method == LIBINPUT_CONFIG_SCROLL_ON_BUTTON_DOWN &&\n\t    button == device->scroll.button) {\n\t\tevdev_button_scroll_button(device, time, state);\n\t\treturn;\n\t}\n\n\tevdev_pointer_post_button(device, time, button, state);\n}","24244":"static void usbredir_handle_interrupt_out_data(USBRedirDevice *dev,\n                                               USBPacket *p, uint8_t ep)\n{\n    struct usb_redir_interrupt_packet_header interrupt_packet;\n    uint8_t buf[p->iov.size];\n\n    DPRINTF(\"STR\", ep,\n            p->iov.size, p->id);\n\n    interrupt_packet.endpoint  = ep;\n    interrupt_packet.length    = p->iov.size;\n\n    usb_packet_copy(p, buf, p->iov.size);\n    usbredir_log_data(dev, \"STR\", buf, p->iov.size);\n    usbredirparser_send_interrupt_packet(dev->parser, p->id,\n                                    &interrupt_packet, buf, p->iov.size);\n    usbredirparser_do_write(dev->parser);\n}","24825":"static int __init init_ext2_fs(void)\n{\n\tint err = init_ext2_xattr();\n\tif (err)\n\t\treturn err;\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n        err = register_filesystem(&ext2_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\texit_ext2_xattr();\n\treturn err;\n}","24854":"static void suboption(struct Curl_easy *data)\n{\n  struct curl_slist *v;\n  unsigned char temp[2048];\n  ssize_t bytes_written;\n  size_t len;\n  int err;\n  char varname[128] = \"\";\n  char varval[128] = \"\";\n  struct TELNET *tn = data->req.p.telnet;\n  struct connectdata *conn = data->conn;\n\n  printsub(data, '<', (unsigned char *)tn->subbuffer, CURL_SB_LEN(tn) + 2);\n  switch(CURL_SB_GET(tn)) {\n    case CURL_TELOPT_TTYPE:\n      len = strlen(tn->subopt_ttype) + 4 + 2;\n      msnprintf((char *)temp, sizeof(temp),\n                \"STR\", CURL_IAC, CURL_SB, CURL_TELOPT_TTYPE,\n                CURL_TELQUAL_IS, tn->subopt_ttype, CURL_IAC, CURL_SE);\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"STR\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n    case CURL_TELOPT_XDISPLOC:\n      len = strlen(tn->subopt_xdisploc) + 4 + 2;\n      msnprintf((char *)temp, sizeof(temp),\n                \"STR\", CURL_IAC, CURL_SB, CURL_TELOPT_XDISPLOC,\n                CURL_TELQUAL_IS, tn->subopt_xdisploc, CURL_IAC, CURL_SE);\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"STR\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n    case CURL_TELOPT_NEW_ENVIRON:\n      msnprintf((char *)temp, sizeof(temp),\n                \"STR\", CURL_IAC, CURL_SB, CURL_TELOPT_NEW_ENVIRON,\n                CURL_TELQUAL_IS);\n      len = 4;\n\n      for(v = tn->telnet_vars; v; v = v->next) {\n        size_t tmplen = (strlen(v->data) + 1);\n        \n        if(len + tmplen < (int)sizeof(temp)-6) {\n          if(sscanf(v->data, \"STR\", varname, varval)) {\n            msnprintf((char *)&temp[len], sizeof(temp) - len,\n                      \"STR\", CURL_NEW_ENV_VAR, varname,\n                      CURL_NEW_ENV_VALUE, varval);\n            len += tmplen;\n          }\n        }\n      }\n      msnprintf((char *)&temp[len], sizeof(temp) - len,\n                \"STR\", CURL_IAC, CURL_SE);\n      len += 2;\n      bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len);\n      if(bytes_written < 0) {\n        err = SOCKERRNO;\n        failf(data,\"STR\",err);\n      }\n      printsub(data, '>', &temp[2], len-2);\n      break;\n  }\n  return;\n}","25053":"addCharacterClass(FileInfo *nested, const widechar *name, int length,\n\t\tCharacterClass **characterClasses,\n\t\tTranslationTableCharacterAttributes *characterClassAttribute) {\n\t\n\tCharacterClass *class;\n\tif (*characterClassAttribute) {\n\t\tif (!(class = malloc(sizeof(*class) + CHARSIZE * (length - 1))))\n\t\t\t_lou_outOfMemory();\n\t\telse {\n\t\t\tmemset(class, 0, sizeof(*class));\n\t\t\tmemcpy(class->name, name, CHARSIZE * (class->length = length));\n\t\t\tclass->attribute = *characterClassAttribute;\n\t\t\t*characterClassAttribute <<= 1;\n\t\t\tclass->next = *characterClasses;\n\t\t\t*characterClasses = class;\n\t\t\treturn class;\n\t\t}\n\t}\n\tcompileError(nested, \"STR\");\n\treturn NULL;\n}","24904":"void LOGGER::init_base()\n{\n  DBUG_ASSERT(inited == 0);\n  inited= 1;\n\n  \n  if (!file_log_handler)\n    file_log_handler= new Log_to_file_event_handler;\n\n  \n  init_error_log(LOG_FILE);\n\n  file_log_handler->init_pthread_objects();\n  mysql_rwlock_init(key_rwlock_LOCK_logger, &LOCK_logger);\n}","24165":"rsvg_css_parse_font_style (const char *str, gboolean * inherit)\n{\n    SETINHERIT ();\n\n    if (str) {\n        if (!strcmp (str, \"STR\"))\n            return PANGO_STYLE_OBLIQUE;\n        if (!strcmp (str, \"STR\"))\n            return PANGO_STYLE_ITALIC;\n        else if (!strcmp (str, \"STR\")) {\n            UNSETINHERIT ();\n            return PANGO_STYLE_NORMAL;\n        }\n    }\n    UNSETINHERIT ();\n    return PANGO_STYLE_NORMAL;\n}","24800":"static struct stream *bgp_update_packet_eor(struct peer *peer, afi_t afi,\n\t\t\t\t\t    safi_t safi)\n{\n\tstruct stream *s;\n\tiana_afi_t pkt_afi = IANA_AFI_IPV4;\n\tiana_safi_t pkt_safi = IANA_SAFI_UNICAST;\n\n\tif (DISABLE_BGP_ANNOUNCE)\n\t\treturn NULL;\n\n\tif (bgp_debug_neighbor_events(peer))\n\t\tzlog_debug(\"STR\",\n\t\t\t   get_afi_safi_str(afi, safi, false), peer->host);\n\n\ts = stream_new(peer->max_packet_size);\n\n\t\n\tbgp_packet_set_marker(s, BGP_MSG_UPDATE);\n\n\t\n\tstream_putw(s, 0);\n\n\tif (afi == AFI_IP && safi == SAFI_UNICAST) {\n\t\t\n\t\tstream_putw(s, 0);\n\t} else {\n\t\t\n\t\tbgp_map_afi_safi_int2iana(afi, safi, &pkt_afi, &pkt_safi);\n\n\t\t\n\t\tstream_putw(s, 6);\n\t\tstream_putc(s, BGP_ATTR_FLAG_OPTIONAL);\n\t\tstream_putc(s, BGP_ATTR_MP_UNREACH_NLRI);\n\t\tstream_putc(s, 3);\n\t\tstream_putw(s, pkt_afi);\n\t\tstream_putc(s, pkt_safi);\n\t}\n\n\tbgp_packet_set_size(s);\n\treturn s;\n}","24692":"ProcXkbSetGeometry(ClientPtr client)\n{\n    DeviceIntPtr dev;\n    int rc;\n\n    REQUEST(xkbSetGeometryReq);\n    REQUEST_AT_LEAST_SIZE(xkbSetGeometryReq);\n\n    if (!(client->xkbClientFlags & _XkbClientInitialized))\n        return BadAccess;\n\n    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);\n    CHK_ATOM_OR_NONE(stuff->name);\n\n    rc = _XkbSetGeometry(client, dev, stuff);\n    if (rc != Success)\n        return rc;\n\n    if (stuff->deviceSpec == XkbUseCoreKbd) {\n        DeviceIntPtr other;\n\n        for (other = inputInfo.devices; other; other = other->next) {\n            if ((other != dev) && other->key && !IsMaster(other) &&\n                GetMaster(other, MASTER_KEYBOARD) == dev) {\n                rc = XaceHook(XACE_DEVICE_ACCESS, client, other,\n                              DixManageAccess);\n                if (rc == Success)\n                    _XkbSetGeometry(client, other, stuff);\n            }\n        }\n    }\n\n    return Success;\n}","24940":"static int __dev_open(struct net_device *dev)\n{\n\tconst struct net_device_ops *ops = dev->netdev_ops;\n\tint ret;\n\n\tASSERT_RTNL();\n\n\tif (!netif_device_present(dev))\n\t\treturn -ENODEV;\n\n\t\n\tnetpoll_rx_disable(dev);\n\n\tret = call_netdevice_notifiers(NETDEV_PRE_UP, dev);\n\tret = notifier_to_errno(ret);\n\tif (ret)\n\t\treturn ret;\n\n\tset_bit(__LINK_STATE_START, &dev->state);\n\n\tif (ops->ndo_validate_addr)\n\t\tret = ops->ndo_validate_addr(dev);\n\n\tif (!ret && ops->ndo_open)\n\t\tret = ops->ndo_open(dev);\n\n\tnetpoll_rx_enable(dev);\n\n\tif (ret)\n\t\tclear_bit(__LINK_STATE_START, &dev->state);\n\telse {\n\t\tdev->flags |= IFF_UP;\n\t\tnet_dmaengine_get();\n\t\tdev_set_rx_mode(dev);\n\t\tdev_activate(dev);\n\t\tadd_device_randomness(dev->dev_addr, dev->addr_len);\n\t}\n\n\treturn ret;\n}","24045":"inline static bool jas_safe_size_mul(size_t x, size_t y, size_t *result)\n{\n\t\n\tif (x && y > SIZE_MAX \/ x) {\n\t\t\n\t\t*result = 0;\n\t\treturn false;\n\t}\n\t*result = x * y;\n\treturn true;\n}","23894":"static int ssl_parse_cid_ext( mbedtls_ssl_context *ssl,\n                              const unsigned char *buf,\n                              size_t len )\n{\n    size_t peer_cid_len;\n\n    \n    if( ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"STR\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    \n\n    if( len < 1 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"STR\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    peer_cid_len = *buf++;\n    len--;\n\n    if( len != peer_cid_len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"STR\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    \n    if( ssl->negotiate_cid == MBEDTLS_SSL_CID_DISABLED )\n    {\n        \n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"STR\" ) );\n        return( 0 );\n    }\n\n    if( peer_cid_len > MBEDTLS_SSL_CID_OUT_LEN_MAX )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"STR\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    ssl->handshake->cid_in_use = MBEDTLS_SSL_CID_ENABLED;\n    ssl->handshake->peer_cid_len = (uint8_t) peer_cid_len;\n    memcpy( ssl->handshake->peer_cid, buf, peer_cid_len );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"STR\" ) );\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"STR\", buf, peer_cid_len );\n\n    return( 0 );\n}","25056":"BOOL region16_intersect_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n{\n\tREGION16_DATA* newItems;\n\tconst RECTANGLE_16* srcPtr, *endPtr, *srcExtents;\n\tRECTANGLE_16* dstPtr;\n\tUINT32 nbRects, usedRects;\n\tRECTANGLE_16 common, newExtents;\n\tassert(src);\n\tassert(src->data);\n\tsrcPtr = region16_rects(src, &nbRects);\n\n\tif (!nbRects)\n\t{\n\t\tregion16_clear(dst);\n\t\treturn TRUE;\n\t}\n\n\tsrcExtents = region16_extents(src);\n\n\tif (nbRects == 1)\n\t{\n\t\tBOOL intersects = rectangles_intersection(srcExtents, rect, &common);\n\t\tregion16_clear(dst);\n\n\t\tif (intersects)\n\t\t\treturn region16_union_rect(dst, dst, &common);\n\n\t\treturn TRUE;\n\t}\n\n\tnewItems = allocateRegion(nbRects);\n\n\tif (!newItems)\n\t\treturn FALSE;\n\n\tdstPtr = (RECTANGLE_16*)(&newItems[1]);\n\tusedRects = 0;\n\tZeroMemory(&newExtents, sizeof(newExtents));\n\n\t\n\tfor (endPtr = srcPtr + nbRects; (srcPtr < endPtr) && (rect->bottom > srcPtr->top); srcPtr++)\n\t{\n\t\tif (rectangles_intersection(srcPtr, rect, &common))\n\t\t{\n\t\t\t*dstPtr = common;\n\t\t\tusedRects++;\n\t\t\tdstPtr++;\n\n\t\t\tif (rectangle_is_empty(&newExtents))\n\t\t\t{\n\t\t\t\t\n\t\t\t\tnewExtents = common;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnewExtents.top = MIN(common.top, newExtents.top);\n\t\t\t\tnewExtents.left = MIN(common.left, newExtents.left);\n\t\t\t\tnewExtents.bottom = MAX(common.bottom, newExtents.bottom);\n\t\t\t\tnewExtents.right = MAX(common.right, newExtents.right);\n\t\t\t}\n\t\t}\n\t}\n\n\tnewItems->nbRects = usedRects;\n\tnewItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16));\n\n\tif ((dst->data->size > 0) && (dst->data != &empty_region))\n\t\tfree(dst->data);\n\n\tdst->data = realloc(newItems, newItems->size);\n\n\tif (!dst->data)\n\t{\n\t\tfree(newItems);\n\t\treturn FALSE;\n\t}\n\n\tdst->extents = newExtents;\n\treturn region16_simplify_bands(dst);\n}","24932":"static void veth_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct veth_priv *priv;\n\tstruct net_device *peer;\n\n\tpriv = netdev_priv(dev);\n\tpeer = priv->peer;\n\n\tunregister_netdevice_queue(dev, head);\n\tunregister_netdevice_queue(peer, head);\n}","25042":"cairo_surface_t *CairoOutputDev::downscaleSurface(cairo_surface_t *orig_surface) {\n  cairo_surface_t *dest_surface;\n  unsigned char *dest_buffer;\n  int dest_stride;\n  unsigned char *orig_buffer;\n  int orig_width, orig_height;\n  int orig_stride;\n  int scaledHeight;\n  int scaledWidth;\n  GBool res;\n\n  if (printing)\n    return NULL;\n\n  orig_width = cairo_image_surface_get_width (orig_surface);\n  orig_height = cairo_image_surface_get_height (orig_surface);\n  getScaledSize (orig_width, orig_height, &scaledWidth, &scaledHeight);\n  if (scaledWidth >= orig_width || scaledHeight >= orig_height)\n    return NULL;\n\n  dest_surface = cairo_surface_create_similar (orig_surface,\n\t\t\t\t\t       cairo_surface_get_content (orig_surface),\n\t\t\t\t\t       scaledWidth, scaledHeight);\n  dest_buffer = cairo_image_surface_get_data (dest_surface);\n  dest_stride = cairo_image_surface_get_stride (dest_surface);\n\n  orig_buffer = cairo_image_surface_get_data (orig_surface);\n  orig_stride = cairo_image_surface_get_stride (orig_surface);\n\n  res = downscale_box_filter((uint32_t *)orig_buffer,\n\t\t\t     orig_stride, orig_width, orig_height,\n\t\t\t     scaledWidth, scaledHeight, 0, 0,\n\t\t\t     scaledWidth, scaledHeight,\n\t\t\t     (uint32_t *)dest_buffer, dest_stride);\n  if (!res) {\n    cairo_surface_destroy (dest_surface);\n    return NULL;\n  }\n\n  return dest_surface;\n\n}","24796":"evbuffer_copyout_from(struct evbuffer *buf, const struct evbuffer_ptr *pos,\n    void *data_out, size_t datlen)\n{\n\t\n\tstruct evbuffer_chain *chain;\n\tchar *data = data_out;\n\tsize_t nread;\n\tev_ssize_t result = 0;\n\tsize_t pos_in_chain;\n\n\tEVBUFFER_LOCK(buf);\n\n\tif (pos) {\n\t\tchain = pos->internal_.chain;\n\t\tpos_in_chain = pos->internal_.pos_in_chain;\n\t\tif (datlen + pos->pos > buf->total_len)\n\t\t\tdatlen = buf->total_len - pos->pos;\n\t} else {\n\t\tchain = buf->first;\n\t\tpos_in_chain = 0;\n\t\tif (datlen > buf->total_len)\n\t\t\tdatlen = buf->total_len;\n\t}\n\n\n\tif (datlen == 0)\n\t\tgoto done;\n\n\tif (buf->freeze_start) {\n\t\tresult = -1;\n\t\tgoto done;\n\t}\n\n\tnread = datlen;\n\n\twhile (datlen && datlen >= chain->off - pos_in_chain) {\n\t\tsize_t copylen = chain->off - pos_in_chain;\n\t\tmemcpy(data,\n\t\t    chain->buffer + chain->misalign + pos_in_chain,\n\t\t    copylen);\n\t\tdata += copylen;\n\t\tdatlen -= copylen;\n\n\t\tchain = chain->next;\n\t\tpos_in_chain = 0;\n\t\tEVUTIL_ASSERT(chain || datlen==0);\n\t}\n\n\tif (datlen) {\n\t\tEVUTIL_ASSERT(chain);\n\t\tmemcpy(data, chain->buffer + chain->misalign + pos_in_chain,\n\t\t    datlen);\n\t}\n\n\tresult = nread;\ndone:\n\tEVBUFFER_UNLOCK(buf);\n\treturn result;\n}","23933":"mail_config_ews_autodiscover_sync (ECredentialsPrompter *prompter,\n\t\t\t\t   ESource *source,\n\t\t\t\t   const ENamedParameters *credentials,\n\t\t\t\t   gboolean *out_authenticated,\n\t\t\t\t   gpointer user_data,\n\t\t\t\t   GCancellable *cancellable,\n\t\t\t\t   GError **error)\n{\n\tAsyncContext *async_context = user_data;\n\tGError *local_error = NULL;\n\tgboolean res = TRUE;\n\n\te_ews_autodiscover_ws_url_sync (source,\n\t\tasync_context->ews_settings, async_context->email_address,\n\t\tcredentials && e_named_parameters_get (credentials, E_SOURCE_CREDENTIAL_PASSWORD) ?\n\t\te_named_parameters_get (credentials, E_SOURCE_CREDENTIAL_PASSWORD) : \"\",\n\t\t&async_context->certificate_pem, &async_context->certificate_errors,\n\t\tcancellable, &local_error);\n\n\tif (local_error == NULL) {\n\t\t*out_authenticated = TRUE;\n\t} else if (g_error_matches (local_error, SOUP_HTTP_ERROR, SOUP_STATUS_UNAUTHORIZED)) {\n\t\t*out_authenticated = FALSE;\n\t\tg_error_free (local_error);\n\t} else {\n\t\tres = FALSE;\n\t\tg_propagate_error (error, local_error);\n\t}\n\n\treturn res;\n}","23916":"epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)\n{\n\tint r;\n\tsize_t len = 0;\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = sc_check_sw(card, sm->sw1, sm->sw2);\n\tif (r == SC_SUCCESS) {\n\t\tif (exdata->sm) {\n\t\t\tif (0 != decrypt_response(card, sm->resp, plain->resp, &len))\n\t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n\t\t}\n\t\telse {\n\t\t\tmemcpy(plain->resp, sm->resp, sm->resplen);\n\t\t\tlen = sm->resplen;\n\t\t}\n\t}\n\n\tplain->resplen = len;\n\tplain->sw1 = sm->sw1;\n\tplain->sw2 = sm->sw2;\n\n\tsc_log(card->ctx,\n\t       \"STR\",\n\t       plain->resplen, plain->sw1, plain->sw2);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}","24684":"void RGWGetRequestPayment::execute()\n{\n  requester_pays = s->bucket_info.requester_pays;\n}","24425":"uint32_t riff_next_chunk(wav_reader_t *reader, uint32_t *chunk_size)\n{\n    uint32_t fcc;\n    return (pcm_scanl(&reader->io, \"STR\", &fcc, chunk_size) == 2) ? fcc : 0;\n}","23859":"read_pbm_integer(j_compress_ptr cinfo, FILE *infile, unsigned int maxval)\n\n\n\n\n{\n  register int ch;\n  register unsigned int val;\n\n  \n  do {\n    ch = pbm_getc(infile);\n    if (ch == EOF)\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n  } while (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r');\n\n  if (ch < '0' || ch > '9')\n    ERREXIT(cinfo, JERR_PPM_NONNUMERIC);\n\n  val = ch - '0';\n  while ((ch = pbm_getc(infile)) >= '0' && ch <= '9') {\n    val *= 10;\n    val += ch - '0';\n  }\n\n  if (val > maxval)\n    ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n\n  return val;\n}","24089":"static TValue *trace_exit_cp(lua_State *L, lua_CFunction dummy, void *ud)\n{\n  ExitDataCP *exd = (ExitDataCP *)ud;\n  cframe_errfunc(L->cframe) = -1;  \n  \n  cframe_nres(L->cframe) = -2*LUAI_MAXSTACK*(int)sizeof(TValue);\n  exd->pc = lj_snap_restore(exd->J, exd->exptr);\n  UNUSED(dummy);\n  return NULL;\n}","24456":"static const char *parse_scheme(struct parse_state *state)\n{\n\tsize_t mb;\n\tconst char *tmp = state->ptr;\n\n\tdo {\n\t\tswitch (*state->ptr) {\n\t\tcase ':':\n\t\t\t\n\t\t\tstate->url.scheme = &state->buffer[0];\n\t\t\tstate->buffer[state->offset++] = 0;\n\t\t\treturn ++state->ptr;\n\n\t\tcase '0': case '1': case '2': case '3': case '4': case '5': case '6':\n\t\tcase '7': case '8': case '9':\n\t\tcase '+': case '-': case '.':\n\t\t\tif (state->ptr == tmp) {\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\t\n\t\tcase 'A': case 'B': case 'C': case 'D': case 'E': case 'F': case 'G':\n\t\tcase 'H': case 'I': case 'J': case 'K': case 'L': case 'M': case 'N':\n\t\tcase 'O': case 'P': case 'Q': case 'R': case 'S': case 'T': case 'U':\n\t\tcase 'V': case 'W': case 'X': case 'Y': case 'Z':\n\t\tcase 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g':\n\t\tcase 'h': case 'i': case 'j': case 'k': case 'l': case 'm': case 'n':\n\t\tcase 'o': case 'p': case 'q': case 'r': case 's': case 't': case 'u':\n\t\tcase 'v': case 'w': case 'x': case 'y': case 'z':\n\t\t\t\n\t\t\tstate->buffer[state->offset++] = *state->ptr;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (!(mb = parse_mb(state, PARSE_SCHEME, state->ptr, state->end, tmp, 1))) {\n\t\t\t\t\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\tstate->ptr += mb - 1;\n\t\t}\n\t} while (++state->ptr != state->end);\n\n\treturn state->ptr = tmp;\n}","24046":"cmsBool Type_ViewingConditions_Write(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, void* Ptr, cmsUInt32Number nItems)\n{\n    cmsICCViewingConditions* sc = (cmsICCViewingConditions* ) Ptr;\n\n    if (!_cmsWriteXYZNumber(io, &sc ->IlluminantXYZ)) return FALSE;\n    if (!_cmsWriteXYZNumber(io, &sc ->SurroundXYZ)) return FALSE;\n    if (!_cmsWriteUInt32Number(io, sc ->IlluminantType)) return FALSE;\n\n    return TRUE;\n\n    cmsUNUSED_PARAMETER(nItems);\n    cmsUNUSED_PARAMETER(self);\n}","24368":"void __init_work(struct work_struct *work, int onstack)\n{\n\tif (onstack)\n\t\tdebug_object_init_on_stack(work, &work_debug_descr);\n\telse\n\t\tdebug_object_init(work, &work_debug_descr);\n}","23889":"static void parse_version(std::string const& full_version_string,\n                          std::string& version, int& extension_level)\n{\n    PointerHolder<char> vp(true, QUtil::copy_string(full_version_string));\n    char* v = vp.getPointer();\n    char* p1 = strchr(v, '.');\n    char* p2 = (p1 ? strchr(1 + p1, '.') : 0);\n    if (p2 && *(p2 + 1))\n    {\n        *p2++ = '\\0';\n        extension_level = atoi(p2);\n    }\n    version = v;\n}","24335":"int r_bin_pdb_download(RCore *core, int isradjson, int *actions_done, SPDBOptions *options) {\n\tint ret;\n\tSPDBDownloaderOpt opt;\n\tSPDBDownloader pdb_downloader;\n\tRBinInfo *info = r_bin_get_info (core->bin);\n\n\tif (!info || !info->debug_file_name) {\n\t\teprintf (\"STR\");\n\t\treturn 1;\n\t}\n\n\tif (!options || !options->symbol_server || !options->user_agent) {\n\t\teprintf (\"STR\");\n\t\treturn 1;\n\t}\n\n\topt.dbg_file = (char*) r_file_basename (info->debug_file_name);\n\topt.guid = info->guid;\n\topt.symbol_server = options->symbol_server;\n\topt.user_agent = options->user_agent;\n\topt.symbol_store_path = options->symbol_store_path;\n\topt.extract = options->extract;\n\n\tinit_pdb_downloader (&opt, &pdb_downloader);\n\tret = pdb_downloader.download ? pdb_downloader.download (&pdb_downloader) : 0;\n\tif (isradjson && actions_done) {\n\t\tprintf (\"STR\",\n\t\t        *actions_done ? \"STR\");\n\t} else {\n\t\tprintf (\"STR\",\n\t\t        opt.dbg_file, ret ? \"STR\");\n\t}\n\tif (actions_done) {\n\t\t(*actions_done)++;\n\t}\n\tdeinit_pdb_downloader (&pdb_downloader);\n\n\treturn 0;\n}","24616":"virDomainPerfEventDefParseXML(virDomainPerfDefPtr perf,\n                              xmlNodePtr node)\n{\n    int event;\n    g_autofree char *name = NULL;\n    g_autofree char *enabled = NULL;\n\n    if (!(name = virXMLPropString(node, \"STR\"))) {\n        virReportError(VIR_ERR_XML_ERROR, \"STR\"));\n        return -1;\n    }\n\n    if ((event = virPerfEventTypeFromString(name)) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"STR\"), name);\n        return -1;\n    }\n\n    if (perf->events[event] != VIR_TRISTATE_BOOL_ABSENT) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"STR\"), name);\n        return -1;\n    }\n\n    if (!(enabled = virXMLPropString(node, \"STR\"))) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"STR\"), name);\n        return -1;\n    }\n\n    if ((perf->events[event] = virTristateBoolTypeFromString(enabled)) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"STR\"),\n                       enabled, name);\n        return -1;\n    }\n\n    return 0;\n}","24637":"static int IntensityCompare(const void *x,const void *y)\n{\n  double\n    intensity;\n\n  PixelInfo\n    *color_1,\n    *color_2;\n\n  color_1=(PixelInfo *) x;\n  color_2=(PixelInfo *) y;\n  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-\n    GetPixelInfoIntensity((const Image *) NULL,color_2);\n  return((int) intensity);\n}","24956":"void CLASS jpeg_thumb_writer (FILE *tfp,char *t_humb,int t_humb_length)\n{\n  ushort exif[5];\n  struct tiff_hdr th;\n  fputc (0xff, tfp);\n  fputc (0xd8, tfp);\n  if (strcmp (t_humb+6, \"STR\")) {\n    memcpy (exif, \"STR\", 10);\n    exif[1] = htons (8 + sizeof th);\n    fwrite (exif, 1, sizeof exif, tfp);\n    tiff_head (&th, 0);\n    fwrite (&th, 1, sizeof th, tfp);\n  }\n  fwrite (t_humb+2, 1, t_humb_length-2, tfp);\n}","24720":"TfLiteStatus HardSwishPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_STATUS(GenericPrepare(context, node));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n\n  if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8) {\n    HardSwishData* data = static_cast<HardSwishData*>(node->user_data);\n    HardSwishParams* params = &data->params;\n    const TfLiteTensor* input;\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n    params->input_zero_point = input->params.zero_point;\n    params->output_zero_point = output->params.zero_point;\n    const float input_scale = input->params.scale;\n    const float hires_input_scale = (1.0f \/ 128.0f) * input_scale;\n    const float reluish_scale = 3.0f \/ 32768.0f;\n    const float output_scale = output->params.scale;\n\n    const float output_multiplier = hires_input_scale \/ output_scale;\n\n    int32_t output_multiplier_fixedpoint_int32;\n    QuantizeMultiplier(output_multiplier, &output_multiplier_fixedpoint_int32,\n                       &params->output_multiplier_exponent);\n    DownScaleInt32ToInt16Multiplier(\n        output_multiplier_fixedpoint_int32,\n        &params->output_multiplier_fixedpoint_int16);\n    TF_LITE_ENSURE(context, params->output_multiplier_exponent <= 0);\n\n    const float reluish_multiplier = hires_input_scale \/ reluish_scale;\n    int32_t reluish_multiplier_fixedpoint_int32;\n    QuantizeMultiplier(reluish_multiplier, &reluish_multiplier_fixedpoint_int32,\n                       &params->reluish_multiplier_exponent);\n    DownScaleInt32ToInt16Multiplier(\n        reluish_multiplier_fixedpoint_int32,\n        &params->reluish_multiplier_fixedpoint_int16);\n  }\n  return kTfLiteOk;\n}","24954":"static inline int may_ptrace_stop(void)\n{\n\tif (!likely(current->ptrace))\n\t\treturn 0;\n\t\n\tif (unlikely(current->mm->core_state) &&\n\t    unlikely(current->mm == current->parent->mm))\n\t\treturn 0;\n\n\treturn 1;\n}","24307":"static void unqueue_me_pi(struct futex_q *q)\n{\n\tWARN_ON(plist_node_empty(&q->list));\n\tplist_del(&q->list, &q->list.plist);\n\n\tBUG_ON(!q->pi_state);\n\tfree_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\n\tspin_unlock(q->lock_ptr);\n\n\tdrop_futex_key_refs(&q->key);\n}","23983":"static void add_rev_cmdline_list(struct rev_info *revs,\n\t\t\t\t struct commit_list *commit_list,\n\t\t\t\t int whence,\n\t\t\t\t unsigned flags)\n{\n\twhile (commit_list) {\n\t\tstruct object *object = &commit_list->item->object;\n\t\tadd_rev_cmdline(revs, object, oid_to_hex(&object->oid),\n\t\t\t\twhence, flags);\n\t\tcommit_list = commit_list->next;\n\t}\n}","24380":"int rds_cmsg_rdma_dest(struct rds_sock *rs, struct rds_message *rm,\n\t\t\t  struct cmsghdr *cmsg)\n{\n\tunsigned long flags;\n\tstruct rds_mr *mr;\n\tu32 r_key;\n\tint err = 0;\n\n\tif (cmsg->cmsg_len < CMSG_LEN(sizeof(rds_rdma_cookie_t)) ||\n\t    rm->m_rdma_cookie != 0)\n\t\treturn -EINVAL;\n\n\tmemcpy(&rm->m_rdma_cookie, CMSG_DATA(cmsg), sizeof(rm->m_rdma_cookie));\n\n\t\n\tr_key = rds_rdma_cookie_key(rm->m_rdma_cookie);\n\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\tmr = rds_mr_tree_walk(&rs->rs_rdma_keys, r_key, NULL);\n\tif (!mr)\n\t\terr = -EINVAL;\t\n\telse\n\t\trefcount_inc(&mr->r_refcount);\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\n\tif (mr) {\n\t\tmr->r_trans->sync_mr(mr->r_trans_private, DMA_TO_DEVICE);\n\t\trm->rdma.op_rdma_mr = mr;\n\t}\n\treturn err;\n}","24158":"int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)\n{\n\tstruct hexline *hx;\n\tu8 reset;\n\tint ret,pos=0;\n\n\thx = kmalloc(sizeof(*hx), GFP_KERNEL);\n\tif (!hx)\n\t\treturn -ENOMEM;\n\n\t\n\treset = 1;\n\tif ((ret = usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1)) != 1)\n\t\terr(\"STR\");\n\n\twhile ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {\n\t\tdeb_fw(\"STR\", hx->addr, hx->len, hx->chk);\n\t\tret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);\n\n\t\tif (ret != hx->len) {\n\t\t\terr(\"STR\",\n\t\t\t\tret, hx->len);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret < 0) {\n\t\terr(\"STR\",pos,ret);\n\t\tkfree(hx);\n\t\treturn ret;\n\t}\n\n\tif (ret == 0) {\n\t\t\n\t\treset = 0;\n\t\tif (ret || usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1) != 1) {\n\t\t\terr(\"STR\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else\n\t\tret = -EIO;\n\n\tkfree(hx);\n\n\treturn ret;\n}","23876":"static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"STR\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"STR\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}","24379":"int esp_output_head(struct xfrm_state *x, struct sk_buff *skb, struct esp_info *esp)\n{\n\tu8 *tail;\n\tint nfrags;\n\tint esph_offset;\n\tstruct page *page;\n\tstruct sk_buff *trailer;\n\tint tailen = esp->tailen;\n\n\t\n\tif (x->encap) {\n\t\tint err = esp_output_encap(x, skb, esp);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (!skb_cloned(skb)) {\n\t\tif (tailen <= skb_tailroom(skb)) {\n\t\t\tnfrags = 1;\n\t\t\ttrailer = skb;\n\t\t\ttail = skb_tail_pointer(trailer);\n\n\t\t\tgoto skip_cow;\n\t\t} else if ((skb_shinfo(skb)->nr_frags < MAX_SKB_FRAGS)\n\t\t\t   && !skb_has_frag_list(skb)) {\n\t\t\tint allocsize;\n\t\t\tstruct sock *sk = skb->sk;\n\t\t\tstruct page_frag *pfrag = &x->xfrag;\n\n\t\t\tesp->inplace = false;\n\n\t\t\tallocsize = ALIGN(tailen, L1_CACHE_BYTES);\n\n\t\t\tspin_lock_bh(&x->lock);\n\n\t\t\tif (unlikely(!skb_page_frag_refill(allocsize, pfrag, GFP_ATOMIC))) {\n\t\t\t\tspin_unlock_bh(&x->lock);\n\t\t\t\tgoto cow;\n\t\t\t}\n\n\t\t\tpage = pfrag->page;\n\t\t\tget_page(page);\n\n\t\t\ttail = page_address(page) + pfrag->offset;\n\n\t\t\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\n\t\t\tnfrags = skb_shinfo(skb)->nr_frags;\n\n\t\t\t__skb_fill_page_desc(skb, nfrags, page, pfrag->offset,\n\t\t\t\t\t     tailen);\n\t\t\tskb_shinfo(skb)->nr_frags = ++nfrags;\n\n\t\t\tpfrag->offset = pfrag->offset + allocsize;\n\n\t\t\tspin_unlock_bh(&x->lock);\n\n\t\t\tnfrags++;\n\n\t\t\tskb->len += tailen;\n\t\t\tskb->data_len += tailen;\n\t\t\tskb->truesize += tailen;\n\t\t\tif (sk && sk_fullsock(sk))\n\t\t\t\trefcount_add(tailen, &sk->sk_wmem_alloc);\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\ncow:\n\tesph_offset = (unsigned char *)esp->esph - skb_transport_header(skb);\n\n\tnfrags = skb_cow_data(skb, tailen, &trailer);\n\tif (nfrags < 0)\n\t\tgoto out;\n\ttail = skb_tail_pointer(trailer);\n\tesp->esph = (struct ip_esp_hdr *)(skb_transport_header(skb) + esph_offset);\n\nskip_cow:\n\tesp_output_fill_trailer(tail, esp->tfclen, esp->plen, esp->proto);\n\tpskb_put(skb, trailer, tailen);\n\nout:\n\treturn nfrags;\n}","24869":"static void __xen_evtchn_do_upcall(void)\n{\n\tstruct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);\n\tint cpu = smp_processor_id();\n\n\tdo {\n\t\tvcpu_info->evtchn_upcall_pending = 0;\n\n\t\txen_evtchn_handle_events(cpu);\n\n\t\tBUG_ON(!irqs_disabled());\n\n\t\tvirt_rmb(); \n\n\t} while (vcpu_info->evtchn_upcall_pending);\n}","24128":"void ext4_ext_store_pblock(struct ext4_extent *ex, ext4_fsblk_t pb)\n{\n\tex->ee_start_lo = cpu_to_le32((unsigned long) (pb & 0xffffffff));\n\tex->ee_start_hi = cpu_to_le16((unsigned long) ((pb >> 31) >> 1) & 0xffff);\n}","24285":"int selinux_audit_rule_match(u32 sid, u32 field, u32 op, void *vrule,\n\t\t\t     struct audit_context *actx)\n{\n\tstruct context *ctxt;\n\tstruct mls_level *level;\n\tstruct selinux_audit_rule *rule = vrule;\n\tint match = 0;\n\n\tif (!rule) {\n\t\taudit_log(actx, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t\t  \"STR\");\n\t\treturn -ENOENT;\n\t}\n\n\tread_lock(&policy_rwlock);\n\n\tif (rule->au_seqno < latest_granting) {\n\t\taudit_log(actx, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t\t  \"STR\");\n\t\tmatch = -ESTALE;\n\t\tgoto out;\n\t}\n\n\tctxt = sidtab_search(&sidtab, sid);\n\tif (!ctxt) {\n\t\taudit_log(actx, GFP_ATOMIC, AUDIT_SELINUX_ERR,\n\t\t\t  \"STR\",\n\t\t\t  sid);\n\t\tmatch = -ENOENT;\n\t\tgoto out;\n\t}\n\n\t\n\tswitch (field) {\n\tcase AUDIT_SUBJ_USER:\n\tcase AUDIT_OBJ_USER:\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = (ctxt->user == rule->au_ctxt.user);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = (ctxt->user != rule->au_ctxt.user);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AUDIT_SUBJ_ROLE:\n\tcase AUDIT_OBJ_ROLE:\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = (ctxt->role == rule->au_ctxt.role);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = (ctxt->role != rule->au_ctxt.role);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AUDIT_SUBJ_TYPE:\n\tcase AUDIT_OBJ_TYPE:\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = (ctxt->type == rule->au_ctxt.type);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = (ctxt->type != rule->au_ctxt.type);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase AUDIT_SUBJ_SEN:\n\tcase AUDIT_SUBJ_CLR:\n\tcase AUDIT_OBJ_LEV_LOW:\n\tcase AUDIT_OBJ_LEV_HIGH:\n\t\tlevel = ((field == AUDIT_SUBJ_SEN ||\n\t\t\t  field == AUDIT_OBJ_LEV_LOW) ?\n\t\t\t &ctxt->range.level[0] : &ctxt->range.level[1]);\n\t\tswitch (op) {\n\t\tcase Audit_equal:\n\t\t\tmatch = mls_level_eq(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t     level);\n\t\t\tbreak;\n\t\tcase Audit_not_equal:\n\t\t\tmatch = !mls_level_eq(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t      level);\n\t\t\tbreak;\n\t\tcase Audit_lt:\n\t\t\tmatch = (mls_level_dom(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t       level) &&\n\t\t\t\t !mls_level_eq(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t       level));\n\t\t\tbreak;\n\t\tcase Audit_le:\n\t\t\tmatch = mls_level_dom(&rule->au_ctxt.range.level[0],\n\t\t\t\t\t      level);\n\t\t\tbreak;\n\t\tcase Audit_gt:\n\t\t\tmatch = (mls_level_dom(level,\n\t\t\t\t\t      &rule->au_ctxt.range.level[0]) &&\n\t\t\t\t !mls_level_eq(level,\n\t\t\t\t\t       &rule->au_ctxt.range.level[0]));\n\t\t\tbreak;\n\t\tcase Audit_ge:\n\t\t\tmatch = mls_level_dom(level,\n\t\t\t\t\t      &rule->au_ctxt.range.level[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn match;\n}","24473":"int wc_SetSubject(Cert* cert, const char* subjectFile)\n{\n    int         ret;\n    int         derSz;\n    byte*       der;\n\n    if (cert == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    der = (byte*)XMALLOC(EIGHTK_BUF, cert->heap, DYNAMIC_TYPE_CERT);\n    if (der == NULL) {\n        WOLFSSL_MSG(\"STR\");\n        return MEMORY_E;\n    }\n\n    derSz = wc_PemCertToDer(subjectFile, der, EIGHTK_BUF);\n    ret = SetNameFromCert(&cert->subject, der, derSz);\n    XFREE(der, cert->heap, DYNAMIC_TYPE_CERT);\n\n    return ret;\n}","24186":"bool_t xdr_nullstring(XDR *xdrs, char **objp)\n{\n     u_int size;\n\n     if (xdrs->x_op == XDR_ENCODE) {\n\t  if (*objp == NULL)\n\t       size = 0;\n\t  else\n\t       size = strlen(*objp) + 1;\n     }\n     if (! xdr_u_int(xdrs, &size)) {\n\t  return FALSE;\n\t}\n     switch (xdrs->x_op) {\n     case XDR_DECODE:\n\t  if (size == 0) {\n\t       *objp = NULL;\n\t       return TRUE;\n\t  } else if (*objp == NULL) {\n\t       *objp = (char *) mem_alloc(size);\n\t       if (*objp == NULL) {\n\t\t    errno = ENOMEM;\n\t\t    return FALSE;\n\t       }\n\t  }\n\t  return (xdr_opaque(xdrs, *objp, size));\n\n     case XDR_ENCODE:\n\t  if (size != 0)\n\t       return (xdr_opaque(xdrs, *objp, size));\n\t  return TRUE;\n\n     case XDR_FREE:\n\t  if (*objp != NULL)\n\t       mem_free(*objp, size);\n\t  *objp = NULL;\n\t  return TRUE;\n     }\n\n     return FALSE;\n}","24344":"static void enable_no_ext_master_secret(gnutls_priority_t c)\n{\n\tc->no_ext_master_secret = 1;\n}","24734":"dist_pl(PG_FUNCTION_ARGS)\n{\n\tPoint\t   *pt = PG_GETARG_POINT_P(0);\n\tLINE\t   *line = PG_GETARG_LINE_P(1);\n\n\tPG_RETURN_FLOAT8(dist_pl_internal(pt, line));\n}","24269":"S3BootScriptSaveSmbusExecute (\r\n  IN  UINTN                             SmBusAddress,\r\n  IN  EFI_SMBUS_OPERATION               Operation,\r\n  IN  UINTN                             *Length,\r\n  IN  VOID                              *Buffer\r\n  )\r\n{\r\n  EFI_STATUS            Status;\r\n  UINTN                 BufferLength;\r\n  UINT8                 DataSize;\r\n  UINT8                *Script;\r\n  EFI_BOOT_SCRIPT_SMBUS_EXECUTE  ScriptSmbusExecute;\r\n\r\n  if (Length == NULL) {\r\n    BufferLength = 0;\r\n  } else {\r\n    BufferLength = *Length;\r\n  }\r\n\r\n  Status = CheckParameters (SmBusAddress, Operation, &BufferLength, Buffer);\r\n  if (EFI_ERROR (Status)) {\r\n    return Status;\r\n  }\r\n\r\n  DataSize = (UINT8)(sizeof (EFI_BOOT_SCRIPT_SMBUS_EXECUTE) + BufferLength);\r\n\r\n  Script = S3BootScriptGetEntryAddAddress (DataSize);\r\n  if (Script == NULL) {\r\n    return RETURN_OUT_OF_RESOURCES;\r\n  }\r\n  \n  \n  \n  ScriptSmbusExecute.OpCode       = EFI_BOOT_SCRIPT_SMBUS_EXECUTE_OPCODE;\r\n  ScriptSmbusExecute.Length       = DataSize;\r\n  ScriptSmbusExecute.SmBusAddress = (UINT64) SmBusAddress;\r\n  ScriptSmbusExecute.Operation    = Operation;\r\n  ScriptSmbusExecute.DataSize     = (UINT32) BufferLength;\r\n\r\n  CopyMem ((VOID*)Script, (VOID*)&ScriptSmbusExecute, sizeof (EFI_BOOT_SCRIPT_SMBUS_EXECUTE));\r\n  CopyMem (\r\n    (VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_SMBUS_EXECUTE)),\r\n    Buffer,\r\n    BufferLength\r\n    );\r\n\r\n  SyncBootScript (Script);\r\n\r\n  return RETURN_SUCCESS;\r\n}\r","24167":"      static double mp_image_display(_cimg_math_parser& mp) {\n        mp_check_list(mp,\"STR\");\n        const unsigned int ind = (unsigned int)cimg::mod((int)_mp_arg(2),mp.imglist.width());\n        cimg::mutex(6);\n        CImg<T> &img = mp.imglist[ind];\n        CImg<charT> title(256);\n        std::fputc('\\n',cimg::output());\n        cimg_snprintf(title,title._width,\"STR\",ind);\n        img.display(title);\n        cimg::mutex(6,0);\n        return cimg::type<double>::nan();\n      }","24946":"void _pam_log(int err, const char *format, ...) {\n    char msg[256];\n    va_list args;\n\n    va_start(args, format);\n    vsnprintf(msg, sizeof(msg), format, args);\n    syslog(err, \"STR\", msg);\n    va_end(args);\n}","24321":"mc_clear_all(mrb_state *mrb)\n{\n  struct mrb_cache_entry *mc = mrb->cache;\n  int i;\n\n  for (i=0; i<MRB_METHOD_CACHE_SIZE; i++) {\n    mc[i].c = 0;\n  }\n}","23890":"TEE_Result tee_svc_copy_from_user(void *kaddr, const void *uaddr, size_t len)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *s;\n\n\tres = tee_ta_get_current_session(&s);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(s->ctx),\n\t\t\t\t\tTEE_MEMORY_ACCESS_READ |\n\t\t\t\t\tTEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t(uaddr_t)uaddr, len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tmemcpy(kaddr, uaddr, len);\n\treturn TEE_SUCCESS;\n}","24444":"static inline void eventpoll_init_file(struct file *file) {}","23952":"String *Item_param::PValue::val_str(String *str,\n                                    const Type_std_attributes *attr)\n{\n  switch (type_handler()->cmp_type()) {\n  case STRING_RESULT:\n    return &m_string_ptr;\n  case REAL_RESULT:\n    str->set_real(real, NOT_FIXED_DEC, &my_charset_bin);\n    return str;\n  case INT_RESULT:\n    str->set_int(integer, attr->unsigned_flag, &my_charset_bin);\n    return str;\n  case DECIMAL_RESULT:\n    if (my_decimal2string(E_DEC_FATAL_ERROR, &m_decimal, 0, 0, 0, str) <= 1)\n      return str;\n    return NULL;\n  case TIME_RESULT:\n  {\n    if (str->reserve(MAX_DATE_STRING_REP_LENGTH))\n      return NULL;\n    str->length((uint) my_TIME_to_str(&time, (char*) str->ptr(),\n                attr->decimals));\n    str->set_charset(&my_charset_bin);\n    return str;\n  }\n  case ROW_RESULT:\n    DBUG_ASSERT(0);\n    break;\n  }\n  return NULL;\n}","24356":"static int jas_iccprof_gettagtab(jas_stream_t *in, jas_icctagtab_t *tagtab)\n{\n\tint i;\n\tjas_icctagtabent_t *tagtabent;\n\n\tif (tagtab->ents) {\n\t\tjas_free(tagtab->ents);\n\t\ttagtab->ents = 0;\n\t}\n\tif (jas_iccgetuint32(in, &tagtab->numents))\n\t\tgoto error;\n\tif (!(tagtab->ents = jas_malloc(tagtab->numents *\n\t  sizeof(jas_icctagtabent_t))))\n\t\tgoto error;\n\ttagtabent = tagtab->ents;\n\tfor (i = 0; i < JAS_CAST(long, tagtab->numents); ++i) {\n\t\tif (jas_iccgetuint32(in, &tagtabent->tag) ||\n\t\tjas_iccgetuint32(in, &tagtabent->off) ||\n\t\tjas_iccgetuint32(in, &tagtabent->len))\n\t\t\tgoto error;\n\t\t++tagtabent;\n\t}\n\treturn 0;\nerror:\n\tif (tagtab->ents) {\n\t\tjas_free(tagtab->ents);\n\t\ttagtab->ents = 0;\n\t}\n\treturn -1;\n}","24632":"GF_Err sbgp_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_SampleGroupBox *ptr = (GF_SampleGroupBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 8);\n\tptr->grouping_type = gf_bs_read_u32(bs);\n\n\tif (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->grouping_type_parameter = gf_bs_read_u32(bs);\n\t}\n\tptr->entry_count = gf_bs_read_u32(bs);\n\n\tif (ptr->size < sizeof(GF_SampleGroupEntry)*ptr->entry_count || (u64)ptr->entry_count > (u64)SIZE_MAX\/sizeof(GF_SampleGroupEntry))\n\t    return GF_ISOM_INVALID_FILE;\n\n\tptr->sample_entries = gf_malloc(sizeof(GF_SampleGroupEntry)*ptr->entry_count);\n\tif (!ptr->sample_entries) return GF_OUT_OF_MEM;\n\n\tfor (i=0; i<ptr->entry_count; i++) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->sample_entries[i].sample_count = gf_bs_read_u32(bs);\n\t\tptr->sample_entries[i].group_description_index = gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}","24039":"static int lockState(const char *stateFilename, int skip_state_lock)\n{\n    int lockFd;\n\n    if (!strcmp(stateFilename, \"STR\")) {\n        return 0;\n    }\n\n    lockFd = open(stateFilename, O_RDWR | O_CLOEXEC);\n    if (lockFd == -1) {\n        if (errno == ENOENT) {\n            message(MESS_DEBUG, \"STR\",\n                    stateFilename);\n\n            \n            lockFd = open(stateFilename, O_CREAT | O_EXCL | O_WRONLY,\n                          S_IWUSR | S_IRUSR | S_IRGRP | S_IROTH);\n            if (lockFd == -1) {\n                message(MESS_ERROR, \"STR\",\n                        stateFilename, strerror(errno));\n                return 1;\n            }\n        } else {\n            message(MESS_ERROR, \"STR\",\n                    stateFilename, strerror(errno));\n            return 1;\n        }\n    }\n\n    if (skip_state_lock) {\n        message(MESS_DEBUG, \"STR\",\n                stateFilename);\n        close(lockFd);\n        return 0;\n    }\n\n    if (flock(lockFd, LOCK_EX | LOCK_NB) == -1) {\n        if (errno == EWOULDBLOCK) {\n            message(MESS_ERROR, \"STR\"\n                    \"STR\"\n                    \"STR\", stateFilename);\n        } else {\n            message(MESS_ERROR, \"STR\",\n                    stateFilename, strerror(errno));\n        }\n        close(lockFd);\n        return 1;\n    }\n\n    \n    return 0;\n}","24495":"static int ctrl_fill_mcgrp_info(struct genl_family *family,\n\t\t\t\tconst struct genl_multicast_group *grp,\n\t\t\t\tint grp_id, u32 portid, u32 seq, u32 flags,\n\t\t\t\tstruct sk_buff *skb, u8 cmd)\n{\n\tvoid *hdr;\n\tstruct nlattr *nla_grps;\n\tstruct nlattr *nest;\n\n\thdr = genlmsg_put(skb, portid, seq, &genl_ctrl, flags, cmd);\n\tif (hdr == NULL)\n\t\treturn -1;\n\n\tif (nla_put_string(skb, CTRL_ATTR_FAMILY_NAME, family->name) ||\n\t    nla_put_u16(skb, CTRL_ATTR_FAMILY_ID, family->id))\n\t\tgoto nla_put_failure;\n\n\tnla_grps = nla_nest_start(skb, CTRL_ATTR_MCAST_GROUPS);\n\tif (nla_grps == NULL)\n\t\tgoto nla_put_failure;\n\n\tnest = nla_nest_start(skb, 1);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(skb, CTRL_ATTR_MCAST_GRP_ID, grp_id) ||\n\t    nla_put_string(skb, CTRL_ATTR_MCAST_GRP_NAME,\n\t\t\t   grp->name))\n\t\tgoto nla_put_failure;\n\n\tnla_nest_end(skb, nest);\n\tnla_nest_end(skb, nla_grps);\n\n\treturn genlmsg_end(skb, hdr);\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}","24620":"compute_Perms_value_V5_clear(std::string const& encryption_key,\n                             QPDF::EncryptionData const& data,\n                             unsigned char k[16])\n{\n    \n    unsigned long long extended_perms =\n        0xffffffff00000000LL | static_cast<unsigned long long>(data.getP());\n    for (int i = 0; i < 8; ++i)\n    {\n        k[i] = static_cast<unsigned char>(extended_perms & 0xff);\n        extended_perms >>= 8;\n    }\n    k[8] = data.getEncryptMetadata() ? 'T' : 'F';\n    k[9] = 'a';\n    k[10] = 'd';\n    k[11] = 'b';\n    QUtil::initializeWithRandomBytes(k + 12, 4);\n}","24042":"static inline int ext4_ext_space_block_idx(struct inode *inode, int check)\n{\n\tint size;\n\n\tsize = (inode->i_sb->s_blocksize - sizeof(struct ext4_extent_header))\n\t\t\t\/ sizeof(struct ext4_extent_idx);\n\tif (!check) {\n#ifdef AGGRESSIVE_TEST\n\t\tif (size > 5)\n\t\t\tsize = 5;\n#endif\n\t}\n\treturn size;\n}","24576":"make_weights (PixopsFilter     *filter,\n\t      PixopsInterpType  interp_type,\t      \n\t      double            scale_x,\n\t      double            scale_y)\n{\n  switch (interp_type)\n    {\n    case PIXOPS_INTERP_NEAREST:\n      g_assert_not_reached ();\n      break;\n\n    case PIXOPS_INTERP_TILES:\n      tile_make_weights (&filter->x, scale_x);\n      tile_make_weights (&filter->y, scale_y);\n      break;\n      \n    case PIXOPS_INTERP_BILINEAR:\n      bilinear_magnify_make_weights (&filter->x, scale_x);\n      bilinear_magnify_make_weights (&filter->y, scale_y);\n      break;\n      \n    case PIXOPS_INTERP_HYPER:\n      bilinear_box_make_weights (&filter->x, scale_x);\n      bilinear_box_make_weights (&filter->y, scale_y);\n      break;\n    }\n}","23974":"_outRangeTblRef(StringInfo str, const RangeTblRef *node)\n{\n\tWRITE_NODE_TYPE(\"STR\");\n\n\tWRITE_INT_FIELD(rtindex);\n}","24436":"static void php_imagepolygon(INTERNAL_FUNCTION_PARAMETERS, int filled)\n{\n\tzval *IM, *POINTS;\n\tlong NPOINTS, COL;\n\tzval **var = NULL;\n\tgdImagePtr im;\n\tgdPointPtr points;\n\tint npoints, col, nelem, i;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"STR\", &IM, &POINTS, &NPOINTS, &COL) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"STR\", le_gd);\n\n\tnpoints = NPOINTS;\n\tcol = COL;\n\n\tnelem = zend_hash_num_elements(Z_ARRVAL_P(POINTS));\n\tif (nelem < 6) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"STR\");\n\t\tRETURN_FALSE;\n\t}\n\tif (npoints <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"STR\");\n\t\tRETURN_FALSE;\n\t}\n\tif (nelem < npoints * 2) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"STR\", npoints, nelem\/2);\n\t\tRETURN_FALSE;\n\t}\n\n\tpoints = (gdPointPtr) safe_emalloc(npoints, sizeof(gdPoint), 0);\n\n\tfor (i = 0; i < npoints; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {\n\t\t\tSEPARATE_ZVAL((var));\n\t\t\tconvert_to_long(*var);\n\t\t\tpoints[i].x = Z_LVAL_PP(var);\n\t\t}\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {\n\t\t\tSEPARATE_ZVAL(var);\n\t\t\tconvert_to_long(*var);\n\t\t\tpoints[i].y = Z_LVAL_PP(var);\n\t\t}\n\t}\n\n\tif (filled) {\n\t\tgdImageFilledPolygon(im, points, npoints, col);\n\t} else {\n\t\tgdImagePolygon(im, points, npoints, col);\n\t}\n\n\tefree(points);\n\tRETURN_TRUE;\n}","24901":"data_accept(databuf_t *data, ftpbuf_t *ftp TSRMLS_DC)\n{\n\tphp_sockaddr_storage addr;\n\tsocklen_t\t\t\tsize;\n\n#if HAVE_OPENSSL_EXT\n\tSSL_CTX\t\t*ctx;\n\tlong ssl_ctx_options = SSL_OP_ALL;\n#endif\n\n\tif (data->fd != -1) {\n\t\tgoto data_accepted;\n\t}\n\tsize = sizeof(addr);\n\tdata->fd = my_accept(ftp, data->listener, (struct sockaddr*) &addr, &size);\n\tclosesocket(data->listener);\n\tdata->listener = -1;\n\n\tif (data->fd == -1) {\n\t\tefree(data);\n\t\treturn NULL;\n\t}\n\ndata_accepted:\n#if HAVE_OPENSSL_EXT\n\t\n\t\n\tif (ftp->use_ssl && ftp->use_ssl_for_data) {\n\t\tctx = SSL_CTX_new(SSLv23_client_method());\n\t\tif (ctx == NULL) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"STR\");\n\t\t\treturn 0;\n\t\t}\n\n#if OPENSSL_VERSION_NUMBER >= 0x0090605fL\n\t\tssl_ctx_options &= ~SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;\n#endif\n\t\tSSL_CTX_set_options(ctx, ssl_ctx_options);\n\n\t\tdata->ssl_handle = SSL_new(ctx);\n\t\tif (data->ssl_handle == NULL) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"STR\");\n\t\t\tSSL_CTX_free(ctx);\n\t\t\treturn 0;\n\t\t}\n\t\t\t\n\t\t\n\t\tSSL_set_fd(data->ssl_handle, data->fd);\n\n\t\tif (ftp->old_ssl) {\n\t\t\tSSL_copy_session_id(data->ssl_handle, ftp->ssl_handle);\n\t\t}\n\t\t\t\n\t\tif (SSL_connect(data->ssl_handle) <= 0) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"STR\");\n\t\t\tSSL_shutdown(data->ssl_handle);\n\t\t\tSSL_free(data->ssl_handle);\n\t\t\treturn 0;\n\t\t}\n\t\t\t\n\t\tdata->ssl_active = 1;\n\t}\t\n\n#endif\n\n\treturn data;\n}","24040":"dns_cache_store(struct module_env* env, struct query_info* msgqinf,\n        struct reply_info* msgrep, int is_referral, time_t leeway, int pside,\n\tstruct regional* region, uint32_t flags)\n{\n\tstruct reply_info* rep = NULL;\n\t\n\trep = reply_info_copy(msgrep, env->alloc, NULL);\n\tif(!rep)\n\t\treturn 0;\n\t\n\t\n\n\tif(is_referral) {\n\t\t\n\t\tstruct rrset_ref ref;\n\t\tsize_t i;\n\t\tfor(i=0; i<rep->rrset_count; i++) {\n\t\t\tpacked_rrset_ttl_add((struct packed_rrset_data*)\n\t\t\t\trep->rrsets[i]->entry.data, *env->now);\n\t\t\tref.key = rep->rrsets[i];\n\t\t\tref.id = rep->rrsets[i]->id;\n\t\t\t\n\t\t\t\n\t\t\t(void)rrset_cache_update(env->rrset_cache, &ref, \n\t\t\t\tenv->alloc, *env->now + \n\t\t\t\t((ntohs(ref.key->rk.type)==LDNS_RR_TYPE_NS\n\t\t\t\t && !pside) ? 0:leeway));\n\t\t}\n\t\tfree(rep);\n\t\treturn 1;\n\t} else {\n\t\t\n\t\tstruct query_info qinf;\n\t\thashvalue_type h;\n\n\t\tqinf = *msgqinf;\n\t\tqinf.qname = memdup(msgqinf->qname, msgqinf->qname_len);\n\t\tif(!qinf.qname) {\n\t\t\treply_info_parsedelete(rep, env->alloc);\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t\n\t\trep->flags |= (BIT_RA | BIT_QR);\n\t\trep->flags &= ~(BIT_AA | BIT_CD);\n\t\th = query_info_hash(&qinf, (uint16_t)flags);\n\t\tdns_cache_store_msg(env, &qinf, h, rep, leeway, pside, msgrep,\n\t\t\tflags, region);\n\t\t\n\t\tfree(qinf.qname);\n\t}\n\treturn 1;\n}","23969":"int options_cmdline(char *arg1, char *arg2) {\n    char *name;\n    CONF_TYPE type;\n\n#ifdef USE_WIN32\n    (void)arg2; \n#endif\n    if(!arg1) {\n        name=\n#ifdef CONFDIR\n            CONFDIR\n#ifdef USE_WIN32\n            \"STR\"\n#else\n            \"STR\"\n#endif\n#endif\n            \"STR\";\n        type=CONF_FILE;\n    } else if(!strcasecmp(arg1, \"STR\")) {\n        parse_global_option(CMD_PRINT_HELP, NULL, NULL);\n        parse_service_option(CMD_PRINT_HELP, NULL, NULL, NULL);\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else if(!strcasecmp(arg1, \"STR\")) {\n        parse_global_option(CMD_PRINT_DEFAULTS, NULL, NULL);\n        parse_service_option(CMD_PRINT_DEFAULTS, NULL, NULL, NULL);\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else if(!strcasecmp(arg1, \"STR\")) {\n        socket_options_print();\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else if(!strcasecmp(arg1, \"STR\")) {\n        print_ssl_options();\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else\n#ifndef USE_WIN32\n    if(!strcasecmp(arg1, \"STR\")) {\n        if(!arg2) {\n            s_log(LOG_ERR, \"STR\");\n            print_syntax();\n            return 1;\n        }\n        name=arg2;\n        type=CONF_FD;\n    } else\n#endif\n    {\n        name=arg1;\n        type=CONF_FILE;\n    }\n\n    if(type==CONF_FILE) {\n#ifdef HAVE_REALPATH\n        char *real_path=NULL;\n#ifdef MAXPATHLEN\n        \n        real_path=malloc(MAXPATHLEN);\n#endif\n        real_path=realpath(name, real_path);\n        if(!real_path) {\n            s_log(LOG_ERR, \"STR\", name);\n            ioerror(\"STR\");\n            return 1;\n        }\n        configuration_file=str_dup(real_path);\n        free(real_path);\n#else\n        configuration_file=str_dup(name);\n#endif\n#ifndef USE_WIN32\n    } else if(type==CONF_FD) {\n        configuration_file=str_dup(name);\n#endif\n    }\n    return options_parse(type);\n}","24848":"int jas_stream_printf(jas_stream_t *stream, const char *fmt, ...)\n{\n\tva_list ap;\n\tchar buf[4096];\n\tint ret;\n\n\tva_start(ap, fmt);\n\tret = vsprintf(buf, fmt, ap);\n\tjas_stream_puts(stream, buf);\n\tva_end(ap);\n\treturn ret;\n}","25011":"static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask)\n\t\treturn -1;\n\n\tioapic_debug(\"STR\"\n\t\t     \"STR\",\n\t\t     entry->fields.dest_id, entry->fields.dest_mode,\n\t\t     entry->fields.delivery_mode, entry->fields.vector,\n\t\t     entry->fields.trig_mode);\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = entry->fields.dest_mode;\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = 0;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr &= ~(1 << irq);\n\n\tif (irq == RTC_GSI && line_status) {\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\tioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = ret;\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}","24328":"static void tcp_connect_init(struct sock *sk)\n{\n\tconst struct dst_entry *dst = __sk_dst_get(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\t__u8 rcv_wscale;\n\tu32 rcv_wnd;\n\n\t\n\ttp->tcp_header_len = sizeof(struct tcphdr);\n\tif (sock_net(sk)->ipv4.sysctl_tcp_timestamps)\n\t\ttp->tcp_header_len += TCPOLEN_TSTAMP_ALIGNED;\n\n#ifdef CONFIG_TCP_MD5SIG\n\tif (tp->af_specific->md5_lookup(sk, sk))\n\t\ttp->tcp_header_len += TCPOLEN_MD5SIG_ALIGNED;\n#endif\n\n\t\n\tif (tp->rx_opt.user_mss)\n\t\ttp->rx_opt.mss_clamp = tp->rx_opt.user_mss;\n\ttp->max_window = 0;\n\ttcp_mtup_init(sk);\n\ttcp_sync_mss(sk, dst_mtu(dst));\n\n\ttcp_ca_dst_init(sk, dst);\n\n\tif (!tp->window_clamp)\n\t\ttp->window_clamp = dst_metric(dst, RTAX_WINDOW);\n\ttp->advmss = tcp_mss_clamp(tp, dst_metric_advmss(dst));\n\n\ttcp_initialize_rcv_mss(sk);\n\n\t\n\tif (sk->sk_userlocks & SOCK_RCVBUF_LOCK &&\n\t    (tp->window_clamp > tcp_full_space(sk) || tp->window_clamp == 0))\n\t\ttp->window_clamp = tcp_full_space(sk);\n\n\trcv_wnd = tcp_rwnd_init_bpf(sk);\n\tif (rcv_wnd == 0)\n\t\trcv_wnd = dst_metric(dst, RTAX_INITRWND);\n\n\ttcp_select_initial_window(sk, tcp_full_space(sk),\n\t\t\t\t  tp->advmss - (tp->rx_opt.ts_recent_stamp ? tp->tcp_header_len - sizeof(struct tcphdr) : 0),\n\t\t\t\t  &tp->rcv_wnd,\n\t\t\t\t  &tp->window_clamp,\n\t\t\t\t  sock_net(sk)->ipv4.sysctl_tcp_window_scaling,\n\t\t\t\t  &rcv_wscale,\n\t\t\t\t  rcv_wnd);\n\n\ttp->rx_opt.rcv_wscale = rcv_wscale;\n\ttp->rcv_ssthresh = tp->rcv_wnd;\n\n\tsk->sk_err = 0;\n\tsock_reset_flag(sk, SOCK_DONE);\n\ttp->snd_wnd = 0;\n\ttcp_init_wl(tp, 0);\n\ttp->snd_una = tp->write_seq;\n\ttp->snd_sml = tp->write_seq;\n\ttp->snd_up = tp->write_seq;\n\ttp->snd_nxt = tp->write_seq;\n\n\tif (likely(!tp->repair))\n\t\ttp->rcv_nxt = 0;\n\telse\n\t\ttp->rcv_tstamp = tcp_jiffies32;\n\ttp->rcv_wup = tp->rcv_nxt;\n\ttp->copied_seq = tp->rcv_nxt;\n\n\tinet_csk(sk)->icsk_rto = tcp_timeout_init(sk);\n\tinet_csk(sk)->icsk_retransmits = 0;\n\ttcp_clear_retrans(tp);\n}","23998":"static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n\n    \n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n\n    \n    if (strcmp(key, \"STR\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!is_correct_filename(value))\n        {\n            error_msg(\"STR\",\n                      key, value);\n            return FALSE;\n        }\n    }\n\n    return TRUE;\n}","24049":"MagickExport Quantum *QueueAuthenticPixels(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  Quantum\n    *magick_restrict pixels;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->methods.queue_authentic_pixels_handler !=\n      (QueueAuthenticPixelsHandler) NULL)\n    {\n      pixels=cache_info->methods.queue_authentic_pixels_handler(image,x,y,\n        columns,rows,exception);\n      return(pixels);\n    }\n  assert(id < (int) cache_info->number_threads);\n  pixels=QueueAuthenticPixelCacheNexus(image,x,y,columns,rows,MagickFalse,\n    cache_info->nexus_info[id],exception);\n  return(pixels);\n}","24015":"static void autocomplete_zignatures(RCore *core, RLineCompletion *completion, const char* msg) {\n\tr_return_if_fail (msg);\n\tint length = strlen (msg);\n\tRSpaces *zs = &core->anal->zign_spaces;\n\tRSpace *s;\n\tRSpaceIter it;\n\n\tr_spaces_foreach (zs, it, s) {\n\t\tif (!strncmp (msg, s->name, length)) {\n\t\t\tr_line_completion_push (completion, s->name);\n\t\t}\n\t}\n\n\tif (strlen (msg) == 0) {\n\t\tr_line_completion_push (completion, \"STR\");\n\t}\n}","24199":"static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\n\tBUG_ON(!vcpu->mmio_needed);\n\n\t\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\n\tif (frag->len <= 8) {\n\t\t\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\t\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\n\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\n\t\t\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}","24862":"zmq::curve_server_t::curve_server_t (session_base_t *session_,\n                                     const std::string &peer_address_,\n                                     const options_t &options_) :\n    mechanism_t (options_),\n    session (session_),\n    peer_address (peer_address_),\n    state (expect_hello),\n    cn_nonce (1),\n    sync()\n{\n    \n    memcpy (secret_key, options_.curve_secret_key, crypto_box_SECRETKEYBYTES);\n    scoped_lock_t lock (sync);\n#if defined(HAVE_TWEETNACL)\n    \n    unsigned char tmpbytes[4];\n    randombytes(tmpbytes, 4);\n#else\n    \n    sodium_init();\n#endif\n\n    \n    const int rc = crypto_box_keypair (cn_public, cn_secret);\n    zmq_assert (rc == 0);\n}","24342":"static void hid_process_event(struct hid_device *hid, struct hid_field *field,\n\t\tstruct hid_usage *usage, __s32 value, int interrupt)\n{\n\tstruct hid_driver *hdrv = hid->driver;\n\tint ret;\n\n\tif (!list_empty(&hid->debug_list))\n\t\thid_dump_input(hid, usage, value);\n\n\tif (hdrv && hdrv->event && hid_match_usage(hid, usage)) {\n\t\tret = hdrv->event(hid, field, usage, value);\n\t\tif (ret != 0) {\n\t\t\tif (ret < 0)\n\t\t\t\thid_err(hid, \"STR\",\n\t\t\t\t\t\thdrv->name, ret);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (hid->claimed & HID_CLAIMED_INPUT)\n\t\thidinput_hid_event(hid, field, usage, value);\n\tif (hid->claimed & HID_CLAIMED_HIDDEV && interrupt && hid->hiddev_hid_event)\n\t\thid->hiddev_hid_event(hid, field, usage, value);\n}","24817":"HeaderMap::Lookup HeaderMapImpl::lookup(const LowerCaseString& key,\n                                        const HeaderEntry** entry) const {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.get());\n  if (cb) {\n    \n    \n    \n    \n    \n    \n    StaticLookupResponse ref_lookup_response = cb(const_cast<HeaderMapImpl&>(*this));\n    *entry = *ref_lookup_response.entry_;\n    if (*entry) {\n      return Lookup::Found;\n    } else {\n      return Lookup::NotFound;\n    }\n  } else {\n    *entry = nullptr;\n    return Lookup::NotSupported;\n  }\n}","24077":"static void timeout_work(struct work_struct *work)\n{\n\tstruct tpm_chip *chip = container_of(work, struct tpm_chip, work);\n\n\tmutex_lock(&chip->buffer_mutex);\n\tatomic_set(&chip->data_pending, 0);\n\tmemset(chip->data_buffer, 0, TPM_BUFSIZE);\n\tmutex_unlock(&chip->buffer_mutex);\n}","24024":"inline TfLiteStatus GetMutableInputSafe(const TfLiteContext* context,\n                                        const TfLiteNode* node, int index,\n                                        const TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(\n      context, ValidateTensorIndexingSafe(context, index, node->inputs->size,\n                                          node->inputs->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}","24377":"static int sfq_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct sfq_sched_data *q = qdisc_priv(sch);\n\tint i;\n\tint err;\n\n\tq->sch = sch;\n\ttimer_setup(&q->perturb_timer, sfq_perturbation, TIMER_DEFERRABLE);\n\n\terr = tcf_block_get(&q->block, &q->filter_list, sch, extack);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < SFQ_MAX_DEPTH + 1; i++) {\n\t\tq->dep[i].next = i + SFQ_MAX_FLOWS;\n\t\tq->dep[i].prev = i + SFQ_MAX_FLOWS;\n\t}\n\n\tq->limit = SFQ_MAX_DEPTH;\n\tq->maxdepth = SFQ_MAX_DEPTH;\n\tq->cur_depth = 0;\n\tq->tail = NULL;\n\tq->divisor = SFQ_DEFAULT_HASH_DIVISOR;\n\tq->maxflows = SFQ_DEFAULT_FLOWS;\n\tq->quantum = psched_mtu(qdisc_dev(sch));\n\tq->scaled_quantum = SFQ_ALLOT_SIZE(q->quantum);\n\tq->perturb_period = 0;\n\tq->perturbation = prandom_u32();\n\n\tif (opt) {\n\t\tint err = sfq_change(sch, opt);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tq->ht = sfq_alloc(sizeof(q->ht[0]) * q->divisor);\n\tq->slots = sfq_alloc(sizeof(q->slots[0]) * q->maxflows);\n\tif (!q->ht || !q->slots) {\n\t\t\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < q->divisor; i++)\n\t\tq->ht[i] = SFQ_EMPTY_SLOT;\n\n\tfor (i = 0; i < q->maxflows; i++) {\n\t\tslot_queue_init(&q->slots[i]);\n\t\tsfq_link(q, i);\n\t}\n\tif (q->limit >= 1)\n\t\tsch->flags |= TCQ_F_CAN_BYPASS;\n\telse\n\t\tsch->flags &= ~TCQ_F_CAN_BYPASS;\n\treturn 0;\n}","24200":"com_delimiter(String *buffer __attribute__((unused)), char *line)\n{\n  char buff[256], *tmp;\n\n  strmake_buf(buff, line);\n  tmp= get_arg(buff, 0);\n\n  if (!tmp || !*tmp)\n  {\n    put_info(\"STR\",\n\t     INFO_ERROR);\n    return 0;\n  }\n  else\n  {\n    if (strstr(tmp, \"STR\")) \n    {\n      put_info(\"STR\", INFO_ERROR);\n      return 0;\n    }\n  }\n  strmake_buf(delimiter, tmp);\n  delimiter_length= (int)strlen(delimiter);\n  delimiter_str= delimiter;\n  return 0;\n}","24876":"static void sendsuboption(struct Curl_easy *data, int option)\n{\n  ssize_t bytes_written;\n  int err;\n  unsigned short x, y;\n  unsigned char *uc1, *uc2;\n  struct TELNET *tn = data->req.p.telnet;\n  struct connectdata *conn = data->conn;\n\n  switch(option) {\n  case CURL_TELOPT_NAWS:\n    \n    CURL_SB_CLEAR(tn);\n    CURL_SB_ACCUM(tn, CURL_IAC);\n    CURL_SB_ACCUM(tn, CURL_SB);\n    CURL_SB_ACCUM(tn, CURL_TELOPT_NAWS);\n    \n    \n    x = htons(tn->subopt_wsx);\n    y = htons(tn->subopt_wsy);\n    uc1 = (unsigned char *)&x;\n    uc2 = (unsigned char *)&y;\n    CURL_SB_ACCUM(tn, uc1[0]);\n    CURL_SB_ACCUM(tn, uc1[1]);\n    CURL_SB_ACCUM(tn, uc2[0]);\n    CURL_SB_ACCUM(tn, uc2[1]);\n\n    CURL_SB_ACCUM(tn, CURL_IAC);\n    CURL_SB_ACCUM(tn, CURL_SE);\n    CURL_SB_TERM(tn);\n    \n\n    printsub(data, '>', (unsigned char *)tn->subbuffer + 2,\n             CURL_SB_LEN(tn)-2);\n\n    \n    bytes_written = swrite(conn->sock[FIRSTSOCKET], tn->subbuffer, 3);\n    if(bytes_written < 0) {\n      err = SOCKERRNO;\n      failf(data, \"STR\", err);\n    }\n    \n    send_telnet_data(data, (char *)tn->subbuffer + 3, 4);\n    \n    bytes_written = swrite(conn->sock[FIRSTSOCKET], tn->subbuffer + 7, 2);\n    if(bytes_written < 0) {\n      err = SOCKERRNO;\n      failf(data, \"STR\", err);\n    }\n    break;\n  }\n}","24084":"static inline int __tcp_mtu_to_mss(struct sock *sk, int pmtu)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tint mss_now;\n\n\t\n\tmss_now = pmtu - icsk->icsk_af_ops->net_header_len - sizeof(struct tcphdr);\n\n\t\n\tif (icsk->icsk_af_ops->net_frag_header_len) {\n\t\tconst struct dst_entry *dst = __sk_dst_get(sk);\n\n\t\tif (dst && dst_allfrag(dst))\n\t\t\tmss_now -= icsk->icsk_af_ops->net_frag_header_len;\n\t}\n\n\t\n\tif (mss_now > tp->rx_opt.mss_clamp)\n\t\tmss_now = tp->rx_opt.mss_clamp;\n\n\t\n\tmss_now -= icsk->icsk_ext_hdr_len;\n\n\t\n\tif (mss_now < 48)\n\t\tmss_now = 48;\n\treturn mss_now;\n}","24296":"\tUriSuite() {\n\t\tTEST_ADD(UriSuite::testDistinction)\n\t\tTEST_ADD(UriSuite::testIpFour)\n\t\tTEST_ADD(UriSuite::testIpSixPass)\n\t\tTEST_ADD(UriSuite::testIpSixFail)\n\t\tTEST_ADD(UriSuite::testUri)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort1)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort2)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort22_Bug1948038)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_1)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_2)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_3)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_4)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_related_1)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_related_12)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort23_Bug3510198_related_2)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort3)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort4)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort5)\n\t\tTEST_ADD(UriSuite::testUriUserInfoHostPort6)\n\t\tTEST_ADD(UriSuite::testUriHostRegname)\n\t\tTEST_ADD(UriSuite::testUriHostIpFour1)\n\t\tTEST_ADD(UriSuite::testUriHostIpFour2)\n\t\tTEST_ADD(UriSuite::testUriHostIpSix1)\n\t\tTEST_ADD(UriSuite::testUriHostIpSix2)\n\t\tTEST_ADD(UriSuite::testUriHostIpFuture)\n\t\tTEST_ADD(UriSuite::testUriHostEmpty)\n\t\tTEST_ADD(UriSuite::testUriComponents)\n\t\tTEST_ADD(UriSuite::testUriComponents_Bug20070701)\n\t\tTEST_ADD(UriSuite::testEscaping)\n\t\tTEST_ADD(UriSuite::testUnescaping)\n\t\tTEST_ADD(UriSuite::testTrailingSlash)\n\t\tTEST_ADD(UriSuite::testAddBase)\n\t\tTEST_ADD(UriSuite::testToString)\n\t\tTEST_ADD(UriSuite::testToString_Bug1950126)\n\t\tTEST_ADD(UriSuite::testToStringCharsRequired)\n\t\tTEST_ADD(UriSuite::testToStringCharsRequired)\n\t\tTEST_ADD(UriSuite::testNormalizeSyntaxMaskRequired)\n\t\tTEST_ADD(UriSuite::testNormalizeSyntax)\n\t\tTEST_ADD(UriSuite::testNormalizeSyntaxComponents)\n\t\tTEST_ADD(UriSuite::testNormalizeCrash_Bug20080224)\n\t\tTEST_ADD(UriSuite::testFilenameUriConversion)\n\t\tTEST_ADD(UriSuite::testCrash_FreeUriMembers_Bug20080116)\n\t\tTEST_ADD(UriSuite::testCrash_Report2418192)\n\t\tTEST_ADD(UriSuite::testPervertedQueryString);\n\t\tTEST_ADD(UriSuite::testQueryStringEndingInEqualSign_NonBug32);\n\t\tTEST_ADD(UriSuite::testCrash_MakeOwner_Bug20080207)\n\t\tTEST_ADD(UriSuite::testQueryList)\n\t\tTEST_ADD(UriSuite::testQueryListPair)\n\t\tTEST_ADD(UriSuite::testQueryDissection_Bug3590761)\n\t\tTEST_ADD(UriSuite::testFreeCrash_Bug20080827)\n\t\tTEST_ADD(UriSuite::testParseInvalid_Bug16)\n\t\tTEST_ADD(UriSuite::testRangeComparison)\n\t\tTEST_ADD(UriSuite::testRangeComparison_RemoveBaseUri_Issue19)\n\t\tTEST_ADD(UriSuite::testEquals)\n\t\tTEST_ADD(UriSuite::testHostTextTermination_Issue15)\n\t}","23826":"TPMI_ALG_CIPHER_MODE_Unmarshal(TPMI_ALG_CIPHER_MODE*target, BYTE **buffer, INT32 *size, BOOL allowNull)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM_ALG_ID_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n#if ALG_CTR\t\n\t  case TPM_ALG_CTR:\n#endif\n#if ALG_OFB\t\n\t  case TPM_ALG_OFB:\n#endif\n#if ALG_CBC\n\t  case TPM_ALG_CBC:\n#endif\n#if ALG_CFB\t\n\t  case TPM_ALG_CFB:\n#endif\n#if ALG_ECB\t\n\t  case TPM_ALG_ECB:\n#endif\n\t    break;\n\t  case TPM_ALG_NULL:\n\t    if (allowNull) {\n\t\tbreak;\n\t    }\n\t  default:\n\t    rc = TPM_RC_MODE;\n\t}\n    }\n    return rc;\n}","24511":"void qxl_render_update(PCIQXLDevice *qxl)\n{\n    VGACommonState *vga = &qxl->vga;\n    QXLRect dirty[32], update;\n    void *ptr;\n    int i;\n\n    if (qxl->guest_primary.resized) {\n        qxl->guest_primary.resized = 0;\n\n        if (qxl->guest_primary.flipped) {\n            qemu_free(qxl->guest_primary.flipped);\n            qxl->guest_primary.flipped = NULL;\n        }\n        qemu_free_displaysurface(vga->ds);\n\n        qxl->guest_primary.data = qemu_get_ram_ptr(qxl->vga.vram_offset);\n        if (qxl->guest_primary.stride < 0) {\n            \n            qxl->guest_primary.stride = -qxl->guest_primary.stride;\n            qxl->guest_primary.flipped = qemu_malloc(qxl->guest_primary.surface.width *\n                                                     qxl->guest_primary.stride);\n            ptr = qxl->guest_primary.flipped;\n        } else {\n            ptr = qxl->guest_primary.data;\n        }\n        dprint(qxl, 1, \"STR\",\n               __FUNCTION__,\n               qxl->guest_primary.surface.width,\n               qxl->guest_primary.surface.height,\n               qxl->guest_primary.stride,\n               qxl->guest_primary.bytes_pp,\n               qxl->guest_primary.bits_pp,\n               qxl->guest_primary.flipped ? \"STR\");\n        vga->ds->surface =\n            qemu_create_displaysurface_from(qxl->guest_primary.surface.width,\n                                            qxl->guest_primary.surface.height,\n                                            qxl->guest_primary.bits_pp,\n                                            qxl->guest_primary.stride,\n                                            ptr);\n        dpy_resize(vga->ds);\n    }\n\n    if (!qxl->guest_primary.commands) {\n        return;\n    }\n    qxl->guest_primary.commands = 0;\n\n    update.left   = 0;\n    update.right  = qxl->guest_primary.surface.width;\n    update.top    = 0;\n    update.bottom = qxl->guest_primary.surface.height;\n\n    memset(dirty, 0, sizeof(dirty));\n    qxl_spice_update_area(qxl, 0, &update,\n                          dirty, ARRAY_SIZE(dirty), 1, QXL_SYNC);\n\n    for (i = 0; i < ARRAY_SIZE(dirty); i++) {\n        if (qemu_spice_rect_is_empty(dirty+i)) {\n            break;\n        }\n        if (qxl->guest_primary.flipped) {\n            qxl_flip(qxl, dirty+i);\n        }\n        dpy_update(vga->ds,\n                   dirty[i].left, dirty[i].top,\n                   dirty[i].right - dirty[i].left,\n                   dirty[i].bottom - dirty[i].top);\n    }\n}","23956":"static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)\n{\n\tchar *ksep, *vsep;\n\tsize_t klen, vlen;\n\t\n\tunsigned int new_vlen;\n\n\tif (var->ptr >= var->end) {\n\t\treturn 0;\n\t}\n\n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var->end;\n\t\t}\n\t}\n\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\t\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\t\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\n\n\tphp_url_decode(var->ptr, klen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(ksep, vlen);\n\t}\n\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &ksep, vlen, &new_vlen TSRMLS_CC)) {\n\t\tphp_register_variable_safe(var->ptr, ksep, new_vlen, arr TSRMLS_CC);\n\t}\n\n\tvar->ptr = vsep + (vsep != var->end);\n\treturn 1;\n}","24682":"static void renameReloadSchema(Parse *pParse, int iDb){\n  Vdbe *v = pParse->pVdbe;\n  if( v ){\n    sqlite3ChangeCookie(pParse, iDb);\n    sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, iDb, 0);\n    if( iDb!=1 ) sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, 1, 0);\n  }\n}","24731":"static int get_line(JournalImporter *imp, char **line, size_t *size) {\n        ssize_t n;\n        char *c = NULL;\n\n        assert(imp);\n        assert(imp->state == IMPORTER_STATE_LINE);\n        assert(imp->offset <= imp->filled);\n        assert(imp->filled <= imp->size);\n        assert(!imp->buf || imp->size > 0);\n        assert(imp->fd >= 0);\n\n        for (;;) {\n                if (imp->buf) {\n                        size_t start = MAX(imp->scanned, imp->offset);\n\n                        c = memchr(imp->buf + start, '\\n',\n                                   imp->filled - start);\n                        if (c != NULL)\n                                break;\n                }\n\n                imp->scanned = imp->filled;\n                if (imp->scanned >= DATA_SIZE_MAX)\n                        return log_error_errno(SYNTHETIC_ERRNO(E2BIG),\n                                               \"STR\",\n                                               DATA_SIZE_MAX);\n\n                if (imp->passive_fd)\n                        \n                        return -EAGAIN;\n\n                \n                assert_cc(DATA_SIZE_MAX < ENTRY_SIZE_MAX);\n                if (imp->size - imp->filled < LINE_CHUNK &&\n                    !realloc_buffer(imp, MIN(imp->filled + LINE_CHUNK, ENTRY_SIZE_MAX)))\n                                return log_oom();\n\n                assert(imp->buf);\n                assert(imp->size - imp->filled >= LINE_CHUNK ||\n                       imp->size == ENTRY_SIZE_MAX);\n\n                n = read(imp->fd,\n                         imp->buf + imp->filled,\n                         imp->size - imp->filled);\n                if (n < 0) {\n                        if (errno != EAGAIN)\n                                log_error_errno(errno, \"STR\",\n                                                imp->fd,\n                                                imp->size - imp->filled);\n                        return -errno;\n                } else if (n == 0)\n                        return 0;\n\n                imp->filled += n;\n        }\n\n        *line = imp->buf + imp->offset;\n        *size = c + 1 - imp->buf - imp->offset;\n        imp->offset += *size;\n\n        return 1;\n}","24786":"static void save_text_if_changed(const char *name, const char *new_value)\n{\n    \n    \n    if (!g_hash_table_lookup(g_loaded_texts, name))\n        return;\n\n    const char *old_value = g_cd ? problem_data_get_content_or_NULL(g_cd, name) : \"\";\n    if (!old_value)\n        old_value = \"\";\n    if (strcmp(new_value, old_value) != 0)\n    {\n        struct dump_dir *dd = wizard_open_directory_for_writing(g_dump_dir_name);\n        if (dd)\n            dd_save_text(dd, name, new_value);\n\n\n        dd_close(dd);\n        problem_data_reload_from_dump_dir();\n        update_gui_state_from_problem_data( 0);\n    }\n}","24919":"cmsUInt32Number BaseToBase(cmsUInt32Number in, int BaseIn, int BaseOut)\n{\n    char Buff[100];\n    int i, len;\n    cmsUInt32Number out;\n\n    for (len=0; in > 0 && len < 100; len++) {\n\n        Buff[len] = (char) (in % BaseIn);\n        in \/= BaseIn;\n    }\n\n    for (i=len-1, out=0; i >= 0; --i) {\n        out = out * BaseOut + Buff[i];\n    }\n\n    return out;\n}","24673":"static int put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)\n{\n\tif (!access_ok(VERIFY_WRITE, up, sizeof(*up)))\n\t\treturn -EFAULT;\n\treturn __put_v4l2_format32(kp, up);\n}","24509":"R_API char *r_socket_http_post (const char *url, const char *data, int *code, int *rlen) {\n\tRSocket *s;\n\tbool ssl = r_str_startswith (url, \"STR\");\n\tchar *uri = strdup (url);\n\tif (!uri) {\n\t\treturn NULL;\n\t}\n\n\tchar *host = strstr (uri, \"STR\");\n\tif (!host) {\n\t\tfree (uri);\n\t\tprintf (\"STR\");\n\t\treturn NULL;\n\t}\n\thost += 3;\n\tchar *port = strchr (host, ':');\n\tif (!port) {\n\t\tport = (ssl)? \"STR\";\n\t} else {\n\t\t*port++ = 0;\n\t}\n\tchar *path = strchr (host, '\/');\n\tif (!path) {\n\t\tpath = \"\";\n\t} else {\n\t\t*path++ = 0;\n\t}\n\ts = r_socket_new (ssl);\n\tif (!s) {\n\t\tprintf (\"STR\");\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tif (!r_socket_connect_tcp (s, host, port, 0)) {\n\t\teprintf (\"STR\", host, port);\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\t\n\tr_socket_printf (s,\n\t\t\t\"STR\"\n\t\t\t\"STR\"\n\t\t\t\"STR\"\n\t\t\t\"STR\"\n\t\t\t\"STR\"\n\t\t\t\"STR\"\n\t\t\t\"STR\", path, host, (int)strlen (data));\n\tfree (uri);\n\tr_socket_write (s, (void *)data, strlen (data));\n\treturn r_socket_http_answer (s, code, rlen);\n}","24966":"static int su3000_power_ctrl(struct dvb_usb_device *d, int i)\n{\n\tstruct dw2102_state *state = (struct dw2102_state *)d->priv;\n\tu8 obuf[] = {0xde, 0};\n\n\tinfo(\"STR\", __func__, i, state->initialized);\n\n\tif (i && !state->initialized) {\n\t\tstate->initialized = 1;\n\t\t\n\t\treturn dvb_usb_generic_rw(d, obuf, 2, NULL, 0, 0);\n\t}\n\n\treturn 0;\n}","24313":"static void imap_parser_save_arg(struct imap_parser *parser,\n\t\t\t\t const unsigned char *data, size_t size)\n{\n\tstruct imap_arg *arg;\n\tchar *str;\n\n\targ = imap_arg_create(parser);\n\n\tswitch (parser->cur_type) {\n\tcase ARG_PARSE_ATOM:\n\tcase ARG_PARSE_TEXT:\n\t\tif (size == 3 && i_memcasecmp(data, \"STR\", 3) == 0) {\n\t\t\t\n\t\t\targ->type = IMAP_ARG_NIL;\n\t\t} else {\n\t\t\t\n\t\t\targ->type = IMAP_ARG_ATOM;\n\t\t}\n\t\targ->_data.str = imap_parser_strdup(parser, data, size);\n\t\targ->str_len = size;\n\t\tbreak;\n\tcase ARG_PARSE_STRING:\n\t\t\n\t\ti_assert(size > 0);\n\n\t\targ->type = IMAP_ARG_STRING;\n\t\tstr = p_strndup(parser->pool, data+1, size-1);\n\n\t\t\n\t\tif (parser->str_first_escape >= 0 &&\n\t\t    (parser->flags & IMAP_PARSE_FLAG_NO_UNESCAPE) == 0) {\n\t\t\t\n\t\t\t(void)str_unescape(str + parser->str_first_escape-1);\n\t\t}\n\t\targ->_data.str = str;\n\t\targ->str_len = strlen(str);\n\t\tbreak;\n\tcase ARG_PARSE_LITERAL_DATA:\n\t\tif ((parser->flags & IMAP_PARSE_FLAG_LITERAL_SIZE) != 0) {\n\t\t\t\n\t\t\targ->type = parser->literal_nonsync ?\n\t\t\t\tIMAP_ARG_LITERAL_SIZE_NONSYNC :\n\t\t\t\tIMAP_ARG_LITERAL_SIZE;\n\t\t\targ->_data.literal_size = parser->literal_size;\n\t\t\targ->literal8 = parser->literal8;\n\t\t\tbreak;\n\t\t}\n\t\t\n\tcase ARG_PARSE_LITERAL_DATA_FORCED:\n\t\tif ((parser->flags & IMAP_PARSE_FLAG_LITERAL_TYPE) != 0)\n\t\t\targ->type = IMAP_ARG_LITERAL;\n\t\telse\n\t\t\targ->type = IMAP_ARG_STRING;\n\t\targ->_data.str = imap_parser_strdup(parser, data, size);\n\t\targ->literal8 = parser->literal8;\n\t\targ->str_len = size;\n\t\tbreak;\n\tdefault:\n                i_unreached();\n\t}\n\n\tparser->cur_type = ARG_PARSE_NONE;\n}","23914":"  Http::Http1::CodecStats& http1CodecStats() {\n    return Http::Http1::CodecStats::atomicGet(http1_codec_stats_, stats_store_);\n  }","24842":"static BROTLI_INLINE BROTLI_BOOL SafeReadBlockLength(\n    BrotliDecoderState* s, uint32_t* result, const HuffmanCode* table,\n    BrotliBitReader* br) {\n  uint32_t index;\n  if (s->substate_read_block_length == BROTLI_STATE_READ_BLOCK_LENGTH_NONE) {\n    if (!SafeReadSymbol(table, br, &index)) {\n      return BROTLI_FALSE;\n    }\n  } else {\n    index = s->block_length_index;\n  }\n  {\n    uint32_t bits;\n    uint32_t nbits = _kBrotliPrefixCodeRanges[index].nbits;\n    uint32_t offset = _kBrotliPrefixCodeRanges[index].offset;\n    if (!BrotliSafeReadBits(br, nbits, &bits)) {\n      s->block_length_index = index;\n      s->substate_read_block_length = BROTLI_STATE_READ_BLOCK_LENGTH_SUFFIX;\n      return BROTLI_FALSE;\n    }\n    *result = offset + bits;\n    s->substate_read_block_length = BROTLI_STATE_READ_BLOCK_LENGTH_NONE;\n    return BROTLI_TRUE;\n  }\n}","24431":"static struct page *alloc_migrate_huge_page(struct hstate *h, gfp_t gfp_mask,\n\t\t\t\t     int nid, nodemask_t *nmask)\n{\n\tstruct page *page;\n\n\tif (hstate_is_gigantic(h))\n\t\treturn NULL;\n\n\tpage = alloc_fresh_huge_page(h, gfp_mask, nid, nmask, NULL);\n\tif (!page)\n\t\treturn NULL;\n\n\t\n\tSetPageHugeTemporary(page);\n\n\treturn page;\n}","24918":"static void vgacon_scrolldelta(struct vc_data *c, int lines)\n{\n\tint start, end, count, soff;\n\n\tif (!lines) {\n\t\tvgacon_restore_screen(c);\n\t\treturn;\n\t}\n\n\tif (!vgacon_scrollback_cur->data)\n\t\treturn;\n\n\tif (!vgacon_scrollback_cur->save) {\n\t\tvgacon_cursor(c, CM_ERASE);\n\t\tvgacon_save_screen(c);\n\t\tc->vc_origin = (unsigned long)c->vc_screenbuf;\n\t\tvgacon_scrollback_cur->save = 1;\n\t}\n\n\tvgacon_scrollback_cur->restore = 0;\n\tstart = vgacon_scrollback_cur->cur + lines;\n\tend = start + abs(lines);\n\n\tif (start < 0)\n\t\tstart = 0;\n\n\tif (start > vgacon_scrollback_cur->cnt)\n\t\tstart = vgacon_scrollback_cur->cnt;\n\n\tif (end < 0)\n\t\tend = 0;\n\n\tif (end > vgacon_scrollback_cur->cnt)\n\t\tend = vgacon_scrollback_cur->cnt;\n\n\tvgacon_scrollback_cur->cur = start;\n\tcount = end - start;\n\tsoff = vgacon_scrollback_cur->tail -\n\t\t((vgacon_scrollback_cur->cnt - end) * c->vc_size_row);\n\tsoff -= count * c->vc_size_row;\n\n\tif (soff < 0)\n\t\tsoff += vgacon_scrollback_cur->size;\n\n\tcount = vgacon_scrollback_cur->cnt - start;\n\n\tif (count > c->vc_rows)\n\t\tcount = c->vc_rows;\n\n\tif (count) {\n\t\tint copysize;\n\n\t\tint diff = c->vc_rows - count;\n\t\tvoid *d = (void *) c->vc_visible_origin;\n\t\tvoid *s = (void *) c->vc_screenbuf;\n\n\t\tcount *= c->vc_size_row;\n\t\t\n\t\tcopysize = min(count, vgacon_scrollback_cur->size - soff);\n\t\tscr_memcpyw(d, vgacon_scrollback_cur->data + soff, copysize);\n\t\td += copysize;\n\t\tcount -= copysize;\n\n\t\tif (count) {\n\t\t\tscr_memcpyw(d, vgacon_scrollback_cur->data, count);\n\t\t\td += count;\n\t\t}\n\n\t\tif (diff)\n\t\t\tscr_memcpyw(d, s, diff * c->vc_size_row);\n\t} else\n\t\tvgacon_cursor(c, CM_MOVE);\n}","24761":"PHP_FUNCTION(radius_put_vendor_addr)\n{\n\tlong type, vendor;\n\tint addrlen;\n\tchar\t*addr;\n\tradius_descriptor *raddesc;\n\tzval *z_radh;\n\tstruct in_addr intern_addr;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"STR\", &z_radh, &vendor,\n\t\t&type, &addr, &addrlen) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, \"STR\", le_radius);\n\n\tif (inet_aton(addr, &intern_addr) == 0) {\n\t\tzend_error(E_ERROR, \"STR\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (rad_put_vendor_addr(raddesc->radh, vendor, type, intern_addr) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_TRUE;\n\t}\n}","24414":"int hashtable_init(hashtable_t *hashtable)\n{\n    size_t i;\n\n    hashtable->size = 0;\n    hashtable->num_buckets = 0;  \n    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n\n    list_init(&hashtable->list);\n\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n\n    return 0;\n}","24912":"gql_intro_eval(agooErr err, gqlDoc doc, gqlSel sel, gqlValue result, int depth) {\n    struct _gqlField\tfield;\n    struct _gqlCobj\tobj;\n\n    if (0 == strcmp(\"STR\", sel->name)) {\n\tif (1 < depth) {\n\t    return agoo_err_set(err, AGOO_ERR_EVAL, \"STR\");\n\t}\n\tobj.clas = &root_class;\n\tobj.ptr = NULL;\n    } else if (0 == strcmp(\"STR\", sel->name)) {\n\tif (1 < depth) {\n\t    return agoo_err_set(err, AGOO_ERR_EVAL, \"STR\");\n\t}\n\tobj.clas = &root_class;\n\tobj.ptr = NULL;\n    } else {\n\treturn agoo_err_set(err, AGOO_ERR_EVAL, \"STR\", sel->name);\n    }\n    memset(&field, 0, sizeof(field));\n    field.name = sel->name;\n    field.type = sel->type;\n\n    doc->funcs.resolve = gql_cobj_resolve;\n    doc->funcs.type = gql_cobj_ref_type;\n\n    return gql_cobj_resolve(err, doc, &obj, &field, sel, result, depth);\n}","23924":"struct inet_peer *inet_getpeer(struct inetpeer_addr *daddr, int create)\n{\n\tstruct inet_peer __rcu **stack[PEER_MAXDEPTH], ***stackptr;\n\tstruct inet_peer_base *base = family_to_base(daddr->family);\n\tstruct inet_peer *p;\n\tunsigned int sequence;\n\tint invalidated, gccnt = 0;\n\n\t\n\trcu_read_lock();\n\tsequence = read_seqbegin(&base->lock);\n\tp = lookup_rcu(daddr, base);\n\tinvalidated = read_seqretry(&base->lock, sequence);\n\trcu_read_unlock();\n\n\tif (p)\n\t\treturn p;\n\n\t\n\tif (!create && !invalidated)\n\t\treturn NULL;\n\n\t\n\twrite_seqlock_bh(&base->lock);\nrelookup:\n\tp = lookup(daddr, stack, base);\n\tif (p != peer_avl_empty) {\n\t\tatomic_inc(&p->refcnt);\n\t\twrite_sequnlock_bh(&base->lock);\n\t\treturn p;\n\t}\n\tif (!gccnt) {\n\t\tgccnt = inet_peer_gc(base, stack, stackptr);\n\t\tif (gccnt && create)\n\t\t\tgoto relookup;\n\t}\n\tp = create ? kmem_cache_alloc(peer_cachep, GFP_ATOMIC) : NULL;\n\tif (p) {\n\t\tp->daddr = *daddr;\n\t\tatomic_set(&p->refcnt, 1);\n\t\tatomic_set(&p->rid, 0);\n\t\tatomic_set(&p->ip_id_count, secure_ip_id(daddr->addr.a4));\n\t\tp->tcp_ts_stamp = 0;\n\t\tp->metrics[RTAX_LOCK-1] = INETPEER_METRICS_NEW;\n\t\tp->rate_tokens = 0;\n\t\tp->rate_last = 0;\n\t\tp->pmtu_expires = 0;\n\t\tp->pmtu_orig = 0;\n\t\tmemset(&p->redirect_learned, 0, sizeof(p->redirect_learned));\n\n\n\t\t\n\t\tlink_to_pool(p, base);\n\t\tbase->total++;\n\t}\n\twrite_sequnlock_bh(&base->lock);\n\n\treturn p;\n}","24983":"int\nPerl_re_printf(pTHX_ const char *fmt, ...)\n{\n    va_list ap;\n    int result;\n    PerlIO *f= Perl_debug_log;\n    PERL_ARGS_ASSERT_RE_PRINTF;\n    va_start(ap, fmt);\n    result = PerlIO_vprintf(f, fmt, ap);\n    va_end(ap);\n    return result;","23874":"void ModuleSQL::init()\n{\n\tDispatcher = new DispatcherThread(this);\n\tServerInstance->Threads.Start(Dispatcher);\n}","24297":"GetDecimalFromHex(char hex)\n{\n\tif (isdigit((unsigned char) hex))\n\t\treturn hex - '0';\n\telse\n\t\treturn tolower((unsigned char) hex) - 'a' + 10;\n}","24345":"int kvm_fix_hypercall(struct kvm_vcpu *vcpu)\n{\n\tchar instruction[3];\n\tint ret = 0;\n\tunsigned long rip = kvm_rip_read(vcpu);\n\n\n\t\n\tkvm_mmu_zap_all(vcpu->kvm);\n\n\tkvm_x86_ops->patch_hypercall(vcpu, instruction);\n\tif (emulator_write_emulated(rip, instruction, 3, vcpu)\n\t    != X86EMUL_CONTINUE)\n\t\tret = -EFAULT;\n\n\treturn ret;\n}","24892":"static void gs_usb_xmit_callback(struct urb *urb)\n{\n\tstruct gs_tx_context *txc = urb->context;\n\tstruct gs_can *dev = txc->dev;\n\tstruct net_device *netdev = dev->netdev;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"STR\", txc->echo_id);\n\n\tusb_free_coherent(urb->dev,\n\t\t\t  urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer,\n\t\t\t  urb->transfer_dma);\n}","23880":"static int fill_prefix_v4(prefix_t *p, const struct in_addr *a, int b, int mb) {\n  if(b < 0 || b > mb)\n    return(-1);\n\n  memset(p, 0, sizeof(prefix_t));\n  memcpy(&p->add.sin, a, (mb + 7) \/ 8);\n  p->family = AF_INET;\n  p->bitlen = b;\n  p->ref_count = 0;\n\n  return(0);\n}","24939":"PHP_FUNCTION(locale_compose)\n{\n\tsmart_str      \tloc_name_s = {0};\n\tsmart_str *loc_name = &loc_name_s;\n\tzval*\t\t\tarr\t= NULL;\n\tHashTable*\t\thash_arr = NULL;\n\tint \t\t\tresult = 0;\n\n\tintl_error_reset( NULL TSRMLS_CC );\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"STR\",\n\t\t&arr) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \"STR\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\n\thash_arr = HASH_OF( arr );\n\n\tif( !hash_arr || zend_hash_num_elements( hash_arr ) == 0 )\n\t\tRETURN_FALSE;\n\n\t\n\tresult = append_key_value(loc_name, hash_arr,  LOC_GRANDFATHERED_LANG_TAG);\t\n\tif( result == SUCCESS){\n\t\tRETURN_SMART_STR(loc_name);\n\t}\n\tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n\t\tRETURN_FALSE;\n\t}\n\n\t\n\tresult = append_key_value(loc_name, hash_arr , LOC_LANG_TAG);\t\n\tif( result == LOC_NOT_FOUND ){\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\"STR\", 0 TSRMLS_CC );\n\t\tsmart_str_free(loc_name);\n\t\tRETURN_FALSE;\n\t}\n\tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n\t\tRETURN_FALSE;\n\t}\n\n\t\n\tresult = append_multiple_key_values(loc_name, hash_arr , LOC_EXTLANG_TAG TSRMLS_CC);\n\tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n\t\tRETURN_FALSE;\n\t}\n\n\t\n\tresult = append_key_value(loc_name, hash_arr , LOC_SCRIPT_TAG); \n\tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n\t\tRETURN_FALSE;\n\t}\n\t\n\t\n\tresult = append_key_value( loc_name, hash_arr , LOC_REGION_TAG);\n\tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n\t\tRETURN_FALSE;\n\t}\n\n\t\n\tresult = append_multiple_key_values( loc_name, hash_arr , LOC_VARIANT_TAG TSRMLS_CC); \n\tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n\t\tRETURN_FALSE;\n\t}\n\n\t\n\tresult = append_multiple_key_values( loc_name, hash_arr , LOC_PRIVATE_TAG TSRMLS_CC);\n\tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_SMART_STR(loc_name);\n}","24815":"static int _snd_timer_stop(struct snd_timer_instance * timeri,\n\t\t\t   int keep_flag, int event)\n{\n\tstruct snd_timer *timer;\n\tunsigned long flags;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {\n\t\tif (!keep_flag) {\n\t\t\tspin_lock_irqsave(&slave_active_lock, flags);\n\t\t\ttimeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;\n\t\t\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\t\t}\n\t\tgoto __end;\n\t}\n\ttimer = timeri->timer;\n\tif (!timer)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tlist_del_init(&timeri->ack_list);\n\tlist_del_init(&timeri->active_list);\n\tif ((timeri->flags & SNDRV_TIMER_IFLG_RUNNING) &&\n\t    !(--timer->running)) {\n\t\ttimer->hw.stop(timer);\n\t\tif (timer->flags & SNDRV_TIMER_FLG_RESCHED) {\n\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_RESCHED;\n\t\t\tsnd_timer_reschedule(timer, 0);\n\t\t\tif (timer->flags & SNDRV_TIMER_FLG_CHANGE) {\n\t\t\t\ttimer->flags &= ~SNDRV_TIMER_FLG_CHANGE;\n\t\t\t\ttimer->hw.start(timer);\n\t\t\t}\n\t\t}\n\t}\n\tif (!keep_flag)\n\t\ttimeri->flags &=\n\t\t\t~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);\n\tspin_unlock_irqrestore(&timer->lock, flags);\n      __end:\n\tif (event != SNDRV_TIMER_EVENT_RESOLUTION)\n\t\tsnd_timer_notify1(timeri, event);\n\treturn 0;\n}","24771":"glue(glue(cirrus_bitblt_rop_fwd_transp_, ROP_NAME),_16)(CirrusVGAState *s,\n\t\t\t\t\t\t\tuint8_t *dst,const uint8_t *src,\n\t\t\t\t\t\t\tint dstpitch,int srcpitch,\n\t\t\t\t\t\t\tint bltwidth,int bltheight)\n{\n    int x,y;\n    uint8_t p1, p2;\n    dstpitch -= bltwidth;\n    srcpitch -= bltwidth;\n\n    if (bltheight > 1 && (dstpitch < 0 || srcpitch < 0)) {\n        return;\n    }\n\n    for (y = 0; y < bltheight; y++) {\n        for (x = 0; x < bltwidth; x+=2) {\n\t    p1 = *dst;\n\t    p2 = *(dst+1);\n            ROP_OP(&p1, *src);\n            ROP_OP(&p2, *(src + 1));\n\t    if ((p1 != s->vga.gr[0x34]) || (p2 != s->vga.gr[0x35])) {\n\t\t*dst = p1;\n\t\t*(dst+1) = p2;\n\t    }\n            dst+=2;\n            src+=2;\n        }\n        dst += dstpitch;\n        src += srcpitch;\n    }\n}","24091":"static struct sock *unix_create1(struct net *net, struct socket *sock, int kern)\n{\n\tstruct sock *sk = NULL;\n\tstruct unix_sock *u;\n\n\tatomic_long_inc(&unix_nr_socks);\n\tif (atomic_long_read(&unix_nr_socks) > 2 * get_max_files())\n\t\tgoto out;\n\n\tsk = sk_alloc(net, PF_UNIX, GFP_KERNEL, &unix_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\n\tsock_init_data(sock, sk);\n\tlockdep_set_class(&sk->sk_receive_queue.lock,\n\t\t\t\t&af_unix_sk_receive_queue_lock_key);\n\n\tsk->sk_write_space\t= unix_write_space;\n\tsk->sk_max_ack_backlog\t= net->unx.sysctl_max_dgram_qlen;\n\tsk->sk_destruct\t\t= unix_sock_destructor;\n\tu\t  = unix_sk(sk);\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tspin_lock_init(&u->lock);\n\tatomic_long_set(&u->inflight, 0);\n\tINIT_LIST_HEAD(&u->link);\n\tmutex_init(&u->readlock); \n\tinit_waitqueue_head(&u->peer_wait);\n\tunix_insert_socket(unix_sockets_unbound(sk), sk);\nout:\n\tif (sk == NULL)\n\t\tatomic_long_dec(&unix_nr_socks);\n\telse {\n\t\tlocal_bh_disable();\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\t\tlocal_bh_enable();\n\t}\n\treturn sk;\n}","24163":"static int f2fs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\tblock_t total_count, user_block_count, start_count, ovp_count;\n\tu64 avail_node_count;\n\n\ttotal_count = le64_to_cpu(sbi->raw_super->block_count);\n\tuser_block_count = sbi->user_block_count;\n\tstart_count = le32_to_cpu(sbi->raw_super->segment0_blkaddr);\n\tovp_count = SM_I(sbi)->ovp_segments << sbi->log_blocks_per_seg;\n\tbuf->f_type = F2FS_SUPER_MAGIC;\n\tbuf->f_bsize = sbi->blocksize;\n\n\tbuf->f_blocks = total_count - start_count;\n\tbuf->f_bfree = user_block_count - valid_user_blocks(sbi) + ovp_count;\n\tbuf->f_bavail = user_block_count - valid_user_blocks(sbi) -\n\t\t\t\t\t\tsbi->reserved_blocks;\n\n\tavail_node_count = sbi->total_node_count - F2FS_RESERVED_NODE_NUM;\n\n\tif (avail_node_count > user_block_count) {\n\t\tbuf->f_files = user_block_count;\n\t\tbuf->f_ffree = buf->f_bavail;\n\t} else {\n\t\tbuf->f_files = avail_node_count;\n\t\tbuf->f_ffree = min(avail_node_count - valid_node_count(sbi),\n\t\t\t\t\tbuf->f_bavail);\n\t}\n\n\tbuf->f_namelen = F2FS_NAME_LEN;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\n#ifdef CONFIG_QUOTA\n\tif (is_inode_flag_set(dentry->d_inode, FI_PROJ_INHERIT) &&\n\t\t\tsb_has_quota_limits_enabled(sb, PRJQUOTA)) {\n\t\tf2fs_statfs_project(sb, F2FS_I(dentry->d_inode)->i_projid, buf);\n\t}\n#endif\n\treturn 0;\n}","24320":"PackLinuxElf32::check_pt_dynamic(Elf32_Phdr const *const phdr)\n{\n    unsigned t = get_te32(&phdr->p_offset), s = sizeof(Elf32_Dyn) + t;\n    unsigned filesz = get_te32(&phdr->p_filesz), memsz = get_te32(&phdr->p_memsz);\n    if (s < t || file_size < (off_t)s\n    ||  (3 & t) || (7 & (filesz | memsz))  \n    ||  filesz < sizeof(Elf32_Dyn)\n    ||  memsz  < sizeof(Elf32_Dyn)\n    ||  filesz < memsz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \"STR\",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    sz_dynseg = memsz;\n    return t;\n}","24082":"TEST_F(HttpConnectionManagerImplTest, FilterDirectDecodeEncodeDataTrailers) {\n  InSequence s;\n  setup(false, \"\");\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> Http::Status {\n    RequestDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    RequestHeaderMapPtr headers{\n        new TestRequestHeaderMapImpl{{\"STR\"}}};\n    decoder->decodeHeaders(std::move(headers), false);\n\n    Buffer::OwnedImpl fake_data(\"STR\");\n    decoder->decodeData(fake_data, false);\n\n    RequestTrailerMapPtr trailers{new TestRequestTrailerMapImpl{{\"STR\"}}};\n    decoder->decodeTrailers(std::move(trailers));\n    return Http::okStatus();\n  }));\n\n  EXPECT_CALL(*route_config_provider_.route_config_, route(_, _, _, _));\n  setupFilterChain(2, 2);\n\n  EXPECT_CALL(*decoder_filters_[0], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*decoder_filters_[1], decodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::StopIteration));\n\n  Buffer::OwnedImpl decode_buffer;\n  EXPECT_CALL(*decoder_filters_[0], decodeData(_, false))\n      .WillOnce(Invoke([&](Buffer::Instance& data, bool) {\n        decode_buffer.move(data);\n        return FilterDataStatus::StopIterationNoBuffer;\n      }));\n  EXPECT_CALL(*decoder_filters_[0], decodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::StopIteration));\n  EXPECT_CALL(*decoder_filters_[0], decodeComplete());\n\n  \n  Buffer::OwnedImpl fake_input(\"STR\");\n  conn_manager_->onData(fake_input, false);\n\n  Buffer::OwnedImpl decoded_data_to_forward;\n  decoded_data_to_forward.move(decode_buffer, 2);\n  EXPECT_CALL(*decoder_filters_[1], decodeData(BufferStringEqual(\"STR\"), false))\n      .WillOnce(Return(FilterDataStatus::StopIterationNoBuffer));\n  decoder_filters_[0]->callbacks_->injectDecodedDataToFilterChain(decoded_data_to_forward, false);\n\n  EXPECT_CALL(*decoder_filters_[1], decodeData(BufferStringEqual(\"STR\"), false))\n      .WillOnce(Return(FilterDataStatus::StopIterationNoBuffer));\n  decoder_filters_[0]->callbacks_->injectDecodedDataToFilterChain(decode_buffer, false);\n\n  EXPECT_CALL(*decoder_filters_[1], decodeTrailers(_));\n  EXPECT_CALL(*decoder_filters_[1], decodeComplete());\n  decoder_filters_[0]->callbacks_->continueDecoding();\n\n  \n  EXPECT_CALL(*encoder_filters_[1], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(*encoder_filters_[0], encodeHeaders(_, false))\n      .WillOnce(Return(FilterHeadersStatus::Continue));\n  EXPECT_CALL(response_encoder_, encodeHeaders(_, false));\n\n  Buffer::OwnedImpl encoder_buffer;\n  EXPECT_CALL(*encoder_filters_[1], encodeData(_, false))\n      .WillOnce(Invoke([&](Buffer::Instance& data, bool) {\n        encoder_buffer.move(data);\n        return FilterDataStatus::StopIterationNoBuffer;\n      }));\n  EXPECT_CALL(*encoder_filters_[1], encodeTrailers(_))\n      .WillOnce(Return(FilterTrailersStatus::StopIteration));\n  EXPECT_CALL(*encoder_filters_[1], encodeComplete());\n\n  decoder_filters_[1]->callbacks_->encodeHeaders(\n      ResponseHeaderMapPtr{new TestResponseHeaderMapImpl{{\"STR\"}}}, false);\n  Buffer::OwnedImpl response_body(\"STR\");\n  decoder_filters_[1]->callbacks_->encodeData(response_body, false);\n  decoder_filters_[1]->callbacks_->encodeTrailers(\n      ResponseTrailerMapPtr{new TestResponseTrailerMapImpl{{\"STR\"}}});\n\n  Buffer::OwnedImpl encoded_data_to_forward;\n  encoded_data_to_forward.move(encoder_buffer, 3);\n  EXPECT_CALL(*encoder_filters_[0], encodeData(BufferStringEqual(\"STR\"), false));\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n  encoder_filters_[1]->callbacks_->injectEncodedDataToFilterChain(encoded_data_to_forward, false);\n\n  EXPECT_CALL(*encoder_filters_[0], encodeData(BufferStringEqual(\"STR\"), false));\n  EXPECT_CALL(response_encoder_, encodeData(_, false));\n  encoder_filters_[1]->callbacks_->injectEncodedDataToFilterChain(encoder_buffer, false);\n\n  EXPECT_CALL(*encoder_filters_[0], encodeTrailers(_));\n  EXPECT_CALL(*encoder_filters_[0], encodeComplete());\n  EXPECT_CALL(response_encoder_, encodeTrailers(_));\n  expectOnDestroy();\n  encoder_filters_[1]->callbacks_->continueEncoding();\n}","24317":"static int xc2028_signal(struct dvb_frontend *fe, u16 *strength)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tu16                 frq_lock, signal = 0;\n\tint                 rc, i;\n\n\ttuner_dbg(\"STR\", __func__);\n\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t\n\tif (!rc) {\n\t\t*strength = 0;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&priv->lock);\n\n\t\n\tfor (i = 0; i < 3; i++) {\n\t\trc = xc2028_get_reg(priv, XREG_LOCK, &frq_lock);\n\t\tif (rc < 0)\n\t\t\tgoto ret;\n\n\t\tif (frq_lock)\n\t\t\tbreak;\n\t\tmsleep(6);\n\t}\n\n\t\n\tif (frq_lock == 2)\n\t\tgoto ret;\n\n\t\n\trc = xc2028_get_reg(priv, XREG_SNR, &signal);\n\tif (rc < 0)\n\t\tgoto ret;\n\n\t\n\n\tsignal = ((1 << 12) - 1) | ((signal & 0x07) << 12);\n\nret:\n\tmutex_unlock(&priv->lock);\n\n\t*strength = signal;\n\n\ttuner_dbg(\"STR\", signal);\n\n\treturn rc;\n}","24619":"void\nmono_reflection_initialize_generic_parameter (MonoReflectionGenericParam *gparam)\n{\n\tMonoGenericParamFull *param;\n\tMonoImage *image;\n\tMonoClass *pklass;\n\n\tMONO_ARCH_SAVE_REGS;\n\n\tparam = g_new0 (MonoGenericParamFull, 1);\n\n\tif (gparam->mbuilder) {\n\t\tif (!gparam->mbuilder->generic_container) {\n\t\t\tMonoReflectionTypeBuilder *tb = (MonoReflectionTypeBuilder *)gparam->mbuilder->type;\n\t\t\tMonoClass *klass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)tb));\n\t\t\tgparam->mbuilder->generic_container = mono_image_alloc0 (klass->image, sizeof (MonoGenericContainer));\n\t\t\tgparam->mbuilder->generic_container->is_method = TRUE;\n\t\t\t\n\t\t\tgparam->mbuilder->generic_container->image = klass->image;\n\t\t}\n\t\tparam->param.owner = gparam->mbuilder->generic_container;\n\t} else if (gparam->tbuilder) {\n\t\tif (!gparam->tbuilder->generic_container) {\n\t\t\tMonoClass *klass = mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)gparam->tbuilder));\n\t\t\tgparam->tbuilder->generic_container = mono_image_alloc0 (klass->image, sizeof (MonoGenericContainer));\n\t\t\tgparam->tbuilder->generic_container->owner.klass = klass;\n\t\t}\n\t\tparam->param.owner = gparam->tbuilder->generic_container;\n\t}\n\n\tparam->info.name = mono_string_to_utf8 (gparam->name);\n\tparam->param.num = gparam->index;\n\n\timage = &gparam->tbuilder->module->dynamic_image->image;\n\tpklass = mono_class_from_generic_parameter ((MonoGenericParam *) param, image, gparam->mbuilder != NULL);\n\n\tgparam->type.type = &pklass->byval_arg;\n\n\tMOVING_GC_REGISTER (&pklass->reflection_info);\n\tpklass->reflection_info = gparam; \n\tmono_image_lock (image);\n\timage->reflection_info_unregister_classes = g_slist_prepend (image->reflection_info_unregister_classes, pklass);\n\tmono_image_unlock (image);","24516":"    Network::ListenSocketFactory& listenSocketFactory() override {\n      return *parent_.socket_factory_;\n    }","24405":"sph_enc16be(void *dst, unsigned val)\n{\n\t((unsigned char *)dst)[0] = (val >> 8);\n\t((unsigned char *)dst)[1] = val;\n}","23871":"ArgParser::argKeepFilesOpenThreshold(char* parameter)\n{\n    o.keep_files_open_threshold =\n        static_cast<size_t>(QUtil::string_to_int(parameter));\n}","24073":"    CImg<T>& opening(const unsigned int sx, const unsigned int sy, const unsigned int sz=1) {\n      if (is_empty() || (sx<=1 && sy<=1 && sz<=1)) return *this;\n      return get_opening(sx,sy,sz).move_to(*this);\n    }","24539":"static long vhost_vdpa_set_status(struct vhost_vdpa *v, u8 __user *statusp)\n{\n\tstruct vdpa_device *vdpa = v->vdpa;\n\tconst struct vdpa_config_ops *ops = vdpa->config;\n\tu8 status, status_old;\n\tint ret, nvqs = v->nvqs;\n\tu16 i;\n\n\tif (copy_from_user(&status, statusp, sizeof(status)))\n\t\treturn -EFAULT;\n\n\tstatus_old = ops->get_status(vdpa);\n\n\t\n\tif (status != 0 && (status_old & ~status) != 0)\n\t\treturn -EINVAL;\n\n\tif ((status_old & VIRTIO_CONFIG_S_DRIVER_OK) && !(status & VIRTIO_CONFIG_S_DRIVER_OK))\n\t\tfor (i = 0; i < nvqs; i++)\n\t\t\tvhost_vdpa_unsetup_vq_irq(v, i);\n\n\tif (status == 0) {\n\t\tret = ops->reset(vdpa);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else\n\t\tops->set_status(vdpa, status);\n\n\tif ((status & VIRTIO_CONFIG_S_DRIVER_OK) && !(status_old & VIRTIO_CONFIG_S_DRIVER_OK))\n\t\tfor (i = 0; i < nvqs; i++)\n\t\t\tvhost_vdpa_setup_vq_irq(v, i);\n\n\treturn 0;\n}","24100":"CURLcode Curl_close(struct SessionHandle *data)\n{\n  struct Curl_multi *m;\n\n  if(!data)\n    return CURLE_OK;\n\n  Curl_expire(data, 0); \n\n  m = data->multi;\n\n  if(m)\n    \n    curl_multi_remove_handle(data->multi, data);\n\n  if(data->multi_easy)\n    \n    curl_multi_cleanup(data->multi_easy);\n\n  \n  if(data->state.timeoutlist) {\n    Curl_llist_destroy(data->state.timeoutlist, NULL);\n    data->state.timeoutlist = NULL;\n  }\n\n  data->magic = 0; \n\n  if(data->state.rangestringalloc)\n    free(data->state.range);\n\n  \n  Curl_safefree(data->state.pathbuffer);\n  data->state.path = NULL;\n\n  \n  Curl_free_request_state(data);\n\n  \n  Curl_ssl_close_all(data);\n  Curl_safefree(data->state.first_host);\n  Curl_safefree(data->state.scratch);\n  Curl_ssl_free_certinfo(data);\n\n  \n  if(data->req.newurl) {\n    free(data->req.newurl);\n    data->req.newurl = NULL;\n  }\n\n  if(data->change.referer_alloc) {\n    Curl_safefree(data->change.referer);\n    data->change.referer_alloc = FALSE;\n  }\n  data->change.referer = NULL;\n\n  if(data->change.url_alloc) {\n    Curl_safefree(data->change.url);\n    data->change.url_alloc = FALSE;\n  }\n  data->change.url = NULL;\n\n  Curl_safefree(data->state.headerbuff);\n\n  Curl_flush_cookies(data, 1);\n\n  Curl_digest_cleanup(data);\n\n  Curl_safefree(data->info.contenttype);\n  Curl_safefree(data->info.wouldredirect);\n\n  \n  Curl_resolver_cleanup(data->state.resolver);\n\n  Curl_convert_close(data);\n\n  \n  if(data->share) {\n    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);\n    data->share->dirty--;\n    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);\n  }\n\n  Curl_freeset(data);\n  free(data);\n  return CURLE_OK;\n}","23895":"static int mxf_read_generic_descriptor(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFDescriptor *descriptor = arg;\n    descriptor->pix_fmt = AV_PIX_FMT_NONE;\n    switch(tag) {\n    case 0x3F01:\n        descriptor->sub_descriptors_count = avio_rb32(pb);\n        descriptor->sub_descriptors_refs = av_calloc(descriptor->sub_descriptors_count, sizeof(UID));\n        if (!descriptor->sub_descriptors_refs)\n            return AVERROR(ENOMEM);\n        avio_skip(pb, 4); \n        avio_read(pb, (uint8_t *)descriptor->sub_descriptors_refs, descriptor->sub_descriptors_count * sizeof(UID));\n        break;\n    case 0x3004:\n        avio_read(pb, descriptor->essence_container_ul, 16);\n        break;\n    case 0x3006:\n        descriptor->linked_track_id = avio_rb32(pb);\n        break;\n    case 0x3201: \n        avio_read(pb, descriptor->essence_codec_ul, 16);\n        break;\n    case 0x3203:\n        descriptor->width = avio_rb32(pb);\n        break;\n    case 0x3202:\n        descriptor->height = avio_rb32(pb);\n        break;\n    case 0x320C:\n        descriptor->frame_layout = avio_r8(pb);\n        break;\n    case 0x320E:\n        descriptor->aspect_ratio.num = avio_rb32(pb);\n        descriptor->aspect_ratio.den = avio_rb32(pb);\n        break;\n    case 0x3212:\n        descriptor->field_dominance = avio_r8(pb);\n        break;\n    case 0x3301:\n        descriptor->component_depth = avio_rb32(pb);\n        break;\n    case 0x3302:\n        descriptor->horiz_subsampling = avio_rb32(pb);\n        break;\n    case 0x3308:\n        descriptor->vert_subsampling = avio_rb32(pb);\n        break;\n    case 0x3D03:\n        descriptor->sample_rate.num = avio_rb32(pb);\n        descriptor->sample_rate.den = avio_rb32(pb);\n        break;\n    case 0x3D06: \n        avio_read(pb, descriptor->essence_codec_ul, 16);\n        break;\n    case 0x3D07:\n        descriptor->channels = avio_rb32(pb);\n        break;\n    case 0x3D01:\n        descriptor->bits_per_sample = avio_rb32(pb);\n        break;\n    case 0x3401:\n        mxf_read_pixel_layout(pb, descriptor);\n        break;\n    default:\n        \n        if (IS_KLV_KEY(uid, mxf_sony_mpeg4_extradata)) {\n            if (descriptor->extradata)\n                av_log(NULL, AV_LOG_WARNING, \"STR\");\n            av_free(descriptor->extradata);\n            descriptor->extradata_size = 0;\n            descriptor->extradata = av_malloc(size);\n            if (!descriptor->extradata)\n                return AVERROR(ENOMEM);\n            descriptor->extradata_size = size;\n            avio_read(pb, descriptor->extradata, size);\n        }\n        break;\n    }\n    return 0;\n}","23929":"static int ssl_parse_supported_elliptic_curves( ssl_context *ssl,\n                                                const unsigned char *buf,\n                                                size_t len )\n{\n    size_t list_size, our_size;\n    const unsigned char *p;\n    const ecp_curve_info *curve_info, **curves;\n\n    list_size = ( ( buf[0] << 8 ) | ( buf[1] ) );\n    if( list_size + 2 != len ||\n        list_size % 2 != 0 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"STR\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n\n    \n    our_size = list_size \/ 2 + 1;\n    if( our_size > POLARSSL_ECP_DP_MAX )\n        our_size = POLARSSL_ECP_DP_MAX;\n\n    if( ( curves = polarssl_malloc( our_size * sizeof( *curves ) ) ) == NULL )\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n\n    \n    memset( (void *) curves, 0, our_size * sizeof( *curves ) );\n    ssl->handshake->curves = curves;\n\n    p = buf + 2;\n    while( list_size > 0 && our_size > 1 )\n    {\n        curve_info = ecp_curve_info_from_tls_id( ( p[0] << 8 ) | p[1] );\n\n        if( curve_info != NULL )\n        {\n            *curves++ = curve_info;\n            our_size--;\n        }\n\n        list_size -= 2;\n        p += 2;\n    }\n\n    return( 0 );\n}","24978":"new_fixup(struct archive_write_disk *a, const char *pathname)\n{\n\tstruct fixup_entry *fe;\n\n\tfe = (struct fixup_entry *)calloc(1, sizeof(struct fixup_entry));\n\tif (fe == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"STR\");\n\t\treturn (NULL);\n\t}\n\tfe->next = a->fixup_list;\n\ta->fixup_list = fe;\n\tfe->fixup = 0;\n\tfe->mode = 0;\n\tfe->name = strdup(pathname);\n\treturn (fe);\n}","24623":"LogLuvClose(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\n\t\n\ttd->td_samplesperpixel =\n\t    (td->td_photometric == PHOTOMETRIC_LOGL) ? 1 : 3;\n\ttd->td_bitspersample = 16;\n\ttd->td_sampleformat = SAMPLEFORMAT_INT;\n}","24175":"    int BSONTool::run() {\n        _objcheck = hasParam( \"STR\" );\n\n        if ( hasParam( \"STR\" ) )\n            _matcher.reset( new Matcher( fromjson( getParam( \"STR\" ) ) ) );\n\n        return doRun();\n    }","25036":"int git_smart__store_refs(transport_smart *t, int flushes)\n{\n\tgitno_buffer *buf = &t->buffer;\n\tgit_vector *refs = &t->refs;\n\tint error, flush = 0, recvd;\n\tconst char *line_end = NULL;\n\tgit_pkt *pkt = NULL;\n\tsize_t i;\n\n\t\n\tgit_vector_foreach(refs, i, pkt) {\n\t\tgit_pkt_free(pkt);\n\t}\n\tgit_vector_clear(refs);\n\tpkt = NULL;\n\n\tdo {\n\t\tif (buf->offset > 0)\n\t\t\terror = git_pkt_parse_line(&pkt, buf->data, &line_end, buf->offset);\n\t\telse\n\t\t\terror = GIT_EBUFS;\n\n\t\tif (error < 0 && error != GIT_EBUFS)\n\t\t\treturn error;\n\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif ((recvd = gitno_recv(buf)) < 0)\n\t\t\t\treturn recvd;\n\n\t\t\tif (recvd == 0 && !flush) {\n\t\t\t\tgiterr_set(GITERR_NET, \"STR\");\n\t\t\t\treturn GIT_EEOF;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tgitno_consume(buf, line_end);\n\t\tif (pkt->type == GIT_PKT_ERR) {\n\t\t\tgiterr_set(GITERR_NET, \"STR\", ((git_pkt_err *)pkt)->error);\n\t\t\tgit__free(pkt);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (pkt->type != GIT_PKT_FLUSH && git_vector_insert(refs, pkt) < 0)\n\t\t\treturn -1;\n\n\t\tif (pkt->type == GIT_PKT_FLUSH) {\n\t\t\tflush++;\n\t\t\tgit_pkt_free(pkt);\n\t\t}\n\t} while (flush < flushes);\n\n\treturn flush;\n}","24713":"int jas_image_readcmpt(jas_image_t *image, int cmptno, jas_image_coord_t x,\n  jas_image_coord_t y, jas_image_coord_t width, jas_image_coord_t height,\n  jas_matrix_t *data)\n{\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_coord_t i;\n\tjas_image_coord_t j;\n\tint k;\n\tjas_seqent_t v;\n\tint c;\n\tjas_seqent_t *dr;\n\tjas_seqent_t *d;\n\tint drs;\n\n\tif (cmptno < 0 || cmptno >= image->numcmpts_) {\n\t\treturn -1;\n\t}\n\n\tcmpt = image->cmpts_[cmptno];\n\tif (x >= cmpt->width_ || y >= cmpt->height_ ||\n\t  x + width > cmpt->width_ ||\n\t  y + height > cmpt->height_) {\n\t\treturn -1;\n\t}\n\n\tif (jas_matrix_numrows(data) != height || jas_matrix_numcols(data) != width) {\n\t\tif (jas_matrix_resize(data, height, width)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tdr = jas_matrix_getref(data, 0, 0);\n\tdrs = jas_matrix_rowstep(data);\n\tfor (i = 0; i < height; ++i, dr += drs) {\n\t\td = dr;\n\t\tif (jas_stream_seek(cmpt->stream_, (cmpt->width_ * (y + i) + x)\n\t\t  * cmpt->cps_, SEEK_SET) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (j = width; j > 0; --j, ++d) {\n\t\t\tv = 0;\n\t\t\tfor (k = cmpt->cps_; k > 0; --k) {\n\t\t\t\tif ((c = jas_stream_getc(cmpt->stream_)) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tv = (v << 8) | (c & 0xff);\n\t\t\t}\n\t\t\t*d = bitstoint(v, cmpt->prec_, cmpt->sgnd_);\n\t\t}\n\t}\n\n\treturn 0;\n}","24887":"static long bio_zlib_callback_ctrl(BIO *b, int cmd, bio_info_cb *fp)\n\t{\n\tif(!b->next_bio)\n\t\treturn 0;\n\treturn\n\t\tBIO_callback_ctrl(b->next_bio, cmd, fp);\n\t}","23913":"get_princs_2_svc(gprincs_arg *arg, struct svc_req *rqstp)\n{\n    static gprincs_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gprincs_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->exp;\n    if (prime_arg == NULL)\n        prime_arg = \"STR\";\n\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_LIST,\n                                                       NULL,\n                                                       NULL)) {\n        ret.code = KADM5_AUTH_LIST;\n        log_unauth(\"STR\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code  = kadm5_get_principals((void *)handle,\n                                         arg->exp, &ret.princs,\n                                         &ret.count);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"STR\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","24062":"void Data::set_length(uint16 l)\n{\n    length_ = l;\n}","24324":"static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof)\n{\n\tchar *ksep, *vsep, *val;\n\tsize_t klen, vlen;\n\tsize_t new_vlen;\n\n\tif (var->ptr >= var->end) {\n\t\treturn 0;\n\t}\n\n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var->end;\n\t\t}\n\t}\n\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\t\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\t\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\n\tphp_url_decode(var->ptr, klen);\n\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr);\n\t}\n\tefree(val);\n\n\tvar->ptr = vsep + (vsep != var->end);\n\treturn 1;\n}","24960":"static ssize_t ppp_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ppp_file *pf = file->private_data;\n\tstruct sk_buff *skb;\n\tssize_t ret;\n\n\tif (!pf)\n\t\treturn -ENXIO;\n\tret = -ENOMEM;\n\tskb = alloc_skb(count + pf->hdrlen, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto out;\n\tskb_reserve(skb, pf->hdrlen);\n\tret = -EFAULT;\n\tif (copy_from_user(skb_put(skb, count), buf, count)) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tskb_queue_tail(&pf->xq, skb);\n\n\tswitch (pf->kind) {\n\tcase INTERFACE:\n\t\tppp_xmit_process(PF_TO_PPP(pf));\n\t\tbreak;\n\tcase CHANNEL:\n\t\tppp_channel_push(PF_TO_CHANNEL(pf));\n\t\tbreak;\n\t}\n\n\tret = count;\n\n out:\n\treturn ret;\n}","24696":"void __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tint need_software_tstamp = sock_flag(sk, SOCK_RCVTSTAMP);\n\tstruct timespec ts[3];\n\tint empty = 1;\n\tstruct skb_shared_hwtstamps *shhwtstamps =\n\t\tskb_hwtstamps(skb);\n\n\t\n\tif (need_software_tstamp && skb->tstamp.tv64 == 0)\n\t\t__net_timestamp(skb);\n\n\tif (need_software_tstamp) {\n\t\tif (!sock_flag(sk, SOCK_RCVTSTAMPNS)) {\n\t\t\tstruct timeval tv;\n\t\t\tskb_get_timestamp(skb, &tv);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMP,\n\t\t\t\t sizeof(tv), &tv);\n\t\t} else {\n\t\t\tskb_get_timestampns(skb, &ts[0]);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPNS,\n\t\t\t\t sizeof(ts[0]), &ts[0]);\n\t\t}\n\t}\n\n\n\tmemset(ts, 0, sizeof(ts));\n\tif (skb->tstamp.tv64 &&\n\t    sock_flag(sk, SOCK_TIMESTAMPING_SOFTWARE)) {\n\t\tskb_get_timestampns(skb, ts + 0);\n\t\tempty = 0;\n\t}\n\tif (shhwtstamps) {\n\t\tif (sock_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE) &&\n\t\t    ktime2ts(shhwtstamps->syststamp, ts + 1))\n\t\t\tempty = 0;\n\t\tif (sock_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE) &&\n\t\t    ktime2ts(shhwtstamps->hwtstamp, ts + 2))\n\t\t\tempty = 0;\n\t}\n\tif (!empty)\n\t\tput_cmsg(msg, SOL_SOCKET,\n\t\t\t SCM_TIMESTAMPING, sizeof(ts), &ts);\n}","24997":"static void vhost_net_ubuf_put_and_wait(struct vhost_net_ubuf_ref *ubufs)\n{\n\tkref_put(&ubufs->kref, vhost_net_zerocopy_done_signal);\n\twait_event(ubufs->wait, !atomic_read(&ubufs->kref.refcount));\n}","24391":"static int sclp_ctl_ioctl_sccb(void __user *user_area)\n{\n\tstruct sclp_ctl_sccb ctl_sccb;\n\tstruct sccb_header *sccb;\n\tint rc;\n\n\tif (copy_from_user(&ctl_sccb, user_area, sizeof(ctl_sccb)))\n\t\treturn -EFAULT;\n\tif (!sclp_ctl_cmdw_supported(ctl_sccb.cmdw))\n\t\treturn -EOPNOTSUPP;\n\tsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sccb)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sizeof(*sccb))) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tif (sccb->length > PAGE_SIZE || sccb->length < 8)\n\t\treturn -EINVAL;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sccb->length)) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\trc = sclp_sync_request(ctl_sccb.cmdw, sccb);\n\tif (rc)\n\t\tgoto out_free;\n\tif (copy_to_user(u64_to_uptr(ctl_sccb.sccb), sccb, sccb->length))\n\t\trc = -EFAULT;\nout_free:\n\tfree_page((unsigned long) sccb);\n\treturn rc;\n}","25051":"   Returns numerically indexed array containing associative array for all transitions in the specified range for the timezone.\n*\/\nPHP_FUNCTION(timezone_transitions_get)\n{\n\tzval                *object, *element;\n\tphp_timezone_obj    *tzobj;\n\tunsigned int         i, begin = 0, found;\n\tlong                 timestamp_begin = LONG_MIN, timestamp_end = LONG_MAX;\n\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"STR\", &object, date_ce_timezone, &timestamp_begin, &timestamp_end) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\ttzobj = (php_timezone_obj *) zend_object_store_get_object(object TSRMLS_CC);\n\tDATE_CHECK_INITIALIZED(tzobj->initialized, DateTimeZone);\n\tif (tzobj->type != TIMELIB_ZONETYPE_ID) {\n\t\tRETURN_FALSE;\n\t}\n\n\n\t\tMAKE_STD_ZVAL(element); \\\n\t\tarray_init(element); \\\n\t\tadd_assoc_long(element, \"STR\",     timestamp_begin); \\\n\t\tadd_assoc_string(element, \"STR\", php_format_date(DATE_FORMAT_ISO8601, 13, timestamp_begin, 0 TSRMLS_CC), 0); \\\n\t\tadd_assoc_long(element, \"STR\", tzobj->tzi.tz->type[0].offset); \\\n\t\tadd_assoc_bool(element, \"STR\",  tzobj->tzi.tz->type[0].isdst); \\\n\t\tadd_assoc_string(element, \"STR\", &tzobj->tzi.tz->timezone_abbr[tzobj->tzi.tz->type[0].abbr_idx], 1); \\\n\t\tadd_next_index_zval(return_value, element);\n\n\n\t\tMAKE_STD_ZVAL(element); \\\n\t\tarray_init(element); \\\n\t\tadd_assoc_long(element, \"STR\",     ts); \\\n\t\tadd_assoc_string(element, \"STR\", php_format_date(DATE_FORMAT_ISO8601, 13, ts, 0 TSRMLS_CC), 0); \\\n\t\tadd_assoc_long(element, \"STR\", tzobj->tzi.tz->type[tzobj->tzi.tz->trans_idx[i]].offset); \\\n\t\tadd_assoc_bool(element, \"STR\",  tzobj->tzi.tz->type[tzobj->tzi.tz->trans_idx[i]].isdst); \\\n\t\tadd_assoc_string(element, \"STR\", &tzobj->tzi.tz->timezone_abbr[tzobj->tzi.tz->type[tzobj->tzi.tz->trans_idx[i]].abbr_idx], 1); \\\n\t\tadd_next_index_zval(return_value, element);\n\n\n\n\tarray_init(return_value);\n\n\tif (timestamp_begin == LONG_MIN) {\n\t\tadd_nominal();\n\t\tbegin = 0;\n\t\tfound = 1;\n\t} else {\n\t\tbegin = 0;\n\t\tfound = 0;\n\t\tif (tzobj->tzi.tz->bit32.timecnt > 0) {\n\t\t\tdo {\n\t\t\t\tif (tzobj->tzi.tz->trans[begin] > timestamp_begin) {\n\t\t\t\t\tif (begin > 0) {\n\t\t\t\t\t\tadd(begin - 1, timestamp_begin);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tadd_nominal();\n\t\t\t\t\t}\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbegin++;\n\t\t\t} while (begin < tzobj->tzi.tz->bit32.timecnt);\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tif (tzobj->tzi.tz->bit32.timecnt > 0) {\n\t\t\tadd_last();\n\t\t} else {\n\t\t\tadd_nominal();\n\t\t}\n\t} else {\n\t\tfor (i = begin; i < tzobj->tzi.tz->bit32.timecnt; ++i) {\n\t\t\tif (tzobj->tzi.tz->trans[i] < timestamp_end) {\n\t\t\t\tadd(i, tzobj->tzi.tz->trans[i]);\n\t\t\t}\n\t\t}","24553":"eval_expr_typval(typval_T *expr, typval_T *argv, int argc, typval_T *rettv)\n{\n    char_u\t*s;\n    char_u\tbuf[NUMBUFLEN];\n    funcexe_T\tfuncexe;\n\n    if (expr->v_type == VAR_FUNC)\n    {\n\ts = expr->vval.v_string;\n\tif (s == NULL || *s == NUL)\n\t    return FAIL;\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_evaluate = TRUE;\n\tif (call_func(s, -1, rettv, argc, argv, &funcexe) == FAIL)\n\t    return FAIL;\n    }\n    else if (expr->v_type == VAR_PARTIAL)\n    {\n\tpartial_T   *partial = expr->vval.v_partial;\n\n\tif (partial == NULL)\n\t    return FAIL;\n\n\tif (partial->pt_func != NULL\n\t\t\t  && partial->pt_func->uf_def_status != UF_NOT_COMPILED)\n\t{\n\t    funccall_T\t*fc = create_funccal(partial->pt_func, rettv);\n\t    int\t\tr;\n\n\t    if (fc == NULL)\n\t\treturn FAIL;\n\n\t    \n\t    r = call_def_function(partial->pt_func, argc, argv,\n\t\t\t\t\t  DEF_USE_PT_ARGV, partial, fc, rettv);\n\t    remove_funccal();\n\t    if (r == FAIL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    s = partial_name(partial);\n\t    if (s == NULL || *s == NUL)\n\t\treturn FAIL;\n\t    CLEAR_FIELD(funcexe);\n\t    funcexe.fe_evaluate = TRUE;\n\t    funcexe.fe_partial = partial;\n\t    if (call_func(s, -1, rettv, argc, argv, &funcexe) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n    else if (expr->v_type == VAR_INSTR)\n    {\n\treturn exe_typval_instr(expr, rettv);\n    }\n    else\n    {\n\ts = tv_get_string_buf_chk_strict(expr, buf, in_vim9script());\n\tif (s == NULL)\n\t    return FAIL;\n\ts = skipwhite(s);\n\tif (eval1_emsg(&s, rettv, NULL) == FAIL)\n\t    return FAIL;\n\tif (*skipwhite(s) != NUL)  \n\t{\n\t    clear_tv(rettv);\n\t    semsg(_(e_invalid_expression_str), s);\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}","23945":"MODRET set_requirevalidshell(cmd_rec *cmd) {\n  int bool = -1;\n  config_rec *c = NULL;\n\n  CHECK_ARGS(cmd, 1);\n  CHECK_CONF(cmd, CONF_ROOT|CONF_VIRTUAL|CONF_GLOBAL|CONF_ANON);\n\n  bool = get_boolean(cmd, 1);\n  if (bool == -1)\n    CONF_ERROR(cmd, \"STR\");\n\n  c = add_config_param(cmd->argv[0], 1, NULL);\n  c->argv[0] = pcalloc(c->pool, sizeof(unsigned char));\n  *((unsigned char *) c->argv[0]) = bool;\n  c->flags |= CF_MERGEDOWN;\n\n  return PR_HANDLED(cmd);\n}","24679":"proto_read_ulong_buffer (p11_rpc_message *msg,\n                         CK_ULONG_PTR *buffer,\n                         CK_ULONG *n_buffer)\n{\n\tuint32_t length;\n\n\tassert (msg != NULL);\n\tassert (buffer != NULL);\n\tassert (n_buffer != NULL);\n\tassert (msg->input != NULL);\n\n\t\n\tassert (!msg->signature || p11_rpc_message_verify_part (msg, \"STR\"));\n\n\t\n\tif (!p11_rpc_buffer_get_uint32 (msg->input, &msg->parsed, &length))\n\t\treturn PARSE_ERROR;\n\n\t*n_buffer = length;\n\t*buffer = NULL;\n\n\t\n\tif (length == 0)\n\t\treturn CKR_OK;\n\n\t*buffer = p11_rpc_message_alloc_extra (msg, length * sizeof (CK_ULONG));\n\tif (!*buffer)\n\t\treturn CKR_DEVICE_MEMORY;\n\n\treturn CKR_OK;\n}","24968":"static void h2_session_ev_data_read(h2_session *session, int arg, const char *msg)\n{\n    switch (session->state) {\n        case H2_SESSION_ST_IDLE:\n        case H2_SESSION_ST_WAIT:\n            transit(session, \"STR\", H2_SESSION_ST_BUSY);\n            break;\n        default:\n            \n            break;\n    }\n}","24850":"static void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tbuf[0] = CP2112_GPIO_SET;\n\tbuf[1] = value ? 0xff : 0;\n\tbuf[2] = 1 << offset;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_SET, buf,\n\t\t\t\t CP2112_GPIO_SET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0)\n\t\thid_err(hdev, \"STR\", ret);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}","23881":"mono_custom_attrs_from_method (MonoMethod *method)\n{\n\tguint32 idx;\n\n\t\n\tif (method->is_inflated)\n\t\tmethod = ((MonoMethodInflated *) method)->declaring;\n\t\n\tif (method->dynamic || method->klass->image->dynamic)\n\t\treturn lookup_custom_attr (method->klass->image, method);\n\n\tif (!method->token)\n\t\t\n\t\treturn NULL;\n\n\tidx = mono_method_get_index (method);\n\tidx <<= MONO_CUSTOM_ATTR_BITS;\n\tidx |= MONO_CUSTOM_ATTR_METHODDEF;\n\treturn mono_custom_attrs_from_index (method->klass->image, idx);\n}","24085":"static vm_fault_t binder_vm_fault(struct vm_fault *vmf)\n{\n\treturn VM_FAULT_SIGBUS;\n}","24209":"PJ_DEF(void) pjsua_config_dup(pj_pool_t *pool,\n\t\t\t      pjsua_config *dst,\n\t\t\t      const pjsua_config *src)\n{\n    unsigned i;\n\n    pj_memcpy(dst, src, sizeof(*src));\n\n    for (i=0; i<src->outbound_proxy_cnt; ++i) {\n\tpj_strdup_with_null(pool, &dst->outbound_proxy[i],\n\t\t\t    &src->outbound_proxy[i]);\n    }\n\n    for (i=0; i<src->cred_count; ++i) {\n\tpjsip_cred_dup(pool, &dst->cred_info[i], &src->cred_info[i]);\n    }\n\n    pj_strdup_with_null(pool, &dst->user_agent, &src->user_agent);\n    pj_strdup_with_null(pool, &dst->stun_domain, &src->stun_domain);\n    pj_strdup_with_null(pool, &dst->stun_host, &src->stun_host);\n\n    for (i=0; i<src->stun_srv_cnt; ++i) {\n\tpj_strdup_with_null(pool, &dst->stun_srv[i], &src->stun_srv[i]);\n    }\n\n    pjsua_srtp_opt_dup(pool, &dst->srtp_opt, &src->srtp_opt, PJ_FALSE);\n}","24093":"static int update_remove_entry(struct libmnt_update *upd, struct libmnt_lock *lc)\n{\n\tstruct libmnt_table *tb;\n\tint rc = 0, u_lc = -1;\n\n\tassert(upd);\n\tassert(upd->target);\n\n\tDBG(UPDATE, mnt_debug_h(upd, \"STR\", upd->filename));\n\n\tif (lc)\n\t\tmnt_lock_file(lc);\n\telse if (upd->userspace_only)\n\t\tu_lc = utab_lock(upd->filename);\n\n\ttb = __mnt_new_table_from_file(upd->filename,\n\t\t\tupd->userspace_only ? MNT_FMT_UTAB : MNT_FMT_MTAB);\n\tif (tb) {\n\t\tstruct libmnt_fs *rem = mnt_table_find_target(tb, upd->target, MNT_ITER_BACKWARD);\n\t\tif (rem) {\n\t\t\tmnt_table_remove_fs(tb, rem);\n\t\t\trc = update_table(upd, tb);\n\t\t\tmnt_free_fs(rem);\n\t\t}\n\t}\n\tif (lc)\n\t\tmnt_unlock_file(lc);\n\telse if (u_lc != -1)\n\t\tutab_unlock(u_lc);\n\n\tmnt_free_table(tb);\n\treturn rc;\n}","23900":"static int lsig_eval(cli_ctx *ctx, struct cli_matcher *root, struct cli_ac_data *acdata, struct cli_target_info *target_info, const char *hash, uint32_t lsid)\n{\n    unsigned evalcnt = 0;\n    uint64_t evalids = 0;\n    fmap_t *map = *ctx->fmap;\n    struct cli_ac_lsig *ac_lsig = root->ac_lsigtable[lsid];\n    char * exp = ac_lsig->u.logic;\n    char* exp_end = exp + strlen(exp);\n    int rc;\n\n    rc = cli_ac_chkmacro(root, acdata, lsid);\n    if (rc != CL_SUCCESS)\n        return rc;\n    if (cli_ac_chklsig(exp, exp_end, acdata->lsigcnt[lsid], &evalcnt, &evalids, 0) == 1) {\n        if(ac_lsig->tdb.container && ac_lsig->tdb.container[0] != cli_get_container_type(ctx, -1))\n            return CL_CLEAN;\n        if(ac_lsig->tdb.intermediates && !intermediates_eval(ctx, ac_lsig))\n            return CL_CLEAN;\n        if(ac_lsig->tdb.filesize && (ac_lsig->tdb.filesize[0] > map->len || ac_lsig->tdb.filesize[1] < map->len))\n            return CL_CLEAN;\n\n        if(ac_lsig->tdb.ep || ac_lsig->tdb.nos) {\n            if(!target_info || target_info->status != 1)\n                return CL_CLEAN;\n            if(ac_lsig->tdb.ep && (ac_lsig->tdb.ep[0] > target_info->exeinfo.ep || ac_lsig->tdb.ep[1] < target_info->exeinfo.ep))\n                return CL_CLEAN;\n            if(ac_lsig->tdb.nos && (ac_lsig->tdb.nos[0] > target_info->exeinfo.nsections || ac_lsig->tdb.nos[1] < target_info->exeinfo.nsections))\n                return CL_CLEAN;\n        }\n\n        if(hash && ac_lsig->tdb.handlertype) {\n            if(memcmp(ctx->handlertype_hash, hash, 16)) {\n                ctx->recursion++;\n                memcpy(ctx->handlertype_hash, hash, 16);\n                if(cli_magic_scandesc_type(ctx, ac_lsig->tdb.handlertype[0]) == CL_VIRUS) {\n                    ctx->recursion--;\n                    return CL_VIRUS;\n                }\n                ctx->recursion--;\n                return CL_CLEAN;\n            }\n        }\n        \n        if(ac_lsig->tdb.icongrp1 || ac_lsig->tdb.icongrp2) {\n            if(!target_info || target_info->status != 1)\n                return CL_CLEAN;\n            if(matchicon(ctx, &target_info->exeinfo, ac_lsig->tdb.icongrp1, ac_lsig->tdb.icongrp2) == CL_VIRUS) {\n                if(!ac_lsig->bc_idx) {\n                    rc = cli_append_virus(ctx, ac_lsig->virname);\n                    if (rc != CL_CLEAN)\n                        return rc;\n                } else if(cli_bytecode_runlsig(ctx, target_info, &ctx->engine->bcs, ac_lsig->bc_idx, acdata->lsigcnt[lsid], acdata->lsigsuboff_first[lsid], map) == CL_VIRUS) {\n                    return CL_VIRUS;\n                }\n            }\n            return CL_CLEAN;\n        }\n        if(!ac_lsig->bc_idx) {\n            rc = cli_append_virus(ctx, ac_lsig->virname);\n            if (rc != CL_CLEAN)\n                return rc;\n        }\n        if(cli_bytecode_runlsig(ctx, target_info, &ctx->engine->bcs, ac_lsig->bc_idx, acdata->lsigcnt[lsid], acdata->lsigsuboff_first[lsid], map) == CL_VIRUS) {\n            return CL_VIRUS;\n        }\n    }\n    \n    return CL_CLEAN;\n}","24518":"ArgParser::argCoalesceContents()\n{\n    o.coalesce_contents = true;\n}","24651":"static inline unsigned long zap_pud_range(struct mmu_gather *tlb,\n\t\t\t\tstruct vm_area_struct *vma, p4d_t *p4d,\n\t\t\t\tunsigned long addr, unsigned long end,\n\t\t\t\tstruct zap_details *details)\n{\n\tpud_t *pud;\n\tunsigned long next;\n\n\tpud = pud_offset(p4d, addr);\n\tdo {\n\t\tnext = pud_addr_end(addr, end);\n\t\tif (pud_trans_huge(*pud) || pud_devmap(*pud)) {\n\t\t\tif (next - addr != HPAGE_PUD_SIZE) {\n\t\t\t\tVM_BUG_ON_VMA(!rwsem_is_locked(&tlb->mm->mmap_sem), vma);\n\t\t\t\tsplit_huge_pud(vma, pud, addr);\n\t\t\t} else if (zap_huge_pud(tlb, vma, pud, addr))\n\t\t\t\tgoto next;\n\t\t\t\n\t\t}\n\t\tif (pud_none_or_clear_bad(pud))\n\t\t\tcontinue;\n\t\tnext = zap_pmd_range(tlb, vma, pud, addr, next, details);\nnext:\n\t\tcond_resched();\n\t} while (pud++, addr = next, addr != end);\n\n\treturn addr;\n}","24004":"bool Item_sum_bit::add_as_window(ulonglong value)\n{\n  DBUG_ASSERT(as_window_function);\n  for (int i= 0; i < NUM_BIT_COUNTERS; i++)\n  {\n    bit_counters[i]+= (value & (1ULL << i)) ? 1 : 0;\n  }\n  \n  num_values_added = MY_MAX(num_values_added, num_values_added + 1);\n  set_bits_from_counters();\n  return 0;\n}","23954":"static int err_attr_cb(const struct nlattr *attr, void *data)\n{\n\tconst struct nlattr **tb = data;\n\tuint16_t type;\n\n\tif (mnl_attr_type_valid(attr, NLMSGERR_ATTR_MAX) < 0) {\n\t\tfprintf(stderr, \"STR\");\n\t\treturn MNL_CB_ERROR;\n\t}\n\n\ttype = mnl_attr_get_type(attr);\n\tif (mnl_attr_validate(attr, extack_policy[type]) < 0) {\n\t\tfprintf(stderr, \"STR\",\n\t\t\ttype);\n\t\treturn MNL_CB_ERROR;\n\t}\n\n\ttb[type] = attr;\n\treturn MNL_CB_OK;\n}","23984":"int hfi1_user_sdma_alloc_queues(struct hfi1_ctxtdata *uctxt,\n\t\t\t\tstruct hfi1_filedata *fd)\n{\n\tint ret = -ENOMEM;\n\tchar buf[64];\n\tstruct hfi1_devdata *dd;\n\tstruct hfi1_user_sdma_comp_q *cq;\n\tstruct hfi1_user_sdma_pkt_q *pq;\n\n\tif (!uctxt || !fd)\n\t\treturn -EBADF;\n\n\tif (!hfi1_sdma_comp_ring_size)\n\t\treturn -EINVAL;\n\n\tdd = uctxt->dd;\n\n\tpq = kzalloc(sizeof(*pq), GFP_KERNEL);\n\tif (!pq)\n\t\treturn -ENOMEM;\n\tpq->dd = dd;\n\tpq->ctxt = uctxt->ctxt;\n\tpq->subctxt = fd->subctxt;\n\tpq->n_max_reqs = hfi1_sdma_comp_ring_size;\n\tatomic_set(&pq->n_reqs, 0);\n\tinit_waitqueue_head(&pq->wait);\n\tatomic_set(&pq->n_locked, 0);\n\tpq->mm = fd->mm;\n\n\tiowait_init(&pq->busy, 0, NULL, NULL, defer_packet_queue,\n\t\t    activate_packet_queue, NULL, NULL);\n\tpq->reqidx = 0;\n\n\tpq->reqs = kcalloc(hfi1_sdma_comp_ring_size,\n\t\t\t   sizeof(*pq->reqs),\n\t\t\t   GFP_KERNEL);\n\tif (!pq->reqs)\n\t\tgoto pq_reqs_nomem;\n\n\tpq->req_in_use = kcalloc(BITS_TO_LONGS(hfi1_sdma_comp_ring_size),\n\t\t\t\t sizeof(*pq->req_in_use),\n\t\t\t\t GFP_KERNEL);\n\tif (!pq->req_in_use)\n\t\tgoto pq_reqs_no_in_use;\n\n\tsnprintf(buf, 64, \"STR\", dd->unit, uctxt->ctxt,\n\t\t fd->subctxt);\n\tpq->txreq_cache = kmem_cache_create(buf,\n\t\t\t\t\t    sizeof(struct user_sdma_txreq),\n\t\t\t\t\t    L1_CACHE_BYTES,\n\t\t\t\t\t    SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t    NULL);\n\tif (!pq->txreq_cache) {\n\t\tdd_dev_err(dd, \"STR\",\n\t\t\t   uctxt->ctxt);\n\t\tgoto pq_txreq_nomem;\n\t}\n\n\tcq = kzalloc(sizeof(*cq), GFP_KERNEL);\n\tif (!cq)\n\t\tgoto cq_nomem;\n\n\tcq->comps = vmalloc_user(PAGE_ALIGN(sizeof(*cq->comps)\n\t\t\t\t * hfi1_sdma_comp_ring_size));\n\tif (!cq->comps)\n\t\tgoto cq_comps_nomem;\n\n\tcq->nentries = hfi1_sdma_comp_ring_size;\n\n\tret = hfi1_mmu_rb_register(pq, pq->mm, &sdma_rb_ops, dd->pport->hfi1_wq,\n\t\t\t\t   &pq->handler);\n\tif (ret) {\n\t\tdd_dev_err(dd, \"STR\", ret);\n\t\tgoto pq_mmu_fail;\n\t}\n\n\trcu_assign_pointer(fd->pq, pq);\n\tfd->cq = cq;\n\n\treturn 0;\n\npq_mmu_fail:\n\tvfree(cq->comps);\ncq_comps_nomem:\n\tkfree(cq);\ncq_nomem:\n\tkmem_cache_destroy(pq->txreq_cache);\npq_txreq_nomem:\n\tkfree(pq->req_in_use);\npq_reqs_no_in_use:\n\tkfree(pq->reqs);\npq_reqs_nomem:\n\tkfree(pq);\n\n\treturn ret;\n}","24903":"AlterForeignServerOwner_oid(Oid srvId, Oid newOwnerId)\n{\n\tHeapTuple\ttup;\n\tRelation\trel;\n\n\trel = table_open(ForeignServerRelationId, RowExclusiveLock);\n\n\ttup = SearchSysCacheCopy1(FOREIGNSERVEROID, ObjectIdGetDatum(srvId));\n\n\tif (!HeapTupleIsValid(tup))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"STR\", srvId)));\n\n\tAlterForeignServerOwner_internal(rel, tup, newOwnerId);\n\n\theap_freetuple(tup);\n\n\ttable_close(rel, RowExclusiveLock);\n}","24371":"\t\tvoid CWebServer::Cmd_DownloadUpdate(WebEmSession & session, const request& req, Json::Value &root)\n\t\t{\n\t\t\tif (!m_mainworker.StartDownloadUpdate())\n\t\t\t\treturn;\n\t\t\troot[\"STR\";\n\t\t\troot[\"STR\";\n\t\t}","24559":"static void do_json_page_labels(QPDF& pdf, Options& o, JSON& j)\n{\n    JSON j_labels = j.addDictionaryMember(\"STR\", JSON::makeArray());\n    QPDFPageLabelDocumentHelper pldh(pdf);\n    QPDFPageDocumentHelper pdh(pdf);\n    std::vector<QPDFPageObjectHelper> pages = pdh.getAllPages();\n    if (pldh.hasPageLabels())\n    {\n        std::vector<QPDFObjectHandle> labels;\n        pldh.getLabelsForPageRange(0, pages.size() - 1, 0, labels);\n        for (std::vector<QPDFObjectHandle>::iterator iter = labels.begin();\n             iter != labels.end(); ++iter)\n        {\n            std::vector<QPDFObjectHandle>::iterator next = iter;\n            ++next;\n            if (next == labels.end())\n            {\n                \n                \n                \n                break;\n            }\n            JSON j_label = j_labels.addArrayElement(JSON::makeDictionary());\n            j_label.addDictionaryMember(\"STR\", (*iter).getJSON());\n            ++iter;\n            j_label.addDictionaryMember(\"STR\", (*iter).getJSON());\n        }\n    }\n}","24957":"vhost_user_set_inflight_fd(struct virtio_net **pdev, VhostUserMsg *msg,\n\t\t\t   int main_fd __rte_unused)\n{\n\tuint64_t mmap_size, mmap_offset;\n\tuint16_t num_queues, queue_size;\n\tstruct virtio_net *dev = *pdev;\n\tuint32_t pervq_inflight_size;\n\tstruct vhost_virtqueue *vq;\n\tvoid *addr;\n\tint fd, i;\n\n\tfd = msg->fds[0];\n\tif (msg->size != sizeof(msg->payload.inflight) || fd < 0) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"STR\",\n\t\t\tmsg->size, fd);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\n\tmmap_size = msg->payload.inflight.mmap_size;\n\tmmap_offset = msg->payload.inflight.mmap_offset;\n\tnum_queues = msg->payload.inflight.num_queues;\n\tqueue_size = msg->payload.inflight.queue_size;\n\n\tif (vq_is_packed(dev))\n\t\tpervq_inflight_size = get_pervq_shm_size_packed(queue_size);\n\telse\n\t\tpervq_inflight_size = get_pervq_shm_size_split(queue_size);\n\n\tVHOST_LOG_CONFIG(INFO,\n\t\t\"STR\", mmap_size);\n\tVHOST_LOG_CONFIG(INFO,\n\t\t\"STR\", mmap_offset);\n\tVHOST_LOG_CONFIG(INFO,\n\t\t\"STR\", num_queues);\n\tVHOST_LOG_CONFIG(INFO,\n\t\t\"STR\", queue_size);\n\tVHOST_LOG_CONFIG(INFO,\n\t\t\"STR\", fd);\n\tVHOST_LOG_CONFIG(INFO,\n\t\t\"STR\",\n\t\tpervq_inflight_size);\n\n\tif (!dev->inflight_info) {\n\t\tdev->inflight_info = calloc(1,\n\t\t\t\t\t    sizeof(struct inflight_mem_info));\n\t\tif (dev->inflight_info == NULL) {\n\t\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\t\"STR\");\n\t\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t\t}\n\t}\n\n\tif (dev->inflight_info->addr)\n\t\tmunmap(dev->inflight_info->addr, dev->inflight_info->size);\n\n\taddr = mmap(0, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,\n\t\t    fd, mmap_offset);\n\tif (addr == MAP_FAILED) {\n\t\tVHOST_LOG_CONFIG(ERR, \"STR\");\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\n\tif (dev->inflight_info->fd)\n\t\tclose(dev->inflight_info->fd);\n\n\tdev->inflight_info->fd = fd;\n\tdev->inflight_info->addr = addr;\n\tdev->inflight_info->size = mmap_size;\n\n\tfor (i = 0; i < num_queues; i++) {\n\t\tvq = dev->virtqueue[i];\n\t\tif (vq_is_packed(dev)) {\n\t\t\tvq->inflight_packed = addr;\n\t\t\tvq->inflight_packed->desc_num = queue_size;\n\t\t} else {\n\t\t\tvq->inflight_split = addr;\n\t\t\tvq->inflight_split->desc_num = queue_size;\n\t\t}\n\t\taddr = (void *)((char *)addr + pervq_inflight_size);\n\t}\n\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}","24867":"int ssh_bind_accept_fd(ssh_bind sshbind, ssh_session session, socket_t fd){\n    int i, rc;\n\n    if (session == NULL){\n        ssh_set_error(sshbind, SSH_FATAL,\"STR\");\n        return SSH_ERROR;\n    }\n\n    session->server = 1;\n    session->version = 2;\n\n    \n    for (i = 0; i < 10; ++i) {\n      if (sshbind->wanted_methods[i]) {\n        session->opts.wanted_methods[i] = strdup(sshbind->wanted_methods[i]);\n        if (session->opts.wanted_methods[i] == NULL) {\n          return SSH_ERROR;\n        }\n      }\n    }\n\n    if (sshbind->bindaddr == NULL)\n      session->opts.bindaddr = NULL;\n    else {\n      SAFE_FREE(session->opts.bindaddr);\n      session->opts.bindaddr = strdup(sshbind->bindaddr);\n      if (session->opts.bindaddr == NULL) {\n        return SSH_ERROR;\n      }\n    }\n\n    session->common.log_verbosity = sshbind->common.log_verbosity;\n    if(sshbind->banner != NULL)\n    \tsession->opts.custombanner = strdup(sshbind->banner);\n    ssh_socket_free(session->socket);\n    session->socket = ssh_socket_new(session);\n    if (session->socket == NULL) {\n      \n      ssh_set_error_oom(sshbind);\n      return SSH_ERROR;\n    }\n    ssh_socket_set_fd(session->socket, fd);\n    ssh_socket_get_poll_handle_out(session->socket);\n\n    \n    rc = ssh_bind_import_keys(sshbind);\n    if (rc != SSH_OK) {\n      return SSH_ERROR;\n    }\n\n#ifdef HAVE_ECC\n    if (sshbind->ecdsa) {\n        session->srv.ecdsa_key = ssh_key_dup(sshbind->ecdsa);\n        if (session->srv.ecdsa_key == NULL) {\n          ssh_set_error_oom(sshbind);\n          return SSH_ERROR;\n        }\n    }\n#endif\n    if (sshbind->dsa) {\n        session->srv.dsa_key = ssh_key_dup(sshbind->dsa);\n        if (session->srv.dsa_key == NULL) {\n          ssh_set_error_oom(sshbind);\n          return SSH_ERROR;\n        }\n    }\n    if (sshbind->rsa) {\n        session->srv.rsa_key = ssh_key_dup(sshbind->rsa);\n        if (session->srv.rsa_key == NULL) {\n          ssh_set_error_oom(sshbind);\n          return SSH_ERROR;\n        }\n    }\n    return SSH_OK;\n}","24152":"static void cgi_web_auth(void)\n{\n\tconst char *user = getenv(\"STR\");\n\tstruct passwd *pwd;\n\tconst char *head = \"STR\";\n\tconst char *tail = \"STR\";\n\n\tif (!user) {\n\t\tprintf(\"STR\",\n\t\t       head, tail);\n\t\texit(0);\n\t}\n\n\tpwd = Get_Pwnam_alloc(talloc_tos(), user);\n\tif (!pwd) {\n\t\tprintf(\"STR\", head, user, tail);\n\t\texit(0);\n\t}\n\n\tC_user = SMB_STRDUP(user);\n\n\tif (!setuid(0)) {\n\t\tC_pass = secrets_fetch_generic(\"STR\");\n\t\tif (C_pass == NULL) {\n\t\t\tchar *tmp_pass = NULL;\n\t\t\ttmp_pass = generate_random_password(talloc_tos(),\n\t\t\t\t\t\t\t    16, 16);\n\t\t\tif (tmp_pass == NULL) {\n\t\t\t\tprintf(\"STR\"\n\t\t\t\t       \"STR\", head, tail);\n\t\t\t\texit(0);\n\t\t\t}\n\t\t\tsecrets_store_generic(\"STR\", tmp_pass);\n\t\t\tC_pass = SMB_STRDUP(tmp_pass);\n\t\t\tTALLOC_FREE(tmp_pass);\n\t\t}\n\t}\n\tsetuid(pwd->pw_uid);\n\tif (geteuid() != pwd->pw_uid || getuid() != pwd->pw_uid) {\n\t\tprintf(\"STR\", \n\t\t       head, user, (int)geteuid(), (int)getuid(), tail);\n\t\texit(0);\n\t}\n\tTALLOC_FREE(pwd);\n}","24784":"QUtil::uint_to_string(unsigned long long num, int length)\n{\n    return int_to_string_base(num, 10, length);\n}","24990":"bool VideoTrack::Write(IMkvWriter* writer) const {\n  if (!Track::Write(writer))\n    return false;\n\n  const uint64_t size = VideoPayloadSize();\n\n  if (!WriteEbmlMasterElement(writer, libwebm::kMkvVideo, size))\n    return false;\n\n  const int64_t payload_position = writer->Position();\n  if (payload_position < 0)\n    return false;\n\n  if (!WriteEbmlElement(\n          writer, libwebm::kMkvPixelWidth,\n          static_cast<uint64>((pixel_width_ > 0) ? pixel_width_ : width_)))\n    return false;\n  if (!WriteEbmlElement(\n          writer, libwebm::kMkvPixelHeight,\n          static_cast<uint64>((pixel_height_ > 0) ? pixel_height_ : height_)))\n    return false;\n  if (display_width_ > 0) {\n    if (!WriteEbmlElement(writer, libwebm::kMkvDisplayWidth,\n                          static_cast<uint64>(display_width_)))\n      return false;\n  }\n  if (display_height_ > 0) {\n    if (!WriteEbmlElement(writer, libwebm::kMkvDisplayHeight,\n                          static_cast<uint64>(display_height_)))\n      return false;\n  }\n  if (crop_left_ > 0) {\n    if (!WriteEbmlElement(writer, libwebm::kMkvPixelCropLeft,\n                          static_cast<uint64>(crop_left_)))\n      return false;\n  }\n  if (crop_right_ > 0) {\n    if (!WriteEbmlElement(writer, libwebm::kMkvPixelCropRight,\n                          static_cast<uint64>(crop_right_)))\n      return false;\n  }\n  if (crop_top_ > 0) {\n    if (!WriteEbmlElement(writer, libwebm::kMkvPixelCropTop,\n                          static_cast<uint64>(crop_top_)))\n      return false;\n  }\n  if (crop_bottom_ > 0) {\n    if (!WriteEbmlElement(writer, libwebm::kMkvPixelCropBottom,\n                          static_cast<uint64>(crop_bottom_)))\n      return false;\n  }\n  if (stereo_mode_ > kMono) {\n    if (!WriteEbmlElement(writer, libwebm::kMkvStereoMode,\n                          static_cast<uint64>(stereo_mode_)))\n      return false;\n  }\n  if (alpha_mode_ > kNoAlpha) {\n    if (!WriteEbmlElement(writer, libwebm::kMkvAlphaMode,\n                          static_cast<uint64>(alpha_mode_)))\n      return false;\n  }\n  if (frame_rate_ > 0.0) {\n    if (!WriteEbmlElement(writer, libwebm::kMkvFrameRate,\n                          static_cast<float>(frame_rate_))) {\n      return false;\n    }\n  }\n  if (colour_) {\n    if (!colour_->Write(writer))\n      return false;\n  }\n  if (projection_) {\n    if (!projection_->Write(writer))\n      return false;\n  }\n\n  const int64_t stop_position = writer->Position();\n  if (stop_position < 0 ||\n      stop_position - payload_position != static_cast<int64_t>(size)) {\n    return false;\n  }\n\n  return true;\n}","24531":"updateDevice(const struct header * headers, time_t t)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\t\n\t\t\tsyslog(LOG_DEBUG, \"STR\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\tp->t = t;\n\t\t\t\n\t\t\tif(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)\n\t\t\t{\n\t\t\t\tstruct device * tmp;\n\t\t\t\ttmp = realloc(p, sizeof(struct device)\n\t\t\t\t    + headers[0].l+headers[1].l+headers[2].l);\n\t\t\t\tif(!tmp)\t\n\t\t\t\t{\n\t\t\t\t\tsyslog(LOG_ERR, \"STR\");\n\t\t\t\t\tfree(p);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tp = tmp;\n\t\t\t\t*pp = p;\n\t\t\t}\n\t\t\tmemcpy(p->data + p->headers[0].l + p->headers[1].l,\n\t\t\t       headers[2].p, headers[2].l);\n\t\t\t\n\t\t\treturn 0;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t\n\t}\n\tsyslog(LOG_INFO, \"STR\",\n\t       headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\n\t{\n\t\tchar * pc;\n\t\tint i;\n\t\tp = malloc(  sizeof(struct device)\n\t\t           + headers[0].l+headers[1].l+headers[2].l );\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"STR\");\n\t\t\treturn -1;\n\t\t}\n\t\tp->next = devlist;\n\t\tp->t = t;\n\t\tpc = p->data;\n\t\tfor(i = 0; i < 3; i++)\n\t\t{\n\t\t\tp->headers[i].p = pc;\n\t\t\tp->headers[i].l = headers[i].l;\n\t\t\tmemcpy(pc, headers[i].p, headers[i].l);\n\t\t\tpc += headers[i].l;\n\t\t}\n\t\tdevlist = p;\n\t\tsendNotifications(NOTIF_NEW, p, NULL);\n\t}\n\treturn 1;\n}","24340":"void dummy_error_processor(THD *thd, void *data)\n{}","24038":"static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\tstruct msghdr *msg, size_t len, int noblock, int flags,\n\t\tint *addr_len)\n{\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\tstruct sockaddr_ieee802154 *saddr;\n\n\tsaddr = (struct sockaddr_ieee802154 *)msg->msg_name;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\t\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (saddr) {\n\t\tsaddr->family = AF_IEEE802154;\n\t\tsaddr->addr = mac_cb(skb)->sa;\n\t}\n\tif (addr_len)\n\t\t*addr_len = sizeof(*saddr);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;\n\treturn copied;\n}","24394":"void Initialize(v8::Local<v8::Object> exports,\n                v8::Local<v8::Value> unused,\n                v8::Local<v8::Context> context,\n                void* priv) {\n  v8::Isolate* isolate = context->GetIsolate();\n  gin_helper::Dictionary dict(isolate, exports);\n  dict.Set(\"STR\", WebContents::GetConstructor(isolate)\n                              ->GetFunction(context)\n                              .ToLocalChecked());\n  dict.SetMethod(\"STR\", &WebContents::Create);\n  dict.SetMethod(\"STR\", &WebContents::FromWeakMapID);\n  dict.SetMethod(\"STR\", &WebContents::GetAll);\n}","24988":"int pointZZ_pIsIdentityElement(const PointZZ_p * op) {\n    return mpz_cmp_ui(op->x, 0) == 0 && mpz_cmp_ui(op->y, 0) == 0 ? 1 : 0;\n}","25061":"key_ref_t keyring_search_aux(key_ref_t keyring_ref,\n\t\t\t     struct keyring_search_context *ctx)\n{\n\tstruct key *keyring;\n\tlong err;\n\n\tctx->iterator = keyring_search_iterator;\n\tctx->possessed = is_key_possessed(keyring_ref);\n\tctx->result = ERR_PTR(-EAGAIN);\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey_check(keyring);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn ERR_PTR(-ENOTDIR);\n\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM)) {\n\t\terr = key_task_permission(keyring_ref, ctx->cred, KEY_NEED_SEARCH);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\trcu_read_lock();\n\tctx->now = current_kernel_time();\n\tif (search_nested_keyrings(keyring, ctx))\n\t\t__key_get(key_ref_to_ptr(ctx->result));\n\trcu_read_unlock();\n\treturn ctx->result;\n}","24010":"static int lmf_header_load(lmf_header *lmfh, RBuffer *buf, Sdb *db) {\n\tif (r_buf_size (buf) < sizeof (lmf_header)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, \"STR\", 1) < QNX_HDR_SIZE) {\n\t\treturn false;\n\t}\n\tr_strf_buffer (32);\n\tsdb_set (db, \"STR\", lmfh->version), 0);\n\tsdb_set (db, \"STR\", lmfh->cflags), 0);\n\tsdb_set (db, \"STR\", lmfh->cpu), 0);\n\tsdb_set (db, \"STR\", lmfh->fpu), 0);\n\tsdb_set (db, \"STR\", lmfh->code_index), 0);\n\tsdb_set (db, \"STR\", lmfh->stack_index), 0);\n\tsdb_set (db, \"STR\", lmfh->heap_index), 0);\n\tsdb_set (db, \"STR\", lmfh->argv_index), 0);\n\tsdb_set (db, \"STR\", lmfh->code_offset), 0);\n\tsdb_set (db, \"STR\", lmfh->stack_nbytes), 0);\n\tsdb_set (db, \"STR\", lmfh->heap_nbytes), 0);\n\tsdb_set (db, \"STR\", lmfh->image_base), 0);\n\treturn true;\n}","23856":"static int MagickDLLCall PostscriptDelegateMessage(void *handle,\n  const char *message,int length)\n{\n  char\n    **messages;\n\n  ssize_t\n    offset;\n\n  offset=0;\n  messages=(char **) handle;\n  if (*messages == (char *) NULL)\n    *messages=(char *) AcquireQuantumMemory(length+1,sizeof(char *));\n  else\n    {\n      offset=strlen(*messages);\n      *messages=(char *) ResizeQuantumMemory(*messages,offset+length+1,\n        sizeof(char *));\n    }\n  if (*messages == (char *) NULL)\n    return(0);\n  (void) memcpy(*messages+offset,message,length);\n  (*messages)[length+offset] ='\\0';\n  return(length);\n}","24886":"static int cdrom_ioctl_drive_status(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"STR\");\n\n\tif (!(cdi->ops->capability & CDC_DRIVE_STATUS))\n\t\treturn -ENOSYS;\n\tif (!CDROM_CAN(CDC_SELECT_DISC) ||\n\t    (arg == CDSL_CURRENT || arg == CDSL_NONE))\n\t\treturn cdi->ops->drive_status(cdi, CDSL_CURRENT);\n\tif (((int)arg >= cdi->capacity))\n\t\treturn -EINVAL;\n\treturn cdrom_slot_status(cdi, arg);\n}","24363":"static pdf_creator_t *new_creator(int *n_elements)\n{\n    pdf_creator_t *daddy;\n\n    static const pdf_creator_t creator_template[] = \n    {\n        {\"STR\"},\n        {\"STR\"},\n        {\"STR\"},\n        {\"STR\"},\n        {\"STR\"},\n        {\"STR\"},\n        {\"STR\"},\n        {\"STR\"},\n        {\"STR\"},\n    };\n\n    daddy = malloc(sizeof(creator_template));\n    memcpy(daddy, creator_template, sizeof(creator_template));\n\n    if (n_elements)\n      *n_elements = sizeof(creator_template) \/ sizeof(creator_template[0]);\n\n    return daddy;\n}","24412":"static inline int mk_vhost_fdt_close(struct session_request *sr)\n{\n    int id;\n    unsigned int hash;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n\n    if (config->fdt == MK_FALSE) {\n        return close(sr->fd_file);\n    }\n\n    id   = sr->vhost_fdt_id;\n    hash = sr->vhost_fdt_hash;\n\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return close(sr->fd_file);\n    }\n\n    \n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        \n        hc->readers--;\n        if (hc->readers == 0) {\n            hc->fd   = -1;\n            hc->hash = 0;\n            ht->av_slots++;\n            return close(sr->fd_file);\n        }\n        else {\n            return 0;\n        }\n    }\n\n    return close(sr->fd_file);\n}","25004":"find_pipeline (pid, alive_only, jobp)\n     pid_t pid;\n     int alive_only;\n     int *jobp;\t\t\n{\n  int job;\n  PROCESS *p;\n\n  \n  if (jobp)\n    *jobp = NO_JOB;\n  if (the_pipeline)\n    {\n      p = the_pipeline;\n      do\n\t{\n\t  \n\t  if (p->pid == pid && ((alive_only == 0 && PRECYCLED(p) == 0) || PALIVE(p)))\n\t    return (p);\n\n\t  p = p->next;\n\t}\n      while (p != the_pipeline);\n    }\n  \n  if (last_procsub_child)\n    {\n      p = last_procsub_child;\n      do\n\t{\n\t  \n\t  if (p->pid == pid && ((alive_only == 0 && PRECYCLED(p) == 0) || PALIVE(p)))\n\t    return (p);\n\n\t  p = p->next;\n\t}\n      while (p != last_procsub_child);\n    }\n\n  job = find_job (pid, alive_only, &p);\n  if (jobp)\n    *jobp = job;\n  return (job == NO_JOB) ? (PROCESS *)NULL : jobs[job]->pipe;\n}","24835":"DEFUN (show_ip_bgp_rsclient_summary,\n       show_ip_bgp_rsclient_summary_cmd,\n       \"STR\",\n       SHOW_STR\n       IP_STR\n       BGP_STR\n       \"STR\"\n       \"STR\")\n{\n  return bgp_show_rsclient_summary_vty (vty, NULL, AFI_IP, SAFI_UNICAST);\n}","23855":"duplicate_PropertyValue (const PTPPropertyValue *src, PTPPropertyValue *dst, uint16_t type) {\n\tif (type == PTP_DTC_STR) {\n\t\tif (src->str)\n\t\t\tdst->str = strdup(src->str);\n\t\telse\n\t\t\tdst->str = NULL;\n\t\treturn;\n\t}\n\n\tif (type & PTP_DTC_ARRAY_MASK) {\n\t\tunsigned int i;\n\n\t\tdst->a.count = src->a.count;\n\t\tdst->a.v = malloc (sizeof(src->a.v[0])*src->a.count);\n\t\tfor (i=0;i<src->a.count;i++)\n\t\t\tduplicate_PropertyValue (&src->a.v[i], &dst->a.v[i], type & ~PTP_DTC_ARRAY_MASK);\n\t\treturn;\n\t}\n\tswitch (type & ~PTP_DTC_ARRAY_MASK) {\n\tcase PTP_DTC_INT8:\tdst->i8 = src->i8; break;\n\tcase PTP_DTC_UINT8:\tdst->u8 = src->u8; break;\n\tcase PTP_DTC_INT16:\tdst->i16 = src->i16; break;\n\tcase PTP_DTC_UINT16:\tdst->u16 = src->u16; break;\n\tcase PTP_DTC_INT32:\tdst->i32 = src->i32; break;\n\tcase PTP_DTC_UINT32:\tdst->u32 = src->u32; break;\n\tcase PTP_DTC_UINT64:\tdst->u64 = src->u64; break;\n\tcase PTP_DTC_INT64:\tdst->i64 = src->i64; break;\n#if 0\n\tcase PTP_DTC_INT128:\tdst->i128 = src->i128; break;\n\tcase PTP_DTC_UINT128:\tdst->u128 = src->u128; break;\n#endif\n\tdefault:\t\tbreak;\n\t}\n\treturn;\n}","24105":"  void WillReleaseScriptContext(v8::Local<v8::Context> context,\n                                int32_t world_id) override {\n    if (weak_context_.IsEmpty() ||\n        weak_context_.Get(context->GetIsolate()) == context)\n      electron_ipc_remote_.reset();\n  }","23885":"  void DoRealForwardFFT(OpKernelContext* ctx, uint64* fft_shape,\n                        const Tensor& in, Tensor* out) {\n    \n    const auto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);\n    auto device = ctx->eigen_device<CPUDevice>();\n    auto input = Tensor(in).flat_inner_dims<RealT, FFTRank + 1>();\n    const auto input_dims = input.dimensions();\n\n    \n    Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> input_slice_sizes;\n    input_slice_sizes[0] = input_dims[0];\n    TensorShape temp_shape{input_dims[0]};\n    for (int i = 1; i <= FFTRank; ++i) {\n      input_slice_sizes[i] = fft_shape[i - 1];\n      temp_shape.AddDim(fft_shape[i - 1]);\n    }\n\n    auto output = out->flat_inner_dims<ComplexT, FFTRank + 1>();\n    const Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> zero_start_indices;\n\n    \n    Tensor temp;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<ComplexT>::v(),\n                                           temp_shape, &temp));\n    auto full_fft = temp.flat_inner_dims<ComplexT, FFTRank + 1>();\n    full_fft.device(device) =\n        input.slice(zero_start_indices, input_slice_sizes)\n            .template fft<Eigen::BothParts, Eigen::FFT_FORWARD>(axes);\n\n    \n    output.device(device) =\n        full_fft.slice(zero_start_indices, output.dimensions());\n  }","24823":"lseg_send(PG_FUNCTION_ARGS)\n{\n\tLSEG\t   *ls = PG_GETARG_LSEG_P(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendfloat8(&buf, ls->p[0].x);\n\tpq_sendfloat8(&buf, ls->p[0].y);\n\tpq_sendfloat8(&buf, ls->p[1].x);\n\tpq_sendfloat8(&buf, ls->p[1].y);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}","24066":"static BROTLI_NOINLINE BrotliDecoderErrorCode SafeProcessCommands(\n    BrotliDecoderState* s) {\n  return ProcessCommandsInternal(1, s);\n}","23950":"http_GetHdrQ(const struct http *hp, hdr_t hdr, const char *field)\n{\n\tconst char *hb, *he, *b, *e;\n\tint i;\n\tdouble a, f;\n\n\ti = http_GetHdrToken(hp, hdr, field, &hb, &he);\n\tif (!i)\n\t\treturn (0.);\n\n\tif (hb == NULL)\n\t\treturn (1.);\n\twhile (http_split(&hb, he, \"STR\", &b, &e)) {\n\t\tif (*b != 'q')\n\t\t\tcontinue;\n\t\tfor (b++; b < e && vct_issp(*b); b++)\n\t\t\tcontinue;\n\t\tif (b == e || *b != '=')\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (b == NULL)\n\t\treturn (1.);\n\tfor (b++; b < e && vct_issp(*b); b++)\n\t\tcontinue;\n\tif (b == e || (*b != '.' && !vct_isdigit(*b)))\n\t\treturn (0.);\n\ta = 0;\n\twhile (b < e && vct_isdigit(*b)) {\n\t\ta *= 10.;\n\t\ta += *b - '0';\n\t\tb++;\n\t}\n\tif (b == e || *b++ != '.')\n\t\treturn (a);\n\tf = .1;\n\twhile (b < e && vct_isdigit(*b)) {\n\t\ta += f * (*b - '0');\n\t\tf *= .1;\n\t\tb++;\n\t}\n\treturn (a);\n}","25052":"static void test_do_deinit(void)\n{\n\tdict_deinit(&keys_dict);\n\tdict_driver_unregister(&dict_driver_file);\n\toauth2_validation_key_cache_deinit(&key_cache);\n\ti_unlink(\"STR\");\n\tbuffer_free(&hs_sign_key);\n\tdcrypt_deinitialize();\n}","24068":"static void destroy_con(struct rtrs_clt_con *con)\n{\n\tstruct rtrs_clt_path *clt_path = to_clt_path(con->c.path);\n\n\tclt_path->s.con[con->c.cid] = NULL;\n\tmutex_destroy(&con->con_mutex);\n\tkfree(con);\n}","24103":"static sctp_xmit_t __sctp_packet_append_chunk(struct sctp_packet *packet,\n\t\t\t\t\t      struct sctp_chunk *chunk)\n{\n\tsctp_xmit_t retval = SCTP_XMIT_OK;\n\t__u16 chunk_len = WORD_ROUND(ntohs(chunk->chunk_hdr->length));\n\n\t\n\tretval = sctp_packet_will_fit(packet, chunk, chunk_len);\n\tif (retval != SCTP_XMIT_OK)\n\t\tgoto finish;\n\n\t\n\tswitch (chunk->chunk_hdr->type) {\n\t    case SCTP_CID_DATA:\n\t\t\n\t\tsctp_packet_append_data(packet, chunk);\n\t\t\n\t\tpacket->has_sack = 1;\n\t\t\n\t\tpacket->has_auth = 1;\n\t\t\n\t\tpacket->has_data = 1;\n\t\t\n\t\tchunk->sent_at = jiffies;\n\t\tbreak;\n\t    case SCTP_CID_COOKIE_ECHO:\n\t\tpacket->has_cookie_echo = 1;\n\t\tbreak;\n\n\t    case SCTP_CID_SACK:\n\t\tpacket->has_sack = 1;\n\t\tbreak;\n\n\t    case SCTP_CID_AUTH:\n\t\tpacket->has_auth = 1;\n\t\tpacket->auth = chunk;\n\t\tbreak;\n\t}\n\n\t\n\tlist_add_tail(&chunk->list, &packet->chunk_list);\n\tpacket->size += chunk_len;\n\tchunk->transport = packet->transport;\nfinish:\n\treturn retval;\n}","24252":"static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n\n    \n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n\n    \n    if (strcmp(key, \"STR\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!str_is_correct_filename(value))\n        {\n            error_msg(\"STR\",\n                      key, value);\n            return FALSE;\n        }\n    }\n\n    return TRUE;\n}","24211":"  void Compute(OpKernelContext* context) override {\n    \n    const Tensor& input_tensor = context->input(0);\n    const auto input_tensor_flat = input_tensor.flat<int32>();\n    const Tensor& input_splits = context->input(1);\n    const auto input_splits_flat = input_splits.flat<SPLITS_TYPE>();\n\n    \n    \n    \n    TensorShape output_shape({input_splits.dim_size(0) - 1});\n    Tensor* output_tensor;\n    OP_REQUIRES_OK(context, context->allocate_output(\"STR\", output_shape,\n                                                     &output_tensor));\n    auto output_tensor_flat = output_tensor->flat<tstring>();\n\n    \n    int idx = 0;\n    \n    for (int i = 1; i < input_splits_flat.size(); ++i) {\n      icu::UnicodeString unicode_string;\n      icu::UnicodeStringAppendable appendable_unicode_string(unicode_string);\n      for (; idx < input_splits_flat(i); ++idx) {\n        int32 code_point = input_tensor_flat(idx);\n        \n        if (!U_IS_UNICODE_CHAR(code_point)) {\n          if (error_options_.error_on_malformatting) {\n            context->CtxFailure(errors::InvalidArgument(\n                \"STR\"));\n            return;\n          } else if (!error_options_.elide_replacement) {\n            code_point = error_options_.subst;\n          }\n        }\n        appendable_unicode_string.appendCodePoint(code_point);\n      }\n      \n      tstring result;\n      Encode(encoding_, unicode_string, &result);\n      output_tensor_flat(i - 1) = std::move(result);\n    }\n  }","24984":"static inline void PushSequence(input_translation_t *table, uint16_t Type, uint32_t *offset, void *stack) {\nuint32_t i = table->number_of_sequences;\nuint32_t index = cache.lookup_info[Type].index;\n\n\tif ( table->number_of_sequences >= cache.max_ipfix_elements ) {\n\t\tsyslog(LOG_ERR, \"STR\", \n\t\t\t__FILE__, __LINE__);\n\t\tdbg_printf(\"STR\", \n\t\t\t__FILE__, __LINE__);\n\t\treturn;\n\t}\n\n\tif ( cache.lookup_info[Type].found ) {\n\t\t\ttable->sequence[i].id = ipfix_element_map[index].sequence;\n\t\t\ttable->sequence[i].input_offset  = cache.lookup_info[Type].offset;\n\t\t\ttable->sequence[i].output_offset = *offset;\n\t\t\ttable->sequence[i].stack = stack;\n\t} else {\n\t\t\ttable->sequence[i].id = ipfix_element_map[index].zero_sequence;\n\t\t\ttable->sequence[i].input_offset  = 0;\n\t\t\ttable->sequence[i].output_offset = *offset;\n\t\t\ttable->sequence[i].stack = NULL;\n\t}\n\tdbg_printf(\"STR\",\n\t\ti, Type, ipfix_element_map[index].length, ipfix_element_map[index].out_length, table->sequence[i].id, \n\t\ttable->sequence[i].input_offset, table->sequence[i].output_offset);\n\ttable->number_of_sequences++;\n\t(*offset) += ipfix_element_map[index].out_length;\n\n} ","24961":"void elevator_exit(struct request_queue *q, struct elevator_queue *e)\n{\n\tmutex_lock(&e->sysfs_lock);\n\tif (e->type->ops.exit_sched)\n\t\tblk_mq_exit_sched(q, e);\n\tmutex_unlock(&e->sysfs_lock);\n\n\tkobject_put(&e->kobj);\n}","23965":"bool get_key_map_from_key_list(key_map *map, TABLE *table,\n                               List<String> *index_list)\n{\n  List_iterator_fast<String> it(*index_list);\n  String *name;\n  uint pos;\n\n  map->clear_all();\n  while ((name=it++))\n  {\n    if (table->s->keynames.type_names == 0 ||\n        (pos= find_type(&table->s->keynames, name->ptr(),\n                        name->length(), 1)) <=\n        0)\n    {\n      my_error(ER_KEY_DOES_NOT_EXITS, MYF(0), name->c_ptr(),\n\t       table->pos_in_table_list->alias.str);\n      map->set_all();\n      return 1;\n    }\n    map->set_bit(pos-1);\n  }\n  return 0;\n}","24937":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteSpaceToDepthParams*>(node->builtin_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 ||\n                     data_type == kTfLiteInt8 || data_type == kTfLiteInt32 ||\n                     data_type == kTfLiteInt64);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  const int block_size = params->block_size;\n  const int input_height = input->dims->data[1];\n  const int input_width = input->dims->data[2];\n  int output_height = input_height \/ block_size;\n  int output_width = input_width \/ block_size;\n\n  TF_LITE_ENSURE_EQ(context, input_height, output_height * block_size);\n  TF_LITE_ENSURE_EQ(context, input_width, output_width * block_size);\n\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = input->dims->data[0];\n  output_size->data[1] = output_height;\n  output_size->data[2] = output_width;\n  output_size->data[3] = input->dims->data[3] * block_size * block_size;\n\n  return context->ResizeTensor(context, output, output_size);\n}","24813":"bool WindowsServiceControl::install( const QString& filePath, const QString& displayName  )\n{\n\tm_serviceHandle = CreateService(\n\t\t\t\tm_serviceManager,\t\t\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( m_name ),\t\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( displayName ),\n\t\t\t\tSERVICE_ALL_ACCESS,\t\n\t\t\t\tSERVICE_WIN32_OWN_PROCESS,\n\t\t\t\t\n\t\t\t\tSERVICE_AUTO_START,\t\n\t\t\t\tSERVICE_ERROR_NORMAL,\t\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( filePath ),\t\t\n\t\t\t\tnullptr,\t\t\t\n\t\t\t\tnullptr,\t\t\t\n\t\t\t\tL\"STR\",\t\t\n\t\t\t\tnullptr,\t\t\t\n\t\t\t\tnullptr );\t\t\t\n\n\tif( m_serviceHandle == nullptr )\n\t{\n\t\tconst auto error = GetLastError();\n\t\tif( error == ERROR_SERVICE_EXISTS )\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"STR\" ).arg( m_name ) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"STR\" ).arg( m_name ) );\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tSC_ACTION serviceActions;\n\tserviceActions.Delay = 10000;\n\tserviceActions.Type = SC_ACTION_RESTART;\n\n\tSERVICE_FAILURE_ACTIONS serviceFailureActions;\n\tserviceFailureActions.dwResetPeriod = 0;\n\tserviceFailureActions.lpRebootMsg = nullptr;\n\tserviceFailureActions.lpCommand = nullptr;\n\tserviceFailureActions.lpsaActions = &serviceActions;\n\tserviceFailureActions.cActions = 1;\n\tChangeServiceConfig2( m_serviceHandle, SERVICE_CONFIG_FAILURE_ACTIONS, &serviceFailureActions );\n\n\t\n\tvInfo() << qUtf8Printable( tr( \"STR\" ).arg( m_name ) );\n\n\treturn true;\n}","24095":"static inline bool unconditional(const struct ipt_ip *ip)\n{\n\tstatic const struct ipt_ip uncond;\n\n\treturn memcmp(ip, &uncond, sizeof(uncond)) == 0;\n#undef FWINV\n}","23971":"PM_io_parser(std::ostream& os, const PMDEC& D)\n: Base(D), in(std::cin), out(os),\n  VI(Base::vertices_begin(),Base::vertices_end(),'v'),\n  EI(Base::halfedges_begin(),Base::halfedges_end(),'e'),\n  FI(Base::faces_begin(),Base::faces_end(),'f'),\n  vn(Base::number_of_vertices()),\n  en(Base::number_of_halfedges()),\n  fn(Base::number_of_faces())\n{ verbose = (get_mode(out) != CGAL::IO::ASCII &&\n             get_mode(out) != CGAL::IO::BINARY);\n}","23918":"static struct vm_area_struct *vma_to_resize(unsigned long addr,\n\tunsigned long old_len, unsigned long new_len, unsigned long *p)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\n\tif (!vma || vma->vm_start > addr)\n\t\tgoto Efault;\n\n\tif (is_vm_hugetlb_page(vma))\n\t\tgoto Einval;\n\n\t\n\tif (old_len > vma->vm_end - addr)\n\t\tgoto Efault;\n\n\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {\n\t\tif (new_len > old_len)\n\t\t\tgoto Efault;\n\t}\n\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked, lock_limit;\n\t\tlocked = mm->locked_vm << PAGE_SHIFT;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlocked += new_len - old_len;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\tgoto Eagain;\n\t}\n\n\tif (!may_expand_vm(mm, (new_len - old_len) >> PAGE_SHIFT))\n\t\tgoto Enomem;\n\n\tif (vma->vm_flags & VM_ACCOUNT) {\n\t\tunsigned long charged = (new_len - old_len) >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory(charged))\n\t\t\tgoto Efault;\n\t\t*p = charged;\n\t}\n\n\treturn vma;\n\nEfault:\t\n\treturn ERR_PTR(-EFAULT);\nEinval:\n\treturn ERR_PTR(-EINVAL);\nEnomem:\n\treturn ERR_PTR(-ENOMEM);\nEagain:\n\treturn ERR_PTR(-EAGAIN);\n}","24150":"utils_clear_filled_connection_certs (NMConnection *connection)\n{\n\tNMSetting8021x *s_8021x;\n\n\tg_return_if_fail (connection != NULL);\n\n\ts_8021x = NM_SETTING_802_1X (nm_connection_get_setting (connection, NM_TYPE_SETTING_802_1X));\n\tif (!s_8021x)\n\t\treturn;\n\n\tg_object_set (s_8021x,\n\t              NM_SETTING_802_1X_CA_CERT, NULL,\n\t              NM_SETTING_802_1X_CLIENT_CERT, NULL,\n\t              NM_SETTING_802_1X_PRIVATE_KEY, NULL,\n\t              NM_SETTING_802_1X_PHASE2_CA_CERT, NULL,\n\t              NM_SETTING_802_1X_PHASE2_CLIENT_CERT, NULL,\n\t              NM_SETTING_802_1X_PHASE2_PRIVATE_KEY, NULL,\n\t              NULL);\n}","24144":"int proc_dostring(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}","24053":"default_adapter_changed (GDBusObjectManager   *manager,\n\t\t\t const char           *path,\n\t\t\t BluetoothClient      *client)\n{\n\tBluetoothClientPrivate *priv = BLUETOOTH_CLIENT_GET_PRIVATE(client);\n\tGtkTreeIter iter;\n\tGtkTreePath *tree_path;\n\tgboolean powered;\n\n\tg_assert (!priv->default_adapter);\n\n\tif (get_iter_from_path (priv->store, &iter, path) == FALSE)\n\t\treturn;\n\n\ttree_path = gtk_tree_model_get_path (GTK_TREE_MODEL (priv->store), &iter);\n\tpriv->default_adapter = gtk_tree_row_reference_new (GTK_TREE_MODEL (priv->store), tree_path);\n\tgtk_tree_path_free (tree_path);\n\n\tgtk_tree_store_set (priv->store, &iter,\n\t\t\t    BLUETOOTH_COLUMN_DEFAULT, TRUE, -1);\n\n\tgtk_tree_model_get (GTK_TREE_MODEL(priv->store), &iter,\n\t\t\t   BLUETOOTH_COLUMN_POWERED, &powered, -1);\n\n\tif (powered) {\n\t\tg_object_notify (G_OBJECT (client), \"STR\");\n\t\tg_object_notify (G_OBJECT (client), \"STR\");\n\t\tg_object_notify (G_OBJECT (client), \"STR\");\n\t\tg_object_notify (G_OBJECT (client), \"STR\");\n\t\tg_object_notify (G_OBJECT (client), \"STR\");\n\t\treturn;\n\t}\n\n\t\n\tadapter_set_powered (client, path, TRUE);\n}","24392":"DECLARESepPutFunc(putRGBAAseparate8bittile)\n{\n\t(void) img; (void) x; (void) y; \n\tfor( ; h > 0; --h) {\n\t\tUNROLL8(w, NOP, *cp++ = PACK4(*r++, *g++, *b++, *a++));\n\t\tSKEW4(r, g, b, a, fromskew);\n\t\tcp += toskew;\n\t}\n}","23867":"void __init trap_init(void)\n{\n\tint i;\n\n#ifdef CONFIG_EISA\n\tvoid __iomem *p = early_ioremap(0x0FFFD9, 4);\n\n\tif (readl(p) == 'E' + ('I'<<8) + ('S'<<16) + ('A'<<24))\n\t\tEISA_bus = 1;\n\tearly_iounmap(p, 4);\n#endif\n\n\tset_intr_gate(X86_TRAP_DE, divide_error);\n\tset_intr_gate_ist(X86_TRAP_NMI, &nmi, NMI_STACK);\n\t\n\tset_system_intr_gate(X86_TRAP_OF, &overflow);\n\tset_intr_gate(X86_TRAP_BR, bounds);\n\tset_intr_gate(X86_TRAP_UD, invalid_op);\n\tset_intr_gate(X86_TRAP_NM, device_not_available);\n#ifdef CONFIG_X86_32\n\tset_task_gate(X86_TRAP_DF, GDT_ENTRY_DOUBLEFAULT_TSS);\n#else\n\tset_intr_gate_ist(X86_TRAP_DF, &double_fault, DOUBLEFAULT_STACK);\n#endif\n\tset_intr_gate(X86_TRAP_OLD_MF, coprocessor_segment_overrun);\n\tset_intr_gate(X86_TRAP_TS, invalid_TSS);\n\tset_intr_gate(X86_TRAP_NP, segment_not_present);\n\tset_intr_gate_ist(X86_TRAP_SS, &stack_segment, STACKFAULT_STACK);\n\tset_intr_gate(X86_TRAP_GP, general_protection);\n\tset_intr_gate(X86_TRAP_SPURIOUS, spurious_interrupt_bug);\n\tset_intr_gate(X86_TRAP_MF, coprocessor_error);\n\tset_intr_gate(X86_TRAP_AC, alignment_check);\n#ifdef CONFIG_X86_MCE\n\tset_intr_gate_ist(X86_TRAP_MC, &machine_check, MCE_STACK);\n#endif\n\tset_intr_gate(X86_TRAP_XF, simd_coprocessor_error);\n\n\t\n\tfor (i = 0; i < FIRST_EXTERNAL_VECTOR; i++)\n\t\tset_bit(i, used_vectors);\n\n#ifdef CONFIG_IA32_EMULATION\n\tset_system_intr_gate(IA32_SYSCALL_VECTOR, ia32_syscall);\n\tset_bit(IA32_SYSCALL_VECTOR, used_vectors);\n#endif\n\n#ifdef CONFIG_X86_32\n\tset_system_trap_gate(SYSCALL_VECTOR, &system_call);\n\tset_bit(SYSCALL_VECTOR, used_vectors);\n#endif\n\n\t\n\t__set_fixmap(FIX_RO_IDT, __pa_symbol(idt_table), PAGE_KERNEL_RO);\n\tidt_descr.address = fix_to_virt(FIX_RO_IDT);\n\n\t\n\tcpu_init();\n\n\tx86_init.irqs.trap_init();\n\n#ifdef CONFIG_X86_64\n\tmemcpy(&debug_idt_table, &idt_table, IDT_ENTRIES * 16);\n\tset_nmi_gate(X86_TRAP_DB, &debug);\n\tset_nmi_gate(X86_TRAP_BP, &int3);\n#endif\n}","24804":"static int efi_capsule_release(struct inode *inode, struct file *file)\n{\n\tstruct capsule_info *cap_info = file->private_data;\n\n\tif (cap_info->index > 0 &&\n\t    (cap_info->header.headersize == 0 ||\n\t     cap_info->count < cap_info->total_size)) {\n\t\tpr_err(\"STR\");\n\t\tefi_free_all_buff_pages(cap_info);\n\t}\n\n\tkfree(cap_info->pages);\n\tkfree(cap_info->phys);\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\treturn 0;\n}","24403":"static size_t WritePSDChannel(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  const QuantumType quantum_type, unsigned char *compact_pixels,\n  MagickOffsetType size_offset,const MagickBooleanType separate,\n  const CompressionType compression,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    monochrome;\n\n  QuantumInfo\n    *quantum_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    count,\n    length;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n\n\n\n  int\n    flush,\n    level;\n\n  unsigned char\n    *compressed_pixels;\n\n  z_stream\n    stream;\n\n  compressed_pixels=(unsigned char *) NULL;\n  flush=Z_NO_FLUSH;\n#endif\n  count=0;\n  if (separate != MagickFalse)\n    {\n      size_offset=TellBlob(image)+2;\n      count+=WriteCompressionStart(psd_info,image,next_image,compression,1);\n    }\n  if (next_image->depth > 8)\n    next_image->depth=16;\n  monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n    MagickTrue : MagickFalse;\n  quantum_info=AcquireQuantumInfo(image_info,next_image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    return(0);\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (compression == ZipCompression)\n    {\n      compressed_pixels=(unsigned char *) AcquireQuantumMemory(CHUNK,\n        sizeof(*compressed_pixels));\n      if (compressed_pixels == (unsigned char *) NULL)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          return(0);\n        }\n      memset(&stream,0,sizeof(stream));\n      stream.data_type=Z_BINARY;\n      level=Z_DEFAULT_COMPRESSION;\n      if ((image_info->quality > 0 && image_info->quality < 10))\n        level=(int) image_info->quality;\n      if (deflateInit(&stream,level) != Z_OK)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          return(0);\n        }\n    }\n#endif\n  for (y=0; y < (ssize_t) next_image->rows; y++)\n  {\n    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    if (monochrome != MagickFalse)\n      for (i=0; i < (ssize_t) length; i++)\n        pixels[i]=(~pixels[i]);\n    if (compression == RLECompression)\n      {\n        length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,\n          exception);\n        count+=WriteBlob(image,length,compact_pixels);\n        size_offset+=WritePSDOffset(psd_info,image,length,size_offset);\n      }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n    else if (compression == ZipCompression)\n      {\n        stream.avail_in=(uInt) length;\n        stream.next_in=(Bytef *) pixels;\n        if (y == (ssize_t) next_image->rows-1)\n          flush=Z_FINISH;\n        do {\n            stream.avail_out=(uInt) CHUNK;\n            stream.next_out=(Bytef *) compressed_pixels;\n            if (deflate(&stream,flush) == Z_STREAM_ERROR)\n              break;\n            length=(size_t) CHUNK-stream.avail_out;\n            if (length > 0)\n              count+=WriteBlob(image,length,compressed_pixels);\n        } while (stream.avail_out == 0);\n      }\n#endif\n    else\n      count+=WriteBlob(image,length,pixels);\n  }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (compression == ZipCompression)\n    {\n      (void) deflateEnd(&stream);\n      compressed_pixels=(unsigned char *) RelinquishMagickMemory(\n        compressed_pixels);\n    }\n#endif\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  return(count);\n}","24467":"void CUser::SetClientEncoding(const CString& s) {\n    m_sClientEncoding = s;\n    for (CClient* pClient : GetAllClients()) {\n        pClient->SetEncoding(s);\n    }\n}","24081":"__gdata_service_query (GDataService *self, GDataAuthorizationDomain *domain, const gchar *feed_uri, GDataQuery *query, GType entry_type,\n                       GCancellable *cancellable, GDataQueryProgressCallback progress_callback, gpointer progress_user_data, GError **error,\n                       gboolean is_async)\n{\n\tGDataServiceClass *klass;\n\tGDataFeed *feed;\n\tSoupMessage *message;\n\n\tmessage = _gdata_service_query (self, domain, feed_uri, query, cancellable, error);\n\tif (message == NULL)\n\t\treturn NULL;\n\n\tg_assert (message->response_body->data != NULL);\n\tklass = GDATA_SERVICE_GET_CLASS (self);\n\tfeed = _gdata_feed_new_from_xml (klass->feed_type, message->response_body->data, message->response_body->length, entry_type,\n\t                                 progress_callback, progress_user_data, is_async, error);\n\tg_object_unref (message);\n\n\tif (feed == NULL)\n\t\treturn NULL;\n\n\t\n\tif (query != NULL && feed != NULL && gdata_feed_get_etag (feed) != NULL)\n\t\tgdata_query_set_etag (query, gdata_feed_get_etag (feed));\n\n\t\n\tif (query != NULL && feed != NULL) {\n\t\tGDataLink *_link;\n\n\t\t_link = gdata_feed_look_up_link (feed, \"STR\");\n\t\tif (_link != NULL)\n\t\t\t_gdata_query_set_next_uri (query, gdata_link_get_uri (_link));\n\t\t_link = gdata_feed_look_up_link (feed, \"STR\");\n\t\tif (_link != NULL)\n\t\t\t_gdata_query_set_previous_uri (query, gdata_link_get_uri (_link));\n\t}\n\n\treturn feed;\n}","23925":"listener_add_ck_ref_entry (GSListener     *listener,\n                           int             entry_type,\n                           DBusConnection *connection,\n                           DBusMessage    *message,\n                           guint32        *cookiep)\n{\n        GSListenerRefEntry *entry;\n\n        entry = g_new0 (GSListenerRefEntry, 1);\n        entry->entry_type = entry_type;\n        entry->connection = g_strdup (dbus_message_get_sender (message));\n        entry->cookie = listener_generate_unique_key (listener, entry_type);\n        entry->application = g_strdup (\"STR\");\n        entry->reason = g_strdup (\"STR\");\n        g_get_current_time (&entry->since);\n\n        \n        listener_add_ref_entry (listener, entry_type, entry);\n\n        if (cookiep != NULL) {\n                *cookiep = entry->cookie;\n        }\n}","24219":"static int ax25_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tax25_cb *ax25;\n\n\tif (sk == NULL)\n\t\treturn 0;\n\n\tsock_hold(sk);\n\tsock_orphan(sk);\n\tlock_sock(sk);\n\tax25 = sk_to_ax25(sk);\n\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\tswitch (ax25->state) {\n\t\tcase AX25_STATE_0:\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(ax25, 0);\n\t\t\tlock_sock(sk);\n\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_1:\n\t\tcase AX25_STATE_2:\n\t\t\tax25_send_control(ax25, AX25_DISC, AX25_POLLON, AX25_COMMAND);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(ax25, 0);\n\t\t\tlock_sock(sk);\n\t\t\tif (!sock_flag(ax25->sk, SOCK_DESTROY))\n\t\t\t\tax25_destroy_socket(ax25);\n\t\t\tbreak;\n\n\t\tcase AX25_STATE_3:\n\t\tcase AX25_STATE_4:\n\t\t\tax25_clear_queues(ax25);\n\t\t\tax25->n2count = 0;\n\n\t\t\tswitch (ax25->ax25_dev->values[AX25_VALUES_PROTOCOL]) {\n\t\t\tcase AX25_PROTO_STD_SIMPLEX:\n\t\t\tcase AX25_PROTO_STD_DUPLEX:\n\t\t\t\tax25_send_control(ax25,\n\t\t\t\t\t\t  AX25_DISC,\n\t\t\t\t\t\t  AX25_POLLON,\n\t\t\t\t\t\t  AX25_COMMAND);\n\t\t\t\tax25_stop_t2timer(ax25);\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n#ifdef CONFIG_AX25_DAMA_SLAVE\n\t\t\tcase AX25_PROTO_DAMA_SLAVE:\n\t\t\t\tax25_stop_t3timer(ax25);\n\t\t\t\tax25_stop_idletimer(ax25);\n\t\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t\tax25_calculate_t1(ax25);\n\t\t\tax25_start_t1timer(ax25);\n\t\t\tax25->state = AX25_STATE_2;\n\t\t\tsk->sk_state                = TCP_CLOSE;\n\t\t\tsk->sk_shutdown            |= SEND_SHUTDOWN;\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsock_set_flag(sk, SOCK_DESTROY);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tsk->sk_state     = TCP_CLOSE;\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tsk->sk_state_change(sk);\n\t\tax25_destroy_socket(ax25);\n\t}\n\n\tsock->sk   = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}","24055":"rsvg_new_filter_primitive_convolve_matrix (void)\n{\n    RsvgFilterPrimitiveConvolveMatrix *filter;\n    filter = g_new (RsvgFilterPrimitiveConvolveMatrix, 1);\n    _rsvg_node_init (&filter->super.super);\n    filter->super.in = g_string_new (\"STR\");\n    filter->super.result = g_string_new (\"STR\");\n    filter->super.x.factor = filter->super.y.factor = filter->super.width.factor =\n        filter->super.height.factor = 'n';\n    filter->divisor = 0;\n    filter->bias = 0;\n    filter->dx = 0;\n    filter->dy = 0;\n    filter->preservealpha = FALSE;\n    filter->edgemode = 0;\n    filter->super.render = &rsvg_filter_primitive_convolve_matrix_render;\n    filter->super.super.free = &rsvg_filter_primitive_convolve_matrix_free;\n    filter->super.super.set_atts = rsvg_filter_primitive_convolve_matrix_set_atts;\n    return (RsvgNode *) filter;\n}","24299":"  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& dims = context->input(1);\n\n    if (TensorShapeUtils::IsScalar(input.shape())) {\n      context->set_output(0, input);\n    } else {\n      const int input_dims = input.dims();\n      OP_REQUIRES(context, TensorShapeUtils::IsVector(dims.shape()),\n                  errors::InvalidArgument(\"STR\",\n                                          dims.dims()));\n\n      OP_REQUIRES(\n          context, input_dims == dims.dim_size(0),\n          errors::InvalidArgument(\n              \"STR\"\n              \"STR\",\n              input_dims, \"STR\"));\n      OP_REQUIRES(context, input_dims <= 8,\n                  errors::Unimplemented(\n                      \"STR\"));\n\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(0, input.shape(), &output));\n\n\n  case NDIMS:                                                               \\\n    HandleReverseCase<Device, T, NDIMS>(context, dims.vec<bool>(), output); \\\n    return;\n\n      switch (input_dims) {\n        HANDLE_REVERSE(0);\n        HANDLE_REVERSE(1);\n        HANDLE_REVERSE(2);\n        HANDLE_REVERSE(3);\n        HANDLE_REVERSE(4);\n        HANDLE_REVERSE(5);\n        HANDLE_REVERSE(6);\n        HANDLE_REVERSE(7);\n        HANDLE_REVERSE(8);\n      }\n#undef HANDLE_REVERSE\n    }\n  }","24212":"static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loaddr, Sdb *sdb) {\n\tif (!buf || !sz || sz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tRBuffer *tbuf = r_buf_new ();\n\tr_buf_set_bytes (tbuf, buf, sz);\n\tstruct r_bin_bflt_obj *res = r_bin_bflt_new_buf (tbuf);\n\tr_buf_free (tbuf);\n\treturn res ? res : NULL;\n}","23814":"static int local_link(FsContext *ctx, V9fsPath *oldpath,\n                      V9fsPath *dirpath, const char *name)\n{\n    char *odirpath = g_path_get_dirname(oldpath->data);\n    char *oname = g_path_get_basename(oldpath->data);\n    int ret = -1;\n    int odirfd, ndirfd;\n\n    odirfd = local_opendir_nofollow(ctx, odirpath);\n    if (odirfd == -1) {\n        goto out;\n    }\n\n    ndirfd = local_opendir_nofollow(ctx, dirpath->data);\n    if (ndirfd == -1) {\n        close_preserve_errno(odirfd);\n        goto out;\n    }\n\n    ret = linkat(odirfd, oname, ndirfd, name, 0);\n    if (ret < 0) {\n        goto out_close;\n    }\n\n    \n    if (ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n        int omap_dirfd, nmap_dirfd;\n\n        ret = mkdirat(ndirfd, VIRTFS_META_DIR, 0700);\n        if (ret < 0 && errno != EEXIST) {\n            goto err_undo_link;\n        }\n\n        omap_dirfd = openat_dir(odirfd, VIRTFS_META_DIR);\n        if (omap_dirfd == -1) {\n            goto err;\n        }\n\n        nmap_dirfd = openat_dir(ndirfd, VIRTFS_META_DIR);\n        if (nmap_dirfd == -1) {\n            close_preserve_errno(omap_dirfd);\n            goto err;\n        }\n\n        ret = linkat(omap_dirfd, oname, nmap_dirfd, name, 0);\n        close_preserve_errno(nmap_dirfd);\n        close_preserve_errno(omap_dirfd);\n        if (ret < 0 && errno != ENOENT) {\n            goto err_undo_link;\n        }\n\n        ret = 0;\n    }\n    goto out_close;\n\nerr:\n    ret = -1;\nerr_undo_link:\n    unlinkat_preserve_errno(ndirfd, name, 0);\nout_close:\n    close_preserve_errno(ndirfd);\n    close_preserve_errno(odirfd);\nout:\n    g_free(oname);\n    g_free(odirpath);\n    return ret;\n}","23886":"  bool ms_verify_authorizer(Connection *con, int peer_type, int protocol,\n                            bufferlist& authorizer, bufferlist& authorizer_reply,\n                            bool& isvalid, CryptoKey& session_key) override {\n    isvalid = true;\n    return true;\n  }","24248":"void next_character(void)\n{\n    \n    strlcpy(cipher, english_alphabet, ENGLISH_ALPHABET_BUF);\n    random_permute_char(cipher, strlen(cipher));\n\n    static char CONFIDENTIAL current_word[CURRENT_WORD_BUF];\n    get_current_word(current_word);\n\n    \n    if (strlen(current_word) > 4) {\n        memzero(current_word, sizeof(current_word));\n\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_SyntaxError,\n                        \"STR\");\n        layoutHome();\n        return;\n    }\n\n    CharacterRequest resp;\n    memset(&resp, 0, sizeof(CharacterRequest));\n\n    resp.word_pos = get_current_word_pos();\n    resp.character_pos = strlen(current_word);\n\n    msg_write(MessageType_MessageType_CharacterRequest, &resp);\n\n    \n    bool auto_completed = false;\n    if (strlen(current_word) >= 3) {\n        auto_completed = attempt_auto_complete(current_word);\n    }\n\n#if DEBUG_LINK\n    if (auto_completed) {\n        strlcpy(auto_completed_word, current_word, CURRENT_WORD_BUF);\n    } else {\n        auto_completed_word[0] = '\\0';\n    }\n#endif\n\n    \n    format_current_word(current_word, auto_completed);\n\n    \n    layout_cipher(current_word, cipher);\n    memzero(current_word, sizeof(current_word));\n}","24382":"  Env *DefaultEnv::GetEnv()\n  {\n    return sEnv;\n  }","24274":"write_vector_vector(BitWriter& w,\n\t\t    int nitems1, std::vector<T>& vec1, int T::*nitems2,\n\t\t    int bits, std::vector<int> T::*vec2)\n{\n    \n    \n    for (int i1 = 0; i1 < nitems1; ++i1)\n    {\n\tfor (int i2 = 0; i2 < vec1.at(i1).*nitems2; ++i2)\n\t{\n\t    w.writeBits((vec1.at(i1).*vec2).at(i2), bits);\n\t}\n    }\n    w.flush();\n}","23996":"Method* InstanceKlass::find_local_method(const Array<Method*>* methods,\n                                         const Symbol* name,\n                                         const Symbol* signature,\n                                         OverpassLookupMode overpass_mode,\n                                         StaticLookupMode static_mode,\n                                         PrivateLookupMode private_mode) {\n  return InstanceKlass::find_method_impl(methods,\n                                         name,\n                                         signature,\n                                         overpass_mode,\n                                         static_mode,\n                                         private_mode);\n}","24131":"void CLASS unpacked_load_raw()\n{\n  int row, col, bits=0;\n\n  while (1 << ++bits < maximum);\n  read_shorts (raw_image, raw_width*raw_height);\n  for (row=0; row < raw_height; row++)\n    for (col=0; col < raw_width; col++)\n      if ((RAW(row,col) >>= load_flags) >> bits\n\t&& (unsigned) (row-top_margin) < height\n\t&& (unsigned) (col-left_margin) < width) derror();\n}","23870":"  epoch_t get_osdmap_epoch() const {\n    return osdmap ? osdmap->get_epoch() : 0;\n  }","24037":"RBinSection *getsection(RBin *a, const char *sn) {\n\tRListIter *iter;\n\tRBinSection *section = NULL;\n\tRBinFile *binfile = a ? a->cur: NULL;\n\tRBinObject *o = binfile ? binfile->o : NULL;\n\n\tif ( o && o->sections) {\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tif (strstr (section->name, sn)) {\n\t\t\t\treturn section;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}","24180":"crm_recv_remote_msg(void *session, gboolean encrypted)\n{\n    char *reply = NULL;\n    xmlNode *xml = NULL;\n\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        reply = cib_recv_tls(session);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        reply = cib_recv_plaintext(GPOINTER_TO_INT(session));\n    }\n    if (reply == NULL || strlen(reply) == 0) {\n        crm_trace(\"STR\");\n\n    } else {\n        xml = string2xml(reply);\n        if (xml == NULL) {\n            crm_err(\"STR\", reply);\n        }\n    }\n\n    free(reply);\n    return xml;\n}","24442":"TEST_P(ProtocolIntegrationTest, MaxStreamDurationWithRetryPolicyWhenRetryUpstreamDisconnection) {\n  testMaxStreamDurationWithRetry(true);\n}","24795":"struct phy_device *mdiobus_get_phy(struct mii_bus *bus, int addr)\n{\n\tstruct mdio_device *mdiodev = bus->mdio_map[addr];\n\n\tif (!mdiodev)\n\t\treturn NULL;\n\n\tif (!(mdiodev->flags & MDIO_DEVICE_FLAG_PHY))\n\t\treturn NULL;\n\n\treturn container_of(mdiodev, struct phy_device, mdio);\n}","24517":"QPDF_Stream::replaceFilterData(QPDFObjectHandle const& filter,\n\t\t\t       QPDFObjectHandle const& decode_parms,\n\t\t\t       size_t length)\n{\n    this->stream_dict.replaceOrRemoveKey(\"STR\", filter);\n    this->stream_dict.replaceOrRemoveKey(\"STR\", decode_parms);\n    if (length == 0)\n    {\n        QTC::TC(\"STR\");\n        this->stream_dict.removeKey(\"STR\");\n    }\n    else\n    {\n        this->stream_dict.replaceKey(\n            \"STR\", QPDFObjectHandle::newInteger(length));\n    }\n}","24756":"static void gf_m2ts_process_pat(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *ses, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)\n{\n\tGF_M2TS_Program *prog;\n\tGF_M2TS_SECTION_ES *pmt;\n\tu32 i, nb_progs, evt_type;\n\tu32 nb_sections;\n\tu32 data_size;\n\tunsigned char *data;\n\tGF_M2TS_Section *section;\n\n\t\n\tif (!(status&GF_M2TS_TABLE_END)) return;\n\n\t\n\tif (status&GF_M2TS_TABLE_REPEAT) {\n\t\tif (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PAT_REPEAT, NULL);\n\t\treturn;\n\t}\n\n\tnb_sections = gf_list_count(sections);\n\tif (nb_sections > 1) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"STR\"));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\tif (!(status&GF_M2TS_TABLE_UPDATE) && gf_list_count(ts->programs)) {\n\t\tif (ts->pat->demux_restarted) {\n\t\t\tts->pat->demux_restarted = 0;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"STR\", table_id, ex_table_id));\n\t\t}\n\t\treturn;\n\t}\n\tnb_progs = data_size \/ 4;\n\n\tfor (i=0; i<nb_progs; i++) {\n\t\tu16 number, pid;\n\t\tnumber = (data[0]<<8) | data[1];\n\t\tpid = (data[2]&0x1f)<<8 | data[3];\n\t\tdata += 4;\n\t\tif (number==0) {\n\t\t\tif (!ts->nit) {\n\t\t\t\tts->nit = gf_m2ts_section_filter_new(gf_m2ts_process_nit, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tGF_SAFEALLOC(prog, GF_M2TS_Program);\n\t\t\tif (!prog) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"STR\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprog->streams = gf_list_new();\n\t\t\tprog->pmt_pid = pid;\n\t\t\tprog->number = number;\n\t\t\tprog->ts = ts;\n\t\t\tgf_list_add(ts->programs, prog);\n\t\t\tGF_SAFEALLOC(pmt, GF_M2TS_SECTION_ES);\n\t\t\tif (!pmt) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"STR\", pid));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpmt->flags = GF_M2TS_ES_IS_SECTION;\n\t\t\tgf_list_add(prog->streams, pmt);\n\t\t\tpmt->pid = prog->pmt_pid;\n\t\t\tpmt->program = prog;\n\t\t\tts->ess[pmt->pid] = (GF_M2TS_ES *)pmt;\n\t\t\tpmt->sec = gf_m2ts_section_filter_new(gf_m2ts_process_pmt, 0);\n\t\t}\n\t}\n\n\tevt_type = (status&GF_M2TS_TABLE_UPDATE) ? GF_M2TS_EVT_PAT_UPDATE : GF_M2TS_EVT_PAT_FOUND;\n\tif (ts->on_event) ts->on_event(ts, evt_type, NULL);\n}","25023":"int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tunsigned char *p;\n\tint ok = 0;\n\tint r;\n\tsize_t len;\n\n\tsc_format_path(str_path, &path);\n\tif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\n\t\tgoto err;\n\t}\n\n\tlen = file ? file->size : 4096;\n\tp = realloc(*data, len);\n\tif (!p) {\n\t\tgoto err;\n\t}\n\t*data = p;\n\t*data_len = len;\n\n\tr = sc_read_binary(card, 0, p, len, 0);\n\tif (r < 0)\n\t\tgoto err;\n\n\t*data_len = r;\n\tok = 1;\n\nerr:\n\tsc_file_free(file);\n\n\treturn ok;\n}","24256":"void CLASS rollei_load_raw()\n{\n  uchar pixel[10];\n  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(raw_width > 32767 || raw_height > 32767)\n    throw LIBRAW_EXCEPTION_IO_BADFILE;\n#endif\n  unsigned maxpixel = raw_width*(raw_height+7);\n\n  isix = raw_width * raw_height * 5 \/ 8;\n  while (fread (pixel, 1, 10, ifp) == 10) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (i=0; i < 10; i+=2) {\n      todo[i]   = iten++;\n      todo[i+1] = pixel[i] << 8 | pixel[i+1];\n      buffer    = pixel[i] >> 2 | buffer << 6;\n    }\n    for (   ; i < 16; i+=2) {\n      todo[i]   = isix++;\n      todo[i+1] = buffer >> (14-i)*5;\n    }\n    for (i = 0; i < 16; i += 2)\n      if(todo[i] < maxpixel)\n        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n      else\n        derror();\n  }\n  maximum = 0x3ff;\n}","24022":"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_setting_default(\n\t\t\t\t\tpjmedia_rtcp_fb_setting *opt)\n{\n    pj_bzero(opt, sizeof(*opt));\n    opt->dont_use_avpf = PJ_TRUE;\n\n    return PJ_SUCCESS;\n}","24624":"void run(char const* filename, char const* filter,\n         bool encode, unsigned int columns,\n         int bits_per_sample, int samples_per_pixel)\n{\n    FILE* in = QUtil::safe_fopen(filename, \"STR\");\n    FILE* o1 = QUtil::safe_fopen(\"STR\");\n    Pipeline* out = new Pl_StdioFile(\"STR\", o1);\n    Pipeline* pl = 0;\n    if (strcmp(filter, \"STR\") == 0)\n    {\n        pl = new Pl_PNGFilter(\n            \"STR\", out,\n            encode ? Pl_PNGFilter::a_encode : Pl_PNGFilter::a_decode,\n            columns, samples_per_pixel, bits_per_sample);\n    }\n    else if (strcmp(filter, \"STR\") == 0)\n    {\n        pl = new Pl_TIFFPredictor(\n            \"STR\", out,\n            encode ? Pl_TIFFPredictor::a_encode : Pl_TIFFPredictor::a_decode,\n            columns, samples_per_pixel, bits_per_sample);\n    }\n    else\n    {\n        std::cerr << \"STR\" << filter << std::endl;\n        exit(2);\n    }\n    assert((2 * (columns + 1)) < 1024);\n    unsigned char buf[1024];\n    size_t len;\n    while (true)\n    {\n\tlen = fread(buf, 1, (2 * columns) + 1, in);\n\tif (len == 0)\n\t{\n\t    break;\n\t}\n\tpl->write(buf, len);\n\tlen = fread(buf, 1, 1, in);\n\tif (len == 0)\n\t{\n\t    break;\n\t}\n\tpl->write(buf, len);\n\tlen = fread(buf, 1, 1, in);\n\tif (len == 0)\n\t{\n\t    break;\n\t}\n\tpl->write(buf, len);\n    }\n\n    pl->finish();\n    delete pl;\n    delete out;\n    fclose(o1);\n    fclose(in);\n\n    std::cout << \"STR\" << std::endl;\n}","23979":"static int jsR_hasproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Property *ref;\n\tint k;\n\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"STR\")) {\n\t\t\tjs_pushnumber(J, obj->u.a.length);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"STR\")) {\n\t\t\tjs_pushnumber(J, obj->u.s.length);\n\t\t\treturn 1;\n\t\t}\n\t\tif (js_isarrayindex(J, name, &k)) {\n\t\t\tjs_pushrune(J, js_runeat(J, obj->u.s.string, k));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"STR\")) {\n\t\t\tjs_pushliteral(J, obj->u.r.source);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"STR\")) {\n\t\t\tjs_pushboolean(J, obj->u.r.flags & JS_REGEXP_G);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"STR\")) {\n\t\t\tjs_pushboolean(J, obj->u.r.flags & JS_REGEXP_I);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"STR\")) {\n\t\t\tjs_pushboolean(J, obj->u.r.flags & JS_REGEXP_M);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"STR\")) {\n\t\t\tjs_pushnumber(J, obj->u.r.last);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.has && obj->u.user.has(J, obj->u.user.data, name))\n\t\t\treturn 1;\n\t}\n\n\tref = jsV_getproperty(J, obj, name);\n\tif (ref) {\n\t\tif (ref->getter) {\n\t\t\tjs_pushobject(J, ref->getter);\n\t\t\tjs_pushobject(J, obj);\n\t\t\tjs_call(J, 0);\n\t\t} else {\n\t\t\tjs_pushvalue(J, ref->value);\n\t\t}\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}","24235":"static void process_stat_settings(ADD_STAT add_stats, void *c) {\n    assert(add_stats);\n    APPEND_STAT(\"STR\", (unsigned long long)settings.maxbytes);\n    APPEND_STAT(\"STR\", settings.maxconns);\n    APPEND_STAT(\"STR\", settings.port);\n    APPEND_STAT(\"STR\", settings.udpport);\n    APPEND_STAT(\"STR\");\n    APPEND_STAT(\"STR\", settings.verbose);\n    APPEND_STAT(\"STR\", (unsigned long)settings.oldest_live);\n    APPEND_STAT(\"STR\");\n    APPEND_STAT(\"STR\",\n                settings.socketpath ? settings.socketpath : \"STR\");\n    APPEND_STAT(\"STR\", settings.access);\n    APPEND_STAT(\"STR\", settings.factor);\n    APPEND_STAT(\"STR\", settings.chunk_size);\n    APPEND_STAT(\"STR\", settings.num_threads);\n    APPEND_STAT(\"STR\", settings.num_threads_per_udp);\n    APPEND_STAT(\"STR\", settings.prefix_delimiter);\n    APPEND_STAT(\"STR\",\n                settings.detail_enabled ? \"STR\");\n    APPEND_STAT(\"STR\", settings.reqs_per_event);\n    APPEND_STAT(\"STR\");\n    APPEND_STAT(\"STR\", settings.backlog);\n    APPEND_STAT(\"STR\",\n                prot_text(settings.binding_protocol));\n    APPEND_STAT(\"STR\");\n    APPEND_STAT(\"STR\", settings.item_size_max);\n    APPEND_STAT(\"STR\");\n    APPEND_STAT(\"STR\", settings.hashpower_init);\n    APPEND_STAT(\"STR\");\n    APPEND_STAT(\"STR\", settings.slab_automove);\n    APPEND_STAT(\"STR\", settings.tail_repair_time);\n    APPEND_STAT(\"STR\");\n}","23834":"authentic_match_card(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tint i;\n\n\tsc_log_hex(ctx, \"STR\", card->atr.value, card->atr.len);\n\ti = _sc_match_atr(card, authentic_known_atrs, &card->type);\n\tif (i < 0)   {\n\t\tsc_log(ctx, \"STR\");\n\t\treturn 0;\n\t}\n\n\tsc_log(ctx, \"STR\", authentic_known_atrs[i].name);\n\treturn 1;\n}","24106":"g_execvp(const char* p1, char* args[])\n{\n#if defined(_WIN32)\n  return 0;\n#else\n  return execvp(p1, args);\n#endif\n}","24851":"_vte_table_printi(struct _vte_table *table, const char *lead, int *count)\n{\n\tunsigned int i;\n\tchar *newlead = NULL;\n\n\t(*count)++;\n\n\t\n\tif (table->result != NULL) {\n\t\tg_printerr(\"STR\", lead,\n\t\t\ttable->result, table->increment);\n\t}\n\n\t\n\tfor (i = 1; i < VTE_TABLE_MAX_LITERAL; i++) {\n\t\tif ((table->table != NULL) && (table->table[i] != NULL)) {\n\t\t\tif (i < 32) {\n\t\t\t\tnewlead = g_strdup_printf(\"STR\", lead,\n\t\t\t\t\t\t\t  i + 64);\n\t\t\t} else {\n\t\t\t\tnewlead = g_strdup_printf(\"STR\", lead, i);\n\t\t\t}\n\t\t\t_vte_table_printi(table->table[i], newlead, count);\n\t\t\tg_free(newlead);\n\t\t}\n\t}\n\n\t\n\tif (table->table_string != NULL) {\n\t\tnewlead = g_strdup_printf(\"STR\", lead);\n\t\t_vte_table_printi(table->table_string,\n\t\t\t\t  newlead, count);\n\t\tg_free(newlead);\n\t}\n\n\t\n\tif (table->table_number != NULL) {\n\t\tnewlead = g_strdup_printf(\"STR\", lead);\n\t\t_vte_table_printi(table->table_number,\n\t\t\t\t  newlead, count);\n\t\tg_free(newlead);\n\t}\n}","24611":"static void DecodeIPv4inIPv6(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t plen, PacketQueue *pq)\n{\n\n    if (unlikely(plen < IPV4_HEADER_LEN)) {\n        ENGINE_SET_INVALID_EVENT(p, IPV4_IN_IPV6_PKT_TOO_SMALL);\n        return;\n    }\n    if (IP_GET_RAW_VER(pkt) == 4) {\n        if (pq != NULL) {\n            Packet *tp = PacketTunnelPktSetup(tv, dtv, p, pkt, plen, DECODE_TUNNEL_IPV4, pq);\n            if (tp != NULL) {\n                PKT_SET_SRC(tp, PKT_SRC_DECODER_IPV6);\n                \n                PacketEnqueue(pq,tp);\n                StatsIncr(tv, dtv->counter_ipv4inipv6);\n                return;\n            }\n        }\n    } else {\n        ENGINE_SET_EVENT(p, IPV4_IN_IPV6_WRONG_IP_VER);\n    }\n    return;\n}","24743":"int ecall_restore(const char *input, uint64_t input_len, char **output,\n                  uint64_t *output_len) {\n  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,\n                                                              input_len) ||\n      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(\n          output_len, sizeof(uint64_t)) ||\n      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(output,\n                                                              *output_len)) {\n    asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"STR\");\n  }\n  int result = 0;\n  size_t tmp_output_len;\n  try {\n    result = asylo::Restore(input, static_cast<size_t>(input_len), output,\n                            &tmp_output_len);\n  } catch (...) {\n    LOG(FATAL) << \"STR\";\n  }\n\n  if (output_len) {\n    *output_len = static_cast<uint64_t>(tmp_output_len);\n  }\n  return result;\n}","24323":"int setup_tests(void)\n{\n#ifndef OPENSSL_NO_DEPRECATED_3_0\n    ADD_TEST(test_long_32bit);\n    ADD_TEST(test_long_64bit);\n#endif\n    ADD_TEST(test_int32);\n    ADD_TEST(test_uint32);\n    ADD_TEST(test_int64);\n    ADD_TEST(test_uint64);\n    return 1;\n}","24035":"static int vmci_transport_send_conn_request(struct sock *sk, size_t size)\n{\n\treturn vmci_transport_send_control_pkt(sk,\n\t\t\t\t\tVMCI_TRANSPORT_PACKET_TYPE_REQUEST,\n\t\t\t\t\tsize, 0, NULL,\n\t\t\t\t\tVSOCK_PROTO_INVALID,\n\t\t\t\t\tVMCI_INVALID_HANDLE);\n}","24499":"static int clone_submodule(const char *path, const char *gitdir, const char *url,\n\t\t\t   const char *depth, struct string_list *reference,\n\t\t\t   int quiet, int progress)\n{\n\tstruct child_process cp = CHILD_PROCESS_INIT;\n\n\targv_array_push(&cp.args, \"STR\");\n\targv_array_push(&cp.args, \"STR\");\n\tif (quiet)\n\t\targv_array_push(&cp.args, \"STR\");\n\tif (progress)\n\t\targv_array_push(&cp.args, \"STR\");\n\tif (depth && *depth)\n\t\targv_array_pushl(&cp.args, \"STR\", depth, NULL);\n\tif (reference->nr) {\n\t\tstruct string_list_item *item;\n\t\tfor_each_string_list_item(item, reference)\n\t\t\targv_array_pushl(&cp.args, \"STR\",\n\t\t\t\t\t item->string, NULL);\n\t}\n\tif (gitdir && *gitdir)\n\t\targv_array_pushl(&cp.args, \"STR\", gitdir, NULL);\n\n\targv_array_push(&cp.args, url);\n\targv_array_push(&cp.args, path);\n\n\tcp.git_cmd = 1;\n\tprepare_submodule_repo_env(&cp.env_array);\n\tcp.no_stdin = 1;\n\n\treturn run_command(&cp);\n}","24868":"pk_transaction_get_state (PkTransaction *transaction)\n{\n\tg_return_val_if_fail (PK_IS_TRANSACTION (transaction), PK_TRANSACTION_STATE_UNKNOWN);\n\n\treturn transaction->priv->state;\n}","24633":"delegpt_add_target(struct delegpt* dp, struct regional* region, \n\tuint8_t* name, size_t namelen, struct sockaddr_storage* addr, \n\tsocklen_t addrlen, uint8_t bogus, uint8_t lame)\n{\n\tstruct delegpt_ns* ns = delegpt_find_ns(dp, name, namelen);\n\tlog_assert(!dp->dp_type_mlc);\n\tif(!ns) {\n\t\t\n\t\treturn 1;\n\t}\n\tif(!lame) {\n\t\tif(addr_is_ip6(addr, addrlen))\n\t\t\tns->got6 = 1;\n\t\telse\tns->got4 = 1;\n\t\tif(ns->got4 && ns->got6)\n\t\t\tns->resolved = 1;\n\t}\n\treturn delegpt_add_addr(dp, region, addr, addrlen, bogus, lame, NULL);\n}","24587":"static void carve_deps_at_address(RzDyldCache *cache, cache_img_t *img, HtPU *path_to_idx, ut64 address, int *deps, bool printing) {\n\tut64 pa = va2pa(address, cache->n_maps, cache->maps, cache->buf, 0, NULL, NULL);\n\tif (pa == UT64_MAX) {\n\t\treturn;\n\t}\n\tstruct MACH0_(mach_header) mh;\n\tif (rz_buf_fread_at(cache->buf, pa, (ut8 *)&mh, \"STR\", 1) != sizeof(struct MACH0_(mach_header))) {\n\t\treturn;\n\t}\n\tif (mh.magic != MH_MAGIC_64 || mh.sizeofcmds == 0) {\n\t\treturn;\n\t}\n\tut64 cmds_at = pa + sizeof(struct MACH0_(mach_header));\n\tut8 *cmds = malloc(mh.sizeofcmds + 1);\n\tif (!cmds || rz_buf_read_at(cache->buf, cmds_at, cmds, mh.sizeofcmds) != mh.sizeofcmds) {\n\t\tgoto beach;\n\t}\n\tcmds[mh.sizeofcmds] = 0;\n\tut8 *cursor = cmds;\n\tut8 *end = cmds + mh.sizeofcmds;\n\twhile (cursor < end) {\n\t\tut32 cmd = rz_read_le32(cursor);\n\t\tut32 cmdsize = rz_read_le32(cursor + sizeof(ut32));\n\t\tif (cmd == LC_LOAD_DYLIB ||\n\t\t\tcmd == LC_LOAD_WEAK_DYLIB ||\n\t\t\tcmd == LC_REEXPORT_DYLIB ||\n\t\t\tcmd == LC_LOAD_UPWARD_DYLIB) {\n\t\t\tbool found;\n\t\t\tif (cursor + 24 >= end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst char *key = (const char *)cursor + 24;\n\t\t\tsize_t dep_index = (size_t)ht_pu_find(path_to_idx, key, &found);\n\t\t\tif (!found || dep_index >= cache->hdr->imagesCount) {\n\t\t\t\tRZ_LOG_WARN(\"STR\", key);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdeps[dep_index]++;\n\t\t\tif (printing) {\n\t\t\t\tRZ_LOG_INFO(\"STR\", key);\n\t\t\t}\n\t\t}\n\t\tcursor += cmdsize;\n\t}\n\nbeach:\n\tfree(cmds);\n}","24063":"remove_hrtimer(struct hrtimer *timer, struct hrtimer_clock_base *base, bool restart)\n{\n\tif (hrtimer_is_queued(timer)) {\n\t\tu8 state = timer->state;\n\t\tint reprogram;\n\n\t\t\n\t\tdebug_deactivate(timer);\n\t\ttimer_stats_hrtimer_clear_start_info(timer);\n\t\treprogram = base->cpu_base == this_cpu_ptr(&hrtimer_bases);\n\n\t\tif (!restart)\n\t\t\tstate = HRTIMER_STATE_INACTIVE;\n\n\t\t__remove_hrtimer(timer, base, state, reprogram);\n\t\treturn 1;\n\t}\n\treturn 0;\n}","24108":"static double ipow( double n, int exp )\n{\n\tdouble r;\n\n\tif ( exp < 0 )\n\t\treturn 1.0 \/ ipow( n, -exp );\n\tr = 1;\n\twhile ( exp > 0 ) {\n\t\tif ( exp & 1 )\n\t\t\tr *= n;\n\t\texp >>= 1;\n\t\tn *= n;\n\t}\n\treturn r;\n}","24232":"\nstatic struct page **io_pin_pages(unsigned long ubuf, unsigned long len,\n\t\t\t\t  int *npages)\n{\n\tunsigned long start, end, nr_pages;\n\tstruct vm_area_struct **vmas = NULL;\n\tstruct page **pages = NULL;\n\tint i, pret, ret = -ENOMEM;\n\n\tend = (ubuf + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tstart = ubuf >> PAGE_SHIFT;\n\tnr_pages = end - start;\n\n\tpages = kvmalloc_array(nr_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages)\n\t\tgoto done;\n\n\tvmas = kvmalloc_array(nr_pages, sizeof(struct vm_area_struct *),\n\t\t\t      GFP_KERNEL);\n\tif (!vmas)\n\t\tgoto done;\n\n\tret = 0;\n\tmmap_read_lock(current->mm);\n\tpret = pin_user_pages(ubuf, nr_pages, FOLL_WRITE | FOLL_LONGTERM,\n\t\t\t      pages, vmas);\n\tif (pret == nr_pages) {\n\t\t\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct vm_area_struct *vma = vmas[i];\n\n\t\t\tif (vma_is_shmem(vma))\n\t\t\t\tcontinue;\n\t\t\tif (vma->vm_file &&\n\t\t\t    !is_file_hugepages(vma->vm_file)) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t*npages = nr_pages;\n\t} else {\n\t\tret = pret < 0 ? pret : -EFAULT;\n\t}\n\tmmap_read_unlock(current->mm);\n\tif (ret) {\n\t\t\n\t\tif (pret > 0)\n\t\t\tunpin_user_pages(pages, pret);\n\t\tgoto done;\n\t}\n\tret = 0;\ndone:\n\tkvfree(vmas);\n\tif (ret < 0) {\n\t\tkvfree(pages);\n\t\tpages = ERR_PTR(ret);\n\t}\n\treturn pages;","23841":"int main(int argc, char* argv[])\n{\n    if (argc != 7)\n    {\n\tstd::cerr << \"STR\"\n                  << \"STR\"\n                  << std::endl;\n\texit(2);\n    }\n    char* filter = argv[1];\n    bool encode = (strcmp(argv[2], \"STR\") == 0);\n    char* filename = argv[3];\n    int columns = QUtil::string_to_int(argv[4]);\n    int samples_per_pixel = QUtil::string_to_int(argv[5]);\n    int bits_per_sample = QUtil::string_to_int(argv[6]);\n\n    try\n    {\n\trun(filename, filter, encode,\n            columns, bits_per_sample, samples_per_pixel);\n    }\n    catch (std::exception& e)\n    {\n\tstd::cout << e.what() << std::endl;\n    }\n    return 0;\n}","23851":"static int econet_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sockaddr_ec *sec = (struct sockaddr_ec *)uaddr;\n\tstruct sock *sk;\n\tstruct econet_sock *eo;\n\n\t\n\n\tif (addr_len < sizeof(struct sockaddr_ec) ||\n\t    sec->sec_family != AF_ECONET)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&econet_mutex);\n\n\tsk = sock->sk;\n\teo = ec_sk(sk);\n\n\teo->cb\t    = sec->cb;\n\teo->port    = sec->port;\n\teo->station = sec->addr.station;\n\teo->net\t    = sec->addr.net;\n\n\tmutex_unlock(&econet_mutex);\n\n\treturn 0;\n}","24142":"static inline void sk_eat_skb(struct sock *sk, struct sk_buff *skb, bool copied_early)\n{\n\t__skb_unlink(skb, &sk->sk_receive_queue);\n\tif (!copied_early)\n\t\t__kfree_skb(skb);\n\telse\n\t\t__skb_queue_tail(&sk->sk_async_wait_queue, skb);\n}","23910":"ctl_putdata(\n\tconst char *dp,\n\tunsigned int dlen,\n\tint bin\t\t\t\n\t)\n{\n\tint overhead;\n\tunsigned int currentlen;\n\n\toverhead = 0;\n\tif (!bin) {\n\t\tdatanotbinflag = TRUE;\n\t\toverhead = 3;\n\t\tif (datasent) {\n\t\t\t*datapt++ = ',';\n\t\t\tdatalinelen++;\n\t\t\tif ((dlen + datalinelen + 1) >= MAXDATALINELEN) {\n\t\t\t\t*datapt++ = '\\r';\n\t\t\t\t*datapt++ = '\\n';\n\t\t\t\tdatalinelen = 0;\n\t\t\t} else {\n\t\t\t\t*datapt++ = ' ';\n\t\t\t\tdatalinelen++;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\twhile (dlen + overhead + datapt > dataend) {\n\t\t\n\t\tcurrentlen = MIN(dlen, (unsigned int)(dataend - datapt));\n\n\t\tmemcpy(datapt, dp, currentlen);\n\n\t\tdatapt += currentlen;\n\t\tdp += currentlen;\n\t\tdlen -= currentlen;\n\t\tdatalinelen += currentlen;\n\n\t\tctl_flushpkt(CTL_MORE);\n\t}\n\n\tmemcpy(datapt, dp, dlen);\n\tdatapt += dlen;\n\tdatalinelen += dlen;\n\tdatasent = TRUE;\n}","24273":"static int msg_parse_fetch (IMAP_HEADER *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp;\n\n  if (!s)\n    return -1;\n\n  while (*s)\n  {\n    SKIPWS (s);\n\n    if (ascii_strncasecmp (\"STR\", s, 5) == 0)\n    {\n      if ((s = msg_parse_flags (h, s)) == NULL)\n        return -1;\n    }\n    else if (ascii_strncasecmp (\"STR\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS (s);\n      if (mutt_atoui (s, &h->data->uid) < 0)\n        return -1;\n\n      s = imap_next_word (s);\n    }\n    else if (ascii_strncasecmp (\"STR\", s, 12) == 0)\n    {\n      s += 12;\n      SKIPWS (s);\n      if (*s != '\\\"')\n      {\n        dprint (1, (debugfile, \"STR\", s));\n        return -1;\n      }\n      s++;\n      ptmp = tmp;\n      while (*s && *s != '\\\"')\n        *ptmp++ = *s++;\n      if (*s != '\\\"')\n        return -1;\n      s++; \n      *ptmp = 0;\n      h->received = imap_parse_date (tmp);\n    }\n    else if (ascii_strncasecmp (\"STR\", s, 11) == 0)\n    {\n      s += 11;\n      SKIPWS (s);\n      ptmp = tmp;\n      while (isdigit ((unsigned char) *s))\n        *ptmp++ = *s++;\n      *ptmp = 0;\n      if (mutt_atol (tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if (!ascii_strncasecmp (\"STR\", s, 4) ||\n      !ascii_strncasecmp (\"STR\", s, 13))\n    {\n      \n      return -2;\n    }\n    else if (*s == ')')\n      s++; \n    else if (*s)\n    {\n      \n      imap_error (\"STR\", s);\n      return -1;\n    }\n  }\n\n  return 0;\n}","24279":"local block_state deflate_huff(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    int bflush;             \n\n    for (;;) {\n        \n        if (s->lookahead == 0) {\n            fill_window(s);\n            if (s->lookahead == 0) {\n                if (flush == Z_NO_FLUSH)\n                    return need_more;\n                break;      \n            }\n        }\n\n        \n        s->match_length = 0;\n        Tracevv((stderr,\"STR\", s->window[s->strstart]));\n        _tr_tally_lit (s, s->window[s->strstart], bflush);\n        s->lookahead--;\n        s->strstart++;\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}","23869":"int EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator,\n                           const BIGNUM *order, const BIGNUM *cofactor)\n{\n    if (generator == NULL) {\n        ECerr(EC_F_EC_GROUP_SET_GENERATOR, ERR_R_PASSED_NULL_PARAMETER);\n        return 0;\n    }\n\n    if (group->generator == NULL) {\n        group->generator = EC_POINT_new(group);\n        if (group->generator == NULL)\n            return 0;\n    }\n    if (!EC_POINT_copy(group->generator, generator))\n        return 0;\n\n    if (order != NULL) {\n        if (!BN_copy(&group->order, order))\n            return 0;\n    } else\n        BN_zero(&group->order);\n\n    if (cofactor != NULL) {\n        if (!BN_copy(&group->cofactor, cofactor))\n            return 0;\n    } else\n        BN_zero(&group->cofactor);\n\n    \n    if (EC_GROUP_VERSION(group)) {\n        \n        if (BN_is_odd(&group->order))\n            return ec_precompute_mont_data(group);\n\n        BN_MONT_CTX_free(group->mont_data);\n        group->mont_data = NULL;\n    }\n\n    return 1;\n}","24699":"char *VDir::MapPathA(const char *pInName)\n{   \n    char szBuffer[(MAX_PATH+1)*2];\n    char szlBuf[MAX_PATH+1];\n    int length = strlen(pInName);\n\n    if (!length)\n\treturn (char*)pInName;\n\n    if (length > MAX_PATH) {\n\tstrncpy(szlBuf, pInName, MAX_PATH);\n\tif (IsPathSep(pInName[0]) && !IsPathSep(pInName[1])) {   \n\t    \n\t    szlBuf[MAX_PATH-2] = '\\0';\n\t}\n\telse\n\t    szlBuf[MAX_PATH] = '\\0';\n\tpInName = szlBuf;\n    }\n    \n\n    if (pInName[1] == ':') {\n\t\n\tif (IsPathSep(pInName[2])) {\n\t    \n\t    DoGetFullPathNameA((char*)pInName, sizeof(szLocalBufferA), szLocalBufferA);\n\t}\n\telse {\n\t    \n\t    strcpy(szBuffer, GetDirA(DriveIndex(*pInName)));\n\t    strcat(szBuffer, &pInName[2]);\n\t    if(strlen(szBuffer) > MAX_PATH)\n\t\tszBuffer[MAX_PATH] = '\\0';\n\n\t    DoGetFullPathNameA(szBuffer, sizeof(szLocalBufferA), szLocalBufferA);\n\t}\n    }\n    else {\n\t\n\tif (IsPathSep(pInName[1]) && IsPathSep(pInName[0])) {\n\t    \n\t    DoGetFullPathNameA((char*)pInName, sizeof(szLocalBufferA), szLocalBufferA);\n\t}\n\telse {\n\t    strcpy(szBuffer, GetDefaultDirA());\n\t    if (IsPathSep(pInName[0])) {\n\t\t\n\t\tstrcpy(&szBuffer[2], pInName);\n\t\tDoGetFullPathNameA(szBuffer, sizeof(szLocalBufferA), szLocalBufferA);\n\t    }\n\t    else {\n\t\t\n\t\tif (IsSpecialFileName(pInName)) {\n\t\t    return (char*)pInName;\n\t\t}\n\t\telse {\n\t\t    strcat(szBuffer, pInName);\n\t\t    if (strlen(szBuffer) > MAX_PATH)\n\t\t\tszBuffer[MAX_PATH] = '\\0';\n\n\t\t    DoGetFullPathNameA(szBuffer, sizeof(szLocalBufferA), szLocalBufferA);\n\t\t}\n\t    }\n\t}\n    }\n\n    return szLocalBufferA;\n}","24192":"static void vhost_scsi_exit(void)\n{\n\tvhost_scsi_deregister_configfs();\n\tvhost_scsi_deregister();\n\tdestroy_workqueue(vhost_scsi_workqueue);\n};","24740":"dtls1_hm_fragment_new(unsigned long frag_len)\n\t{\n\thm_fragment *frag = NULL;\n\tunsigned char *buf = NULL;\n\n\tfrag = (hm_fragment *)OPENSSL_malloc(sizeof(hm_fragment));\n\tif ( frag == NULL)\n\t\treturn NULL;\n\n\tif (frag_len)\n\t\t{\n\t\tbuf = (unsigned char *)OPENSSL_malloc(frag_len);\n\t\tif ( buf == NULL)\n\t\t\t{\n\t\t\tOPENSSL_free(frag);\n\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\n\tfrag->fragment = buf;\n\n\treturn frag;\n\t}","23877":"static int crypto_init_shash_ops_compat(struct crypto_tfm *tfm)\n{\n\tstruct hash_tfm *crt = &tfm->crt_hash;\n\tstruct crypto_alg *calg = tfm->__crt_alg;\n\tstruct shash_alg *alg = __crypto_shash_alg(calg);\n\tstruct shash_desc **descp = crypto_tfm_ctx(tfm);\n\tstruct crypto_shash *shash;\n\tstruct shash_desc *desc;\n\n\tif (!crypto_mod_get(calg))\n\t\treturn -EAGAIN;\n\n\tshash = crypto_create_tfm(calg, &crypto_shash_type);\n\tif (IS_ERR(shash)) {\n\t\tcrypto_mod_put(calg);\n\t\treturn PTR_ERR(shash);\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(shash),\n\t\t       GFP_KERNEL);\n\tif (!desc) {\n\t\tcrypto_free_shash(shash);\n\t\treturn -ENOMEM;\n\t}\n\n\t*descp = desc;\n\tdesc->tfm = shash;\n\ttfm->exit = crypto_exit_shash_ops_compat;\n\n\tcrt->init = shash_compat_init;\n\tcrt->update = shash_compat_update;\n\tcrt->final  = shash_compat_final;\n\tcrt->digest = shash_compat_digest;\n\tcrt->setkey = shash_compat_setkey;\n\n\tcrt->digestsize = alg->digestsize;\n\n\treturn 0;\n}","24906":"static int sdp_parse_fmtp_config_h264(AVFormatContext *s,\n                                      AVStream *stream,\n                                      PayloadContext *h264_data,\n                                      const char *attr, const char *value)\n{\n    AVCodecParameters *par = stream->codecpar;\n\n    if (!strcmp(attr, \"STR\")) {\n        av_log(s, AV_LOG_DEBUG, \"STR\", atoi(value));\n        h264_data->packetization_mode = atoi(value);\n        \n        if (h264_data->packetization_mode > 1)\n            av_log(s, AV_LOG_ERROR,\n                   \"STR\");\n    } else if (!strcmp(attr, \"STR\")) {\n        if (strlen(value) == 6)\n            parse_profile_level_id(s, h264_data, value);\n    } else if (!strcmp(attr, \"STR\")) {\n        int ret;\n        if (value[strlen(value) - 1] == ',') {\n            av_log(s, AV_LOG_WARNING, \"STR\");\n            return 0;\n        }\n        par->extradata_size = 0;\n        av_freep(&par->extradata);\n        ret = ff_h264_parse_sprop_parameter_sets(s, &par->extradata,\n                                                 &par->extradata_size, value);\n        av_log(s, AV_LOG_DEBUG, \"STR\",\n               par->extradata, par->extradata_size);\n        return ret;\n    }\n    return 0;\n}","24757":"int rtl_usb_probe(struct usb_interface *intf,\n\t\t  const struct usb_device_id *id,\n\t\t  struct rtl_hal_cfg *rtl_hal_cfg)\n{\n\tint err;\n\tstruct ieee80211_hw *hw = NULL;\n\tstruct rtl_priv *rtlpriv = NULL;\n\tstruct usb_device\t*udev;\n\tstruct rtl_usb_priv *usb_priv;\n\n\thw = ieee80211_alloc_hw(sizeof(struct rtl_priv) +\n\t\t\t\tsizeof(struct rtl_usb_priv), &rtl_ops);\n\tif (!hw) {\n\t\tWARN_ONCE(true, \"STR\");\n\t\treturn -ENOMEM;\n\t}\n\trtlpriv = hw->priv;\n\trtlpriv->hw = hw;\n\trtlpriv->usb_data = kcalloc(RTL_USB_MAX_RX_COUNT, sizeof(u32),\n\t\t\t\t    GFP_KERNEL);\n\tif (!rtlpriv->usb_data)\n\t\treturn -ENOMEM;\n\n\t\n\tspin_lock_init(&rtlpriv->locks.usb_lock);\n\tINIT_WORK(&rtlpriv->works.fill_h2c_cmd,\n\t\t  rtl_fill_h2c_cmd_work_callback);\n\tINIT_WORK(&rtlpriv->works.lps_change_work,\n\t\t  rtl_lps_change_work_callback);\n\n\trtlpriv->usb_data_index = 0;\n\tinit_completion(&rtlpriv->firmware_loading_complete);\n\tSET_IEEE80211_DEV(hw, &intf->dev);\n\tudev = interface_to_usbdev(intf);\n\tusb_get_dev(udev);\n\tusb_priv = rtl_usbpriv(hw);\n\tmemset(usb_priv, 0, sizeof(*usb_priv));\n\tusb_priv->dev.intf = intf;\n\tusb_priv->dev.udev = udev;\n\tusb_set_intfdata(intf, hw);\n\t\n\trtlpriv->rtlhal.interface = INTF_USB;\n\trtlpriv->cfg = rtl_hal_cfg;\n\trtlpriv->intf_ops = &rtl_usb_ops;\n\t\n\t_rtl_usb_io_handler_init(&udev->dev, hw);\n\trtlpriv->cfg->ops->read_chip_version(hw);\n\t\n\trtlpriv->cfg->ops->read_eeprom_info(hw);\n\terr = _rtl_usb_init(hw);\n\tif (err)\n\t\tgoto error_out2;\n\trtl_usb_init_sw(hw);\n\t\n\terr = rtl_init_core(hw);\n\tif (err) {\n\t\tpr_err(\"STR\");\n\t\tgoto error_out2;\n\t}\n\tif (rtlpriv->cfg->ops->init_sw_vars(hw)) {\n\t\tpr_err(\"STR\");\n\t\tgoto error_out;\n\t}\n\trtlpriv->cfg->ops->init_sw_leds(hw);\n\n\terr = ieee80211_register_hw(hw);\n\tif (err) {\n\t\tpr_err(\"STR\");\n\t\terr = -ENODEV;\n\t\tgoto error_out;\n\t}\n\trtlpriv->mac80211.mac80211_registered = 1;\n\n\tset_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status);\n\treturn 0;\n\nerror_out:\n\trtl_deinit_core(hw);\nerror_out2:\n\t_rtl_usb_io_handler_release(hw);\n\tusb_put_dev(udev);\n\tcomplete(&rtlpriv->firmware_loading_complete);\n\treturn -ENODEV;\n}","24762":"static int data_pending(const struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n\n#ifdef ENABLE_QUIC\n  if(conn->transport == TRNSPRT_QUIC)\n    return Curl_quic_data_pending(data);\n#endif\n\n  \n  return conn->handler->protocol&(CURLPROTO_SCP|CURLPROTO_SFTP) ||\n#if defined(USE_NGHTTP2)\n    Curl_ssl_data_pending(conn, FIRSTSOCKET) ||\n    \n    ((conn->handler->protocol&PROTO_FAMILY_HTTP) && conn->httpversion >= 20);\n#else\n    Curl_ssl_data_pending(conn, FIRSTSOCKET);\n#endif\n}","24156":"static int btrfs_finish_sprout(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root = fs_info->chunk_root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_dev_item *dev_item;\n\tstruct btrfs_device *device;\n\tstruct btrfs_key key;\n\tu8 fs_uuid[BTRFS_FSID_SIZE];\n\tu8 dev_uuid[BTRFS_UUID_SIZE];\n\tu64 devid;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = BTRFS_DEV_ITEMS_OBJECTID;\n\tkey.offset = 0;\n\tkey.type = BTRFS_DEV_ITEM_KEY;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tleaf = path->nodes[0];\nnext_slot:\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tleaf = path->nodes[0];\n\t\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_DEV_ITEMS_OBJECTID ||\n\t\t    key.type != BTRFS_DEV_ITEM_KEY)\n\t\t\tbreak;\n\n\t\tdev_item = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t  struct btrfs_dev_item);\n\t\tdevid = btrfs_device_id(leaf, dev_item);\n\t\tread_extent_buffer(leaf, dev_uuid, btrfs_device_uuid(dev_item),\n\t\t\t\t   BTRFS_UUID_SIZE);\n\t\tread_extent_buffer(leaf, fs_uuid, btrfs_device_fsid(dev_item),\n\t\t\t\t   BTRFS_FSID_SIZE);\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,\n\t\t\t\t\t   fs_uuid);\n\t\tBUG_ON(!device); \n\n\t\tif (device->fs_devices->seeding) {\n\t\t\tbtrfs_set_device_generation(leaf, dev_item,\n\t\t\t\t\t\t    device->generation);\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t}\n\n\t\tpath->slots[0]++;\n\t\tgoto next_slot;\n\t}\n\tret = 0;\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}","25005":"bool WebContents::SendIPCMessageToFrame(bool internal,\n                                        int32_t frame_id,\n                                        const std::string& channel,\n                                        v8::Local<v8::Value> args) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  blink::CloneableMessage message;\n  if (!gin::ConvertFromV8(isolate, args, &message)) {\n    isolate->ThrowException(v8::Exception::Error(\n        gin::StringToV8(isolate, \"STR\")));\n    return false;\n  }\n  auto frames = web_contents()->GetAllFrames();\n  auto iter = std::find_if(frames.begin(), frames.end(), [frame_id](auto* f) {\n    return f->GetRoutingID() == frame_id;\n  });\n  if (iter == frames.end())\n    return false;\n  if (!(*iter)->IsRenderFrameLive())\n    return false;\n\n  mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n  (*iter)->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n  electron_renderer->Message(internal, channel, std::move(message),\n                             0 );\n  return true;\n}","24120":"static void __vt_event_dequeue(struct vt_event_wait *vw)\n{\n\tunsigned long flags;\n\n\t\n\tspin_lock_irqsave(&vt_event_lock, flags);\n\tlist_del(&vw->list);\n\tspin_unlock_irqrestore(&vt_event_lock, flags);\n}","24241":"static int usbhid_parse(struct hid_device *hid)\n{\n\tstruct usb_interface *intf = to_usb_interface(hid->dev.parent);\n\tstruct usb_host_interface *interface = intf->cur_altsetting;\n\tstruct usb_device *dev = interface_to_usbdev (intf);\n\tstruct hid_descriptor *hdesc;\n\tu32 quirks = 0;\n\tunsigned int rsize = 0;\n\tchar *rdesc;\n\tint ret, n;\n\n\tquirks = usbhid_lookup_quirk(le16_to_cpu(dev->descriptor.idVendor),\n\t\t\tle16_to_cpu(dev->descriptor.idProduct));\n\n\tif (quirks & HID_QUIRK_IGNORE)\n\t\treturn -ENODEV;\n\n\t\n\tif (interface->desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT) {\n\t\tif (interface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD ||\n\t\t\tinterface->desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE)\n\t\t\t\tquirks |= HID_QUIRK_NOGET;\n\t}\n\n\tif (usb_get_extra_descriptor(interface, HID_DT_HID, &hdesc) &&\n\t    (!interface->desc.bNumEndpoints ||\n\t     usb_get_extra_descriptor(&interface->endpoint[0], HID_DT_HID, &hdesc))) {\n\t\tdbg_hid(\"STR\");\n\t\treturn -ENODEV;\n\t}\n\n\thid->version = le16_to_cpu(hdesc->bcdHID);\n\thid->country = hdesc->bCountryCode;\n\n\tfor (n = 0; n < hdesc->bNumDescriptors; n++)\n\t\tif (hdesc->desc[n].bDescriptorType == HID_DT_REPORT)\n\t\t\trsize = le16_to_cpu(hdesc->desc[n].wDescriptorLength);\n\n\tif (!rsize || rsize > HID_MAX_DESCRIPTOR_SIZE) {\n\t\tdbg_hid(\"STR\", rsize);\n\t\treturn -EINVAL;\n\t}\n\n\trdesc = kmalloc(rsize, GFP_KERNEL);\n\tif (!rdesc)\n\t\treturn -ENOMEM;\n\n\thid_set_idle(dev, interface->desc.bInterfaceNumber, 0, 0);\n\n\tret = hid_get_class_descriptor(dev, interface->desc.bInterfaceNumber,\n\t\t\tHID_DT_REPORT, rdesc, rsize);\n\tif (ret < 0) {\n\t\tdbg_hid(\"STR\");\n\t\tkfree(rdesc);\n\t\tgoto err;\n\t}\n\n\tret = hid_parse_report(hid, rdesc, rsize);\n\tkfree(rdesc);\n\tif (ret) {\n\t\tdbg_hid(\"STR\");\n\t\tgoto err;\n\t}\n\n\thid->quirks |= quirks;\n\n\treturn 0;\nerr:\n\treturn ret;\n}","23852":"dissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n        proto_tree *tree, usb_conv_info_t *usb_conv_info)\n{\n    gint     offset_start;\n    guint16  bcdADC;\n    guint8   ver_major;\n    double   ver;\n    guint8   if_in_collection, i;\n    audio_conv_info_t *audio_conv_info;\n\n\n    offset_start = offset;\n\n    bcdADC = tvb_get_letohs(tvb, offset);\n    ver_major = USB_AUDIO_BCD44_TO_DEC(bcdADC>>8);\n    ver = ver_major + USB_AUDIO_BCD44_TO_DEC(bcdADC&0xFF) \/ 100.0;\n\n    proto_tree_add_double_format_value(tree, hf_ac_if_hdr_ver,\n            tvb, offset, 2, ver, \"STR\", ver);\n    audio_conv_info = (audio_conv_info_t *)usb_conv_info->class_data;\n    if(!audio_conv_info) {\n        audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);\n        usb_conv_info->class_data = audio_conv_info;\n        usb_conv_info->class_data_type = USB_CONV_AUDIO;\n        \n    } else if (usb_conv_info->class_data_type != USB_CONV_AUDIO) {\n        \n        return 0;\n    }\n    audio_conv_info->ver_major = ver_major;\n    offset += 2;\n\n    \n    if (ver_major==1) {\n        proto_tree_add_item(tree, hf_ac_if_hdr_total_len,\n                tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        offset += 2;\n        if_in_collection = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_ac_if_hdr_bInCollection,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n\n        for (i=0; i<if_in_collection; i++) {\n            proto_tree_add_item(tree, hf_ac_if_hdr_if_num,\n                    tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            offset++;\n        }\n    }\n\n    return offset-offset_start;\n}","23866":"rsvg_new_image (void)\n{\n    RsvgNodeImage *image;\n    image = g_new (RsvgNodeImage, 1);\n    _rsvg_node_init (&image->super);\n    g_assert (image->super.state);\n    image->img = NULL;\n    image->preserve_aspect_ratio = RSVG_ASPECT_RATIO_XMID_YMID;\n    image->x = image->y = image->w = image->h = _rsvg_css_parse_length (\"STR\");\n    image->super.free = rsvg_node_image_free;\n    image->super.draw = rsvg_node_image_draw;\n    image->super.set_atts = rsvg_node_image_set_atts;\n    return &image->super;\n}","24717":"static ssize_t host_features_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct vbg_dev *gdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"STR\", gdev->host_features);\n}","25048":"flatpak_dir_get_default_locale_languages (FlatpakDir *self)\n{\n  g_auto(GStrv) extra_languages = NULL;\n  const GPtrArray *langs;\n  int i;\n\n  extra_languages = flatpak_dir_get_config_strv (self, \"STR\");\n  for (i = 0; extra_languages != NULL && extra_languages[i] != NULL; i++)\n    {\n      \n      gchar *match = strpbrk (extra_languages[i], \"STR\");\n      if (match != NULL)\n        *match = '\\0';\n    }\n\n  if (flatpak_dir_is_user (self))\n    {\n      g_auto(GStrv) locale_langs = flatpak_get_current_locale_langs ();\n\n      return sort_strv (flatpak_strv_merge (extra_languages, locale_langs));\n    }\n\n  \n  langs = get_system_locales (self);\n\n  return sort_strv (flatpak_strv_merge (extra_languages, (char **) langs->pdata));\n}","23898":"rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings)\n{\n\trdpCredssp* credssp;\n\n\tcredssp = (rdpCredssp*) malloc(sizeof(rdpCredssp));\n\tZeroMemory(credssp, sizeof(rdpCredssp));\n\n\tif (credssp != NULL)\n\t{\n\t\tHKEY hKey;\n\t\tLONG status;\n\t\tDWORD dwType;\n\t\tDWORD dwSize;\n\n\t\tcredssp->instance = instance;\n\t\tcredssp->settings = settings;\n\t\tcredssp->server = settings->ServerMode;\n\t\tcredssp->transport = transport;\n\t\tcredssp->send_seq_num = 0;\n\t\tcredssp->recv_seq_num = 0;\n\t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n\n\t\tif (credssp->server)\n\t\t{\n\t\t\tstatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(\"STR\"),\n\t\t\t\t\t0, KEY_READ | KEY_WOW64_64KEY, &hKey);\n\n\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t{\n\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\"STR\"), NULL, &dwType, NULL, &dwSize);\n\n\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t{\n\t\t\t\t\tcredssp->SspiModule = (LPTSTR) malloc(dwSize + sizeof(TCHAR));\n\n\t\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\"STR\"), NULL, &dwType,\n\t\t\t\t\t\t\t(BYTE*) credssp->SspiModule, &dwSize);\n\n\t\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t\t{\n\t\t\t\t\t\t_tprintf(_T(\"STR\"), credssp->SspiModule);\n\t\t\t\t\t\tRegCloseKey(hKey);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn credssp;\n}","24092":"static int hash__init_new_context(struct mm_struct *mm)\n{\n\tint index;\n\n\tindex = hash__alloc_context_id();\n\tif (index < 0)\n\t\treturn index;\n\n\t\n\tif (mm->context.id == 0)\n\t\tslice_init_new_context_exec(mm);\n\n\tsubpage_prot_init_new_context(mm);\n\n\tpkey_mm_init(mm);\n\treturn index;\n}","24877":"  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    const string& name = handle.scalar<tstring>()();\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"STR\"));\n    OP_REQUIRES_OK(ctx, session_state->DeleteTensor(name));\n  }","23830":"static char *get_netscape_format(const struct Cookie *co)\n{\n  return aprintf(\n    \"STR\"     \n    \"STR\" \n    \"STR\"   \n    \"STR\"   \n    \"STR\"   \n    \"STR\"   \n    \"STR\"   \n    \"STR\",    \n    co->httponly?\"STR\",\n    \n    (co->tailmatch && co->domain && co->domain[0] != '.')? \"STR\",\n    co->domain?co->domain:\"STR\",\n    co->tailmatch?\"STR\",\n    co->path?co->path:\"STR\",\n    co->secure?\"STR\",\n    co->expires,\n    co->name,\n    co->value?co->value:\"\");\n}","24198":"int main( int argc, char *argv[] )\n{\n    ((void) argc);\n    ((void) argv);\n\n    printf(\"STR\"\n           \"STR\");\n    return( 0 );\n}","24204":"asmlinkage __visible void __attribute__((weak)) smp_threshold_interrupt(void)\n{\n}","23991":"check_item_writable(svar_T *sv, int check_writable, char_u *name)\n{\n    if ((check_writable == ASSIGN_CONST && sv->sv_const != 0)\n\t    || (check_writable == ASSIGN_FINAL\n\t\t\t\t\t      && sv->sv_const == ASSIGN_CONST))\n    {\n\tsemsg(_(e_cannot_change_readonly_variable_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}","25058":"bool Cipher::parseFinishKeyX(QByteArray key)\n{\n    QCA::Initializer init;\n\n    if (key.length() != 181)\n        return false;\n\n    QCA::SecureArray remoteKey = QByteArray::fromBase64(key.left(180));\n    QCA::DLGroup group(m_primeNum, QCA::BigInteger(2));\n\n    QCA::DHPublicKey remotePub(group, remoteKey);\n\n    if (remotePub.isNull())\n        return false;\n\n    if (m_tempKey.isNull())\n        return false;\n\n    QByteArray sharedKey = m_tempKey.deriveKey(remotePub).toByteArray();\n    sharedKey = QCA::Hash(\"STR\").hash(sharedKey).toByteArray().toBase64();\n\n    \n    while (sharedKey.endsWith('=')) sharedKey.chop(1);\n\n    bool success = setKey(sharedKey);\n\n    return success;\n}","24838":"  void used_tables_and_const_cache_update_and_join(uint argc, Item **argv)\n  {\n    for (uint i=0 ; i < argc ; i++)\n      used_tables_and_const_cache_update_and_join(argv[i]);\n  }","24653":"static void test_bug11037()\n{\n  MYSQL_STMT *stmt;\n  int rc;\n  const char *stmt_text;\n\n  myheader(\"STR\");\n\n  mysql_query(mysql, \"STR\");\n\n  rc= mysql_query(mysql, \"STR\");\n  myquery(rc);\n\n  rc= mysql_query(mysql, \"STR\");\n  myquery(rc);\n\n  stmt_text= \"STR\";\n  stmt= mysql_stmt_init(mysql);\n  rc= mysql_stmt_prepare(stmt, stmt_text, strlen(stmt_text));\n\n  \n  rc = mysql_stmt_fetch(stmt);\n  DIE_UNLESS(rc==1);\n  if (!opt_silent)\n    fprintf(stdout, \"STR\",\n            mysql_stmt_errno(stmt), mysql_stmt_error(stmt));\n\n  rc= mysql_stmt_execute(stmt);\n  check_execute(stmt, rc);\n\n  rc= mysql_stmt_fetch(stmt);\n  DIE_UNLESS(rc==0);\n\n  rc= mysql_stmt_fetch(stmt);\n  DIE_UNLESS(rc==MYSQL_NO_DATA);\n\n  rc= mysql_stmt_fetch(stmt);\n  DIE_UNLESS(rc==MYSQL_NO_DATA);\n\n  mysql_stmt_close(stmt);\n  rc= mysql_query(mysql, \"STR\");\n  myquery(rc);\n}","24146":"ofputil_encode_get_async_reply(const struct ofp_header *oh,\n                               const struct ofputil_async_cfg *ac)\n{\n    struct ofpbuf *buf;\n\n    enum ofpraw raw = (oh->version < OFP14_VERSION\n                       ? OFPRAW_OFPT13_GET_ASYNC_REPLY\n                       : OFPRAW_OFPT14_GET_ASYNC_REPLY);\n    struct ofpbuf *reply = ofpraw_alloc_reply(raw, oh, 0);\n    ofputil_put_async_config__(ac, reply,\n                               raw == OFPRAW_OFPT14_GET_ASYNC_REPLY,\n                               oh->version, UINT32_MAX);\n    return reply;\n\n    return buf;\n}","24833":"  virtual void updateHorizScaling(GfxState * ) {}","24133":"parse_MULTIPATH(const char *arg, struct ofpbuf *ofpacts,\n                enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return multipath_parse(ofpact_put_MULTIPATH(ofpacts), arg);\n}","24476":"static int __init acpi_custom_method_init(void)\n{\n\tif (!acpi_debugfs_dir)\n\t\treturn -ENOENT;\n\n\tcm_dentry = debugfs_create_file(\"STR\", S_IWUSR,\n\t\t\t\t\tacpi_debugfs_dir, NULL, &cm_fops);\n\tif (!cm_dentry)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}","24847":"ipv4_sanity_check(const struct ip_header *nh, size_t size,\n                  int *ip_lenp, uint16_t *tot_lenp)\n{\n    int ip_len;\n    uint16_t tot_len;\n\n    if (OVS_UNLIKELY(size < IP_HEADER_LEN)) {\n        return false;\n    }\n    ip_len = IP_IHL(nh->ip_ihl_ver) * 4;\n\n    if (OVS_UNLIKELY(ip_len < IP_HEADER_LEN || size < ip_len)) {\n        return false;\n    }\n\n    tot_len = ntohs(nh->ip_tot_len);\n    if (OVS_UNLIKELY(tot_len > size || ip_len > tot_len ||\n                size - tot_len > UINT8_MAX)) {\n        return false;\n    }\n\n    *ip_lenp = ip_len;\n    *tot_lenp = tot_len;\n\n    return true;\n}","24636":"static int peak_usb_set_bittiming(struct net_device *netdev)\n{\n\tstruct peak_usb_device *dev = netdev_priv(netdev);\n\tconst struct peak_usb_adapter *pa = dev->adapter;\n\n\tif (pa->dev_set_bittiming) {\n\t\tstruct can_bittiming *bt = &dev->can.bittiming;\n\t\tint err = pa->dev_set_bittiming(dev, bt);\n\n\t\tif (err)\n\t\t\tnetdev_info(netdev, \"STR\",\n\t\t\t\t    err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}","23977":"void safe_connect(MYSQL* mysql, const char *name, const char *host,\n                  const char *user, const char *pass, const char *db,\n                  int port, const char *sock)\n{\n  int failed_attempts= 0;\n\n  DBUG_ENTER(\"STR\");\n\n  verbose_msg(\"STR\"\n              \"STR\", \n              host, port, sock, user, name, failed_attempts);\n  while(!mysql_real_connect(mysql, host,user, pass, db, port, sock,\n                            CLIENT_MULTI_STATEMENTS | CLIENT_REMEMBER_OPTIONS))\n  {\n    \n\n    if ((mysql_errno(mysql) == CR_CONN_HOST_ERROR ||\n         mysql_errno(mysql) == CR_CONNECTION_ERROR) &&\n        failed_attempts < opt_max_connect_retries)\n    {\n      verbose_msg(\"STR\", failed_attempts,\n                  opt_max_connect_retries, mysql_errno(mysql),\n                  mysql_error(mysql));\n      my_sleep(connection_retry_sleep);\n    }\n    else\n    {\n      if (failed_attempts > 0)\n        die(\"STR\", name,\n            failed_attempts, mysql_errno(mysql), mysql_error(mysql));\n      else\n        die(\"STR\", name,\n            mysql_errno(mysql), mysql_error(mysql));\n    }\n    failed_attempts++;\n  }\n  verbose_msg(\"STR\");\n  DBUG_VOID_RETURN;\n}","24497":"static void trim_marked(struct audit_tree *tree)\n{\n\tstruct list_head *p, *q;\n\tspin_lock(&hash_lock);\n\tif (tree->goner) {\n\t\tspin_unlock(&hash_lock);\n\t\treturn;\n\t}\n\t\n\tfor (p = tree->chunks.next; p != &tree->chunks; p = q) {\n\t\tstruct node *node = list_entry(p, struct node, list);\n\t\tq = p->next;\n\t\tif (node->index & (1U<<31)) {\n\t\t\tlist_del_init(p);\n\t\t\tlist_add(p, &tree->chunks);\n\t\t}\n\t}\n\n\twhile (!list_empty(&tree->chunks)) {\n\t\tstruct node *node;\n\t\tstruct audit_chunk *chunk;\n\n\t\tnode = list_entry(tree->chunks.next, struct node, list);\n\n\t\t\n\t\tif (!(node->index & (1U<<31)))\n\t\t\tbreak;\n\n\t\tchunk = find_chunk(node);\n\t\tget_inotify_watch(&chunk->watch);\n\t\tspin_unlock(&hash_lock);\n\n\t\tuntag_chunk(chunk, node);\n\n\t\tput_inotify_watch(&chunk->watch);\n\t\tspin_lock(&hash_lock);\n\t}\n\tif (!tree->root && !tree->goner) {\n\t\ttree->goner = 1;\n\t\tspin_unlock(&hash_lock);\n\t\tmutex_lock(&audit_filter_mutex);\n\t\tkill_rules(tree);\n\t\tlist_del_init(&tree->list);\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tprune_one(tree);\n\t} else {\n\t\tspin_unlock(&hash_lock);\n\t}\n}","24281":"parser_parse_with_statement_start (parser_context_t *context_p) \n{\n  parser_with_statement_t with_statement;\n\n  if (context_p->status_flags & PARSER_IS_STRICT)\n  {\n    parser_raise_error (context_p, PARSER_ERR_WITH_NOT_ALLOWED);\n  }\n\n  parser_parse_enclosed_expr (context_p);\n\n#ifndef JERRY_NDEBUG\n  PARSER_PLUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_WITH_CONTEXT_STACK_ALLOCATION);\n#endif \n\n  uint8_t inside_with = (context_p->status_flags & PARSER_INSIDE_WITH) != 0;\n\n  context_p->status_flags |= PARSER_INSIDE_WITH;\n  parser_emit_cbc_ext_forward_branch (context_p,\n                                      CBC_EXT_WITH_CREATE_CONTEXT,\n                                      &with_statement.branch);\n\n  parser_stack_push (context_p, &with_statement, sizeof (parser_with_statement_t));\n  parser_stack_push_uint8 (context_p, inside_with);\n  parser_stack_push_uint8 (context_p, PARSER_STATEMENT_WITH);\n  parser_stack_iterator_init (context_p, &context_p->last_statement);\n} ","23899":"static void cume_distInvFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct CallCount *p;\n  UNUSED_PARAMETER(nArg); assert( nArg==0 );\n  UNUSED_PARAMETER(apArg);\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  p->nStep++;\n}","24465":"static void manager_invoke_notify_message(Manager *m, Unit *u, pid_t pid, const char *buf, size_t n, FDSet *fds) {\n        _cleanup_strv_free_ char **tags = NULL;\n\n        assert(m);\n        assert(u);\n        assert(buf);\n        assert(n > 0);\n\n        tags = strv_split(buf, \"STR\");\n        if (!tags) {\n                log_oom();\n                return;\n        }\n\n        if (UNIT_VTABLE(u)->notify_message)\n                UNIT_VTABLE(u)->notify_message(u, pid, tags, fds);\n        else\n                log_unit_debug(u, \"STR\");\n}","24670":"std::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"STR\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(nullptr);\n\t\tstrftime(lbuf, sizeof(lbuf), \"STR\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(base);\n\t}\n\treturn fn;\n}","24595":"int Curl_protocol_getsock(struct connectdata *conn,\n                          curl_socket_t *socks,\n                          int numsocks)\n{\n  if(conn->handler->proto_getsock)\n    return conn->handler->proto_getsock(conn, socks, numsocks);\n  \n  socks[0] = conn->sock[FIRSTSOCKET];\n  return GETSOCK_READSOCK(0) | GETSOCK_WRITESOCK(0);\n}","25024":"R_API int r_config_eval(RConfig *cfg, const char *str) {\n\tchar *ptr, *a, *b, name[1024];\n\tunsigned int len;\n\tif (!str || !cfg) {\n\t\treturn false;\n\t}\n\tlen = strlen (str) + 1;\n\tif (len >= sizeof (name)) {\n\t\treturn false;\n\t}\n\tmemcpy (name, str, len);\n\tstr = r_str_chop (name);\n\n\tif (!str) {\n\t\treturn false;\n\t}\n\n\tif (str[0] == '\\0' || !strcmp (str, \"STR\")) {\n\t\tr_config_list (cfg, NULL, 0);\n\t\treturn false;\n\t}\n\n\tif (str[0] == '-') {\n\t\tr_config_rm (cfg, str + 1);\n\t\treturn false;\n\t}\n\n\tptr = strchr (str, '=');\n\tif (ptr) {\n\t\t\n\t\tptr[0] = '\\0';\n\t\ta = r_str_chop (name);\n\t\tb = r_str_chop (ptr + 1);\n\t\t(void) r_config_set (cfg, a, b);\n\t} else {\n\t\tchar *foo = r_str_chop (name);\n\t\tif (foo[strlen (foo) - 1] == '.') {\n\t\t\tr_config_list (cfg, name, 0);\n\t\t\treturn false;\n\t\t} else {\n\t\t\t\n\t\t\tconst char *str = r_config_get (cfg, foo);\n\t\t\tif (str) {\n\t\t\t\tcfg->cb_printf (\"STR\",\n\t\t\t\t\t(((int) (size_t) str) == 1)? \"STR\": str);\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}","24732":"static int test_alt_chains_cert_forgery(void)\n{\n    int ret = 0;\n    int i;\n    X509 *x = NULL;\n    STACK_OF(X509) *untrusted = NULL;\n    BIO *bio = NULL;\n    X509_STORE_CTX *sctx = NULL;\n    X509_STORE *store = NULL;\n    X509_LOOKUP *lookup = NULL;\n\n    store = X509_STORE_new();\n    if (store == NULL)\n        goto err;\n\n    lookup = X509_STORE_add_lookup(store, X509_LOOKUP_file());\n    if (lookup == NULL)\n        goto err;\n    if(!X509_LOOKUP_load_file(lookup, \"STR\", X509_FILETYPE_PEM))\n        goto err;\n\n    untrusted = load_certs_from_file(\"STR\");\n\n    if ((bio = BIO_new_file(\"STR\")) == NULL)\n        goto err;\n\n    if((x = PEM_read_bio_X509(bio, NULL, 0, NULL)) == NULL)\n        goto err;\n\n    sctx = X509_STORE_CTX_new();\n    if (sctx == NULL)\n        goto err;\n\n    if (!X509_STORE_CTX_init(sctx, store, x, untrusted))\n        goto err;\n\n    i = X509_verify_cert(sctx);\n\n    if(i == 0 && X509_STORE_CTX_get_error(sctx) == X509_V_ERR_INVALID_CA) {\n        \n        ret = 1;\n    }\n err:\n    X509_STORE_CTX_free(sctx);\n    X509_free(x);\n    BIO_free(bio);\n    sk_X509_pop_free(untrusted, X509_free);\n    X509_STORE_free(store);\n    if (ret != 1)\n        ERR_print_errors_fp(stderr);\n    return ret;\n}","24401":"R_API st64 r_buf_fread_at(RBuffer *b, ut64 addr, ut8 *buf, const char *fmt, int n) {\n\tr_return_val_if_fail (b && buf && fmt, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tr = r_buf_fread (b, buf, fmt, n);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}","24125":"static void vgacon_flush_scrollback(struct vc_data *c)\n{\n\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\n\tvgacon_scrollback_reset(c->vc_num, size);\n}","24293":"cockpit_auth_empty_cookie_value (const gchar *path, gboolean secure)\n{\n  gchar *application = cockpit_auth_parse_application (path, NULL);\n  gchar *cookie = application_cookie_name (application);\n\n  \n  gchar *cookie_line = g_strdup_printf (\"STR\",\n                                        cookie,\n                                        secure ? \"STR\");\n\n  g_free (application);\n  g_free (cookie);\n\n  return cookie_line;\n}","23975":"vhost_user_get_inflight_fd(struct virtio_net **pdev,\n\t\t\t   VhostUserMsg *msg,\n\t\t\t   int main_fd __rte_unused)\n{\n\tstruct rte_vhost_inflight_info_packed *inflight_packed;\n\tuint64_t pervq_inflight_size, mmap_size;\n\tuint16_t num_queues, queue_size;\n\tstruct virtio_net *dev = *pdev;\n\tint fd, i, j;\n\tvoid *addr;\n\n\tif (msg->size != sizeof(msg->payload.inflight)) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"STR\",\n\t\t\tmsg->size);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\n\tif (dev->inflight_info == NULL) {\n\t\tdev->inflight_info = calloc(1,\n\t\t\t\t\t    sizeof(struct inflight_mem_info));\n\t\tif (!dev->inflight_info) {\n\t\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\t\"STR\");\n\t\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t\t}\n\t}\n\n\tnum_queues = msg->payload.inflight.num_queues;\n\tqueue_size = msg->payload.inflight.queue_size;\n\n\tVHOST_LOG_CONFIG(INFO, \"STR\",\n\t\tmsg->payload.inflight.num_queues);\n\tVHOST_LOG_CONFIG(INFO, \"STR\",\n\t\tmsg->payload.inflight.queue_size);\n\n\tif (vq_is_packed(dev))\n\t\tpervq_inflight_size = get_pervq_shm_size_packed(queue_size);\n\telse\n\t\tpervq_inflight_size = get_pervq_shm_size_split(queue_size);\n\n\tmmap_size = num_queues * pervq_inflight_size;\n\taddr = inflight_mem_alloc(\"STR\", mmap_size, &fd);\n\tif (!addr) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"STR\");\n\t\t\tmsg->payload.inflight.mmap_size = 0;\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tmemset(addr, 0, mmap_size);\n\n\tdev->inflight_info->addr = addr;\n\tdev->inflight_info->size = msg->payload.inflight.mmap_size = mmap_size;\n\tdev->inflight_info->fd = msg->fds[0] = fd;\n\tmsg->payload.inflight.mmap_offset = 0;\n\tmsg->fd_num = 1;\n\n\tif (vq_is_packed(dev)) {\n\t\tfor (i = 0; i < num_queues; i++) {\n\t\t\tinflight_packed =\n\t\t\t\t(struct rte_vhost_inflight_info_packed *)addr;\n\t\t\tinflight_packed->used_wrap_counter = 1;\n\t\t\tinflight_packed->old_used_wrap_counter = 1;\n\t\t\tfor (j = 0; j < queue_size; j++)\n\t\t\t\tinflight_packed->desc[j].next = j + 1;\n\t\t\taddr = (void *)((char *)addr + pervq_inflight_size);\n\t\t}\n\t}\n\n\tVHOST_LOG_CONFIG(INFO,\n\t\t\"STR\",\n\t\tmsg->payload.inflight.mmap_size);\n\tVHOST_LOG_CONFIG(INFO,\n\t\t\"STR\",\n\t\tmsg->payload.inflight.mmap_offset);\n\tVHOST_LOG_CONFIG(INFO,\n\t\t\"STR\", msg->fds[0]);\n\n\treturn RTE_VHOST_MSG_RESULT_REPLY;\n}","24710":"int main(void) {\n    char *output = NULL;\n    CuSuite* suite = CuSuiteNew();\n\n    abs_top_srcdir = getenv(\"STR\");\n    if (abs_top_srcdir == NULL)\n        die(\"STR\");\n\n    abs_top_builddir = getenv(\"STR\");\n    if (abs_top_builddir == NULL)\n        die(\"STR\");\n\n    if (asprintf(&src_root, \"STR\", abs_top_srcdir) < 0) {\n        die(\"STR\");\n    }\n\n    CuSuiteSetup(suite, setup, teardown);\n\n    SUITE_ADD_TEST(suite, testSaveNewFile);\n    SUITE_ADD_TEST(suite, testNonExistentLens);\n    SUITE_ADD_TEST(suite, testMultipleXfm);\n    SUITE_ADD_TEST(suite, testMtime);\n    SUITE_ADD_TEST(suite, testRelPath);\n    SUITE_ADD_TEST(suite, testDoubleSlashPath);\n\n    CuSuiteRun(suite);\n    CuSuiteSummary(suite, &output);\n    CuSuiteDetails(suite, &output);\n    printf(\"STR\", output);\n    free(output);\n    return suite->failCount;\n}","24243":"static struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,\n\t\t\t\t       int attr_len, bool log)\n{\n\n\tstruct sw_flow_actions *acts;\n\tint new_acts_size;\n\tsize_t req_size = NLA_ALIGN(attr_len);\n\tint next_offset = offsetof(struct sw_flow_actions, actions) +\n\t\t\t\t\t(*sfa)->actions_len;\n\n\tif (req_size <= (ksize(*sfa) - next_offset))\n\t\tgoto out;\n\n\tnew_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);\n\n\tif (new_acts_size > MAX_ACTIONS_BUFSIZE) {\n\t\tif ((MAX_ACTIONS_BUFSIZE - next_offset) < req_size) {\n\t\t\tOVS_NLERR(log, \"STR\",\n\t\t\t\t  MAX_ACTIONS_BUFSIZE);\n\t\t\treturn ERR_PTR(-EMSGSIZE);\n\t\t}\n\t\tnew_acts_size = MAX_ACTIONS_BUFSIZE;\n\t}\n\n\tacts = nla_alloc_flow_actions(new_acts_size);\n\tif (IS_ERR(acts))\n\t\treturn (void *)acts;\n\n\tmemcpy(acts->actions, (*sfa)->actions, (*sfa)->actions_len);\n\tacts->actions_len = (*sfa)->actions_len;\n\tacts->orig_len = (*sfa)->orig_len;\n\tkfree(*sfa);\n\t*sfa = acts;\n\nout:\n\t(*sfa)->actions_len += req_size;\n\treturn  (struct nlattr *) ((unsigned char *)(*sfa) + next_offset);\n}","23941":"int setup_tests(void)\n{\n    ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns));\n    return 1;\n}","24751":"TEST(WriterTest, WriteChar) {\n  CHECK_WRITE('a');\n}","24076":"mrb_f_send(mrb_state *mrb, mrb_value self)\n{\n  mrb_sym name;\n  mrb_value block, *regs;\n  mrb_method_t m;\n  struct RClass *c;\n  mrb_callinfo *ci = mrb->c->ci;\n  int n = ci->n;\n\n  if (ci->cci > CINFO_NONE) {\n  funcall:;\n    const mrb_value *argv;\n    mrb_int argc;\n    mrb_get_args(mrb, \"STR\", &name, &argv, &argc, &block);\n    return mrb_funcall_with_block(mrb, self, name, argc, argv, block);\n  }\n\n  regs = mrb->c->ci->stack+1;\n\n  if (n == 0) {\n    mrb_argnum_error(mrb, 0, 1, -1);\n  }\n  else if (n == 15) {\n    name = mrb_obj_to_sym(mrb, RARRAY_PTR(regs[0])[0]);\n  }\n  else {\n    name = mrb_obj_to_sym(mrb, regs[0]);\n  }\n\n  c = mrb_class(mrb, self);\n  m = mrb_method_search_vm(mrb, &c, name);\n  if (MRB_METHOD_UNDEF_P(m)) {            \n    goto funcall;\n  }\n\n  ci->mid = name;\n  ci->u.target_class = c;\n  \n  if (n == 15) {     \n    regs[0] = mrb_ary_subseq(mrb, regs[0], 1, RARRAY_LEN(regs[0]) - 1);\n  }\n  else { \n    for (int i=0; i<n; i++) {\n      regs[i] = regs[i+1];\n    }\n    regs[n] = regs[n+1];        \n    if (ci->nk > 0) {\n      regs[n+1] = regs[n+2];    \n    }\n    ci->n--;\n  }\n\n  if (MRB_METHOD_CFUNC_P(m)) {\n    if (MRB_METHOD_NOARG_P(m)) {\n      check_method_noarg(mrb, ci);\n    }\n\n    if (MRB_METHOD_PROC_P(m)) {\n      mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n    }\n    return MRB_METHOD_CFUNC(m)(mrb, self);\n  }\n  return exec_irep(mrb, self, MRB_METHOD_PROC(m));\n}","24349":"static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *ndev)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tint ret;\n\n\tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n\tret = hns_nic_net_xmit_hw(ndev, skb,\n\t\t\t\t  &tx_ring_data(priv, skb->queue_mapping));\n\tif (ret == NETDEV_TX_OK) {\n\t\tnetif_trans_update(ndev);\n\t\tndev->stats.tx_bytes += skb->len;\n\t\tndev->stats.tx_packets++;\n\t}\n\treturn (netdev_tx_t)ret;\n}","24515":"\n__wsum __skb_checksum(const struct sk_buff *skb, int offset, int len,\n\t\t      __wsum csum, const struct skb_checksum_ops *ops)\n{\n\tint start = skb_headlen(skb);\n\tint i, copy = start - offset;\n\tstruct sk_buff *frag_iter;\n\tint pos = 0;\n\n\t\n\tif (copy > 0) {\n\t\tif (copy > len)\n\t\t\tcopy = len;\n\t\tcsum = ops->update(skb->data + offset, copy, csum);\n\t\tif ((len -= copy) == 0)\n\t\t\treturn csum;\n\t\toffset += copy;\n\t\tpos\t= copy;\n\t}\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\t\tint end;\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\tWARN_ON(start > offset + len);\n\n\t\tend = start + skb_frag_size(frag);\n\t\tif ((copy = end - offset) > 0) {\n\t\t\tu32 p_off, p_len, copied;\n\t\t\tstruct page *p;\n\t\t\t__wsum csum2;\n\t\t\tu8 *vaddr;\n\n\t\t\tif (copy > len)\n\t\t\t\tcopy = len;\n\n\t\t\tskb_frag_foreach_page(frag,\n\t\t\t\t\t      frag->page_offset + offset - start,\n\t\t\t\t\t      copy, p, p_off, p_len, copied) {\n\t\t\t\tvaddr = kmap_atomic(p);\n\t\t\t\tcsum2 = ops->update(vaddr + p_off, p_len, 0);\n\t\t\t\tkunmap_atomic(vaddr);\n\t\t\t\tcsum = ops->combine(csum, csum2, pos, p_len);\n\t\t\t\tpos += p_len;\n\t\t\t}\n\n\t\t\tif (!(len -= copy))\n\t\t\t\treturn csum;\n\t\t\toffset += copy;\n\t\t}\n\t\tstart = end;\n\t}\n\n\tskb_walk_frags(skb, frag_iter) {\n\t\tint end;\n\n\t\tWARN_ON(start > offset + len);\n\n\t\tend = start + frag_iter->len;\n\t\tif ((copy = end - offset) > 0) {\n\t\t\t__wsum csum2;\n\t\t\tif (copy > len)\n\t\t\t\tcopy = len;\n\t\t\tcsum2 = __skb_checksum(frag_iter, offset - start,\n\t\t\t\t\t       copy, 0, ops);\n\t\t\tcsum = ops->combine(csum, csum2, pos, copy);\n\t\t\tif ((len -= copy) == 0)\n\t\t\t\treturn csum;\n\t\t\toffset += copy;\n\t\t\tpos    += copy;\n\t\t}\n\t\tstart = end;\n\t}\n\tBUG_ON(len);\n\n\treturn csum;","24171":"bool ConnectionManagerImpl::ActiveStreamDecoderFilter::recreateStream() {\n  \n  \n  \n  if (!complete() || parent_.stream_info_.bytesReceived() != 0) {\n    return false;\n  }\n  \n  \n  \n  RequestHeaderMapPtr request_headers(std::move(parent_.request_headers_));\n  ResponseEncoder* response_encoder = parent_.response_encoder_;\n  parent_.response_encoder_ = nullptr;\n  response_encoder->getStream().removeCallbacks(parent_);\n  \n  \n  parent_.connection_manager_.doEndStream(this->parent_);\n\n  RequestDecoder& new_stream = parent_.connection_manager_.newStream(*response_encoder, true);\n  \n  \n  \n  if (parent_.stream_info_.filter_state_->hasDataAtOrAboveLifeSpan(\n          StreamInfo::FilterState::LifeSpan::Request)) {\n    (*parent_.connection_manager_.streams_.begin())->stream_info_.filter_state_ =\n        std::make_shared<StreamInfo::FilterStateImpl>(\n            parent_.stream_info_.filter_state_->parent(),\n            StreamInfo::FilterState::LifeSpan::FilterChain);\n  }\n\n  new_stream.decodeHeaders(std::move(request_headers), true);\n  return true;\n}","24260":"static int filter_implies_image(fz_context *ctx, pdf_obj *o)\n{\n\tif (!o)\n\t\treturn 0;\n\tif (pdf_is_name(ctx, o))\n\t\treturn is_image_filter(pdf_to_name(ctx, o));\n\tif (pdf_is_array(ctx, o))\n\t{\n\t\tint i, len;\n\t\tlen = pdf_array_len(ctx, o);\n\t\tfor (i = 0; i < len; i++)\n\t\t\tif (is_image_filter(pdf_to_name(ctx, pdf_array_get(ctx, o, i))))\n\t\t\t\treturn 1;\n\t}\n\treturn 0;\n}","23976":"static int manage_rcvq(struct hfi1_ctxtdata *uctxt, unsigned subctxt,\n\t\t       int start_stop)\n{\n\tstruct hfi1_devdata *dd = uctxt->dd;\n\tunsigned int rcvctrl_op;\n\n\tif (subctxt)\n\t\tgoto bail;\n\t\n\tif (start_stop) {\n\t\t\n\t\tif (uctxt->rcvhdrtail_kvaddr)\n\t\t\tclear_rcvhdrtail(uctxt);\n\t\trcvctrl_op = HFI1_RCVCTRL_CTXT_ENB;\n\t} else {\n\t\trcvctrl_op = HFI1_RCVCTRL_CTXT_DIS;\n\t}\n\thfi1_rcvctrl(dd, rcvctrl_op, uctxt->ctxt);\n\t\nbail:\n\treturn 0;\n}","24519":"struct edns_option* edns_opt_copy_alloc(struct edns_option* list)\n{\n\tstruct edns_option* result = NULL, *cur = NULL, *s;\n\twhile(list) {\n\t\t\n\t\ts = memdup(list, sizeof(*list));\n\t\tif(!s) {\n\t\t\tedns_opt_list_free(result);\n\t\t\treturn NULL;\n\t\t}\n\t\ts->next = NULL;\n\n\t\t\n\t\tif(s->opt_data) {\n\t\t\ts->opt_data = memdup(s->opt_data, s->opt_len);\n\t\t\tif(!s->opt_data) {\n\t\t\t\tfree(s);\n\t\t\t\tedns_opt_list_free(result);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tif(cur)\n\t\t\tcur->next = s;\n\t\telse\tresult = s;\n\t\tcur = s;\n\n\t\t\n\t\tlist = list->next;\n\t}\n\treturn result;\n}","23832":"acpi_parse_x2apic_nmi(struct acpi_subtable_header *header,\n\t\t      const unsigned long end)\n{\n\tstruct acpi_madt_local_x2apic_nmi *x2apic_nmi = NULL;\n\n\tx2apic_nmi = (struct acpi_madt_local_x2apic_nmi *)header;\n\n\tif (BAD_MADT_ENTRY(x2apic_nmi, end))\n\t\treturn -EINVAL;\n\n\tacpi_table_print_madt_entry(header);\n\n\tif (x2apic_nmi->lint != 1)\n\t\tprintk(KERN_WARNING PREFIX \"STR\");\n\n\treturn 0;\n}","24351":"TPMI_ALG_ASYM_SCHEME_Unmarshal(TPMI_ALG_ASYM_SCHEME *target, BYTE **buffer, INT32 *size, BOOL allowNull)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM_ALG_ID_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n#if ALG_ECDH\n\t  case TPM_ALG_ECDH:\n#endif\n#if ALG_ECMQV\n\t  case TPM_ALG_ECMQV:\n#endif\n#if ALG_RSASSA\n\t  case TPM_ALG_RSASSA:\n#endif\n#if ALG_RSAPSS\n\t  case TPM_ALG_RSAPSS:\n#endif\n#if ALG_ECDSA\n\t  case TPM_ALG_ECDSA:\n#endif\n#if ALG_ECDAA\n\t  case TPM_ALG_ECDAA:\n#endif\n#if ALG_SM2\n\t  case TPM_ALG_SM2:\n#endif\n#if ALG_ECSCHNORR\n\t  case TPM_ALG_ECSCHNORR:\n#endif\n#if ALG_RSAES\n\t  case TPM_ALG_RSAES:\n#endif\n#if ALG_OAEP\n\t  case TPM_ALG_OAEP:\n#endif\n\t    break;\n\t  case TPM_ALG_NULL:\n\t    if (allowNull) {\n\t\tbreak;\n\t    }\n\t  default:\n\t    rc = TPM_RC_VALUE;\n\t}\n    }\n    return rc;\n}","23809":"int ip_output(struct sk_buff *skb)\n{\n\tIP_INC_STATS(IPSTATS_MIB_OUTREQUESTS);\n\n\tif (skb->len > dst_mtu(skb->dst) && !skb_shinfo(skb)->tso_size)\n\t\treturn ip_fragment(skb, ip_finish_output);\n\telse\n\t\treturn ip_finish_output(skb);\n}","24831":"host_is_tls_on_connect_port(int port)\n{\nint sep = 0;\nconst uschar * list = tls_in.on_connect_ports;\n\nif (tls_in.on_connect) return TRUE;\n\nfor (uschar * s, * end; s = string_nextinlist(&list, &sep, NULL, 0); )\n  if (Ustrtol(s, &end, 10) == port)\n    return TRUE;\n\nreturn FALSE;\n}","25049":"PHP_FUNCTION(ftok)\n{\n\tchar *pathname, *proj;\n\tint pathname_len, proj_len;\n\tkey_t k;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"STR\", &pathname, &pathname_len, &proj, &proj_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (pathname_len == 0){\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"STR\");\n\t\tRETURN_LONG(-1);\n\t}\n\n\tif (proj_len != 1){\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"STR\");\n\t\tRETURN_LONG(-1);\n    }\n\n\tif ((PG(safe_mode) && (!php_checkuid(pathname, NULL, CHECKUID_CHECK_FILE_AND_DIR))) || php_check_open_basedir(pathname TSRMLS_CC)) {\n\t\tRETURN_LONG(-1);\n\t}\n\n\tk = ftok(pathname, proj[0]);\n\tif (k == -1) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"STR\", strerror(errno));\n\t}\n\n\tRETURN_LONG(k);\n}","24834":"void mem_cgroup_cancel_charge_swapin(struct mem_cgroup *memcg)\n{\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\tif (!memcg)\n\t\treturn;\n\t__mem_cgroup_cancel_charge(memcg, 1);\n}","23793":"static int tstats_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, tstats_show, NULL);\n}","24728":"Bool gf_isom_has_padding_bits(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\n\tif (trak->Media->information->sampleTable->PaddingBits) return GF_TRUE;\n\treturn GF_FALSE;\n}","24385":"int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tint err = -EINVAL;\n\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\tid = kcontrol->id;\n\tdown_write(&card->controls_rwsem);\n\tif (snd_ctl_find_id(card, &id)) {\n\t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"STR\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}","24952":"nv_scroll_line(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n\tscroll_redraw(cap->arg, cap->count1);\n}","24891":"static bool validate_ipv6_net_dev(struct net_device *net_dev,\n\t\t\t\t  const struct sockaddr_in6 *dst_addr,\n\t\t\t\t  const struct sockaddr_in6 *src_addr)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tconst int strict = ipv6_addr_type(&dst_addr->sin6_addr) &\n\t\t\t   IPV6_ADDR_LINKLOCAL;\n\tstruct rt6_info *rt = rt6_lookup(dev_net(net_dev), &dst_addr->sin6_addr,\n\t\t\t\t\t &src_addr->sin6_addr, net_dev->ifindex,\n\t\t\t\t\t NULL, strict);\n\tbool ret;\n\n\tif (!rt)\n\t\treturn false;\n\n\tret = rt->rt6i_idev->dev == net_dev;\n\tip6_rt_put(rt);\n\n\treturn ret;\n#else\n\treturn false;\n#endif\n}","24428":"Curl_ssl_connect(struct Curl_easy *data, struct connectdata *conn,\n                 int sockindex)\n{\n  CURLcode result;\n\n#ifndef CURL_DISABLE_PROXY\n  if(conn->bits.proxy_ssl_connected[sockindex]) {\n    result = ssl_connect_init_proxy(conn, sockindex);\n    if(result)\n      return result;\n  }\n#endif\n\n  if(!ssl_prefs_check(data))\n    return CURLE_SSL_CONNECT_ERROR;\n\n  \n  conn->ssl[sockindex].use = TRUE;\n  conn->ssl[sockindex].state = ssl_connection_negotiating;\n\n  result = Curl_ssl->connect_blocking(data, conn, sockindex);\n\n  if(!result)\n    Curl_pgrsTime(data, TIMER_APPCONNECT); \n  else\n    conn->ssl[sockindex].use = FALSE;\n\n  return result;\n}","24121":"nsubtoks (int tindex)\n{\n  int ntoks1;\n\n  switch (dfa->tokens[tindex - 1])\n    {\n    default:\n      return 1;\n    case QMARK:\n    case STAR:\n    case PLUS:\n      return 1 + nsubtoks(tindex - 1);\n    case CAT:\n    case OR:\n      ntoks1 = nsubtoks(tindex - 1);\n      return 1 + ntoks1 + nsubtoks(tindex - 1 - ntoks1);\n    }\n}","23805":"Pl_LZWDecoder::getFirstChar(int code)\n{\n    unsigned char result = '\\0';\n    if (code < 256)\n    {\n\tresult = static_cast<unsigned char>(code);\n    }\n    else if (code > 257)\n    {\n\tunsigned int idx = code - 258;\n\tif (idx >= table.size())\n        {\n            throw std::logic_error(\n                \"STR\");\n        }\n\tBuffer& b = table.at(idx);\n\tresult = b.getBuffer()[0];\n    }\n    else\n    {\n        throw std::logic_error(\n            \"STR\" +\n            QUtil::int_to_string(code) + \"STR\");\n    }\n    return result;\n}","24808":"void HGraphBuilder::HandleLiteralCompareNil(CompareOperation* expr,\n                                            HValue* value,\n                                            NilValue nil) {\n  ASSERT(!HasStackOverflow());\n  ASSERT(current_block() != NULL);\n  ASSERT(current_block()->HasPredecessor());\n  EqualityKind kind =\n      expr->op() == Token::EQ_STRICT ? kStrictEquality : kNonStrictEquality;\n  HIsNilAndBranch* instr = new(zone()) HIsNilAndBranch(value, kind, nil);\n  instr->set_position(expr->position());\n  return ast_context()->ReturnControl(instr, expr->id());\n}","23789":"inline bool ShapeIsVector(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* shape = GetInput(context, node, kShapeTensor);\n  return (shape->dims->size == 1 && shape->type == kTfLiteInt32);\n}","24052":"static PHP_FUNCTION(preg_split)\n{\n\tchar\t\t\t\t*regex;\t\t\t\n\tchar\t\t\t\t*subject;\t\t\n\tint\t\t\t\t\t regex_len;\n\tint\t\t\t\t\t subject_len;\n\tlong\t\t\t\t limit_val = -1;\n\tlong\t\t\t\t flags = 0;\t\t\n\tpcre_cache_entry\t*pce;\t\t\t\n\n\t\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"STR\", &regex, &regex_len,\n\t\t\t\t\t\t\t  &subject, &subject_len, &limit_val, &flags) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\t\n\t\n\tif ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tphp_pcre_split_impl(pce, subject, subject_len, return_value, limit_val, flags TSRMLS_CC);\n}","24973":"PackLinuxElf32::check_pt_dynamic(Elf32_Phdr const *const phdr)\n{\n    unsigned t = get_te32(&phdr->p_offset), s = sizeof(Elf32_Dyn) + t;\n    unsigned vaddr = get_te32(&phdr->p_vaddr);\n    unsigned filesz = get_te32(&phdr->p_filesz), memsz = get_te32(&phdr->p_memsz);\n    unsigned align = get_te32(&phdr->p_align);\n    if (s < t || (u32_t)file_size < (filesz + t)\n    ||  t < (e_phnum*sizeof(Elf32_Phdr) + sizeof(Elf32_Ehdr))\n    ||  (3 & t) || (7 & (filesz | memsz))  \n    ||  (-1+ align) & (t ^ vaddr)\n    ||  (unsigned long)file_size <= memsz\n    ||  filesz < sizeof(Elf32_Dyn)\n    ||  memsz  < sizeof(Elf32_Dyn)\n    ||  filesz < memsz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \"STR\",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    sz_dynseg = memsz;\n    return t;\n}","23988":"static void xmlGROW (xmlParserCtxtPtr ctxt) {\n    unsigned long curEnd = ctxt->input->end - ctxt->input->cur;\n    unsigned long curBase = ctxt->input->cur - ctxt->input->base;\n\n    if (((curEnd > (unsigned long) XML_MAX_LOOKUP_LIMIT) ||\n         (curBase > (unsigned long) XML_MAX_LOOKUP_LIMIT)) &&\n         ((ctxt->input->buf) && (ctxt->input->buf->readcallback != (xmlInputReadCallback) xmlNop)) &&\n        ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, \"STR\");\n        xmlHaltParser(ctxt);\n\treturn;\n    }\n    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n    if ((ctxt->input->cur > ctxt->input->end) ||\n        (ctxt->input->cur < ctxt->input->base)) {\n        xmlHaltParser(ctxt);\n        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, \"STR\");\n\treturn;\n    }\n    if ((ctxt->input->cur != NULL) && (*ctxt->input->cur == 0) &&\n        (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0))\n\t    xmlPopInput(ctxt);\n}","24849":"CURLcode Curl_http_done(struct connectdata *conn,\n                        CURLcode status, bool premature)\n{\n  struct SessionHandle *data = conn->data;\n  struct HTTP *http =data->req.protop;\n\n  Curl_unencode_cleanup(conn);\n\n#ifdef USE_SPNEGO\n  if(data->state.proxyneg.state == GSS_AUTHSENT ||\n      data->state.negotiate.state == GSS_AUTHSENT)\n    Curl_cleanup_negotiate(data);\n#endif\n\n  \n  conn->fread_func = data->set.fread_func; \n  conn->fread_in = data->set.in; \n  conn->seek_func = data->set.seek_func; \n  conn->seek_client = data->set.seek_client; \n\n  if(http == NULL)\n    return CURLE_OK;\n\n  if(http->send_buffer) {\n    Curl_send_buffer *buff = http->send_buffer;\n\n    free(buff->buffer);\n    free(buff);\n    http->send_buffer = NULL; \n  }\n\n  if(HTTPREQ_POST_FORM == data->set.httpreq) {\n    data->req.bytecount = http->readbytecount + http->writebytecount;\n\n    Curl_formclean(&http->sendit); \n    if(http->form.fp) {\n      \n      fclose(http->form.fp);\n      http->form.fp = NULL;\n    }\n  }\n  else if(HTTPREQ_PUT == data->set.httpreq)\n    data->req.bytecount = http->readbytecount + http->writebytecount;\n\n  if(status)\n    return status;\n\n  if(!premature && \n     !conn->bits.retry &&\n     !data->set.connect_only &&\n     ((http->readbytecount +\n       data->req.headerbytecount -\n       data->req.deductheadercount)) <= 0) {\n    \n    failf(data, \"STR\");\n    return CURLE_GOT_NOTHING;\n  }\n\n  return CURLE_OK;\n}","24718":"static ssize_t acpi_table_aml_write(struct config_item *cfg,\n\t\t\t\t    const void *data, size_t size)\n{\n\tconst struct acpi_table_header *header = data;\n\tstruct acpi_table *table;\n\tint ret;\n\n\ttable = container_of(cfg, struct acpi_table, cfg);\n\n\tif (table->header) {\n\t\tpr_err(\"STR\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (header->length != size) {\n\t\tpr_err(\"STR\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(header->signature, ACPI_SIG_SSDT, 4)) {\n\t\tpr_err(\"STR\");\n\t\treturn -EINVAL;\n\t}\n\n\ttable = container_of(cfg, struct acpi_table, cfg);\n\n\ttable->header = kmemdup(header, header->length, GFP_KERNEL);\n\tif (!table->header)\n\t\treturn -ENOMEM;\n\n\tret = acpi_load_table(table->header, &table->index);\n\tif (ret) {\n\t\tkfree(table->header);\n\t\ttable->header = NULL;\n\t}\n\n\treturn ret;\n}","24894":"asmlinkage void do_notify_resume(__u32 thread_info_flags)\n{\n\t\n\tif (thread_info_flags & _TIF_SINGLESTEP)\n\t\tclear_thread_flag(TIF_SINGLESTEP);\n\n\t\n\tif (thread_info_flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))\n\t\tdo_signal();\n\n\t\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(__frame);\n\t}\n\n} ","24295":"static void vmx_flush_tlb_guest(struct kvm_vcpu *vcpu)\n{\n\t\n\tvpid_sync_context(vmx_get_current_vpid(vcpu));\n}","23863":"void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tstruct timespec64 ts64;\n\tbool sig_none;\n\n\tsig_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n\tiv = timr->it_interval;\n\n\t\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\t\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\n\t\n\tkc->clock_get(timr->it_clock, &ts64);\n\tnow = timespec64_to_ktime(ts64);\n\n\t\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += kc->timer_forward(timr, now);\n\n\tremaining = kc->timer_remaining(timr, now);\n\t\n\tif (remaining <= 0) {\n\t\t\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}","24638":"static void radix__arch_pick_mmap_layout(struct mm_struct *mm,\n\t\t\t\t\tunsigned long random_factor)\n{\n\tif (mmap_is_legacy()) {\n\t\tmm->mmap_base = TASK_UNMAPPED_BASE;\n\t\tmm->get_unmapped_area = radix__arch_get_unmapped_area;\n\t} else {\n\t\tmm->mmap_base = mmap_base(random_factor);\n\t\tmm->get_unmapped_area = radix__arch_get_unmapped_area_topdown;\n\t}\n}","24287":"static int ib_uverbs_event_fasync(int fd, struct file *filp, int on)\n{\n\tstruct ib_uverbs_event_file *file = filp->private_data;\n\n\treturn fasync_helper(fd, filp, on, &file->async_queue);\n}","23994":"frame_fix_width(win_T *wp)\n{\n    wp->w_frame->fr_width = wp->w_width + wp->w_vsep_width;\n}","24760":"static void ffprobe_cleanup(int ret)\n{\n    int i;\n    for (i = 0; i < FF_ARRAY_ELEMS(sections); i++)\n        av_dict_free(&(sections[i].entries_to_show));\n\n#if HAVE_THREADS\n    pthread_mutex_destroy(&log_mutex);\n#endif\n}","24941":"static int network_write (const data_set_t *ds, const value_list_t *vl,\n\t\tuser_data_t __attribute__((unused)) *user_data)\n{\n\tint status;\n\n\tif (!check_send_okay (vl))\n\t{\n#if COLLECT_DEBUG\n\t  char name[6*DATA_MAX_NAME_LEN];\n\t  FORMAT_VL (name, sizeof (name), vl);\n\t  name[sizeof (name) - 1] = 0;\n\t  DEBUG (\"STR\"\n\t      \"STR\", name);\n#endif\n\t  \n\t  pthread_mutex_lock (&stats_lock);\n\t  stats_values_not_sent++;\n\t  pthread_mutex_unlock (&stats_lock);\n\t  return (0);\n\t}\n\n\tuc_meta_data_add_unsigned_int (vl,\n\t    \"STR\", (uint64_t) vl->time);\n\n\tpthread_mutex_lock (&send_buffer_lock);\n\n\tstatus = add_to_buffer (send_buffer_ptr,\n\t\t\tnetwork_config_packet_size - (send_buffer_fill + BUFF_SIG_SIZE),\n\t\t\t&send_buffer_vl,\n\t\t\tds, vl);\n\tif (status >= 0)\n\t{\n\t\t\n\t\tsend_buffer_fill += status;\n\t\tsend_buffer_ptr  += status;\n\n\t\tstats_values_sent++;\n\t}\n\telse\n\t{\n\t\tflush_buffer ();\n\n\t\tstatus = add_to_buffer (send_buffer_ptr,\n\t\t\t\tnetwork_config_packet_size - (send_buffer_fill + BUFF_SIG_SIZE),\n\t\t\t\t&send_buffer_vl,\n\t\t\t\tds, vl);\n\n\t\tif (status >= 0)\n\t\t{\n\t\t\tsend_buffer_fill += status;\n\t\t\tsend_buffer_ptr  += status;\n\n\t\t\tstats_values_sent++;\n\t\t}\n\t}\n\n\tif (status < 0)\n\t{\n\t\tERROR (\"STR\"\n\t\t\t\t\"STR\");\n\t}\n\telse if ((network_config_packet_size - send_buffer_fill) < 15)\n\t{\n\t\tflush_buffer ();\n\t}\n\n\tpthread_mutex_unlock (&send_buffer_lock);\n\n\treturn ((status < 0) ? -1 : 0);\n} ","24746":"\nvoid __skb_tstamp_tx(struct sk_buff *orig_skb,\n\t\t     struct skb_shared_hwtstamps *hwtstamps,\n\t\t     struct sock *sk, int tstype)\n{\n\tstruct sk_buff *skb;\n\tbool tsonly;\n\n\tif (!sk)\n\t\treturn;\n\n\ttsonly = sk->sk_tsflags & SOF_TIMESTAMPING_OPT_TSONLY;\n\tif (!skb_may_tx_timestamp(sk, tsonly))\n\t\treturn;\n\n\tif (tsonly) {\n#ifdef CONFIG_INET\n\t\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS) &&\n\t\t    sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\tskb = tcp_get_timestamping_opt_stats(sk);\n\t\telse\n#endif\n\t\t\tskb = alloc_skb(0, GFP_ATOMIC);\n\t} else {\n\t\tskb = skb_clone(orig_skb, GFP_ATOMIC);\n\t}\n\tif (!skb)\n\t\treturn;\n\n\tif (tsonly) {\n\t\tskb_shinfo(skb)->tx_flags = skb_shinfo(orig_skb)->tx_flags;\n\t\tskb_shinfo(skb)->tskey = skb_shinfo(orig_skb)->tskey;\n\t}\n\n\tif (hwtstamps)\n\t\t*skb_hwtstamps(skb) = *hwtstamps;\n\telse\n\t\tskb->tstamp = ktime_get_real();\n\n\t__skb_complete_tx_timestamp(skb, sk, tstype);","24910":"static int bnx2x_reset_mcp_comp(struct bnx2x *bp, u32 magic_val)\n{\n\tint rc = bnx2x_init_shmem(bp);\n\n\t\n\tif (!CHIP_IS_E1(bp))\n\t\tbnx2x_clp_reset_done(bp, magic_val);\n\n\treturn rc;\n}","23958":"idna_to_ascii_lz (const char *input, char **output, int flags)\n{\n  char *utf8;\n  int rc;\n\n  utf8 = stringprep_locale_to_utf8 (input);\n  if (!utf8)\n    return IDNA_ICONV_ERROR;\n\n  rc = idna_to_ascii_8z (utf8, output, flags);\n\n  free (utf8);\n\n  return rc;\n}","24916":"static int __videobuf_mmap_mapper(struct videobuf_queue *q,\n\t\t\t struct vm_area_struct *vma)\n{\n\tstruct videbuf_vmalloc_memory *mem;\n\tstruct videobuf_mapping *map;\n\tunsigned int first;\n\tint retval;\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\n\t\n\tfor (first = 0; first < VIDEO_MAX_FRAME; first++) {\n\t\tif (NULL == q->bufs[first])\n\t\t\tcontinue;\n\n\t\tif (V4L2_MEMORY_MMAP != q->bufs[first]->memory)\n\t\t\tcontinue;\n\t\tif (q->bufs[first]->boff == offset)\n\t\t\tbreak;\n\t}\n\tif (VIDEO_MAX_FRAME == first) {\n\t\tdprintk(1,\"STR\",\n\t\t\t(vma->vm_pgoff << PAGE_SHIFT));\n\t\treturn -EINVAL;\n\t}\n\n\t\n\tmap = q->bufs[first]->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);\n\tif (NULL == map)\n\t\treturn -ENOMEM;\n\n\tmap->start = vma->vm_start;\n\tmap->end   = vma->vm_end;\n\tmap->q     = q;\n\n\tq->bufs[first]->baddr = vma->vm_start;\n\n\tvma->vm_ops          = &videobuf_vm_ops;\n\tvma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;\n\tvma->vm_private_data = map;\n\n\tmem=q->bufs[first]->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\n\t\n\tretval=remap_vmalloc_range(vma, mem->vmalloc,0);\n\tif (retval<0) {\n\t\tdprintk(1,\"STR\");\n\n\t\tmem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);\n\t\tif (!mem->vma) {\n\t\t\tkfree(map);\n\t\t\tq->bufs[first]->map=NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(mem->vma,vma,sizeof(*vma));\n\t}\n\n\tdprintk(1,\"STR\",\n\t\tmap,q,vma->vm_start,vma->vm_end,\n\t\t(long int) q->bufs[first]->bsize,\n\t\tvma->vm_pgoff,first);\n\n\tvideobuf_vm_open(vma);\n\n\treturn (0);\n}","24839":"static inline void find_entity_for_char_basic(\n\tunsigned int k,\n\tconst entity_stage3_row *table,\n\tconst unsigned char **entity,\n\tsize_t *entity_len)\n{\n\tif (k >= 64U) {\n\t\t*entity     = NULL;\n\t\t*entity_len = 0;\n\t\treturn;\n\t}\n\n\t*entity     = table[k].data.ent.entity;\n\t*entity_len = table[k].data.ent.entity_len;\n}","24981":"GF_Err traf_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *)s;\n\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_TFHD:\n\t\tif (ptr->tfhd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->tfhd = (GF_TrackFragmentHeaderBox *) a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRUN:\n\t\treturn gf_list_add(ptr->TrackRuns, a);\n\tcase GF_ISOM_BOX_TYPE_SDTP:\n\t\tif (ptr->sdtp) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->sdtp = (GF_SampleDependencyTypeBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TFDT:\n\t\tif (ptr->tfdt) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->tfdt = (GF_TFBaseMediaDecodeTimeBox*) a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SUBS:\n\t\tif (!ptr->sub_samples) ptr->sub_samples = gf_list_new();\n\t\treturn gf_list_add(ptr->sub_samples, a);\n\tcase GF_ISOM_BOX_TYPE_SBGP:\n\t\tif (!ptr->sampleGroups) ptr->sampleGroups = gf_list_new();\n\t\tgf_list_add(ptr->sampleGroups, a);\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SGPD:\n\t\tif (!ptr->sampleGroupsDescription) ptr->sampleGroupsDescription = gf_list_new();\n\t\tgf_list_add(ptr->sampleGroupsDescription, a);\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SAIZ:\n\t\tif (!ptr->sai_sizes) ptr->sai_sizes = gf_list_new();\n\t\tgf_list_add(ptr->sai_sizes, a);\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_SAIO:\n\t\tif (!ptr->sai_offsets) ptr->sai_offsets = gf_list_new();\n\t\tgf_list_add(ptr->sai_offsets, a);\n\t\treturn GF_OK;\n\t\n\tcase GF_ISOM_BOX_TYPE_UUID:\n\t\tif ( ((GF_UUIDBox *)a)->internal_4cc==GF_ISOM_BOX_UUID_PSEC) {\n\t\t\tif (ptr->sample_encryption) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\t\tptr->sample_encryption = (GF_SampleEncryptionBox *)a;\n\t\t\tptr->sample_encryption->traf = ptr;\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\treturn gf_isom_box_add_default(s, a);\n\t\t}\n\tcase GF_ISOM_BOX_TYPE_SENC:\n\t\tif (ptr->sample_encryption) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->sample_encryption = (GF_SampleEncryptionBox *)a;\n\t\tptr->sample_encryption->traf = ptr;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}","24550":"static MZ_FORCEINLINE mz_bool mz_zip_array_push_back(mz_zip_archive *pZip,\n                                                     mz_zip_array *pArray,\n                                                     const void *pElements,\n                                                     size_t n) {\n  size_t orig_size = pArray->m_size;\n  if (!mz_zip_array_resize(pZip, pArray, orig_size + n, MZ_TRUE))\n    return MZ_FALSE;\n  memcpy((mz_uint8 *)pArray->m_p + orig_size * pArray->m_element_size,\n         pElements, n * pArray->m_element_size);\n  return MZ_TRUE;\n}","24702":"GF_Err edts_AddBox(GF_Box *s, GF_Box *a)\n{\n\tGF_EditBox *ptr = (GF_EditBox *)s;\n\tif (a->type == GF_ISOM_BOX_TYPE_ELST) {\n\t\tif (ptr->editList) return GF_BAD_PARAM;\n\t\tptr->editList = (GF_EditListBox *)a;\n\t\treturn GF_OK;\n\t} else {\n\t\treturn gf_isom_box_add_default(s, a);\n\t}\n\treturn GF_OK;\n}","24693":"static int sctp_copy_laddrs(struct sock *sk, __u16 port, void *to,\n\t\t\t    size_t space_left, int *bytes_copied)\n{\n\tstruct sctp_sockaddr_entry *addr;\n\tunion sctp_addr temp;\n\tint cnt = 0;\n\tint addrlen;\n\tstruct net *net = sock_net(sk);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(addr, &net->sctp.local_addr_list, list) {\n\t\tif (!addr->valid)\n\t\t\tcontinue;\n\n\t\tif ((PF_INET == sk->sk_family) &&\n\t\t    (AF_INET6 == addr->a.sa.sa_family))\n\t\t\tcontinue;\n\t\tif ((PF_INET6 == sk->sk_family) &&\n\t\t    inet_v6_ipv6only(sk) &&\n\t\t    (AF_INET == addr->a.sa.sa_family))\n\t\t\tcontinue;\n\t\tmemcpy(&temp, &addr->a, sizeof(temp));\n\t\tif (!temp.v4.sin_port)\n\t\t\ttemp.v4.sin_port = htons(port);\n\n\t\taddrlen = sctp_get_pf_specific(sk->sk_family)\n\t\t\t      ->addr_to_user(sctp_sk(sk), &temp);\n\n\t\tif (space_left < addrlen) {\n\t\t\tcnt =  -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(to, &temp, addrlen);\n\n\t\tto += addrlen;\n\t\tcnt++;\n\t\tspace_left -= addrlen;\n\t\t*bytes_copied += addrlen;\n\t}\n\trcu_read_unlock();\n\n\treturn cnt;\n}","24365":"static inline void pmd_free(struct mm_struct *mm, pmd_t *pmd)\n{\n\tBUG_ON((unsigned long)pmd & (PAGE_SIZE-1));\n\tfree_page((unsigned long)pmd);\n}","24410":"xdr_setv4key_arg(XDR *xdrs, setv4key_arg *objp)\n{\n\tunsigned int n_keys = 1;\n\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *) &objp->keyblock,\n\t\t       &n_keys, ~0,\n\t\t       sizeof(krb5_keyblock), xdr_krb5_keyblock)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}","23906":"void buildMessage(SSL& ssl, output_buffer& output, const Message& msg)\n{\n    uint digestSz = ssl.getCrypto().get_digest().get_digestSize();\n    uint sz  = RECORD_HEADER + msg.get_length() + digestSz;                \n    uint pad = 0;\n    uint blockSz = ssl.getCrypto().get_cipher().get_blockSize();\n\n    if (ssl.getSecurity().get_parms().cipher_type_ == block) {\n        if (ssl.isTLSv1_1())  \n            sz += blockSz;\n        sz += 1;       \n        pad = (sz - RECORD_HEADER) % blockSz;\n        pad = blockSz - pad;\n        sz += pad;\n    }\n\n    RecordLayerHeader rlHeader;\n    buildHeader(ssl, rlHeader, msg);\n    rlHeader.length_ = sz - RECORD_HEADER;   \n                                             \n    input_buffer iv;\n    if (ssl.isTLSv1_1() && ssl.getSecurity().get_parms().cipher_type_== block){\n        iv.allocate(blockSz);\n        ssl.getCrypto().get_random().Fill(iv.get_buffer(), blockSz);\n        iv.add_size(blockSz);\n    }\n    \n    uint ivSz = iv.get_size();\n    output.allocate(sz);\n    output << rlHeader << iv << msg;\n    \n    opaque digest[SHA_LEN];                  \n    if (ssl.isTLS())\n        TLS_hmac(ssl, digest, output.get_buffer() + RECORD_HEADER + ivSz,\n                 output.get_size() - RECORD_HEADER - ivSz, msg.get_type());\n    else\n        hmac(ssl, digest, output.get_buffer() + RECORD_HEADER,\n             output.get_size() - RECORD_HEADER, msg.get_type());\n    output.write(digest, digestSz);\n\n    if (ssl.getSecurity().get_parms().cipher_type_ == block)\n        for (uint i = 0; i <= pad; i++) output[AUTO] = pad; \n                                                              \n    input_buffer cipher(rlHeader.length_);\n    ssl.useCrypto().use_cipher().encrypt(cipher.get_buffer(),\n       output.get_buffer() + RECORD_HEADER, output.get_size() - RECORD_HEADER);\n    output.set_current(RECORD_HEADER);\n    output.write(cipher.get_buffer(), cipher.get_capacity());\n}","24797":"BOOL ber_read_contextual_tag(wStream* s, BYTE tag, int* length, BOOL pc)\n{\n\tBYTE byte;\n\n\tif(Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte != ((BER_CLASS_CTXT | BER_PC(pc)) | (BER_TAG_MASK & tag)))\n\t{\n\t\tStream_Rewind(s, 1);\n\t\treturn FALSE;\n\t}\n\n\treturn ber_read_length(s, length);\n}","24803":"bool Sampler::operator==(const Sampler &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->magFilter == other.magFilter &&\n         this->minFilter == other.minFilter && this->name == other.name &&\n         this->wrapS == other.wrapS &&\n         this->wrapT == other.wrapT;\n\n         \n}","24785":"static int mbochs_probe(struct mdev_device *mdev)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mdev_get_type_group_id(mdev)];\n\tstruct device *dev = mdev_dev(mdev);\n\tstruct mdev_state *mdev_state;\n\tint ret = -ENOMEM;\n\n\tif (type->mbytes + mbochs_used_mbytes > max_mbytes)\n\t\treturn -ENOMEM;\n\n\tmdev_state = kzalloc(sizeof(struct mdev_state), GFP_KERNEL);\n\tif (mdev_state == NULL)\n\t\treturn -ENOMEM;\n\tvfio_init_group_dev(&mdev_state->vdev, &mdev->dev, &mbochs_dev_ops);\n\n\tmdev_state->vconfig = kzalloc(MBOCHS_CONFIG_SPACE_SIZE, GFP_KERNEL);\n\tif (mdev_state->vconfig == NULL)\n\t\tgoto err_mem;\n\n\tmdev_state->memsize = type->mbytes * 1024 * 1024;\n\tmdev_state->pagecount = mdev_state->memsize >> PAGE_SHIFT;\n\tmdev_state->pages = kcalloc(mdev_state->pagecount,\n\t\t\t\t    sizeof(struct page *),\n\t\t\t\t    GFP_KERNEL);\n\tif (!mdev_state->pages)\n\t\tgoto err_mem;\n\n\tdev_info(dev, \"STR\", __func__,\n\t\t type->name, type->mbytes, mdev_state->pagecount);\n\n\tmutex_init(&mdev_state->ops_lock);\n\tmdev_state->mdev = mdev;\n\tINIT_LIST_HEAD(&mdev_state->dmabufs);\n\tmdev_state->next_id = 1;\n\n\tmdev_state->type = type;\n\tmdev_state->edid_regs.max_xres = type->max_x;\n\tmdev_state->edid_regs.max_yres = type->max_y;\n\tmdev_state->edid_regs.edid_offset = MBOCHS_EDID_BLOB_OFFSET;\n\tmdev_state->edid_regs.edid_max_size = sizeof(mdev_state->edid_blob);\n\tmbochs_create_config_space(mdev_state);\n\tmbochs_reset(mdev_state);\n\n\tmbochs_used_mbytes += type->mbytes;\n\n\tret = vfio_register_group_dev(&mdev_state->vdev);\n\tif (ret)\n\t\tgoto err_mem;\n\tdev_set_drvdata(&mdev->dev, mdev_state);\n\treturn 0;\n\nerr_mem:\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\n\treturn ret;\n}","25059":"void Krecipes::filePrint()\n{\n\tm_view->print();\n}","23944":"QUtil::seek(FILE* stream, qpdf_offset_t offset, int whence)\n{\n#if HAVE_FSEEKO\n    return fseeko(stream,\n                  QIntC::IntConverter<qpdf_offset_t, off_t>::convert(offset),\n                  whence);\n#elif HAVE_FSEEKO64\n    return fseeko64(stream, offset, whence);\n#else\n# if defined _MSC_VER || defined __BORLANDC__\n    return _fseeki64(stream, offset, whence);\n# else\n    return fseek(stream,\n                 QIntC::IntConverter<qpdf_offset_t, long>(offset),\n                 whence);\n# endif\n#endif\n}","24404":"static void print_name_offset(struct seq_file *m, unsigned long addr)\n{\n\tchar symname[KSYM_NAME_LEN];\n\n\tif (lookup_symbol_name(addr, symname) < 0)\n\t\tseq_printf(m, \"STR\", (void *)addr);\n\telse\n\t\tseq_printf(m, \"STR\", symname);\n}","24357":"int main(void) {\n    char *output = NULL;\n    CuSuite* suite = CuSuiteNew();\n\n    abs_top_srcdir = getenv(\"STR\");\n    if (abs_top_srcdir == NULL)\n        die(\"STR\");\n\n    abs_top_builddir = getenv(\"STR\");\n    if (abs_top_builddir == NULL)\n        die(\"STR\");\n\n    if (asprintf(&src_root, \"STR\", abs_top_srcdir) < 0) {\n        die(\"STR\");\n    }\n\n    CuSuiteSetup(suite, setup, teardown);\n\n    SUITE_ADD_TEST(suite, testSaveNewFile);\n    SUITE_ADD_TEST(suite, testNonExistentLens);\n    SUITE_ADD_TEST(suite, testMultipleXfm);\n    SUITE_ADD_TEST(suite, testMtime);\n    SUITE_ADD_TEST(suite, testRelPath);\n    SUITE_ADD_TEST(suite, testDoubleSlashPath);\n    SUITE_ADD_TEST(suite, testUmask077);\n    SUITE_ADD_TEST(suite, testUmask027);\n    SUITE_ADD_TEST(suite, testUmask022);\n\n    CuSuiteRun(suite);\n    CuSuiteSummary(suite, &output);\n    CuSuiteDetails(suite, &output);\n    printf(\"STR\", output);\n    free(output);\n    return suite->failCount;\n}","24096":"setup_brush(BRUSH * out_brush, BRUSH * in_brush)\n{\n\tBRUSHDATA *brush_data;\n\tuint8 cache_idx;\n\tuint8 colour_code;\n\n\tmemcpy(out_brush, in_brush, sizeof(BRUSH));\n\tif (out_brush->style & 0x80)\n\t{\n\t\tcolour_code = out_brush->style & 0x0f;\n\t\tcache_idx = out_brush->pattern[0];\n\t\tbrush_data = cache_get_brush_data(colour_code, cache_idx);\n\t\tif ((brush_data == NULL) || (brush_data->data == NULL))\n\t\t{\n\t\t\terror(\"STR\", out_brush->style);\n\t\t\tout_brush->bd = NULL;\n\t\t\tmemset(out_brush->pattern, 0, 8);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tout_brush->bd = brush_data;\n\t\t}\n\t\tout_brush->style = 3;\n\t}\n}","24031":"int kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_mmu_flush_tlb(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE)) {\n\t\t\tif (cr3 & CR3_PCID_ENABLED_RESERVED_BITS)\n\t\t\t\treturn 1;\n\t\t} else\n\t\t\tif (cr3 & CR3_L_MODE_RESERVED_BITS)\n\t\t\t\treturn 1;\n\t} else {\n\t\tif (is_pae(vcpu)) {\n\t\t\tif (cr3 & CR3_PAE_RESERVED_BITS)\n\t\t\t\treturn 1;\n\t\t\tif (is_paging(vcpu) &&\n\t\t\t    !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\t\t\treturn 1;\n\t\t}\n\t\t\n\t}\n\n\t\n\tif (unlikely(!gfn_to_memslot(vcpu->kvm, cr3 >> PAGE_SHIFT)))\n\t\treturn 1;\n\tvcpu->arch.cr3 = cr3;\n\t__set_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail);\n\tvcpu->arch.mmu.new_cr3(vcpu);\n\treturn 0;\n}","23937":"cmdline_insert_reg(int *gotesc UNUSED)\n{\n    int\t\ti;\n    int\t\tc;\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\n#endif\n    putcmdline('\"', TRUE);\n    ++no_mapping;\n    ++allow_keys;\n    i = c = plain_vgetc();\t\n    if (i == Ctrl_O)\n\ti = Ctrl_R;\t\t\n    if (i == Ctrl_R)\n\tc = plain_vgetc();\t\n    extra_char = NUL;\n    --no_mapping;\n    --allow_keys;\n#ifdef FEAT_EVAL\n    \n    new_cmdpos = -1;\n    if (c == '=')\n    {\n\tif (ccline.cmdfirstc == '='  \n\t\t|| cmdline_star > 0) \n\t{\n\t    beep_flush();\n\t    c = ESC;\n\t}\n\telse\n\t    c = get_expr_register();\n    }\n#endif\n    if (c != ESC)\t    \n    {\n\tcmdline_paste(c, i == Ctrl_R, FALSE);\n\n#ifdef FEAT_EVAL\n\t\n\t\n\tif (aborting())\n\t{\n\t    *gotesc = TRUE;  \n\t    \n\t    return GOTO_NORMAL_MODE;\n\t}\n#endif\n\tKeyTyped = FALSE;\t\n#ifdef FEAT_EVAL\n\tif (new_cmdpos >= 0)\n\t{\n\t    \n\t    if (new_cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    else\n\t\tccline.cmdpos = new_cmdpos;\n\t}\n#endif\n    }\n    \n    redrawcmd();\n\n    \n    return CMDLINE_NOT_CHANGED;\n}","23865":"virDomainMigrateBegin3Params(virDomainPtr domain,\n                             virTypedParameterPtr params,\n                             int nparams,\n                             char **cookieout,\n                             int *cookieoutlen,\n                             unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"STR\"\n                     \"STR\",\n                     params, nparams, cookieout, cookieoutlen, flags);\n    VIR_TYPED_PARAMS_DEBUG(params, nparams);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, NULL);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainMigrateBegin3Params) {\n        char *xml;\n        xml = conn->driver->domainMigrateBegin3Params(domain, params, nparams,\n                                                      cookieout, cookieoutlen,\n                                                      flags);\n        VIR_DEBUG(\"STR\", NULLSTR(xml));\n        if (!xml)\n            goto error;\n        return xml;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}","23804":"int x9_62_test_internal(BIO *out, int nid, const char *r_in, const char *s_in)\n{\n    int ret = 0;\n    const char message[] = \"STR\";\n    unsigned char digest[20];\n    unsigned int dgst_len = 0;\n    EVP_MD_CTX md_ctx;\n    EC_KEY *key = NULL;\n    ECDSA_SIG *signature = NULL;\n    BIGNUM *r = NULL, *s = NULL;\n\n    EVP_MD_CTX_init(&md_ctx);\n    \n    EVP_DigestInit(&md_ctx, EVP_ecdsa());\n    EVP_DigestUpdate(&md_ctx, (const void *)message, 3);\n    EVP_DigestFinal(&md_ctx, digest, &dgst_len);\n\n    BIO_printf(out, \"STR\", OBJ_nid2sn(nid));\n    \n    if ((key = EC_KEY_new_by_curve_name(nid)) == NULL)\n        goto x962_int_err;\n    if (!EC_KEY_generate_key(key))\n        goto x962_int_err;\n    BIO_printf(out, \"STR\");\n    (void)BIO_flush(out);\n    \n    signature = ECDSA_do_sign(digest, 20, key);\n    if (signature == NULL)\n        goto x962_int_err;\n    BIO_printf(out, \"STR\");\n    (void)BIO_flush(out);\n    \n    if ((r = BN_new()) == NULL || (s = BN_new()) == NULL)\n        goto x962_int_err;\n    if (!BN_dec2bn(&r, r_in) || !BN_dec2bn(&s, s_in))\n        goto x962_int_err;\n    if (BN_cmp(signature->r, r) || BN_cmp(signature->s, s))\n        goto x962_int_err;\n    BIO_printf(out, \"STR\");\n    (void)BIO_flush(out);\n    \n    if (ECDSA_do_verify(digest, 20, signature, key) != 1)\n        goto x962_int_err;\n    BIO_printf(out, \"STR\");\n    (void)BIO_flush(out);\n\n    BIO_printf(out, \"STR\");\n    ret = 1;\n x962_int_err:\n    if (!ret)\n        BIO_printf(out, \"STR\");\n    if (key)\n        EC_KEY_free(key);\n    if (signature)\n        ECDSA_SIG_free(signature);\n    if (r)\n        BN_free(r);\n    if (s)\n        BN_free(s);\n    EVP_MD_CTX_cleanup(&md_ctx);\n    return ret;\n}","23854":"  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n\n    TensorShape out_shape({params.tensor_in_batch, params.out_height,\n                           params.out_width, params.depth});\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n    Tensor* argmax = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, out_shape, &argmax));\n\n    LaunchMaxPoolingWithArgmax<Device, T, Targmax>::launch(\n        context, params, tensor_in, output, argmax, propagate_nans_,\n        include_batch_in_index_);\n  }","23891":"authentic_pin_cmd(struct sc_card *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tint rv = SC_ERROR_INTERNAL;\n\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"STR\", data->cmd, data->pin_type, data->pin_reference);\n\tsc_log(ctx, \"STR\", data->pin1.data, data->pin1.len, data->pin1.tries_left);\n\tsc_log(ctx, \"STR\", data->pin2.data, data->pin2.len);\n\n\tswitch (data->cmd)   {\n\tcase SC_PIN_CMD_VERIFY:\n\t\trv = authentic_pin_verify(card, data);\n\t\tbreak;\n\tcase SC_PIN_CMD_CHANGE:\n\t\trv = authentic_pin_change(card, data, tries_left);\n\t\tbreak;\n\tcase SC_PIN_CMD_UNBLOCK:\n\t\trv = authentic_pin_reset(card, data, tries_left);\n\t\tbreak;\n\tcase SC_PIN_CMD_GET_INFO:\n\t\trv = authentic_pin_get_policy(card, data);\n\t\tbreak;\n\tdefault:\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"STR\");\n\t}\n\n\tif (rv == SC_ERROR_PIN_CODE_INCORRECT && tries_left)\n\t\t*tries_left = data->pin1.tries_left;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}","24773":"GF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex)\n{\n\n\tGF_DataEntryURLBox *entry;\n\tGF_DataMap *map;\n\tGF_Err e;\n\tif (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM;\n\n\tentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\tif (entry->flags == 1) return GF_OK;\n\n\t\n\t\n\tif (entry->type == GF_ISOM_BOX_TYPE_URN) return GF_NOT_SUPPORTED;\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) {\n\t\te = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map);\n\t} else {\n\t\te = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map);\n\t}\n\tif (e) return e;\n\tgf_isom_datamap_del(map);\n\treturn GF_OK;\n}","23825":"void * calloc(size_t n, size_t lb)\n{\n    if (lb && n > SIZE_MAX \/ lb)\n      return NULL;\n#   if defined(GC_LINUX_THREADS) \n        \n        \n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          \n          \n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n          \n          \n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}","24355":"psd_to_gimp_color_map (guchar *map256)\n{\n  guchar *tmpmap;\n  gint    i;\n\n  tmpmap = g_malloc (3 * 256);\n\n  for (i = 0; i < 256; ++i)\n    {\n      tmpmap[i*3  ] = map256[i];\n      tmpmap[i*3+1] = map256[i+256];\n      tmpmap[i*3+2] = map256[i+512];\n    }\n\n  memcpy (map256, tmpmap, 3 * 256);\n  g_free (tmpmap);\n}","24036":"Tracing::Reason ConnectionManagerUtility::mutateTracingRequestHeader(\n    RequestHeaderMap& request_headers, Runtime::Loader& runtime, ConnectionManagerConfig& config,\n    const Router::Route* route) {\n  Tracing::Reason final_reason = Tracing::Reason::NotTraceable;\n  if (!config.tracingConfig()) {\n    return final_reason;\n  }\n\n  auto rid_extension = config.requestIDExtension();\n  const auto rid_to_integer = rid_extension->toInteger(request_headers);\n  \n  if (!rid_to_integer.has_value()) {\n    return final_reason;\n  }\n  const uint64_t result = rid_to_integer.value() % 10000;\n\n  const envoy::type::v3::FractionalPercent* client_sampling =\n      &config.tracingConfig()->client_sampling_;\n  const envoy::type::v3::FractionalPercent* random_sampling =\n      &config.tracingConfig()->random_sampling_;\n  const envoy::type::v3::FractionalPercent* overall_sampling =\n      &config.tracingConfig()->overall_sampling_;\n\n  if (route && route->tracingConfig()) {\n    client_sampling = &route->tracingConfig()->getClientSampling();\n    random_sampling = &route->tracingConfig()->getRandomSampling();\n    overall_sampling = &route->tracingConfig()->getOverallSampling();\n  }\n\n  \n  final_reason = rid_extension->getTraceReason(request_headers);\n  if (Tracing::Reason::NotTraceable == final_reason) {\n    if (request_headers.ClientTraceId() &&\n        runtime.snapshot().featureEnabled(\"STR\", *client_sampling)) {\n      final_reason = Tracing::Reason::ClientForced;\n      rid_extension->setTraceReason(request_headers, final_reason);\n    } else if (request_headers.EnvoyForceTrace()) {\n      final_reason = Tracing::Reason::ServiceForced;\n      rid_extension->setTraceReason(request_headers, final_reason);\n    } else if (runtime.snapshot().featureEnabled(\"STR\", *random_sampling,\n                                                 result)) {\n      final_reason = Tracing::Reason::Sampling;\n      rid_extension->setTraceReason(request_headers, final_reason);\n    }\n  }\n\n  if (final_reason != Tracing::Reason::NotTraceable &&\n      !runtime.snapshot().featureEnabled(\"STR\", *overall_sampling, result)) {\n    final_reason = Tracing::Reason::NotTraceable;\n    rid_extension->setTraceReason(request_headers, final_reason);\n  }\n\n  return final_reason;\n}","24417":"static int io_epoll_ctl_prep(struct io_kiocb *req,\n\t\t\t     const struct io_uring_sqe *sqe)\n{\n#if defined(CONFIG_EPOLL)\n\tif (sqe->ioprio || sqe->buf_index)\n\t\treturn -EINVAL;\n\tif (unlikely(req->ctx->flags & (IORING_SETUP_IOPOLL | IORING_SETUP_SQPOLL)))\n\t\treturn -EINVAL;\n\n\treq->epoll.epfd = READ_ONCE(sqe->fd);\n\treq->epoll.op = READ_ONCE(sqe->len);\n\treq->epoll.fd = READ_ONCE(sqe->off);\n\n\tif (ep_op_has_event(req->epoll.op)) {\n\t\tstruct epoll_event __user *ev;\n\n\t\tev = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\t\tif (copy_from_user(&req->epoll.event, ev, sizeof(*ev)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}","24608":"bssid_strength_changed (NMAccessPoint *ap, GParamSpec *pspec, gpointer user_data)\n{\n\tapplet_schedule_update_icon (NM_APPLET (user_data));\n}","24626":"static TValue *trace_exit_cp(lua_State *L, lua_CFunction dummy, void *ud)\n{\n  ExitDataCP *exd = (ExitDataCP *)ud;\n  cframe_errfunc(L->cframe) = -1;  \n  exd->pc = lj_snap_restore(exd->J, exd->exptr);\n  UNUSED(dummy);\n  return NULL;\n}","24810":"protocol_handshake (struct connection *conn)\n{\n  int r;\n\n  lock_request (conn);\n  if (!newstyle)\n    r = protocol_handshake_oldstyle (conn);\n  else\n    r = protocol_handshake_newstyle (conn);\n  unlock_request (conn);\n\n  return r;\n}","25016":"void wake_up_new_task(struct task_struct *p, unsigned long clone_flags)\n{\n\tunsigned long flags;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(p, &flags);\n\tBUG_ON(p->state != TASK_RUNNING);\n\tupdate_rq_clock(rq);\n\n\tp->prio = effective_prio(p);\n\n\tif (!p->sched_class->task_new || !current->se.on_rq) {\n\t\tactivate_task(rq, p, 0);\n\t} else {\n\t\t\n\t\tp->sched_class->task_new(rq, p);\n\t\tinc_nr_running(rq);\n\t}\n\tcheck_preempt_curr(rq, p);\n#ifdef CONFIG_SMP\n\tif (p->sched_class->task_wake_up)\n\t\tp->sched_class->task_wake_up(rq, p);\n#endif\n\ttask_rq_unlock(rq, &flags);\n}","24546":"AdjustFractDays(double frac, struct  tm * tm, fsec_t *fsec, int scale)\n{\n\tint\t\t\textra_days;\n\n\tif (frac == 0)\n\t\treturn;\n\tfrac *= scale;\n\textra_days = (int) frac;\n\ttm->tm_mday += extra_days;\n\tfrac -= extra_days;\n\tAdjustFractSeconds(frac, tm, fsec, SECS_PER_DAY);\n}","24264":"_outIndexStmt(StringInfo str, const IndexStmt *node)\n{\n\tWRITE_NODE_TYPE(\"STR\");\n\n\tWRITE_STRING_FIELD(idxname);\n\tWRITE_NODE_FIELD(relation);\n\tWRITE_STRING_FIELD(accessMethod);\n\tWRITE_STRING_FIELD(tableSpace);\n\tWRITE_NODE_FIELD(indexParams);\n\tWRITE_NODE_FIELD(options);\n\tWRITE_NODE_FIELD(whereClause);\n\tWRITE_NODE_FIELD(excludeOpNames);\n\tWRITE_STRING_FIELD(idxcomment);\n\tWRITE_OID_FIELD(indexOid);\n\tWRITE_OID_FIELD(oldNode);\n\tWRITE_BOOL_FIELD(unique);\n\tWRITE_BOOL_FIELD(primary);\n\tWRITE_BOOL_FIELD(isconstraint);\n\tWRITE_BOOL_FIELD(deferrable);\n\tWRITE_BOOL_FIELD(initdeferred);\n\tWRITE_BOOL_FIELD(concurrent);\n}","24591":"void ServerConnectionImpl::onResetStream(StreamResetReason reason) {\n  active_request_->response_encoder_.runResetCallbacks(reason);\n  connection_.dispatcher().deferredDelete(std::move(active_request_));\n}","24114":"struct torture_suite *torture_smb2_notify_init(TALLOC_CTX *ctx)\n{\n\tstruct torture_suite *suite = torture_suite_create(ctx, \"STR\");\n\n\ttorture_suite_add_1smb2_test(suite, \"STR\", test_valid_request);\n\ttorture_suite_add_1smb2_test(suite, \"STR\", torture_smb2_notify_tcon);\n\ttorture_suite_add_2smb2_test(suite, \"STR\", torture_smb2_notify_dir);\n\ttorture_suite_add_2smb2_test(suite, \"STR\", torture_smb2_notify_mask);\n\ttorture_suite_add_1smb2_test(suite, \"STR\", torture_smb2_notify_tree_disconnect);\n\ttorture_suite_add_1smb2_test(suite, \"STR\", torture_smb2_notify_tree_disconnect_1);\n\ttorture_suite_add_2smb2_test(suite, \"STR\", torture_smb2_notify_mask_change);\n\ttorture_suite_add_1smb2_test(suite, \"STR\", torture_smb2_notify_close);\n\ttorture_suite_add_1smb2_test(suite, \"STR\", torture_smb2_notify_ulogoff);\n\ttorture_suite_add_1smb2_test(suite, \"STR\", torture_smb2_notify_session_reconnect);\n\ttorture_suite_add_2smb2_test(suite, \"STR\", torture_smb2_notify_invalid_reauth);\n\ttorture_suite_add_1smb2_test(suite, \"STR\", torture_smb2_notify_tree);\n\ttorture_suite_add_2smb2_test(suite, \"STR\", torture_smb2_notify_basedir);\n\ttorture_suite_add_2smb2_test(suite, \"STR\", torture_smb2_notify_double);\n\ttorture_suite_add_1smb2_test(suite, \"STR\", torture_smb2_notify_file);\n\ttorture_suite_add_1smb2_test(suite, \"STR\", torture_smb2_notify_tcp_disconnect);\n\ttorture_suite_add_2smb2_test(suite, \"STR\", torture_smb2_notify_recursive);\n\ttorture_suite_add_1smb2_test(suite, \"STR\", torture_smb2_notify_overflow);\n\ttorture_suite_add_1smb2_test(suite, \"STR\",\n\t\t\t\t     torture_smb2_notify_rmdir1);\n\ttorture_suite_add_1smb2_test(suite, \"STR\",\n\t\t\t\t     torture_smb2_notify_rmdir2);\n\ttorture_suite_add_2smb2_test(suite, \"STR\",\n\t\t\t\t     torture_smb2_notify_rmdir3);\n\ttorture_suite_add_2smb2_test(suite, \"STR\",\n\t\t\t\t     torture_smb2_notify_rmdir4);\n\n\tsuite->description = talloc_strdup(suite, \"STR\");\n\n\treturn suite;\n}","24057":"int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type,\n\t\t      bool initiator)\n{\n\tBT_DBG(\"STR\", conn);\n\n\tif (conn->type == LE_LINK)\n\t\treturn smp_conn_security(conn, sec_level);\n\n\t\n\tif (sec_level == BT_SECURITY_SDP)\n\t\treturn 1;\n\n\t\n\tif (sec_level == BT_SECURITY_LOW && !hci_conn_ssp_enabled(conn))\n\t\treturn 1;\n\n\t\n\tif (!test_bit(HCI_CONN_AUTH, &conn->flags))\n\t\tgoto auth;\n\n\t\n\tif (conn->key_type == HCI_LK_AUTH_COMBINATION_P256 &&\n\t    sec_level == BT_SECURITY_FIPS)\n\t\tgoto encrypt;\n\n\t\n\tif ((conn->key_type == HCI_LK_AUTH_COMBINATION_P192 ||\n\t     conn->key_type == HCI_LK_AUTH_COMBINATION_P256) &&\n\t    sec_level == BT_SECURITY_HIGH)\n\t\tgoto encrypt;\n\n\t\n\tif ((conn->key_type == HCI_LK_UNAUTH_COMBINATION_P192 ||\n\t     conn->key_type == HCI_LK_UNAUTH_COMBINATION_P256) &&\n\t    (sec_level == BT_SECURITY_MEDIUM || sec_level == BT_SECURITY_LOW))\n\t\tgoto encrypt;\n\n\t\n\tif (conn->key_type == HCI_LK_COMBINATION &&\n\t    (sec_level == BT_SECURITY_MEDIUM || sec_level == BT_SECURITY_LOW ||\n\t     conn->pin_length == 16))\n\t\tgoto encrypt;\n\nauth:\n\tif (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags))\n\t\treturn 0;\n\n\tif (initiator)\n\t\tset_bit(HCI_CONN_AUTH_INITIATOR, &conn->flags);\n\n\tif (!hci_conn_auth(conn, sec_level, auth_type))\n\t\treturn 0;\n\nencrypt:\n\tif (test_bit(HCI_CONN_ENCRYPT, &conn->flags))\n\t\treturn 1;\n\n\thci_conn_encrypt(conn);\n\treturn 0;\n}","24482":"_g_key_file_get_string_list (GKeyFile    *key_file,\n\t\t\t     const char  *group_name,\n\t\t\t     const char  *key,\n\t\t\t     GError    **error)\n{\n\tchar  **strv;\n\tGList  *list;\n\tint     i;\n\n\tstrv = g_key_file_get_string_list (key_file, group_name, key, NULL, error);\n\tif (strv == NULL)\n\t\treturn NULL;\n\n\tlist = NULL;\n\tfor (i = 0; strv[i] != NULL; i++)\n\t\tlist = g_list_prepend (list, strv[i]);\n\n\tg_free (strv);\n\n\treturn g_list_reverse (list);\n}","24758":"evbuffer_chain_new(size_t size)\n{\n\tstruct evbuffer_chain *chain;\n\tsize_t to_alloc;\n\n\tsize += EVBUFFER_CHAIN_SIZE;\n\n\t\n\tto_alloc = MIN_BUFFER_SIZE;\n\twhile (to_alloc < size)\n\t\tto_alloc <<= 1;\n\n\t\n\tif ((chain = mm_malloc(to_alloc)) == NULL)\n\t\treturn (NULL);\n\n\tmemset(chain, 0, EVBUFFER_CHAIN_SIZE);\n\n\tchain->buffer_len = to_alloc - EVBUFFER_CHAIN_SIZE;\n\n\t\n\tchain->buffer = EVBUFFER_CHAIN_EXTRA(u_char, chain);\n\n\tchain->refcnt = 1;\n\n\treturn (chain);\n}","24166":"void Locked_tables_list::reset()\n{\n  free_root(&m_locked_tables_root, MYF(0));\n  m_locked_tables= NULL;\n  m_locked_tables_last= &m_locked_tables;\n  m_reopen_array= NULL;\n  m_locked_tables_count= 0;\n  some_table_marked_for_reopen= 0;\n}","23883":"\t\tSetRunner(\n\t\t\tReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tLocal<Value> val_handle,\n\t\t\tMaybeLocal<Object> maybe_options\n\t\t) :\n\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n\t\t\t\tval{TransferOut(val_handle, TransferOptions{maybe_options})},\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference} {\n\t\t\tthat.CheckDisposed();\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"STR\");\n\t\t\t}\n\t\t}","24719":"bool MasteringMetadata::Write(IMkvWriter* writer) const {\n  const uint64_t size = PayloadSize();\n\n  \n  if (size == 0)\n    return true;\n\n  if (!WriteEbmlMasterElement(writer, libwebm::kMkvMasteringMetadata, size))\n    return false;\n  if (luminance_max_ != kValueNotPresent &&\n      !WriteEbmlElement(writer, libwebm::kMkvLuminanceMax, luminance_max_)) {\n    return false;\n  }\n  if (luminance_min_ != kValueNotPresent &&\n      !WriteEbmlElement(writer, libwebm::kMkvLuminanceMin, luminance_min_)) {\n    return false;\n  }\n  if (r_ &&\n      !r_->Write(writer, libwebm::kMkvPrimaryRChromaticityX,\n                 libwebm::kMkvPrimaryRChromaticityY)) {\n    return false;\n  }\n  if (g_ &&\n      !g_->Write(writer, libwebm::kMkvPrimaryGChromaticityX,\n                 libwebm::kMkvPrimaryGChromaticityY)) {\n    return false;\n  }\n  if (b_ &&\n      !b_->Write(writer, libwebm::kMkvPrimaryBChromaticityX,\n                 libwebm::kMkvPrimaryBChromaticityY)) {\n    return false;\n  }\n  if (white_point_ &&\n      !white_point_->Write(writer, libwebm::kMkvWhitePointChromaticityX,\n                           libwebm::kMkvWhitePointChromaticityY)) {\n    return false;\n  }\n\n  return true;\n}","24642":"static void write_response(ESPState *s)\n{\n    uint32_t n;\n\n    trace_esp_write_response(s->status);\n\n    fifo8_reset(&s->fifo);\n    esp_fifo_push(s, s->status);\n    esp_fifo_push(s, 0);\n\n    if (s->dma) {\n        if (s->dma_memory_write) {\n            s->dma_memory_write(s->dma_opaque,\n                                (uint8_t *)fifo8_pop_buf(&s->fifo, 2, &n), 2);\n            s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;\n            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;\n            s->rregs[ESP_RSEQ] = SEQ_CD;\n        } else {\n            s->pdma_cb = write_response_pdma_cb;\n            esp_raise_drq(s);\n            return;\n        }\n    } else {\n        s->ti_size = 2;\n        s->rregs[ESP_RFLAGS] = 2;\n    }\n    esp_raise_irq(s);\n}","24159":"#if IS_ENABLED(CONFIG_CGROUP_NET_PRIO)\nstatic void skb_update_prio(struct sk_buff *skb)\n{\n\tstruct netprio_map *map = rcu_dereference_bh(skb->dev->priomap);\n\n\tif (!skb->priority && skb->sk && map) {\n\t\tunsigned int prioidx = skb->sk->sk_cgrp_prioidx;\n\n\t\tif (prioidx < map->priomap_len)\n\t\t\tskb->priority = map->priomap[prioidx];\n\t}","24194":"void ImapModelOpenConnectionTest::testPreauth()\n{\n    QCoreApplication::processEvents();\n    QCoreApplication::processEvents();\n    QVERIFY(SOCK->writtenStuff().isEmpty());\n    SOCK->fakeReading( \"STR\" );\n    QVERIFY( completedSpy->isEmpty() );\n    QCoreApplication::processEvents();\n    QCoreApplication::processEvents();\n    QCoreApplication::processEvents();\n    QCOMPARE( SOCK->writtenStuff(), QByteArray(\"STR\") );\n    QVERIFY( completedSpy->isEmpty() );\n    SOCK->fakeReading( \"STR\" );\n    QCoreApplication::processEvents();\n    QCoreApplication::processEvents();\n    QCOMPARE( completedSpy->size(), 1 );\n    QVERIFY(failedSpy->isEmpty());\n    QVERIFY( authSpy->isEmpty() );\n    QVERIFY(startTlsUpgradeSpy->isEmpty());\n}","24641":"void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_strdup(src);\n  imap_utf_encode(idata, &buf);\n\n  imap_quote_string(dest, dlen, buf);\n\n  FREE(&buf);\n}","24982":"BGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ctx (gdIOCtxPtr in)\n{\n\t_noLibzError();\n\treturn NULL;\n}","24602":"get_tc(const char *descriptor,\n       int modid,\n       int *tc_index,\n       struct enum_list **ep, struct range_list **rp, char **hint)\n{\n    int             i;\n    struct tc      *tcp;\n\n    i = get_tc_index(descriptor, modid);\n    if (tc_index)\n        *tc_index = i;\n    if (i != -1) {\n        tcp = &tclist[i];\n        if (ep) {\n            free_enums(ep);\n            *ep = copy_enums(tcp->enums);\n        }\n        if (rp) {\n            free_ranges(rp);\n            *rp = copy_ranges(tcp->ranges);\n        }\n        if (hint) {\n            if (*hint)\n                free(*hint);\n            *hint = (tcp->hint ? strdup(tcp->hint) : NULL);\n        }\n        return tcp->type;\n    }\n    return LABEL;\n}","24605":"static inline int compat_copy_match_from_user(struct ipt_entry_match *m,\n\tvoid **dstptr, compat_uint_t *size, const char *name,\n\tconst struct ipt_ip *ip, unsigned int hookmask, int *i)\n{\n\tstruct ipt_entry_match *dm;\n\tstruct ipt_match *match;\n\tint ret;\n\n\tdm = (struct ipt_entry_match *)*dstptr;\n\tmatch = m->u.kernel.match;\n\tif (match->compat)\n\t\tmatch->compat(m, dstptr, size, COMPAT_FROM_USER);\n\telse\n\t\txt_compat_match(m, dstptr, size, COMPAT_FROM_USER);\n\n\tret = xt_check_match(match, AF_INET, dm->u.match_size - sizeof(*dm),\n\t\t\t     name, hookmask, ip->proto,\n\t\t\t     ip->invflags & IPT_INV_PROTO);\n\tif (ret)\n\t\tgoto err;\n\n\tif (m->u.kernel.match->checkentry\n\t    && !m->u.kernel.match->checkentry(name, ip, match, dm->data,\n\t\t\t\t\t      hookmask)) {\n\t\tduprintf(\"STR\",\n\t\t\t m->u.kernel.match->name);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\t(*i)++;\n\treturn 0;\n\nerr:\n\tmodule_put(m->u.kernel.match->me);\n\treturn ret;\n}","24109":"TightDecoder::FilterGradient24(const rdr::U8 *inbuf,\n                               const PixelFormat& pf, PIXEL_T* outbuf,\n                               int stride, const Rect& r)\n{\n  int x, y, c;\n  rdr::U8 prevRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 thisRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 pix[3]; \n  int est[3]; \n\n  memset(prevRow, 0, sizeof(prevRow));\n\n  \n  int rectHeight = r.height();\n  int rectWidth = r.width();\n\n  for (y = 0; y < rectHeight; y++) {\n    \n    for (c = 0; c < 3; c++) {\n      pix[c] = inbuf[y*rectWidth*3+c] + prevRow[c];\n      thisRow[c] = pix[c];\n    }\n    pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride], pix, 1);\n\n    \n    for (x = 1; x < rectWidth; x++) {\n      for (c = 0; c < 3; c++) {\n        est[c] = prevRow[x*3+c] + pix[c] - prevRow[(x-1)*3+c];\n        if (est[c] > 0xff) {\n          est[c] = 0xff;\n        } else if (est[c] < 0) {\n          est[c] = 0;\n        }\n        pix[c] = inbuf[(y*rectWidth+x)*3+c] + est[c];\n        thisRow[x*3+c] = pix[c];\n      }\n      pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride+x], pix, 1);\n    }\n\n    memcpy(prevRow, thisRow, sizeof(prevRow));\n  }\n}","24741":"static inline void net_tx_pkt_sendv(struct NetTxPkt *pkt,\n    NetClientState *nc, const struct iovec *iov, int iov_cnt)\n{\n    if (pkt->is_loopback) {\n        nc->info->receive_iov(nc, iov, iov_cnt);\n    } else {\n        qemu_sendv_packet(nc, iov, iov_cnt);\n    }\n}","24709":"int wc_SignatureGenerate(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* data, word32 data_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len, WC_RNG* rng)\n{\n    int ret;\n    word32 hash_len, hash_enc_len;\n#ifdef WOLFSSL_SMALL_STACK\n    byte *hash_data;\n#else\n    byte hash_data[MAX_DER_DIGEST_SZ];\n#endif\n\n    \n    if (data == NULL || data_len <= 0 ||\n        sig == NULL || sig_len == NULL || *sig_len <= 0 ||\n        key == NULL || key_len <= 0) {\n        return BAD_FUNC_ARG;\n    }\n\n    \n    if ((int)*sig_len < wc_SignatureGetSize(sig_type, key, key_len)) {\n        WOLFSSL_MSG(\"STR\");\n        return BAD_FUNC_ARG;\n    }\n\n    \n    ret = wc_HashGetDigestSize(hash_type);\n    if (ret < 0) {\n        WOLFSSL_MSG(\"STR\");\n        return ret;\n    }\n    hash_enc_len = hash_len = ret;\n\n#if !defined(NO_RSA) && !defined(WOLFSSL_RSA_PUBLIC_ONLY)\n    if (sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC) {\n        \n        hash_enc_len += MAX_DER_DIGEST_ASN_SZ;\n    }\n#endif\n\n#ifdef WOLFSSL_SMALL_STACK\n    \n    hash_data = (byte*)XMALLOC(hash_enc_len, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n    if (hash_data == NULL) {\n        return MEMORY_E;\n    }\n#endif\n\n    \n    ret = wc_Hash(hash_type, data, data_len, hash_data, hash_len);\n    if (ret == 0) {\n        \n        if (sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC) {\n        #if defined(NO_RSA) || defined(NO_ASN) || \\\n                                                defined(WOLFSSL_RSA_PUBLIC_ONLY)\n            ret = SIG_TYPE_E;\n        #else\n            ret = wc_SignatureDerEncode(hash_type, hash_data, hash_len,\n                &hash_enc_len);\n        #endif\n        }\n\n        if (ret == 0) {\n            \n            ret = wc_SignatureGenerateHash(hash_type, sig_type,\n                hash_data, hash_enc_len, sig, sig_len, key, key_len, rng);\n        }\n    }\n\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(hash_data, NULL, DYNAMIC_TYPE_TMP_BUFFER);\n#endif\n\n    return ret;\n}","24020":"static bool unit_test_condition(Unit *u) {\n        assert(u);\n\n        dual_timestamp_get(&u->condition_timestamp);\n        u->condition_result = condition_test_list(u->conditions, condition_type_to_string, log_unit_internal, u);\n\n        unit_add_to_dbus_queue(u);\n\n        return u->condition_result;\n}","24157":"cdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,\n    const cdf_stream_t *sst, const uint64_t clsid[2])\n{\n        cdf_summary_info_header_t si;\n        cdf_property_info_t *info;\n        size_t count;\n        int m;\n\n        if (cdf_unpack_summary_info(sst, h, &si, &info, &count) == -1)\n                return -1;\n\n        if (NOTMIME(ms)) {\n\t\tconst char *str;\n\n                if (file_printf(ms, \"STR\")\n\t\t    == -1)\n                        return -1;\n\n                if (file_printf(ms, \"STR\",\n                    si.si_byte_order == 0xfffe ?  \"STR\") == -1)\n                        return -2;\n                switch (si.si_os) {\n                case 2:\n                        if (file_printf(ms, \"STR\",\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                return -2;\n                        break;\n                case 1:\n                        if (file_printf(ms, \"STR\",\n                            (uint32_t)si.si_os_version >> 8,\n                            si.si_os_version & 0xff) == -1)\n                                return -2;\n                        break;\n                default:\n                        if (file_printf(ms, \"STR\", si.si_os,\n                            si.si_os_version & 0xff,\n                            (uint32_t)si.si_os_version >> 8) == -1)\n                                return -2;\n                        break;\n                }\n\t\tstr = cdf_clsid_to_mime(clsid, clsid2desc);\n\t\tif (str)\n                        if (file_printf(ms, \"STR\", str) == -1)\n\t\t\t\treturn -2;\n        }\n\n        m = cdf_file_property_info(ms, info, count, clsid);\n        free(info);\n\n        return m == -1 ? -2 : m;\n}","23990":"purgekeys_2_svc(purgekeys_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    funcname = \"STR\";\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (!cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp)\n         || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                                arg->princ, NULL))) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(funcname, prime_arg, &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_purgekeys((void *)handle, arg->princ,\n                                   arg->keepkvno);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","24151":"add_locale_metadata_string (GVariantBuilder *metadata_builder,\n                            const char *keyname,\n                            GHashTable *values)\n{\n  if (values == NULL)\n    return;\n\n  GLNX_HASH_TABLE_FOREACH_KV (values, const char *, locale, const char *, value)\n    {\n      const char *key;\n      g_autofree char *key_free = NULL;\n      if (strcmp (locale, \"STR\") == 0)\n        key = keyname;\n      else\n        {\n          key_free = g_strdup_printf (\"STR\", keyname, locale);\n          key = key_free;\n        }\n\n      g_variant_builder_add (metadata_builder, \"STR\", key,\n                             g_variant_new_variant (g_variant_new_string (value)));\n    }\n}","24501":"int PKCS7_dataVerify(X509_STORE *cert_store, X509_STORE_CTX *ctx, BIO *bio,\n                     PKCS7 *p7, PKCS7_SIGNER_INFO *si)\n{\n    PKCS7_ISSUER_AND_SERIAL *ias;\n    int ret = 0, i;\n    STACK_OF(X509) *cert;\n    X509 *x509;\n\n    if (PKCS7_type_is_signed(p7)) {\n        cert = p7->d.sign->cert;\n    } else if (PKCS7_type_is_signedAndEnveloped(p7)) {\n        cert = p7->d.signed_and_enveloped->cert;\n    } else {\n        PKCS7err(PKCS7_F_PKCS7_DATAVERIFY, PKCS7_R_WRONG_PKCS7_TYPE);\n        goto err;\n    }\n    \n    ias = si->issuer_and_serial;\n\n    x509 = X509_find_by_issuer_and_serial(cert, ias->issuer, ias->serial);\n\n    \n    if (x509 == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATAVERIFY,\n                 PKCS7_R_UNABLE_TO_FIND_CERTIFICATE);\n        goto err;\n    }\n\n    \n    if (!X509_STORE_CTX_init(ctx, cert_store, x509, cert)) {\n        PKCS7err(PKCS7_F_PKCS7_DATAVERIFY, ERR_R_X509_LIB);\n        goto err;\n    }\n    X509_STORE_CTX_set_purpose(ctx, X509_PURPOSE_SMIME_SIGN);\n    i = X509_verify_cert(ctx);\n    if (i <= 0) {\n        PKCS7err(PKCS7_F_PKCS7_DATAVERIFY, ERR_R_X509_LIB);\n        X509_STORE_CTX_cleanup(ctx);\n        goto err;\n    }\n    X509_STORE_CTX_cleanup(ctx);\n\n    return PKCS7_signatureVerify(bio, p7, si, x509);\n err:\n    return ret;\n}","24821":"static int vm_stat_get_per_vm(void *data, u64 *val)\n{\n\tstruct kvm_stat_data *stat_data = (struct kvm_stat_data *)data;\n\n\t*val = *(ulong *)((void *)stat_data->kvm + stat_data->offset);\n\n\treturn 0;\n}","24586":"PJ_DEF(pj_status_t) pjmedia_rtp_decode_rtp2(\n\t\t\t\t\t    pjmedia_rtp_session *ses,\n\t\t\t\t\t    const void *pkt, int pkt_len,\n\t\t\t\t\t    const pjmedia_rtp_hdr **hdr,\n\t\t\t\t\t    pjmedia_rtp_dec_hdr *dec_hdr,\n\t\t\t\t\t    const void **payload,\n\t\t\t\t\t    unsigned *payloadlen)\n{\n    int offset;\n\n    PJ_UNUSED_ARG(ses);\n\n    \n    *hdr = (pjmedia_rtp_hdr*)pkt;\n\n    \n    if ((*hdr)->v != RTP_VERSION) {\n\treturn PJMEDIA_RTP_EINVER;\n    }\n\n    \n    offset = sizeof(pjmedia_rtp_hdr) + ((*hdr)->cc * sizeof(pj_uint32_t));\n\n    \n    if ((*hdr)->x) {\n        dec_hdr->ext_hdr = (pjmedia_rtp_ext_hdr*)(((pj_uint8_t*)pkt) + offset);\n        dec_hdr->ext = (pj_uint32_t*)(dec_hdr->ext_hdr + 1);\n        dec_hdr->ext_len = pj_ntohs((dec_hdr->ext_hdr)->length);\n        offset += ((dec_hdr->ext_len + 1) * sizeof(pj_uint32_t));\n    } else {\n\tdec_hdr->ext_hdr = NULL;\n\tdec_hdr->ext = NULL;\n\tdec_hdr->ext_len = 0;\n    }\n\n    \n    if (offset > pkt_len)\n\treturn PJMEDIA_RTP_EINLEN;\n\n    \n    *payload = ((pj_uint8_t*)pkt) + offset;\n    *payloadlen = pkt_len - offset;\n \n    \n    if ((*hdr)->p && *payloadlen > 0) {\n\tpj_uint8_t pad_len;\n\n\tpad_len = ((pj_uint8_t*)(*payload))[*payloadlen - 1];\n\tif (pad_len <= *payloadlen)\n\t    *payloadlen -= pad_len;\n    }\n\n    return PJ_SUCCESS;\n}","24419":"static ssize_t fuse_send_write(struct fuse_io_args *ia, loff_t pos,\n\t\t\t       size_t count, fl_owner_t owner)\n{\n\tstruct kiocb *iocb = ia->io->iocb;\n\tstruct file *file = iocb->ki_filp;\n\tstruct fuse_file *ff = file->private_data;\n\tstruct fuse_mount *fm = ff->fm;\n\tstruct fuse_write_in *inarg = &ia->write.in;\n\tssize_t err;\n\n\tfuse_write_args_fill(ia, ff, pos, count);\n\tinarg->flags = fuse_write_flags(iocb);\n\tif (owner != NULL) {\n\t\tinarg->write_flags |= FUSE_WRITE_LOCKOWNER;\n\t\tinarg->lock_owner = fuse_lock_owner_id(fm->fc, owner);\n\t}\n\n\tif (ia->io->async)\n\t\treturn fuse_async_req_send(fm, ia, count);\n\n\terr = fuse_simple_request(fm, &ia->ap.args);\n\tif (!err && ia->write.out.size > count)\n\t\terr = -EIO;\n\n\treturn err ?: ia->write.out.size;\n}","24047":"int finish_connect(struct child_process *conn)\n{\n\tint code;\n\tif (!conn || conn == &no_fork)\n\t\treturn 0;\n\n\tcode = finish_command(conn);\n\tfree(conn->argv);\n\tfree(conn);\n\treturn code;\n}","24155":"SDL_SetPaletteColors(SDL_Palette * palette, const SDL_Color * colors,\n                     int firstcolor, int ncolors)\n{\n    int status = 0;\n\n    \n    if (!palette) {\n        return -1;\n    }\n    if (ncolors > (palette->ncolors - firstcolor)) {\n        ncolors = (palette->ncolors - firstcolor);\n        status = -1;\n    }\n\n    if (colors != (palette->colors + firstcolor)) {\n        SDL_memcpy(palette->colors + firstcolor, colors,\n                   ncolors * sizeof(*colors));\n    }\n    ++palette->version;\n    if (!palette->version) {\n        palette->version = 1;\n    }\n\n    return status;\n}","24311":"static struct entry *alloc_entry(void)\n{\n\tif (nr_entries >= MAX_ENTRIES)\n\t\treturn NULL;\n\n\treturn entries + nr_entries++;\n}","24254":"static int intel_vgpu_mmap(struct mdev_device *mdev, struct vm_area_struct *vma)\n{\n\tunsigned int index;\n\tu64 virtaddr;\n\tunsigned long req_size, pgoff = 0;\n\tpgprot_t pg_prot;\n\tstruct intel_vgpu *vgpu = mdev_get_drvdata(mdev);\n\n\tindex = vma->vm_pgoff >> (VFIO_PCI_OFFSET_SHIFT - PAGE_SHIFT);\n\tif (index >= VFIO_PCI_ROM_REGION_INDEX)\n\t\treturn -EINVAL;\n\n\tif (vma->vm_end < vma->vm_start)\n\t\treturn -EINVAL;\n\tif ((vma->vm_flags & VM_SHARED) == 0)\n\t\treturn -EINVAL;\n\tif (index != VFIO_PCI_BAR2_REGION_INDEX)\n\t\treturn -EINVAL;\n\n\tpg_prot = vma->vm_page_prot;\n\tvirtaddr = vma->vm_start;\n\treq_size = vma->vm_end - vma->vm_start;\n\tpgoff = vgpu_aperture_pa_base(vgpu) >> PAGE_SHIFT;\n\n\treturn remap_pfn_range(vma, virtaddr, pgoff, req_size, pg_prot);\n}","24030":"void CL_GetPing( int n, char *buf, int buflen, int *pingtime )\n{\n\tconst char\t*str;\n\tint\t\ttime;\n\tint\t\tmaxPing;\n\n\tif (n < 0 || n >= MAX_PINGREQUESTS || !cl_pinglist[n].adr.port)\n\t{\n\t\t\n\t\tbuf[0]    = '\\0';\n\t\t*pingtime = 0;\n\t\treturn;\n\t}\n\n\tstr = NET_AdrToStringwPort( cl_pinglist[n].adr );\n\tQ_strncpyz( buf, str, buflen );\n\n\ttime = cl_pinglist[n].time;\n\tif (!time)\n\t{\n\t\t\n\t\ttime = Sys_Milliseconds() - cl_pinglist[n].start;\n\t\tmaxPing = Cvar_VariableIntegerValue( \"STR\" );\n\t\tif( maxPing < 100 ) {\n\t\t\tmaxPing = 100;\n\t\t}\n\t\tif (time < maxPing)\n\t\t{\n\t\t\t\n\t\t\ttime = 0;\n\t\t}\n\t}\n\n\tCL_SetServerInfoByAddress(cl_pinglist[n].adr, cl_pinglist[n].info, cl_pinglist[n].time);\n\n\t*pingtime = time;\n}","24455":"delete (position p, position_set *s)\n{\n  int i;\n\n  for (i = 0; i < s->nelem; ++i)\n    if (p.index == s->elems[i].index)\n      break;\n  if (i < s->nelem)\n    for (--s->nelem; i < s->nelem; ++i)\n      s->elems[i] = s->elems[i + 1];\n}","24088":"static pyc_object *get_long_object(RzBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tbool neg = false;\n\tut32 tmp = 0;\n\tsize_t size;\n\tsize_t i, j = 0, left = 0;\n\tut32 n;\n\tchar *hexstr;\n\tchar digist2hex[] = \"STR\";\n\n\tst32 ndigits = get_st32(buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = RZ_NEW0(pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_LONG;\n\tif (ndigits < 0) {\n\t\tndigits = -ndigits;\n\t\tneg = true;\n\t}\n\tif (ndigits == 0) {\n\t\tret->data = strdup(\"STR\");\n\t} else {\n\t\tsize = ndigits * 15;\n\t\tsize = (size - 1) \/ 4 + 1;\n\t\tsize += 4 + (neg ? 1 : 0);\n\t\thexstr = malloc(size);\n\t\tif (!hexstr) {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemset(hexstr, 0x20, size);\n\t\tj = size - 1;\n\t\thexstr[j] = 0;\n\t\tfor (i = 0; i < ndigits; i++) {\n\t\t\tn = get_ut16(buffer, &error);\n\t\t\ttmp |= n << left;\n\t\t\tleft += 15;\n\n\t\t\twhile (left >= 4) {\n\t\t\t\thexstr[--j] = digist2hex[tmp & 0xf];\n\t\t\t\ttmp >>= 4;\n\t\t\t\tleft -= 4;\n\t\t\t}\n\t\t}\n\n\t\tif (tmp) {\n\t\t\thexstr[--j] = digist2hex[tmp & 0xf];\n\t\t}\n\n\t\thexstr[--j] = 'x';\n\t\thexstr[--j] = '0';\n\t\tif (neg) {\n\t\t\thexstr[--j] = '-';\n\t\t}\n\n\t\trz_str_trim(hexstr);\n\t\tret->data = hexstr;\n\t}\n\treturn ret;\n}","24802":"static void nfs4_close_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tint clear_rd, clear_wr, clear_rdwr;\n\n\tif (nfs_wait_on_sequence(calldata->arg.seqid, task) != 0)\n\t\treturn;\n\n\tclear_rd = clear_wr = clear_rdwr = 0;\n\tspin_lock(&state->owner->so_lock);\n\t\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tclear_rd |= test_and_clear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tclear_rdwr |= test_and_clear_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tclear_wr |= test_and_clear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tclear_rdwr |= test_and_clear_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t}\n\tspin_unlock(&state->owner->so_lock);\n\tif (!clear_rd && !clear_wr && !clear_rdwr) {\n\t\t\n\t\ttask->tk_action = NULL;\n\t\treturn;\n\t}\n\tnfs_fattr_init(calldata->res.fattr);\n\tif (test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];\n\t\tcalldata->arg.open_flags = FMODE_READ;\n\t} else if (test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];\n\t\tcalldata->arg.open_flags = FMODE_WRITE;\n\t}\n\tcalldata->timestamp = jiffies;\n\trpc_call_start(task);\n}","24995":"    void TiffImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"STR\";\n#endif\n        if (io_->open() != 0) throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        IoCloser closer(*io_);\n        \n        if (!isTiffType(*io_, false)) {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"STR\");\n        }\n        clearMetadata();\n\n        ByteOrder bo = TiffParser::decode(exifData_,\n                                          iptcData_,\n                                          xmpData_,\n                                          io_->mmap(),\n                                          (uint32_t) io_->size());\n        setByteOrder(bo);\n\n        \n        Exiv2::ExifKey            key(\"STR\");\n        Exiv2::ExifData::iterator pos   = exifData_.findKey(key);\n        if ( pos != exifData_.end()  ) {\n            iccProfile_.alloc(pos->count()*pos->typeSize());\n            pos->copy(iccProfile_.pData_,bo);\n        }\n\n    } ","23845":"xmlTextReaderAttributeCount(xmlTextReaderPtr reader) {\n    int ret;\n    xmlAttrPtr attr;\n    xmlNsPtr ns;\n    xmlNodePtr node;\n\n    if (reader == NULL)\n\treturn(-1);\n    if (reader->node == NULL)\n\treturn(0);\n\n    if (reader->curnode != NULL)\n\tnode = reader->curnode;\n    else\n\tnode = reader->node;\n\n    if (node->type != XML_ELEMENT_NODE)\n\treturn(0);\n    if ((reader->state == XML_TEXTREADER_END) ||\n\t(reader->state == XML_TEXTREADER_BACKTRACK))\n\treturn(0);\n    ret = 0;\n    attr = node->properties;\n    while (attr != NULL) {\n\tret++;\n\tattr = attr->next;\n    }\n    ns = node->nsDef;\n    while (ns != NULL) {\n\tret++;\n\tns = ns->next;\n    }\n    return(ret);\n}","24612":"struct ldb_request *map_build_fixup_req(struct map_context *ac,\n\t\t\t\t\tstruct ldb_dn *olddn,\n\t\t\t\t\tstruct ldb_dn *newdn,\n\t\t\t\t\tvoid *context,\n\t\t\t\t\tldb_map_callback_t callback)\n{\n\tstruct ldb_context *ldb;\n\tstruct ldb_request *req;\n\tstruct ldb_message *msg;\n\tconst char *dn;\n\tint ret;\n\n\tldb = ldb_module_get_ctx(ac->module);\n\n\t\n\tmsg = ldb_msg_new(ac);\n\tif (msg == NULL) {\n\t\tmap_oom(ac->module);\n\t\treturn NULL;\n\t}\n\n\t\n\tmsg->dn = ldb_dn_copy(msg, olddn);\n\tdn = ldb_dn_alloc_linearized(msg, newdn);\n\tif ( ! dn || ! ldb_dn_validate(msg->dn)) {\n\t\tgoto failed;\n\t}\n\tif (ldb_msg_add_empty(msg, IS_MAPPED, LDB_FLAG_MOD_REPLACE, NULL) != 0) {\n\t\tgoto failed;\n\t}\n\tif (ldb_msg_add_string(msg, IS_MAPPED, dn) != 0) {\n\t\tgoto failed;\n\t}\n\n\t\n\tret = ldb_build_mod_req(&req, ldb,\n\t\t\t\tac, msg, NULL,\n\t\t\t\tcontext, callback,\n\t\t\t\tac->req);\n\tLDB_REQ_SET_LOCATION(req);\n\tif (ret != LDB_SUCCESS) {\n\t\tgoto failed;\n\t}\n\ttalloc_steal(req, msg);\n\n\treturn req;\nfailed:\n\ttalloc_free(msg);\n\treturn NULL;\n}","24033":"BGD_DECLARE(void *) gdImageGifPtr(gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tif (!_gdImageGifCtx(im, out)) {\n\t\trv = gdDPExtractData(out, size);\n\t} else {\n\t\trv = NULL;\n\t}\n\tout->gd_free(out);\n\treturn rv;\n}","24649":"void * LibRaw_file_datastream::make_jas_stream()\n{\n#ifdef NO_JASPER\n    return NULL;\n#else\n#if defined(WIN32) && !defined(__MINGW32__)\n\tif(wfname())\n\t{\n\t\tjas_file = _wfopen(wfname(),L\"STR\");\n\t\treturn jas_stream_fdopen(fileno(jas_file),\"STR\");\n\t}\n\telse\n#endif\n\t{\n\t\treturn jas_stream_fopen(fname(),\"STR\");\n\t}\n#endif\n}","24019":"    CImg<Tfloat> get_diffusion_tensors(const float sharpness=0.7f, const float anisotropy=0.6f,\n                                       const float alpha=0.6f, const float sigma=1.1f, const bool is_sqrt=false) const {\n      return CImg<Tfloat>(*this,false).diffusion_tensors(sharpness,anisotropy,alpha,sigma,is_sqrt);\n    }","23955":"static void b43_dma_tx_suspend_ring(struct b43_dmaring *ring)\n{\n\tB43_WARN_ON(!ring->tx);\n\tring->ops->tx_suspend(ring);\n}","25006":"static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n  int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,\n  int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,\n  uint_fast32_t inmem)\n{\n\tjas_image_cmpt_t *cmpt;\n\tsize_t size;\n\n\tcmpt = 0;\n\tif (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {\n\t\tgoto error;\n\t}\n\tif (!jas_safe_intfast32_add(tlx, width, 0) ||\n\t  !jas_safe_intfast32_add(tly, height, 0)) {\n\t\tgoto error;\n\t}\n\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\tgoto error;\n\t}\n\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->hstep_ = hstep;\n\tcmpt->vstep_ = vstep;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) \/ 8;\n\n\t\n\t\n\t\n\tif (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||\n\t  !jas_safe_size_mul(size, cmpt->cps_, &size)) {\n\t\tgoto error;\n\t}\n\tcmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :\n\t  jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tgoto error;\n\t}\n\n\t\n\t\n\tif (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||\n\t  jas_stream_putc(cmpt->stream_, 0) == EOF ||\n\t  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {\n\t\tgoto error;\n\t}\n\n\treturn cmpt;\n\nerror:\n\tif (cmpt) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t}\n\treturn 0;\n}","24652":"static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain <= 0) {\n\t\t\t\n\t\t\treturn 0; \n\t\t}\n\n\t\trlen = remain;\n\t}\n\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\n\treturn rlen;\n}","24478":"HeaderEntry* HeaderMapImpl::getExisting(const LowerCaseString& key) {\n  \n  \n  \n  \n  auto lookup = staticLookup(key.get());\n  if (lookup.has_value()) {\n    return *lookup.value().entry_;\n  }\n\n  \n  \n  \n  \n  \n  \n  for (HeaderEntryImpl& header : headers_) {\n    if (header.key() == key.get().c_str()) {\n      return &header;\n    }\n  }\n\n  return nullptr;\n}","24888":"startParsing(XML_Parser parser) {\n  \n  if (parser->m_hash_secret_salt == 0)\n    parser->m_hash_secret_salt = generate_hash_secret_salt(parser);\n  if (parser->m_ns) {\n    \n    return setContext(parser, implicitContext);\n  }\n  return XML_TRUE;\n}","24233":"S_ssc_anything(pTHX_ regnode_ssc *ssc)\n{\n    \n\n    PERL_ARGS_ASSERT_SSC_ANYTHING;\n\n    assert(is_ANYOF_SYNTHETIC(ssc));\n\n    \n    ssc->invlist = sv_2mortal(_add_range_to_invlist(NULL, 0, UV_MAX));\n    ANYOF_FLAGS(ssc) |= SSC_MATCHES_EMPTY_STRING;  \n}","24694":"void snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstamp)\n{\n\tunsigned long flags;\n\tunsigned long resolution = 0;\n\tstruct snd_timer_instance *ti, *ts;\n\n\tif (timer->card && timer->card->shutdown)\n\t\treturn;\n\tif (! (timer->hw.flags & SNDRV_TIMER_HW_SLAVE))\n\t\treturn;\n\tif (snd_BUG_ON(event < SNDRV_TIMER_EVENT_MSTART ||\n\t\t       event > SNDRV_TIMER_EVENT_MRESUME))\n\t\treturn;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (event == SNDRV_TIMER_EVENT_MSTART ||\n\t    event == SNDRV_TIMER_EVENT_MCONTINUE ||\n\t    event == SNDRV_TIMER_EVENT_MRESUME)\n\t\tresolution = snd_timer_hw_resolution(timer);\n\tlist_for_each_entry(ti, &timer->active_list_head, active_list) {\n\t\tif (ti->ccallback)\n\t\t\tti->ccallback(ti, event, tstamp, resolution);\n\t\tlist_for_each_entry(ts, &ti->slave_active_head, active_list)\n\t\t\tif (ts->ccallback)\n\t\t\t\tts->ccallback(ts, event, tstamp, resolution);\n\t}\n\tspin_unlock_irqrestore(&timer->lock, flags);\n}","23849":"const EVP_CIPHER *EVP_aes_128_cbc_hmac_sha1(void)\n\t{\n\treturn NULL;\n\t}","24841":"static bool opt_unrec(struct sk_buff *skb, __u32 offset)\n{\n\tu8 _optval, *op;\n\n\toffset += skb_network_offset(skb);\n\top = skb_header_pointer(skb, offset, sizeof(_optval), &_optval);\n\tif (!op)\n\t\treturn true;\n\treturn (*op & 0xC0) == 0x80;\n}","24197":"static int snd_timer_user_params(struct file *file,\n\t\t\t\t struct snd_timer_params __user *_params)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_params params;\n\tstruct snd_timer *t;\n\tstruct snd_timer_read *tr;\n\tstruct snd_timer_tread *ttr;\n\tint err;\n\n\ttu = file->private_data;\n\tif (!tu->timeri)\n\t\treturn -EBADFD;\n\tt = tu->timeri->timer;\n\tif (!t)\n\t\treturn -EBADFD;\n\tif (copy_from_user(&params, _params, sizeof(params)))\n\t\treturn -EFAULT;\n\tif (!(t->hw.flags & SNDRV_TIMER_HW_SLAVE) && params.ticks < 1) {\n\t\terr = -EINVAL;\n\t\tgoto _end;\n\t}\n\tif (params.queue_size > 0 &&\n\t    (params.queue_size < 32 || params.queue_size > 1024)) {\n\t\terr = -EINVAL;\n\t\tgoto _end;\n\t}\n\tif (params.filter & ~((1<<SNDRV_TIMER_EVENT_RESOLUTION)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_TICK)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_START)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_STOP)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_CONTINUE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_PAUSE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_SUSPEND)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_RESUME)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MSTART)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MSTOP)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MCONTINUE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MPAUSE)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MSUSPEND)|\n\t\t\t      (1<<SNDRV_TIMER_EVENT_MRESUME))) {\n\t\terr = -EINVAL;\n\t\tgoto _end;\n\t}\n\tsnd_timer_stop(tu->timeri);\n\tspin_lock_irq(&t->lock);\n\ttu->timeri->flags &= ~(SNDRV_TIMER_IFLG_AUTO|\n\t\t\t       SNDRV_TIMER_IFLG_EXCLUSIVE|\n\t\t\t       SNDRV_TIMER_IFLG_EARLY_EVENT);\n\tif (params.flags & SNDRV_TIMER_PSFLG_AUTO)\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_AUTO;\n\tif (params.flags & SNDRV_TIMER_PSFLG_EXCLUSIVE)\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_EXCLUSIVE;\n\tif (params.flags & SNDRV_TIMER_PSFLG_EARLY_EVENT)\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_EARLY_EVENT;\n\tspin_unlock_irq(&t->lock);\n\tif (params.queue_size > 0 &&\n\t    (unsigned int)tu->queue_size != params.queue_size) {\n\t\tif (tu->tread) {\n\t\t\tttr = kmalloc(params.queue_size * sizeof(*ttr),\n\t\t\t\t      GFP_KERNEL);\n\t\t\tif (ttr) {\n\t\t\t\tkfree(tu->tqueue);\n\t\t\t\ttu->queue_size = params.queue_size;\n\t\t\t\ttu->tqueue = ttr;\n\t\t\t}\n\t\t} else {\n\t\t\ttr = kmalloc(params.queue_size * sizeof(*tr),\n\t\t\t\t     GFP_KERNEL);\n\t\t\tif (tr) {\n\t\t\t\tkfree(tu->queue);\n\t\t\t\ttu->queue_size = params.queue_size;\n\t\t\t\ttu->queue = tr;\n\t\t\t}\n\t\t}\n\t}\n\ttu->qhead = tu->qtail = tu->qused = 0;\n\tif (tu->timeri->flags & SNDRV_TIMER_IFLG_EARLY_EVENT) {\n\t\tif (tu->tread) {\n\t\t\tstruct snd_timer_tread tread;\n\t\t\ttread.event = SNDRV_TIMER_EVENT_EARLY;\n\t\t\ttread.tstamp.tv_sec = 0;\n\t\t\ttread.tstamp.tv_nsec = 0;\n\t\t\ttread.val = 0;\n\t\t\tsnd_timer_user_append_to_tqueue(tu, &tread);\n\t\t} else {\n\t\t\tstruct snd_timer_read *r = &tu->queue[0];\n\t\t\tr->resolution = 0;\n\t\t\tr->ticks = 0;\n\t\t\ttu->qused++;\n\t\t\ttu->qtail++;\n\t\t}\n\t}\n\ttu->filter = params.filter;\n\ttu->ticks = params.ticks;\n\terr = 0;\n _end:\n\tif (copy_to_user(_params, &params, sizeof(params)))\n\t\treturn -EFAULT;\n\treturn err;\n}","24003":"gdk_pixbuf__jpeg_image_save_to_callback (GdkPixbufSaveFunc   save_func,\n\t\t\t\t\t gpointer            user_data,\n\t\t\t\t\t GdkPixbuf          *pixbuf, \n\t\t\t\t\t gchar             **keys,\n\t\t\t\t\t gchar             **values,\n\t\t\t\t\t GError            **error)\n{\n\treturn real_save_jpeg (pixbuf, keys, values, error,\n\t\t\t       TRUE, NULL, save_func, user_data);\n}","24943":"find_word_start(char_u *ptr)\n{\n    if (has_mbyte)\n\twhile (*ptr != NUL && *ptr != '\\n' && mb_get_class(ptr) <= 1)\n\t    ptr += (*mb_ptr2len)(ptr);\n    else\n\twhile (*ptr != NUL && *ptr != '\\n' && !vim_iswordc(*ptr))\n\t    ++ptr;\n    return ptr;\n}","24783":"static int dispatch_discard_io(struct xen_blkif *blkif,\n\t\t\t\tstruct blkif_request *req)\n{\n\tint err = 0;\n\tint status = BLKIF_RSP_OKAY;\n\tstruct block_device *bdev = blkif->vbd.bdev;\n\tunsigned long secure;\n\n\tblkif->st_ds_req++;\n\n\txen_blkif_get(blkif);\n\tsecure = (blkif->vbd.discard_secure &&\n\t\t (req->u.discard.flag & BLKIF_DISCARD_SECURE)) ?\n\t\t BLKDEV_DISCARD_SECURE : 0;\n\n\terr = blkdev_issue_discard(bdev, req->u.discard.sector_number,\n\t\t\t\t   req->u.discard.nr_sectors,\n\t\t\t\t   GFP_KERNEL, secure);\n\n\tif (err == -EOPNOTSUPP) {\n\t\tpr_debug(DRV_PFX \"STR\");\n\t\tstatus = BLKIF_RSP_EOPNOTSUPP;\n\t} else if (err)\n\t\tstatus = BLKIF_RSP_ERROR;\n\n\tmake_response(blkif, req->u.discard.id, req->operation, status);\n\txen_blkif_put(blkif);\n\treturn err;\n}","24650":"static js_Ast *shift(js_State *J)\n{\n\tjs_Ast *a = additive(J);\nloop:\n\tif (jsP_accept(J, TK_SHL)) { a = EXP2(SHL, a, additive(J)); goto loop; }\n\tif (jsP_accept(J, TK_SHR)) { a = EXP2(SHR, a, additive(J)); goto loop; }\n\tif (jsP_accept(J, TK_USHR)) { a = EXP2(USHR, a, additive(J)); goto loop; }\n\treturn a;\n}","23989":"static int proxy_authz(const char **authzid, struct transaction_t *txn)\n{\n    static char authzbuf[MAX_MAILBOX_BUFFER];\n    unsigned authzlen;\n    int status;\n\n    syslog(LOG_DEBUG, \"STR\", *authzid);\n\n    \n    if (httpd_userid) {\n        free(httpd_userid);\n        httpd_userid = NULL;\n    }\n    if (httpd_extrafolder) {\n        free(httpd_extrafolder);\n        httpd_extrafolder = NULL;\n    }\n    if (httpd_extradomain) {\n        free(httpd_extradomain);\n        httpd_extradomain = NULL;\n    }\n    if (httpd_authstate) {\n        auth_freestate(httpd_authstate);\n        httpd_authstate = NULL;\n    }\n\n    if (!(config_mupdate_server && config_getstring(IMAPOPT_PROXYSERVERS))) {\n        \n        syslog(LOG_NOTICE, \"STR\",\n               txn->conn->clienthost, txn->auth_chal.scheme->name, httpd_authid,\n               \"STR\");\n        return SASL_NOAUTHZ;\n    }\n\n    \n    status = mysasl_canon_user(httpd_saslconn, NULL,\n                               *authzid, strlen(*authzid),\n                               SASL_CU_AUTHZID, NULL,\n                               authzbuf, sizeof(authzbuf), &authzlen);\n    if (status) {\n        syslog(LOG_NOTICE, \"STR\",\n               txn->conn->clienthost, txn->auth_chal.scheme->name,\n               beautify_string(*authzid));\n        return status;\n    }\n\n    \n    status = mysasl_proxy_policy(httpd_saslconn, &httpd_proxyctx,\n                                 authzbuf, authzlen,\n                                 httpd_authid, strlen(httpd_authid),\n                                 NULL, 0, NULL);\n\n    if (status) {\n        syslog(LOG_NOTICE, \"STR\",\n               txn->conn->clienthost, txn->auth_chal.scheme->name, httpd_authid,\n               sasl_errdetail(httpd_saslconn));\n        return status;\n    }\n\n    *authzid = authzbuf;\n\n    return status;\n}","24395":"TRIO_PUBLIC_STRING void trio_destroy TRIO_ARGS1((string), char* string)\n{\n\tif (string)\n\t{\n\t\tTRIO_FREE(string);\n\t}\n}","24958":"TEE_Result syscall_hash_final(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size, void *hash, uint64_t *hash_len)\n{\n\tTEE_Result res, res2;\n\tsize_t hash_size;\n\tsize_t hlen = 0;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\t\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&hlen, hash_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)hash, hlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = tee_hash_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk,\n\t\t\t\t\t\t chunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_hash_final(cs->ctx, cs->algo, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tcase TEE_OPERATION_MAC:\n\t\tres = tee_mac_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_mac_update(cs->ctx, cs->algo, chunk,\n\t\t\t\t\t\tchunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_mac_final(cs->ctx, cs->algo, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\nout:\n\tres2 = put_user_u64(hash_len, hash_size);\n\tif (res2 != TEE_SUCCESS)\n\t\treturn res2;\n\treturn res;\n}","24097":"void __do_SAK(struct tty_struct *tty)\n{\n#ifdef TTY_SOFT_SAK\n\ttty_hangup(tty);\n#else\n\tstruct task_struct *g, *p;\n\tstruct pid *session;\n\tint\t\ti;\n\n\tif (!tty)\n\t\treturn;\n\tsession = tty->session;\n\n\ttty_ldisc_flush(tty);\n\n\ttty_driver_flush_buffer(tty);\n\n\tread_lock(&tasklist_lock);\n\t\n\tdo_each_pid_task(session, PIDTYPE_SID, p) {\n\t\ttty_notice(tty, \"STR\",\n\t\t\t   task_pid_nr(p), p->comm);\n\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t} while_each_pid_task(session, PIDTYPE_SID, p);\n\n\t\n\tdo_each_thread(g, p) {\n\t\tif (p->signal->tty == tty) {\n\t\t\ttty_notice(tty, \"STR\",\n\t\t\t\t   task_pid_nr(p), p->comm);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_lock(p);\n\t\ti = iterate_fd(p->files, 0, this_tty, tty);\n\t\tif (i != 0) {\n\t\t\ttty_notice(tty, \"STR\",\n\t\t\t\t   task_pid_nr(p), p->comm, i - 1);\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID);\n\t\t}\n\t\ttask_unlock(p);\n\t} while_each_thread(g, p);\n\tread_unlock(&tasklist_lock);\n#endif\n}","24606":"static void cirrus_mem_writeb_mode4and5_16bpp(CirrusVGAState * s,\n\t\t\t\t\t      unsigned mode,\n\t\t\t\t\t      unsigned offset,\n\t\t\t\t\t      uint32_t mem_value)\n{\n    int x;\n    unsigned val = mem_value;\n    uint8_t *dst;\n\n    dst = s->vram_ptr + offset;\n    for (x = 0; x < 8; x++) {\n\tif (val & 0x80) {\n\t    *dst = s->cirrus_shadow_gr1;\n\t    *(dst + 1) = s->gr[0x11];\n\t} else if (mode == 5) {\n\t    *dst = s->cirrus_shadow_gr0;\n\t    *(dst + 1) = s->gr[0x10];\n\t}\n\tval <<= 1;\n\tdst += 2;\n    }\n    cpu_physical_memory_set_dirty(s->vram_offset + offset);\n    cpu_physical_memory_set_dirty(s->vram_offset + offset + 15);\n}","24913":"void t_go_generator::generate_deserialize_map_element(ofstream& out,\n                                                      t_map* tmap,\n                                                      bool declare,\n                                                      string prefix) {\n  (void)declare;\n  string key = tmp(\"STR\");\n  string val = tmp(\"STR\");\n  t_field fkey(tmap->get_key_type(), key);\n  t_field fval(tmap->get_val_type(), val);\n  fkey.set_req(t_field::T_OPT_IN_REQ_OUT);\n  fval.set_req(t_field::T_OPT_IN_REQ_OUT);\n  generate_deserialize_field(out, &fkey, true, \"\", false, false, true);\n  generate_deserialize_field(out, &fval, true, \"\", false, false, false, true);\n  indent(out) << prefix << \"STR\" << val << endl;\n}","24529":"int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)\n{\n\tint r;\n\tsigset_t sigsaved;\n\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &vcpu->sigset, &sigsaved);\n\n\tif (unlikely(vcpu->arch.mp_state == KVM_MP_STATE_UNINITIALIZED)) {\n\t\tkvm_vcpu_block(vcpu);\n\t\tclear_bit(KVM_REQ_UNHALT, &vcpu->requests);\n\t\tr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\t\n\tif (!irqchip_in_kernel(vcpu->kvm))\n\t\tkvm_set_cr8(vcpu, kvm_run->cr8);\n\n\tif (vcpu->arch.pio.count || vcpu->mmio_needed) {\n\t\tif (vcpu->mmio_needed) {\n\t\t\tmemcpy(vcpu->mmio_data, kvm_run->mmio.data, 8);\n\t\t\tvcpu->mmio_read_completed = 1;\n\t\t\tvcpu->mmio_needed = 0;\n\t\t}\n\t\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\t\tr = emulate_instruction(vcpu, 0, 0, EMULTYPE_NO_DECODE);\n\t\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\t\tif (r != EMULATE_DONE) {\n\t\t\tr = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (kvm_run->exit_reason == KVM_EXIT_HYPERCALL)\n\t\tkvm_register_write(vcpu, VCPU_REGS_RAX,\n\t\t\t\t     kvm_run->hypercall.ret);\n\n\tr = __vcpu_run(vcpu);\n\nout:\n\tpost_kvm_run_save(vcpu);\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\n\treturn r;\n}","24315":"static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,\n    gint64 *data_offset)\n{\n\tgint64\toffset;\n\tint\tpkt_len;\n\tchar\tline[COSINE_LINE_LENGTH];\n\n\t\n\toffset = cosine_seek_next_packet(wth, err, err_info, line);\n\tif (offset < 0)\n\t\treturn FALSE;\n\t*data_offset = offset;\n\n\t\n\tpkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);\n\tif (pkt_len == -1)\n\t\treturn FALSE;\n\n\t\n\treturn parse_cosine_hex_dump(wth->fh, &wth->phdr, pkt_len,\n\t    wth->frame_buffer, err, err_info);\n}","24549":"GF_Err gf_isom_set_edit_with_rate(GF_ISOFile *movie, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, u32 media_rate)\n{\n\treturn gf_isom_set_edit_internal(movie, trackNumber, EditTime, EditDuration, MediaTime, media_rate, GF_ISOM_EDIT_NORMAL+1);\n\n}","23980":"static bool ide_bmdma_current_needed(void *opaque)\n{\n    BMDMAState *bm = opaque;\n\n    return (bm->cur_prd_len != 0);\n}","24127":"int kvm_highest_pending_irq(struct kvm_vcpu *vcpu)\n{\n    struct vpd *vpd = to_host(vcpu->kvm, vcpu->arch.vpd);\n\n    if (vpd->irr[0] & (1UL << NMI_VECTOR))\n\t\treturn NMI_VECTOR;\n    if (vpd->irr[0] & (1UL << ExtINT_VECTOR))\n\t\treturn ExtINT_VECTOR;\n\n    return find_highest_bits((int *)&vpd->irr[0]);\n}","23847":"void _xml_startElementHandler(void *userData, const XML_Char *name, const XML_Char **attributes)\n{\n\txml_parser *parser = (xml_parser *)userData;\n\tconst char **attrs = (const char **) attributes;\n\tchar *tag_name;\n\tchar *att, *val;\n\tint val_len;\n\tzval *retval, *args[3];\n\n\tif (parser) {\n\t\tparser->level++;\n\n\t\ttag_name = _xml_decode_tag(parser, name);\n\n\t\tif (parser->startElementHandler) {\n\t\t\targs[0] = _xml_resource_zval(parser->index);\n\t\t\targs[1] = _xml_string_zval(((char *) tag_name) + parser->toffset);\n\t\t\tMAKE_STD_ZVAL(args[2]);\n\t\t\tarray_init(args[2]);\n\n\t\t\twhile (attributes && *attributes) {\n\t\t\t\tatt = _xml_decode_tag(parser, attributes[0]);\n\t\t\t\tval = xml_utf8_decode(attributes[1], strlen(attributes[1]), &val_len, parser->target_encoding);\n\n\t\t\t\tadd_assoc_stringl(args[2], att, val, val_len, 0);\n\n\t\t\t\tattributes += 2;\n\n\t\t\t\tefree(att);\n\t\t\t}\n\t\t\t\n\t\t\tif ((retval = xml_call_handler(parser, parser->startElementHandler, parser->startElementPtr, 3, args))) {\n\t\t\t\tzval_ptr_dtor(&retval);\n\t\t\t}\n\t\t} \n\n\t\tif (parser->data) {\n\t\t\tif (parser->level <= XML_MAXLEVEL)  {\n\t\t\t\tzval *tag, *atr;\n\t\t\t\tint atcnt = 0;\n\n\t\t\t\tMAKE_STD_ZVAL(tag);\n\t\t\t\tMAKE_STD_ZVAL(atr);\n\n\t\t\t\tarray_init(tag);\n\t\t\t\tarray_init(atr);\n\n\t\t\t\t_xml_add_to_info(parser,((char *) tag_name) + parser->toffset);\n\n\t\t\t\tadd_assoc_string(tag,\"STR\",((char *) tag_name) + parser->toffset,1); \n\t\t\t\tadd_assoc_string(tag,\"STR\",1);\n\t\t\t\tadd_assoc_long(tag,\"STR\",parser->level);\n\n\t\t\t\tparser->ltags[parser->level-1] = estrdup(tag_name);\n\t\t\t\tparser->lastwasopen = 1;\n\n\t\t\t\tattributes = (const XML_Char **) attrs;\n\n\t\t\t\twhile (attributes && *attributes) {\n\t\t\t\t\tatt = _xml_decode_tag(parser, attributes[0]);\n\t\t\t\t\tval = xml_utf8_decode(attributes[1], strlen(attributes[1]), &val_len, parser->target_encoding);\n\n\t\t\t\t\tadd_assoc_stringl(atr,att,val,val_len,0);\n\n\t\t\t\t\tatcnt++;\n\t\t\t\t\tattributes += 2;\n\n\t\t\t\t\tefree(att);\n\t\t\t\t}\n\n\t\t\t\tif (atcnt) {\n\t\t\t\t\tzend_hash_add(Z_ARRVAL_P(tag),\"STR\"),&atr,sizeof(zval*),NULL);\n\t\t\t\t} else {\n\t\t\t\t\tzval_ptr_dtor(&atr);\n\t\t\t\t}\n\n\t\t\t\tzend_hash_next_index_insert(Z_ARRVAL_P(parser->data),&tag,sizeof(zval*),(void *) &parser->ctag);\n\t\t\t} else if (parser->level == (XML_MAXLEVEL + 1)) {\n\t\t\t\tTSRMLS_FETCH();\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"STR\");\n\t\t\t}\n\t\t}\n\n\t\tefree(tag_name);\n\t}\n}","24882":"wl_map_insert_at(struct wl_map *map, uint32_t flags, uint32_t i, void *data)\n{\n\tunion map_entry *start;\n\tuint32_t count;\n\tstruct wl_array *entries;\n\n\tif (i < WL_SERVER_ID_START) {\n\t\tentries = &map->client_entries;\n\t} else {\n\t\tentries = &map->server_entries;\n\t\ti -= WL_SERVER_ID_START;\n\t}\n\n\tcount = entries->size \/ sizeof *start;\n\tif (count < i) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (count == i) {\n\t\tif (!wl_array_add(entries, sizeof *start))\n\t\t\treturn -1;\n\t}\n\n\tstart = entries->data;\n\tstart[i].data = data;\n\tstart[i].next |= (flags & 0x1) << 1;\n\n\treturn 0;\n}","24610":"static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct s_smc *smc = netdev_priv(dev);\n\tskfddi_priv *lp = &smc->os;\n\tstruct s_skfp_ioctl ioc;\n\tint status = 0;\n\n\tif (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))\n\t\treturn -EFAULT;\n\n\tswitch (ioc.cmd) {\n\tcase SKFP_GET_STATS:\t\n\t\tioc.len = sizeof(lp->MacStat);\n\t\tstatus = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)\n\t\t\t\t? -EFAULT : 0;\n\t\tbreak;\n\tcase SKFP_CLR_STATS:\t\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tmemset(&lp->MacStat, 0, sizeof(lp->MacStat));\n\t\t} else {\n\t\t\tstatus = -EPERM;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"STR\", dev->name, ioc.cmd);\n\t\tstatus = -EOPNOTSUPP;\n\n\t}\t\t\t\n\n\treturn status;\n}\t\t\t\t","24149":"percent_dollar_expand(const char *string, ...)\n{\n\tchar *ret;\n\tint err;\n\tva_list ap;\n\n\tva_start(ap, string);\n\tret = vdollar_percent_expand(&err, 1, 1, string, ap);\n\tva_end(ap);\n\tif (err)\n\t\tfatal_f(\"STR\");\n\treturn ret;\n}","24618":"poppler_fonts_iter_get_font_type (PopplerFontsIter *iter)\n{\n\tFontInfo *info;\n\n\tg_return_val_if_fail (iter != nullptr, POPPLER_FONT_TYPE_UNKNOWN);\n\n\tinfo = (FontInfo *)iter->items->get (iter->index);\n\n\treturn (PopplerFontType)info->getType ();\n}","24370":"struct task_group *sched_create_group(struct task_group *parent)\n{\n\tstruct task_group *tg;\n\n\ttg = kzalloc(sizeof(*tg), GFP_KERNEL);\n\tif (!tg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!alloc_fair_sched_group(tg, parent))\n\t\tgoto err;\n\n\tif (!alloc_rt_sched_group(tg, parent))\n\t\tgoto err;\n\n\treturn tg;\n\nerr:\n\tfree_sched_group(tg);\n\treturn ERR_PTR(-ENOMEM);\n}","24486":"xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {\n    xmlXPathObjectPtr ret;\n\n    if (start == NULL)\n\treturn(NULL);\n    if (end == NULL)\n\treturn(NULL);\n\n    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));\n    if (ret == NULL) {\n        xmlXPtrErrMemory(\"STR\");\n\treturn(NULL);\n    }\n    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));\n    ret->type = XPATH_RANGE;\n    ret->user = start;\n    ret->index = -1;\n    ret->user2 = end;\n    ret->index2 = -1;\n    xmlXPtrRangeCheckOrder(ret);\n    return(ret);\n}","24537":"  virtual enum ha_base_keytype key_type() const { return HA_KEYTYPE_BINARY; }","24021":"static RList *r_bin_wasm_get_data_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\n\tRList *ret = NULL;\n\tRBinWasmDataEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\tsize_t n = 0;\n\n\twhile (i < len && r < count) {\n\n\t\tif (!(ptr = R_NEW0 (RBinWasmDataEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(n = consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tptr->offset.len = n;\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) {\t\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tptr->data = sec->payload_data + i;\n\n\t\tr_list_append (ret, ptr);\n\n\t\tr += 1;\n\n\t}\n\n\treturn ret;\n}","24872":"void __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tint need_software_tstamp = sock_flag(sk, SOCK_RCVTSTAMP);\n\tstruct scm_timestamping tss;\n\tint empty = 1;\n\tstruct skb_shared_hwtstamps *shhwtstamps =\n\t\tskb_hwtstamps(skb);\n\n\t\n\tif (need_software_tstamp && skb->tstamp == 0)\n\t\t__net_timestamp(skb);\n\n\tif (need_software_tstamp) {\n\t\tif (!sock_flag(sk, SOCK_RCVTSTAMPNS)) {\n\t\t\tstruct timeval tv;\n\t\t\tskb_get_timestamp(skb, &tv);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMP,\n\t\t\t\t sizeof(tv), &tv);\n\t\t} else {\n\t\t\tstruct timespec ts;\n\t\t\tskb_get_timestampns(skb, &ts);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPNS,\n\t\t\t\t sizeof(ts), &ts);\n\t\t}\n\t}\n\n\tmemset(&tss, 0, sizeof(tss));\n\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_SOFTWARE) &&\n\t    ktime_to_timespec_cond(skb->tstamp, tss.ts + 0))\n\t\tempty = 0;\n\tif (shhwtstamps &&\n\t    (sk->sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE) &&\n\t    ktime_to_timespec_cond(shhwtstamps->hwtstamp, tss.ts + 2))\n\t\tempty = 0;\n\tif (!empty) {\n\t\tput_cmsg(msg, SOL_SOCKET,\n\t\t\t SCM_TIMESTAMPING, sizeof(tss), &tss);\n\n\t\tif (skb->len && (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS))\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_OPT_STATS,\n\t\t\t\t skb->len, skb->data);\n\t}\n}","24314":"static int virtio_net_handle_mq(VirtIONet *n, uint8_t cmd,\n                                struct iovec *iov, unsigned int iov_cnt)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    struct virtio_net_ctrl_mq mq;\n    size_t s;\n    uint16_t queues;\n\n    s = iov_to_buf(iov, iov_cnt, 0, &mq, sizeof(mq));\n    if (s != sizeof(mq)) {\n        return VIRTIO_NET_ERR;\n    }\n\n    if (cmd != VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET) {\n        return VIRTIO_NET_ERR;\n    }\n\n    queues = lduw_p(&mq.virtqueue_pairs);\n\n    if (queues < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN ||\n        queues > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX ||\n        queues > n->max_queues ||\n        !n->multiqueue) {\n        return VIRTIO_NET_ERR;\n    }\n\n    n->curr_queues = queues;\n    \n    virtio_net_set_status(vdev, vdev->status);\n    virtio_net_set_queues(n);\n\n    return VIRTIO_NET_OK;\n}","24914":"static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tint n;\n\tint ret;\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tlong newbufsize;\n\tlong newpos;\n\n\tassert(buf);\n\tassert(cnt >= 0);\n\n\tJAS_DBGLOG(100, (\"STR\", obj, buf, cnt));\n\tnewpos = m->pos_ + cnt;\n\tif (newpos > m->bufsize_ && m->growable_) {\n\t\tnewbufsize = m->bufsize_;\n\t\twhile (newbufsize < newpos) {\n\t\t\tnewbufsize <<= 1;\n\t\t\tassert(newbufsize >= 0);\n\t\t}\n\t\tJAS_DBGLOG(100, (\"STR\", m->bufsize_,\n\t\t  newbufsize));\n\t\tJAS_DBGLOG(100, (\"STR\", m->bufsize_,\n\t\t  JAS_CAST(unsigned long, newbufsize)));\n\t\tif (mem_resize(m, newbufsize)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (m->pos_ > m->len_) {\n\t\t\n\t\tn = JAS_MIN(m->pos_, m->bufsize_) - m->len_;\n\t\tif (n > 0) {\n\t\t\tmemset(&m->buf_[m->len_], 0, n);\n\t\t\tm->len_ += n;\n\t\t}\n\t\tif (m->pos_ != m->len_) {\n\t\t\t\n\t\t\treturn 0;\n\t\t}\n\t}\n\tn = m->bufsize_ - m->pos_;\n\tret = JAS_MIN(n, cnt);\n\tif (ret > 0) {\n\t\tmemcpy(&m->buf_[m->pos_], buf, ret);\n\t\tm->pos_ += ret;\n\t}\n\tif (m->pos_ > m->len_) {\n\t\tm->len_ = m->pos_;\n\t}\n\tassert(ret == cnt);\n\treturn ret;\n}","23843":"int use_env()\n{\n    int indent;\n    size_t flags = 0;\n    json_t *json;\n    json_error_t error;\n\n    #ifdef _WIN32\n    \n    _setmode(_fileno(stdout), _O_BINARY);\n    _setmode(_fileno(stderr), _O_BINARY);\n    #endif\n\n    indent = getenv_int(\"STR\");\n    if(indent < 0 || indent > 255) {\n        fprintf(stderr, \"STR\", indent);\n        return 2;\n    }\n\n    if(indent > 0)\n        flags |= JSON_INDENT(indent);\n\n    if(getenv_int(\"STR\") > 0)\n        flags |= JSON_COMPACT;\n\n    if(getenv_int(\"STR\"))\n        flags |= JSON_ENSURE_ASCII;\n\n    if(getenv_int(\"STR\"))\n        flags |= JSON_PRESERVE_ORDER;\n\n    if(getenv_int(\"STR\"))\n         flags |= JSON_SORT_KEYS;\n\n    if(getenv_int(\"STR\")) {\n        \n        size_t size = 0, used = 0;\n        char *buffer = NULL;\n\n        while(1) {\n            size_t count;\n\n            size = (size == 0 ? 128 : size * 2);\n            buffer = realloc(buffer, size);\n            if(!buffer) {\n                fprintf(stderr, \"STR\", (int)size);\n                return 1;\n            }\n\n            count = fread(buffer + used, 1, size - used, stdin);\n            if(count < size - used) {\n                buffer[used + count] = '\\0';\n                break;\n            }\n            used += count;\n        }\n\n        json = json_loads(strip(buffer), 0, &error);\n        free(buffer);\n    }\n    else\n        json = json_loadf(stdin, 0, &error);\n\n    if(!json) {\n        fprintf(stderr, \"STR\",\n            error.line, error.column,\n            error.position, error.text);\n        return 1;\n    }\n\n    json_dumpf(json, stdout, flags);\n    json_decref(json);\n\n    return 0;\n}","24929":"void pcntl_signal_dispatch()\n{\n\tzval *param, **handle, *retval;\n\tstruct php_pcntl_pending_signal *queue, *next;\n\tsigset_t mask;\n\tsigset_t old_mask;\n\tTSRMLS_FETCH();\n\t\t\n\t\n\tsigfillset(&mask);\n\tsigprocmask(SIG_BLOCK, &mask, &old_mask);\n\n\t\n\tif (! PCNTL_G(head) || PCNTL_G(processing_signal_queue)) {\n\t\tsigprocmask(SIG_SETMASK, &old_mask, NULL);\n\t\treturn;\n\t}\n\n\t\n\tPCNTL_G(processing_signal_queue) = 1;\n\n\tqueue = PCNTL_G(head);\n\tPCNTL_G(head) = NULL; \n\t\n\t\n\n\twhile (queue) {\n\t\tif (zend_hash_index_find(&PCNTL_G(php_signal_table), queue->signo, (void **) &handle)==SUCCESS) {\n\t\t\tMAKE_STD_ZVAL(retval);\n\t\t\tMAKE_STD_ZVAL(param);\n\t\t\tZVAL_NULL(retval);\n\t\t\tZVAL_LONG(param, queue->signo);\n\n\t\t\t\n\t\t\t\n\t\t\tcall_user_function(EG(function_table), NULL, *handle, retval, 1, &param TSRMLS_CC);\n\t\t\tzval_ptr_dtor(&param);\n\t\t\tzval_ptr_dtor(&retval);\n\t\t}\n\n\t\tnext = queue->next;\n\t\tqueue->next = PCNTL_G(spares);\n\t\tPCNTL_G(spares) = queue;\n\t\tqueue = next;\n\t}\n\n\t\n\tPCNTL_G(processing_signal_queue) = 0;\n\t\n\t\n\tsigprocmask(SIG_SETMASK, &old_mask, NULL);\n}","24788":"int install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->process_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"STR\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->process_keyring = keyring;\n\treturn 0;\n}","24609":"int ipv6_recv_rxpmtu(struct sock *sk, struct msghdr *msg, int len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct sockaddr_in6 *sin;\n\tstruct ip6_mtuinfo mtu_info;\n\tint err;\n\tint copied;\n\n\terr = -EAGAIN;\n\tskb = xchg(&np->rxpmtu, NULL);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\tmemcpy(&mtu_info, IP6CBMTU(skb), sizeof(mtu_info));\n\n\tsin = (struct sockaddr_in6 *)msg->msg_name;\n\tif (sin) {\n\t\tsin->sin6_family = AF_INET6;\n\t\tsin->sin6_flowinfo = 0;\n\t\tsin->sin6_port = 0;\n\t\tsin->sin6_scope_id = mtu_info.ip6m_addr.sin6_scope_id;\n\t\tsin->sin6_addr = mtu_info.ip6m_addr.sin6_addr;\n\t}\n\n\tput_cmsg(msg, SOL_IPV6, IPV6_PATHMTU, sizeof(mtu_info), &mtu_info);\n\n\terr = copied;\n\nout_free_skb:\n\tkfree_skb(skb);\nout:\n\treturn err;\n}","23873":"bytes_fromhex_impl(PyTypeObject *type, PyObject *string)\n\n{\n    PyObject *newstring;\n    char *buf;\n    Py_ssize_t hexlen, byteslen, i, j;\n    int top, bot;\n    void *data;\n    unsigned int kind;\n\n    assert(PyUnicode_Check(string));\n    if (PyUnicode_READY(string))\n        return NULL;\n    kind = PyUnicode_KIND(string);\n    data = PyUnicode_DATA(string);\n    hexlen = PyUnicode_GET_LENGTH(string);\n\n    byteslen = hexlen\/2; \n    newstring = PyBytes_FromStringAndSize(NULL, byteslen);\n    if (!newstring)\n        return NULL;\n    buf = PyBytes_AS_STRING(newstring);\n    for (i = j = 0; i < hexlen; i += 2) {\n        \n        while (PyUnicode_READ(kind, data, i) == ' ')\n            i++;\n        if (i >= hexlen)\n            break;\n        top = hex_digit_to_int(PyUnicode_READ(kind, data, i));\n        bot = hex_digit_to_int(PyUnicode_READ(kind, data, i+1));\n        if (top == -1 || bot == -1) {\n            PyErr_Format(PyExc_ValueError,\n                         \"STR\"\n                         \"STR\", i);\n            goto error;\n        }\n        buf[j++] = (top << 4) + bot;\n    }\n    if (j != byteslen && _PyBytes_Resize(&newstring, j) < 0)\n        goto error;\n    return newstring;\n\n  error:\n    Py_XDECREF(newstring);\n    return NULL;\n}","24855":"static gg_action_t gg_handle_send_proxy_gg(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)\n{\n\tchar *req, *auth;\n\tsize_t req_len;\n\tint res;\n\n\tgg_debug_session(sess, GG_DEBUG_MISC, \"STR\", gg_debug_state(sess->state));\n\n\tif (sess->connect_index > 1 || sess->connect_port[sess->connect_index] == 0) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"STR\");\n\t\te->event.failure = GG_FAILURE_CONNECTING;\n\t\treturn GG_ACTION_FAIL;\n\t}\n\n\tauth = gg_proxy_auth();\n\n\treq = gg_saprintf(\"STR\");\n\n\tfree(auth);\n\n\tsess->connect_index++;\n\n\tif (req == NULL) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"STR\");\n\t\te->event.failure = GG_FAILURE_PROXY;\n\t\treturn GG_ACTION_FAIL;\n\t}\n\n\treq_len = strlen(req);\n\n\tgg_debug_session(sess, GG_DEBUG_MISC, \"STR\", req);\n\n\tres = send(sess->fd, req, req_len, 0);\n\n\tfree(req);\n\n\tif (res == -1 && errno != EINTR && errno != EAGAIN) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"STR\");\n\t\te->event.failure = GG_FAILURE_PROXY;\n\t\treturn GG_ACTION_FAIL;\n\t}\n\n\tif ((size_t) res < req_len) {\n\t\tsess->state = alt_state;\n\t\tsess->check = GG_CHECK_WRITE;\n\t\tsess->timeout = GG_DEFAULT_TIMEOUT;\n\t} else {\n\t\tsess->state = next_state;\n\t\tsess->check = GG_CHECK_READ;\n\t\tsess->timeout = GG_DEFAULT_TIMEOUT;\n\t}\n\n\treturn GG_ACTION_WAIT;\n}","24820":"static void do_json_acroform(QPDF& pdf, Options& o, JSON& j)\n{\n    JSON j_acroform = j.addDictionaryMember(\n        \"STR\", JSON::makeDictionary());\n    QPDFAcroFormDocumentHelper afdh(pdf);\n    j_acroform.addDictionaryMember(\n        \"STR\",\n        JSON::makeBool(afdh.hasAcroForm()));\n    j_acroform.addDictionaryMember(\n        \"STR\",\n        JSON::makeBool(afdh.getNeedAppearances()));\n    JSON j_fields = j_acroform.addDictionaryMember(\n        \"STR\", JSON::makeArray());\n    QPDFPageDocumentHelper pdh(pdf);\n    std::vector<QPDFPageObjectHelper> pages = pdh.getAllPages();\n    int pagepos1 = 0;\n    for (std::vector<QPDFPageObjectHelper>::iterator page_iter =\n             pages.begin();\n         page_iter != pages.end(); ++page_iter)\n    {\n        ++pagepos1;\n        std::vector<QPDFAnnotationObjectHelper> annotations =\n            afdh.getWidgetAnnotationsForPage(*page_iter);\n        for (std::vector<QPDFAnnotationObjectHelper>::iterator annot_iter =\n                 annotations.begin();\n             annot_iter != annotations.end(); ++annot_iter)\n        {\n            QPDFAnnotationObjectHelper& aoh = *annot_iter;\n            QPDFFormFieldObjectHelper ffh =\n                afdh.getFieldForAnnotation(aoh);\n            JSON j_field = j_fields.addArrayElement(\n                JSON::makeDictionary());\n            j_field.addDictionaryMember(\n                \"STR\",\n                ffh.getObjectHandle().getJSON());\n            j_field.addDictionaryMember(\n                \"STR\",\n                ffh.getObjectHandle().getKey(\"STR\").getJSON());\n            j_field.addDictionaryMember(\n                \"STR\",\n                JSON::makeInt(pagepos1));\n            j_field.addDictionaryMember(\n                \"STR\",\n                JSON::makeString(ffh.getFieldType()));\n            j_field.addDictionaryMember(\n                \"STR\",\n                JSON::makeInt(ffh.getFlags()));\n            j_field.addDictionaryMember(\n                \"STR\",\n                JSON::makeString(ffh.getFullyQualifiedName()));\n            j_field.addDictionaryMember(\n                \"STR\",\n                JSON::makeString(ffh.getPartialName()));\n            j_field.addDictionaryMember(\n                \"STR\",\n                JSON::makeString(ffh.getAlternativeName()));\n            j_field.addDictionaryMember(\n                \"STR\",\n                JSON::makeString(ffh.getMappingName()));\n            j_field.addDictionaryMember(\n                \"STR\",\n                ffh.getValue().getJSON());\n            j_field.addDictionaryMember(\n                \"STR\",\n                ffh.getDefaultValue().getJSON());\n            j_field.addDictionaryMember(\n                \"STR\",\n                JSON::makeInt(ffh.getQuadding()));\n            j_field.addDictionaryMember(\n                \"STR\",\n                JSON::makeBool(ffh.isCheckbox()));\n            j_field.addDictionaryMember(\n                \"STR\",\n                JSON::makeBool(ffh.isRadioButton()));\n            j_field.addDictionaryMember(\n                \"STR\",\n                JSON::makeBool(ffh.isChoice()));\n            j_field.addDictionaryMember(\n                \"STR\",\n                JSON::makeBool(ffh.isText()));\n            JSON j_choices = j_field.addDictionaryMember(\n                \"STR\", JSON::makeArray());\n            std::vector<std::string> choices = ffh.getChoices();\n            for (std::vector<std::string>::iterator iter = choices.begin();\n                 iter != choices.end(); ++iter)\n            {\n                j_choices.addArrayElement(JSON::makeString(*iter));\n            }\n            JSON j_annot = j_field.addDictionaryMember(\n                \"STR\", JSON::makeDictionary());\n            j_annot.addDictionaryMember(\n                \"STR\",\n                aoh.getObjectHandle().getJSON());\n            j_annot.addDictionaryMember(\n                \"STR\",\n                JSON::makeString(aoh.getAppearanceState()));\n            j_annot.addDictionaryMember(\n                \"STR\",\n                JSON::makeInt(aoh.getFlags()));\n        }\n    }\n}","24187":"void brcmf_free_vif(struct brcmf_cfg80211_vif *vif)\n{\n\tlist_del(&vif->list);\n\tkfree(vif);\n}","25013":"static int selinux_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)\n{\n\tint err;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tu16 family = sk->sk_family;\n\tu32 sk_sid = sksec->sid;\n\tstruct common_audit_data ad;\n\tstruct lsm_network_audit net = {0,};\n\tchar *addrp;\n\tu8 secmark_active;\n\tu8 peerlbl_active;\n\n\tif (family != PF_INET && family != PF_INET6)\n\t\treturn 0;\n\n\t\n\tif (family == PF_INET6 && skb->protocol == htons(ETH_P_IP))\n\t\tfamily = PF_INET;\n\n\t\n\tif (!selinux_policycap_netpeer)\n\t\treturn selinux_sock_rcv_skb_compat(sk, skb, family);\n\n\tsecmark_active = selinux_secmark_enabled();\n\tpeerlbl_active = selinux_peerlbl_enabled();\n\tif (!secmark_active && !peerlbl_active)\n\t\treturn 0;\n\n\tad.type = LSM_AUDIT_DATA_NET;\n\tad.u.net = &net;\n\tad.u.net->netif = skb->skb_iif;\n\tad.u.net->family = family;\n\terr = selinux_parse_skb(skb, &ad, &addrp, 1, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (peerlbl_active) {\n\t\tu32 peer_sid;\n\n\t\terr = selinux_skb_peerlbl_sid(skb, family, &peer_sid);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = selinux_inet_sys_rcv_skb(sock_net(sk), skb->skb_iif,\n\t\t\t\t\t       addrp, family, peer_sid, &ad);\n\t\tif (err) {\n\t\t\tselinux_netlbl_err(skb, family, err, 0);\n\t\t\treturn err;\n\t\t}\n\t\terr = avc_has_perm(sk_sid, peer_sid, SECCLASS_PEER,\n\t\t\t\t   PEER__RECV, &ad);\n\t\tif (err) {\n\t\t\tselinux_netlbl_err(skb, family, err, 0);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (secmark_active) {\n\t\terr = avc_has_perm(sk_sid, skb->secmark, SECCLASS_PACKET,\n\t\t\t\t   PACKET__RECV, &ad);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn err;\n}","23846":"get_error_for_roundtrip (FlatpakProxyClient *client, Header *header, const char *error_name)\n{\n  Buffer *ping_buffer = get_ping_buffer_for_header (header);\n  GDBusMessage *reply;\n\n  reply = get_error_for_header (client, header, error_name);\n  g_hash_table_replace (client->rewrite_reply, GINT_TO_POINTER (header->serial), reply);\n  return ping_buffer;\n}","24496":"MagickExport Image *GetImageMask(const Image *image,const PixelMask type,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *mask_view,\n    *image_view;\n\n  Image\n    *mask_image;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  \n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"STR\");\n  assert(image->signature == MagickCoreSignature);\n  mask_image=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (mask_image == (Image *) NULL)\n    return((Image *) NULL);\n  status=MagickTrue;\n  mask_image->alpha_trait=UndefinedPixelTrait;\n  (void) SetImageColorspace(mask_image,GRAYColorspace,exception);\n  mask_image->read_mask=MagickFalse;\n  image_view=AcquireVirtualCacheView(image,exception);\n  mask_view=AcquireAuthenticCacheView(mask_image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=GetCacheViewAuthenticPixels(mask_view,0,y,mask_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      switch (type)\n      {\n        case WritePixelMask:\n        {\n          SetPixelGray(mask_image,GetPixelWriteMask(image,p),q);\n          break;\n        }\n        default:\n        {\n          SetPixelGray(mask_image,GetPixelReadMask(image,p),q);\n          break;\n        }\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(mask_image);\n    }\n    if (SyncCacheViewAuthenticPixels(mask_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  mask_view=DestroyCacheView(mask_view);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    mask_image=DestroyImage(mask_image);\n  return(mask_image);\n}","24153":"int manager_serialize(Manager *m, FILE *f, FDSet *fds, bool switching_root) {\n        Iterator i;\n        Unit *u;\n        const char *t;\n        char **e;\n        int r;\n\n        assert(m);\n        assert(f);\n        assert(fds);\n\n        m->n_reloading ++;\n\n        fprintf(f, \"STR\", m->current_job_id);\n        fprintf(f, \"STR\", yes_no(m->taint_usr));\n        fprintf(f, \"STR\", m->n_installed_jobs);\n        fprintf(f, \"STR\", m->n_failed_jobs);\n\n        dual_timestamp_serialize(f, \"STR\", &m->firmware_timestamp);\n        dual_timestamp_serialize(f, \"STR\", &m->loader_timestamp);\n        dual_timestamp_serialize(f, \"STR\", &m->kernel_timestamp);\n        dual_timestamp_serialize(f, \"STR\", &m->initrd_timestamp);\n\n        if (!in_initrd()) {\n                dual_timestamp_serialize(f, \"STR\", &m->userspace_timestamp);\n                dual_timestamp_serialize(f, \"STR\", &m->finish_timestamp);\n                dual_timestamp_serialize(f, \"STR\", &m->security_start_timestamp);\n                dual_timestamp_serialize(f, \"STR\", &m->security_finish_timestamp);\n                dual_timestamp_serialize(f, \"STR\", &m->generators_start_timestamp);\n                dual_timestamp_serialize(f, \"STR\", &m->generators_finish_timestamp);\n                dual_timestamp_serialize(f, \"STR\", &m->units_load_start_timestamp);\n                dual_timestamp_serialize(f, \"STR\", &m->units_load_finish_timestamp);\n        }\n\n        if (!switching_root) {\n                STRV_FOREACH(e, m->environment) {\n                        _cleanup_free_ char *ce;\n\n                        ce = cescape(*e);\n                        if (!ce)\n                                return -ENOMEM;\n\n                        fprintf(f, \"STR\", *e);\n                }\n        }\n\n        if (m->notify_fd >= 0) {\n                int copy;\n\n                copy = fdset_put_dup(fds, m->notify_fd);\n                if (copy < 0)\n                        return copy;\n\n                fprintf(f, \"STR\", copy);\n                fprintf(f, \"STR\", m->notify_socket);\n        }\n\n        if (m->kdbus_fd >= 0) {\n                int copy;\n\n                copy = fdset_put_dup(fds, m->kdbus_fd);\n                if (copy < 0)\n                        return copy;\n\n                fprintf(f, \"STR\", copy);\n        }\n\n        bus_serialize(m, f);\n\n        fputc('\\n', f);\n\n        HASHMAP_FOREACH_KEY(u, t, m->units, i) {\n                if (u->id != t)\n                        continue;\n\n                if (!unit_can_serialize(u))\n                        continue;\n\n                \n                fputs(u->id, f);\n                fputc('\\n', f);\n\n                r = unit_serialize(u, f, fds, !switching_root);\n                if (r < 0) {\n                        m->n_reloading --;\n                        return r;\n                }\n        }\n\n        assert(m->n_reloading > 0);\n        m->n_reloading --;\n\n        if (ferror(f))\n                return -EIO;\n\n        r = bus_fdset_add_all(m, fds);\n        if (r < 0)\n                return r;\n\n        return 0;\n}","24058":"void xchg_mb_border(uint8_t *top_border, uint8_t *src_y, uint8_t *src_cb,\n                    uint8_t *src_cr, ptrdiff_t linesize, ptrdiff_t uvlinesize, int mb_x,\n                    int mb_y, int mb_width, int simple, int xchg)\n{\n    uint8_t *top_border_m1 = top_border - 32;     \n    src_y  -= linesize;\n    src_cb -= uvlinesize;\n    src_cr -= uvlinesize;\n\n\n    do {                                                                      \\\n        if (xchg)                                                             \\\n            AV_SWAP64(b, a);                                                  \\\n        else                                                                  \\\n            AV_COPY64(b, a);                                                  \\\n    } while (0)\n\n    XCHG(top_border_m1 + 8, src_y - 8, xchg);\n    XCHG(top_border, src_y, xchg);\n    XCHG(top_border + 8, src_y + 8, 1);\n    if (mb_x < mb_width - 1)\n        XCHG(top_border + 32, src_y + 16, 1);\n\n    \n    \n    if (!simple || !mb_y) {\n        XCHG(top_border_m1 + 16, src_cb - 8, xchg);\n        XCHG(top_border_m1 + 24, src_cr - 8, xchg);\n        XCHG(top_border + 16, src_cb, 1);\n        XCHG(top_border + 24, src_cr, 1);\n    }\n}","24261":"static __be32 nfsd4_decode_destroy_clientid(struct nfsd4_compoundargs *argp, struct nfsd4_destroy_clientid *dc)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(8);\n\tCOPYMEM(&dc->clientid, 8);\n\n\tDECODE_TAIL;\n}","23860":"static void delete_sdl_soap_binding_function_body(sdlSoapBindingFunctionBody body)\n{\n\tif (body.ns) {\n\t\tefree(body.ns);\n\t}\n\tif (body.headers) {\n\t\tzend_hash_destroy(body.headers);\n\t\tefree(body.headers);\n\t}\n}","24566":"void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\n\tif (prepare && skb_rtable(skb)) {\n\t\t\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\tskb_dst_drop(skb);\n}","24845":"Track* Segment::AddTrack(int32_t number) {\n  Track* const track = new (std::nothrow) Track(&seed_);  \n\n  if (!track)\n    return NULL;\n\n  if (!tracks_.AddTrack(track, number)) {\n    delete track;\n    return NULL;\n  }\n\n  return track;\n}","24339":"chansrv_cleanup(int pid)\n{\n  char text[256];\n\n  g_snprintf(text, 255, \"STR\", pid);\n  if (g_file_exist(text))\n  {\n    g_file_delete(text);\n  }\n  g_snprintf(text, 255, \"STR\", pid);\n  if (g_file_exist(text))\n  {\n    g_file_delete(text);\n  }\n  return 0;\n}","24683":"static inline int audit_del_rule(struct audit_entry *entry,\n\t\t\t\t struct list_head *list)\n{\n\tstruct audit_entry  *e;\n\tstruct audit_field *inode_f = entry->rule.inode_f;\n\tstruct audit_watch *watch, *tmp_watch = entry->rule.watch;\n\tstruct audit_tree *tree = entry->rule.tree;\n\tLIST_HEAD(inotify_list);\n\tint h, ret = 0;\n#ifdef CONFIG_AUDITSYSCALL\n\tint dont_count = 0;\n\n\t\n\tif (entry->rule.listnr == AUDIT_FILTER_USER ||\n\t\tentry->rule.listnr == AUDIT_FILTER_TYPE)\n\t\tdont_count = 1;\n#endif\n\n\tif (inode_f) {\n\t\th = audit_hash_ino(inode_f->val);\n\t\tlist = &audit_inode_hash[h];\n\t}\n\n\tmutex_lock(&audit_filter_mutex);\n\te = audit_find_rule(entry, list);\n\tif (!e) {\n\t\tmutex_unlock(&audit_filter_mutex);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\twatch = e->rule.watch;\n\tif (watch) {\n\t\tstruct audit_parent *parent = watch->parent;\n\n\t\tlist_del(&e->rule.rlist);\n\n\t\tif (list_empty(&watch->rules)) {\n\t\t\taudit_remove_watch(watch);\n\n\t\t\tif (list_empty(&parent->watches)) {\n\t\t\t\t\n\t\t\t\tlist_add(&parent->ilist, &inotify_list);\n\t\t\t\tget_inotify_watch(&parent->wdata);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (e->rule.tree)\n\t\taudit_remove_tree_rule(&e->rule);\n\n\tlist_del_rcu(&e->list);\n\tcall_rcu(&e->rcu, audit_free_rule_rcu);\n\n#ifdef CONFIG_AUDITSYSCALL\n\tif (!dont_count)\n\t\taudit_n_rules--;\n\n\tif (!audit_match_signal(entry))\n\t\taudit_signals--;\n#endif\n\tmutex_unlock(&audit_filter_mutex);\n\n\tif (!list_empty(&inotify_list))\n\t\taudit_inotify_unregister(&inotify_list);\n\nout:\n\tif (tmp_watch)\n\t\taudit_put_watch(tmp_watch); \n\tif (tree)\n\t\taudit_put_tree(tree);\t\n\n\treturn ret;\n}","24145":"gdm_user_get_display_name (GdmUser *user)\n{\n        g_return_val_if_fail (GDM_IS_USER (user), NULL);\n\n        return (user->display_name ? user->display_name\n                : gdm_user_get_real_name (user));\n}","24457":"static int mk_security_check_hotlink(mk_ptr_t url, mk_ptr_t host,\n        mk_ptr_t referer)\n{\n    mk_ptr_t ref_host = parse_referer_host(referer);\n    unsigned int domains_matched = 0;\n    int i = 0;\n    const char *curA, *curB;\n    struct mk_list *head;\n    struct mk_secure_deny_hotlink_t *entry;\n\n    if (ref_host.data == NULL) {\n        return 0;\n    }\n    else if (host.data == NULL) {\n        mk_err(\"STR\");\n        return -1;\n    }\n\n    mk_list_foreach(head, &mk_secure_url) {\n        entry = mk_list_entry(head, struct mk_secure_deny_hotlink_t, _head);\n        i = mk_api->str_search_n(url.data, entry->criteria, MK_STR_INSENSITIVE, url.len);\n        if (i >= 0) {\n            break;\n        }\n    }\n    if (i < 0) {\n        return 0;\n    }\n\n    curA = host.data + host.len;\n    curB = ref_host.data + ref_host.len;\n\n    \n    while (curA > host.data && curB > ref_host.data) {\n        i++;\n        curA--;\n        curB--;\n\n        if ((*curA == '.' && *curB == '.') ||\n                curA == host.data || curB == ref_host.data) {\n            if (i < 1) {\n                break;\n            }\n            else if (curA == host.data &&\n                    !(curB == ref_host.data || *(curB - 1) == '.')) {\n                break;\n            }\n            else if (curB == ref_host.data &&\n                    !(curA == host.data || *(curA - 1) == '.')) {\n                break;\n            }\n            else if (strncasecmp(curA, curB, i)) {\n                break;\n            }\n            domains_matched += 1;\n            i = 0;\n        }\n    }\n\n    \n    return domains_matched >= 2 ? 0 : -1;\n}","24196":"struct inode *fuse_ilookup(struct fuse_conn *fc, u64 nodeid,\n\t\t\t   struct fuse_mount **fm)\n{\n\tstruct fuse_mount *fm_iter;\n\tstruct inode *inode;\n\n\tWARN_ON(!rwsem_is_locked(&fc->killsb));\n\tlist_for_each_entry(fm_iter, &fc->mounts, fc_entry) {\n\t\tif (!fm_iter->sb)\n\t\t\tcontinue;\n\n\t\tinode = ilookup5(fm_iter->sb, nodeid, fuse_inode_eq, &nodeid);\n\t\tif (inode) {\n\t\t\tif (fm)\n\t\t\t\t*fm = fm_iter;\n\t\t\treturn inode;\n\t\t}\n\t}\n\n\treturn NULL;\n}","23963":"static void krb5_save_ccname_done(struct tevent_req *req)\n{\n    struct krb5_auth_state *state = tevent_req_data(req, struct krb5_auth_state);\n    struct krb5child_req *kr = state->kr;\n    struct pam_data *pd = state->pd;\n    int ret;\n    char *password = NULL;\n\n    if (kr->is_offline) {\n        if (dp_opt_get_bool(kr->krb5_ctx->opts,KRB5_STORE_PASSWORD_IF_OFFLINE)) {\n            krb5_pam_handler_cache_auth_step(req);\n            return;\n        }\n\n        DEBUG(4, (\"STR\"));\n        state->pam_status = PAM_AUTHINFO_UNAVAIL;\n        state->dp_err = DP_ERR_OFFLINE;\n        ret = EOK;\n        goto done;\n    }\n\n    if (state->be_ctx->domain->cache_credentials == TRUE) {\n\n        \n        state->pam_status = PAM_SUCCESS;\n        state->dp_err = DP_ERR_OK;\n\n        switch(pd->cmd) {\n            case SSS_PAM_AUTHENTICATE:\n            case SSS_CMD_RENEW:\n            case SSS_PAM_CHAUTHTOK_PRELIM:\n                password = talloc_size(state, pd->authtok_size + 1);\n                if (password != NULL) {\n                    memcpy(password, pd->authtok, pd->authtok_size);\n                    password[pd->authtok_size] = '\\0';\n                }\n                break;\n            case SSS_PAM_CHAUTHTOK:\n                password = talloc_size(state, pd->newauthtok_size + 1);\n                if (password != NULL) {\n                    memcpy(password, pd->newauthtok, pd->newauthtok_size);\n                    password[pd->newauthtok_size] = '\\0';\n                }\n                break;\n            default:\n                DEBUG(0, (\"STR\", pd->cmd));\n        }\n\n        if (password == NULL) {\n            DEBUG(0, (\"STR\"));\n            ret = EOK; \n            goto done;\n        }\n\n        talloc_set_destructor((TALLOC_CTX *)password, password_destructor);\n\n        ret = sysdb_cache_password(state, state->be_ctx->sysdb,\n                                   state->be_ctx->domain, pd->user,\n                                   password);\n        if (ret) {\n            DEBUG(2, (\"STR\"\n                      \"STR\", ret, strerror(ret)));\n        }\n    }\n\n    state->pam_status = PAM_SUCCESS;\n    state->dp_err = DP_ERR_OK;\n    ret = EOK;\n\ndone:\n    if (ret == EOK) {\n        tevent_req_done(req);\n    } else {\n        tevent_req_error(req, ret);\n    }\n\n}","24521":"X509_STORE_CTX *X509_STORE_CTX_get0_parent_ctx(X509_STORE_CTX *ctx)\n\t{\n\treturn ctx->parent;\n\t}","24976":"SPL_METHOD(DirectoryIterator, key)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (intern->u.dir.dirp) {\n\t\tRETURN_LONG(intern->u.dir.index);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}","24573":"void destroy_uploaded_files_hash(TSRMLS_D) \n{\n\tzend_hash_apply(SG(rfc1867_uploaded_files), (apply_func_t) unlink_filename TSRMLS_CC);\n\tzend_hash_destroy(SG(rfc1867_uploaded_files));\n\tFREE_HASHTABLE(SG(rfc1867_uploaded_files));\n}","24781":"R_API void r_bin_java_print_element_value_summary(RBinJavaElementValue *element_value) {\n\tRBinJavaCPTypeObj *obj;\n\tRBinJavaElementValue *ev_element = NULL;\n\tRListIter *iter = NULL, *iter_tmp = NULL;\n\tchar *name;\n\tif (element_value == NULL) {\n\t\teprintf (\"STR\");\n\t\treturn;\n\t}\n\tname = ((RBinJavaElementValueMetas *) element_value->metas->type_info)->name;\n\teprintf (\"STR\");\n\teprintf (\"STR\", element_value->file_offset);\n\teprintf (\"STR\", element_value->tag, name);\n\tswitch (element_value->tag) {\n\tcase R_BIN_JAVA_EV_TAG_BYTE:\n\tcase R_BIN_JAVA_EV_TAG_CHAR:\n\tcase R_BIN_JAVA_EV_TAG_DOUBLE:\n\tcase R_BIN_JAVA_EV_TAG_FLOAT:\n\tcase R_BIN_JAVA_EV_TAG_INT:\n\tcase R_BIN_JAVA_EV_TAG_LONG:\n\tcase R_BIN_JAVA_EV_TAG_SHORT:\n\tcase R_BIN_JAVA_EV_TAG_BOOLEAN:\n\tcase R_BIN_JAVA_EV_TAG_STRING:\n\t\teprintf (\"STR\", element_value->value.const_value.const_value_idx);\n\t\teprintf (\"STR\");\n\t\tobj = element_value->value.const_value.const_value_cp_obj;\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->print_summary (obj);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ENUM:\n\t\teprintf (\"STR\", element_value->value.enum_const_value.const_name_idx);\n\t\teprintf (\"STR\", element_value->value.enum_const_value.type_name_idx);\n\t\teprintf (\"STR\");\n\t\tobj = element_value->value.enum_const_value.const_name_cp_obj;\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->print_summary (obj);\n\t\teprintf (\"STR\");\n\t\tobj = element_value->value.enum_const_value.type_name_cp_obj;\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->print_summary (obj);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_CLASS:\n\t\teprintf (\"STR\", element_value->value.class_value.class_info_idx);\n\t\teprintf (\"STR\");\n\t\tobj = element_value->value.class_value.class_info_cp_obj;\n\t\t((RBinJavaCPTypeMetas *) obj->metas->type_info)->allocs->print_summary (obj);\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ARRAY:\n\t\teprintf (\"STR\", element_value->value.array_value.num_values);\n\t\teprintf (\"STR\");\n\t\tr_list_foreach_safe (element_value->value.array_value.values, iter, iter_tmp, ev_element) {\n\t\t\tr_bin_java_print_element_value_summary (ev_element);\n\t\t}\n\t\tbreak;\n\tcase R_BIN_JAVA_EV_TAG_ANNOTATION:\n\t\teprintf (\"STR\");\n\t\tr_bin_java_print_annotation_summary (&element_value->value.annotation_value);\n\t\tbreak;\n\tdefault:\n\t\t\n\t\tbreak;\n\t}\n}","24488":"static apr_status_t fix_hostname_v6_literal(request_rec *r, char *host)\n{\n    char *dst;\n    int double_colon = 0;\n\n    for (dst = host; *dst; dst++) {\n        if (apr_isxdigit(*dst)) {\n            if (apr_isupper(*dst)) {\n                *dst = apr_tolower(*dst);\n            }\n        }\n        else if (*dst == ':') {\n            if (*(dst + 1) == ':') {\n                if (double_colon)\n                    return APR_EINVAL;\n                double_colon = 1;\n            }\n            else if (*(dst + 1) == '.') {\n                return APR_EINVAL;\n            }\n        }\n        else if (*dst == '.') {\n            \n            if (*(dst + 1) == ':' || *(dst + 1) == '.')\n                return APR_EINVAL;\n        }\n        else {\n            return APR_EINVAL;\n        }\n    }\n    return APR_SUCCESS;\n}","24635":"static void __init resiliency_test(void)\n{\n\tu8 *p;\n\tint type = KMALLOC_NORMAL;\n\n\tBUILD_BUG_ON(KMALLOC_MIN_SIZE > 16 || KMALLOC_SHIFT_HIGH < 10);\n\n\tpr_err(\"STR\");\n\tpr_err(\"STR\");\n\tpr_err(\"STR\");\n\n\tp = kzalloc(16, GFP_KERNEL);\n\tp[16] = 0x12;\n\tpr_err(\"STR\",\n\t       p + 16);\n\n\tvalidate_slab_cache(kmalloc_caches[type][4]);\n\n\t\n\tp = kzalloc(32, GFP_KERNEL);\n\tp[32 + sizeof(void *)] = 0x34;\n\tpr_err(\"STR\",\n\t       p);\n\tpr_err(\"STR\");\n\n\tvalidate_slab_cache(kmalloc_caches[type][5]);\n\tp = kzalloc(64, GFP_KERNEL);\n\tp += 64 + (get_cycles() & 0xff) * sizeof(void *);\n\t*p = 0x56;\n\tpr_err(\"STR\",\n\t       p);\n\tpr_err(\"STR\");\n\tvalidate_slab_cache(kmalloc_caches[type][6]);\n\n\tpr_err(\"STR\");\n\tp = kzalloc(128, GFP_KERNEL);\n\tkfree(p);\n\t*p = 0x78;\n\tpr_err(\"STR\", p);\n\tvalidate_slab_cache(kmalloc_caches[type][7]);\n\n\tp = kzalloc(256, GFP_KERNEL);\n\tkfree(p);\n\tp[50] = 0x9a;\n\tpr_err(\"STR\", p);\n\tvalidate_slab_cache(kmalloc_caches[type][8]);\n\n\tp = kzalloc(512, GFP_KERNEL);\n\tkfree(p);\n\tp[512] = 0xab;\n\tpr_err(\"STR\", p);\n\tvalidate_slab_cache(kmalloc_caches[type][9]);\n}","24570":"PHP_MINFO_FUNCTION(exif)\n{\n\tphp_info_print_table_start();\n\tphp_info_print_table_row(2, \"STR\");\n\tphp_info_print_table_row(2, \"STR\", PHP_EXIF_VERSION);\n\tphp_info_print_table_row(2, \"STR\");\n\tphp_info_print_table_row(2, \"STR\");\n\n\tif (zend_hash_str_exists(&module_registry, \"STR\")-1)) { \n\t\tphp_info_print_table_row(2, \"STR\");\n\t} else {\n\t\tphp_info_print_table_row(2, \"STR\");\n\t}\n\n\tphp_info_print_table_row(2, \"STR\");\n\tphp_info_print_table_end();\n\n\tDISPLAY_INI_ENTRIES();\n}","24660":"static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\treturn -ENOSYS;\n}","24654":"int lgff_init(struct hid_device* hid)\n{\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tconst signed short *ff_bits = ff_joystick;\n\tint error;\n\tint i;\n\n\t\n\tif (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < ARRAY_SIZE(devices); i++) {\n\t\tif (dev->id.vendor == devices[i].idVendor &&\n\t\t    dev->id.product == devices[i].idProduct) {\n\t\t\tff_bits = devices[i].ff;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; ff_bits[i] >= 0; i++)\n\t\tset_bit(ff_bits[i], dev->ffbit);\n\n\terror = input_ff_create_memless(dev, NULL, hid_lgff_play);\n\tif (error)\n\t\treturn error;\n\n\tif ( test_bit(FF_AUTOCENTER, dev->ffbit) )\n\t\tdev->ff->set_autocenter = hid_lgff_set_autocenter;\n\n\tpr_info(\"STR\");\n\n\treturn 0;\n}","24846":"static void __proc_set_tty(struct tty_struct *tty)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tty->ctrl_lock, flags);\n\t\n\tput_pid(tty->session);\n\tput_pid(tty->pgrp);\n\ttty->pgrp = get_pid(task_pgrp(current));\n\tspin_unlock_irqrestore(&tty->ctrl_lock, flags);\n\ttty->session = get_pid(task_session(current));\n\tif (current->signal->tty) {\n\t\ttty_debug(tty, \"STR\",\n\t\t\t  current->signal->tty->name);\n\t\ttty_kref_put(current->signal->tty);\n\t}\n\tput_pid(current->signal->tty_old_pgrp);\n\tcurrent->signal->tty = tty_kref_get(tty);\n\tcurrent->signal->tty_old_pgrp = NULL;\n}","24438":"static int ltalk_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t\tstruct packet_type *pt)\n{\n\t\n\tif (skb->mac.raw[2] == 1) {\n\t\tstruct ddpehdr *ddp;\n\t\t\n\t\tstruct atalk_addr *ap = atalk_find_dev_addr(dev);\n\n\t\tif (!ap || skb->len < sizeof(struct ddpshdr))\n\t\t\tgoto freeit;\n\t\t\n\n\t\tskb_push(skb, sizeof(*ddp) - 4);\n\t\t\n\t\tddp = (struct ddpehdr *)skb->data;\n\n\t\t\n\n\t \t\n\n\t\tddp->deh_dnode = skb->mac.raw[0];     \n\t\tddp->deh_snode = skb->mac.raw[1];     \n\n\t\tddp->deh_dnet  = ap->s_net;\t\n\t\tddp->deh_snet  = ap->s_net;\n\t\tddp->deh_sum   = 0;\t\t\n\t\t\n\t\tddp->deh_len   = skb->len;\n\t\tddp->deh_hops  = DDP_MAXHOPS;\t\n\t\t\n\t\t*((__u16 *)ddp) = htons(*((__u16 *)ddp));\n\t}\n\tskb->h.raw = skb->data;\n\n\treturn atalk_rcv(skb, dev, pt);\nfreeit:\n\tkfree_skb(skb);\n\treturn 0;\n}","25043":"  StringCrosser(const std::vector<\n                    std::unique_ptr<ColumnInterface<InternalType>>>& columns,\n                const int64 num_buckets_unused, const uint64 hash_key_unused,\n                const tstring k_feature_separator)\n      : columns_(columns), k_feature_separator_(k_feature_separator) {}","24538":"encode_DELETE_FIELD(const struct ofpact_delete_field *delete_field,\n                    enum ofp_version ofp_version OVS_UNUSED,\n                    struct ofpbuf *out)\n{\n    struct nx_action_delete_field *nadf = put_NXAST_DELETE_FIELD(out);\n    size_t size = out->size;\n\n    out->size = size - sizeof nadf->pad;\n    nx_put_mff_header(out, delete_field->field, 0, false);\n    out->size = size;\n}","24580":"static int ext4_split_convert_extents(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\t\tstruct ext4_ext_path **ppath,\n\t\t\t\t\tint flags)\n{\n\tstruct ext4_ext_path *path = *ppath;\n\text4_lblk_t eof_block;\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex;\n\tunsigned int ee_len;\n\tint split_flag = 0, depth;\n\n\text_debug(inode, \"STR\",\n\t\t  (unsigned long long)map->m_lblk, map->m_len);\n\n\teof_block = (EXT4_I(inode)->i_disksize + inode->i_sb->s_blocksize - 1)\n\t\t\t>> inode->i_sb->s_blocksize_bits;\n\tif (eof_block < map->m_lblk + map->m_len)\n\t\teof_block = map->m_lblk + map->m_len;\n\t\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\n\t\n\tif (flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN) {\n\t\tsplit_flag |= EXT4_EXT_DATA_VALID1;\n\t\n\t} else if (flags & EXT4_GET_BLOCKS_CONVERT) {\n\t\tsplit_flag |= ee_block + ee_len <= eof_block ?\n\t\t\t      EXT4_EXT_MAY_ZEROOUT : 0;\n\t\tsplit_flag |= (EXT4_EXT_MARK_UNWRIT2 | EXT4_EXT_DATA_VALID2);\n\t}\n\tflags |= EXT4_GET_BLOCKS_PRE_IO;\n\treturn ext4_split_extent(handle, inode, ppath, map, split_flag, flags);\n}","23995":"static inline int xrstor_state_booting(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\n\tWARN_ON(system_state != SYSTEM_BOOTING);\n\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\tasm volatile(\"STR\"\n\t\t\t\"STR\"\n\t\t\t: : \"STR\" (hmask)\n\t\t\t:   \"STR\");\n\telse\n\t\tasm volatile(\"STR\"\n\t\t\t\"STR\"\n\t\t\t: : \"STR\" (hmask)\n\t\t\t:   \"STR\");\n\n\tasm volatile(xstate_fault\n\t\t     : \"STR\" (0)\n\t\t     : \"STR\");\n\n\treturn err;\n}","24416":"    Network::Socket& socket() override { return socket_; }","24787":"static void openpic_msi_write(void *opaque, hwaddr addr, uint64_t val,\n                              unsigned size)\n{\n    OpenPICState *opp = opaque;\n    int idx = opp->irq_msi;\n    int srs, ibs;\n\n    DPRINTF(\"STR\",\n            __func__, addr, val);\n    if (addr & 0xF) {\n        return;\n    }\n\n    switch (addr) {\n    case MSIIR_OFFSET:\n        srs = val >> MSIIR_SRS_SHIFT;\n        idx += srs;\n        ibs = (val & MSIIR_IBS_MASK) >> MSIIR_IBS_SHIFT;\n        opp->msi[srs].msir |= 1 << ibs;\n        openpic_set_irq(opp, idx, 1);\n        break;\n    default:\n        \n        break;\n    }\n}","23964":"BPF_CALL_2(bpf_ringbuf_discard, void *, sample, u64, flags)\n{\n\tbpf_ringbuf_commit(sample, flags, true );\n\treturn 0;\n}","23833":"PHP_FUNCTION(snmp_set_enum_print)\n{\n\tlong a1;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"STR\", &a1) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tnetsnmp_ds_set_boolean(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM, (int) a1);\n\tRETURN_TRUE;\n} ","24962":"DeepScanLineInputFile::~DeepScanLineInputFile ()\n{\n    if (_data->_deleteStream)\n        delete _data->_streamData->is;\n\n    if (_data)\n    {\n        if (!_data->memoryMapped)\n            for (size_t i = 0; i < _data->lineBuffers.size(); i++)\n                delete [] _data->lineBuffers[i]->buffer;\n\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\n        if (_data->partNumber == -1 && _data->_streamData)\n            delete _data->_streamData;\n\n        delete _data;\n    }\n}","24289":"static void esp_fifo_push(ESPState *s, uint8_t val)\n{\n    if (fifo8_num_used(&s->fifo) == ESP_FIFO_SZ) {\n        trace_esp_error_fifo_overrun();\n        return;\n    }\n\n    fifo8_push(&s->fifo, val);\n}","24598":"static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status,\n\t\t\t\t\t\t\t\t__u8 role)\n{\n\tstruct hci_cb *cb;\n\n\tmutex_lock(&hci_cb_list_lock);\n\tlist_for_each_entry(cb, &hci_cb_list, list) {\n\t\tif (cb->role_switch_cfm)\n\t\t\tcb->role_switch_cfm(conn, status, role);\n\t}\n\tmutex_unlock(&hci_cb_list_lock);\n}","24647":"int CLua::loadfile(lua_State *ls, const char *filename, bool trusted,\n                   bool die_on_fail)\n{\n    if (!ls)\n        return -1;\n\n    if (!is_path_safe(filename, trusted))\n    {\n        lua_pushstring(\n            ls,\n            make_stringf(\"STR\", filename).c_str());\n        return -1;\n    }\n\n    string file = datafile_path(filename, die_on_fail);\n    if (file.empty())\n    {\n        lua_pushstring(ls,\n                       make_stringf(\"STR\", filename).c_str());\n        return -1;\n    }\n\n    FileLineInput f(file.c_str());\n    string script;\n    while (!f.eof())\n        script += f.get_line() + \"STR\";\n\n    \n    return luaL_loadbuffer(ls, &script[0], script.length(),\n                           (\"STR\" + file).c_str());\n}","24524":"void updateHandshakeState(QuicServerConnectionState& conn) {\n  \n  \n  auto handshakeLayer = conn.serverHandshakeLayer;\n  auto zeroRttReadCipher = handshakeLayer->getZeroRttReadCipher();\n  auto zeroRttHeaderCipher = handshakeLayer->getZeroRttReadHeaderCipher();\n  \n  \n  \n  \n  auto oneRttWriteCipher = handshakeLayer->getOneRttWriteCipher();\n  \n  auto oneRttReadCipher = handshakeLayer->getOneRttReadCipher();\n\n  auto oneRttWriteHeaderCipher = handshakeLayer->getOneRttWriteHeaderCipher();\n  auto oneRttReadHeaderCipher = handshakeLayer->getOneRttReadHeaderCipher();\n\n  if (zeroRttReadCipher) {\n    if (conn.qLogger) {\n      conn.qLogger->addTransportStateUpdate(kDerivedZeroRttReadCipher);\n    }\n    QUIC_TRACE(fst_trace, conn, \"STR\");\n    conn.readCodec->setZeroRttReadCipher(std::move(zeroRttReadCipher));\n  }\n  if (zeroRttHeaderCipher) {\n    conn.readCodec->setZeroRttHeaderCipher(std::move(zeroRttHeaderCipher));\n  }\n  if (oneRttWriteHeaderCipher) {\n    conn.oneRttWriteHeaderCipher = std::move(oneRttWriteHeaderCipher);\n  }\n  if (oneRttReadHeaderCipher) {\n    conn.readCodec->setOneRttHeaderCipher(std::move(oneRttReadHeaderCipher));\n  }\n\n  if (oneRttWriteCipher) {\n    if (conn.qLogger) {\n      conn.qLogger->addTransportStateUpdate(kDerivedOneRttWriteCipher);\n    }\n    QUIC_TRACE(fst_trace, conn, \"STR\");\n    CHECK(!conn.oneRttWriteCipher.get());\n    conn.oneRttWriteCipher = std::move(oneRttWriteCipher);\n\n    updatePacingOnKeyEstablished(conn);\n\n    \n    \n    auto clientParams = handshakeLayer->getClientTransportParams();\n    if (!clientParams) {\n      throw QuicTransportException(\n          \"STR\",\n          TransportErrorCode::TRANSPORT_PARAMETER_ERROR);\n    }\n    processClientInitialParams(conn, std::move(*clientParams));\n  }\n  if (oneRttReadCipher) {\n    if (conn.qLogger) {\n      conn.qLogger->addTransportStateUpdate(kDerivedOneRttReadCipher);\n    }\n    QUIC_TRACE(fst_trace, conn, \"STR\");\n    \n    conn.writableBytesLimit = folly::none;\n    conn.readCodec->setOneRttReadCipher(std::move(oneRttReadCipher));\n  }\n  auto handshakeReadCipher = handshakeLayer->getHandshakeReadCipher();\n  auto handshakeReadHeaderCipher =\n      handshakeLayer->getHandshakeReadHeaderCipher();\n  if (handshakeReadCipher) {\n    CHECK(handshakeReadHeaderCipher);\n    conn.readCodec->setHandshakeReadCipher(std::move(handshakeReadCipher));\n    conn.readCodec->setHandshakeHeaderCipher(\n        std::move(handshakeReadHeaderCipher));\n  }\n  if (handshakeLayer->isHandshakeDone()) {\n    CHECK(conn.oneRttWriteCipher);\n    if (conn.version != QuicVersion::MVFST_D24 && !conn.sentHandshakeDone) {\n      sendSimpleFrame(conn, HandshakeDoneFrame());\n      conn.sentHandshakeDone = true;\n    }\n  }\n}","24331":"static bool vmx_check_apicv_inhibit_reasons(ulong bit)\n{\n\tulong supported = BIT(APICV_INHIBIT_REASON_DISABLE) |\n\t\t\t  BIT(APICV_INHIBIT_REASON_HYPERV);\n\n\treturn supported & BIT(bit);\n}","24818":"void freeListData(char *** data, unsigned int length) {\n\tint i;\n\tfor(i=0; i<length; i++) {\n\t\tfree((*data)[i]);\n\t}\n\tfree(*data);\n}","24643":"int setTypeAdd(robj *subject, sds value) {\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        dict *ht = subject->ptr;\n        dictEntry *de = dictAddRaw(ht,value,NULL);\n        if (de) {\n            dictSetKey(ht,de,sdsdup(value));\n            dictSetVal(ht,de,NULL);\n            return 1;\n        }\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            uint8_t success = 0;\n            subject->ptr = intsetAdd(subject->ptr,llval,&success);\n            if (success) {\n                \n                if (intsetLen(subject->ptr) > server.set_max_intset_entries)\n                    setTypeConvert(subject,OBJ_ENCODING_HT);\n                return 1;\n            }\n        } else {\n            \n            setTypeConvert(subject,OBJ_ENCODING_HT);\n\n            \n            serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);\n            return 1;\n        }\n    } else {\n        serverPanic(\"STR\");\n    }\n    return 0;\n}","24466":"char *uwsgi_get_binary_path(char *argvzero) {\n\n#if defined(__linux__) || defined(__CYGWIN__)\n\tchar *buf = uwsgi_calloc(PATH_MAX + 1);\n\tssize_t len = readlink(\"STR\", buf, PATH_MAX);\n\tif (len > 0) {\n\t\treturn buf;\n\t}\n\tfree(buf);\n#elif defined(_WIN32)\n\tchar *buf = uwsgi_calloc(PATH_MAX + 1);\n\tif (GetModuleFileName(NULL, buf, PATH_MAX) > 0) {\n\t\treturn buf;\n\t}\n\tfree(buf);\n#elif defined(__NetBSD__)\n\tchar *buf = uwsgi_calloc(PATH_MAX + 1);\n\tssize_t len = readlink(\"STR\", buf, PATH_MAX);\n\tif (len > 0) {\n\t\treturn buf;\n\t}\n\n\tif (realpath(argvzero, buf)) {\n\t\treturn buf;\n\t}\n\tfree(buf);\n#elif defined(__APPLE__)\n\tchar *buf = uwsgi_malloc(uwsgi.page_size);\n\tuint32_t len = uwsgi.page_size;\n\tif (_NSGetExecutablePath(buf, &len) == 0) {\n\t\t\n#ifndef OLD_REALPATH\n\t\tchar *newbuf = realpath(buf, NULL);\n\t\tif (newbuf) {\n\t\t\tfree(buf);\n\t\t\treturn newbuf;\n\t\t}\n#endif\n\t}\n\tfree(buf);\n#elif defined(__sun__)\n\t\n\tchar *buf = (char *) getexecname();\n\tif (buf) {\n\t\t\n\t\tif (buf[0] == '\/') {\n\t\t\treturn buf;\n\t\t}\n\n\t\tchar *newbuf = uwsgi_malloc(PATH_MAX + 1);\n\t\tif (realpath(buf, newbuf)) {\n\t\t\treturn newbuf;\n\t\t}\n\t}\n#elif defined(__FreeBSD__) || defined(__GNU_kFreeBSD__)\n\tchar *buf = uwsgi_malloc(uwsgi.page_size);\n\tsize_t len = uwsgi.page_size;\n\tint mib[4];\n\tmib[0] = CTL_KERN;\n\tmib[1] = KERN_PROC;\n\tmib[2] = KERN_PROC_PATHNAME;\n\tmib[3] = -1;\n\tif (sysctl(mib, 4, buf, &len, NULL, 0) == 0) {\n\t\treturn buf;\n\t}\n\tfree(buf);\n#endif\n\n\n\treturn argvzero;\n\n}","24735":"format_OUTPUT_REG(const struct ofpact_output_reg *a, struct ds *s)\n{\n    ds_put_format(s, \"STR\", colors.special, colors.end);\n    mf_format_subfield(&a->src, s);\n}","23926":"static void correct_endian_cmd_unlink(struct usbip_header_cmd_unlink *pdu,\n\t\t\t\t      int send)\n{\n\tif (send)\n\t\tpdu->seqnum = cpu_to_be32(pdu->seqnum);\n\telse\n\t\tpdu->seqnum = be32_to_cpu(pdu->seqnum);\n}","24505":"e_ews_backend_ref_connection_sync (EEwsBackend *backend,\n\t\t\t\t   ESourceAuthenticationResult *result,\n\t\t\t\t   gchar **out_certificate_pem,\n\t\t\t\t   GTlsCertificateFlags *out_certificate_errors,\n                                   GCancellable *cancellable,\n                                   GError **error)\n{\n\tEEwsConnection *connection = NULL;\n\tESourceAuthenticationResult local_result;\n\tCamelEwsSettings *settings;\n\tgchar *hosturl;\n\tgboolean success;\n\n\tg_return_val_if_fail (E_IS_EWS_BACKEND (backend), NULL);\n\n\tg_mutex_lock (&backend->priv->connection_lock);\n\tif (backend->priv->connection != NULL)\n\t\tconnection = g_object_ref (backend->priv->connection);\n\tg_mutex_unlock (&backend->priv->connection_lock);\n\n\t\n\tif (connection != NULL || !backend->priv->credentials)\n\t\treturn connection;\n\n\tsettings = ews_backend_get_settings (backend);\n\thosturl = camel_ews_settings_dup_hosturl (settings);\n\tconnection = e_ews_connection_new_full (e_backend_get_source (E_BACKEND (backend)), hosturl, settings, FALSE);\n\tg_free (hosturl);\n\n\te_binding_bind_property (\n\t\tbackend, \"STR\",\n\t\tconnection, \"STR\",\n\t\tG_BINDING_SYNC_CREATE);\n\n\tlocal_result = e_ews_connection_try_credentials_sync (connection, backend->priv->credentials, NULL,\n\t\tout_certificate_pem, out_certificate_errors, cancellable, error);\n\tif (result)\n\t\t*result = local_result;\n\n\tsuccess = local_result == E_SOURCE_AUTHENTICATION_ACCEPTED;\n\n\tif (success) {\n\t\tg_mutex_lock (&backend->priv->connection_lock);\n\t\tif (backend->priv->connection != NULL)\n\t\t\tg_object_unref (backend->priv->connection);\n\t\tbackend->priv->connection = g_object_ref (connection);\n\t\tg_mutex_unlock (&backend->priv->connection_lock);\n\t} else {\n\t\tg_object_unref (connection);\n\t\tconnection = NULL;\n\t}\n\n\treturn connection;\n}","24420":"inline StreamWriteResult StreamBase::Write(\n    uv_buf_t* bufs,\n    size_t count,\n    uv_stream_t* send_handle,\n    v8::Local<v8::Object> req_wrap_obj) {\n  Environment* env = stream_env();\n  int err;\n\n  size_t total_bytes = 0;\n  for (size_t i = 0; i < count; ++i)\n    total_bytes += bufs[i].len;\n  bytes_written_ += total_bytes;\n\n  if (send_handle == nullptr) {\n    err = DoTryWrite(&bufs, &count);\n    if (err != 0 || count == 0) {\n      return StreamWriteResult { false, err, nullptr, total_bytes };\n    }\n  }\n\n  HandleScope handle_scope(env->isolate());\n\n  if (req_wrap_obj.IsEmpty()) {\n    req_wrap_obj =\n        env->write_wrap_template()\n            ->NewInstance(env->context()).ToLocalChecked();\n    StreamReq::ResetObject(req_wrap_obj);\n  }\n\n  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap());\n  WriteWrap* req_wrap = CreateWriteWrap(req_wrap_obj);\n\n  err = DoWrite(req_wrap, bufs, count, send_handle);\n  bool async = err == 0;\n\n  if (!async) {\n    req_wrap->Dispose();\n    req_wrap = nullptr;\n  }\n\n  const char* msg = Error();\n  if (msg != nullptr) {\n    req_wrap_obj->Set(env->error_string(), OneByteString(env->isolate(), msg));\n    ClearError();\n  }\n\n  return StreamWriteResult { async, err, req_wrap, total_bytes };\n}","24249":"Bool gf_ac3_parser(u8 *buf, u32 buflen, u32 *pos, GF_AC3Config *hdr, Bool full_parse)\n{\n\tGF_BitStream *bs;\n\tBool ret;\n\n\tif (buflen < 6) return GF_FALSE;\n\t(*pos) = AC3_FindSyncCode(buf, buflen);\n\tif (*pos >= buflen) return GF_FALSE;\n\n\tbs = gf_bs_new((const char*)(buf + *pos), buflen, GF_BITSTREAM_READ);\n\tret = gf_ac3_parser_bs(bs, hdr, full_parse);\n\tgf_bs_del(bs);\n\n\treturn ret;\n}","24464":"static void snd_usb_mixer_free(struct usb_mixer_interface *mixer)\n{\n\tkfree(mixer->id_elems);\n\tif (mixer->urb) {\n\t\tkfree(mixer->urb->transfer_buffer);\n\t\tusb_free_urb(mixer->urb);\n\t}\n\tusb_free_urb(mixer->rc_urb);\n\tkfree(mixer->rc_setup_packet);\n\tkfree(mixer);\n}","24239":"static void l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tstruct l2cap_chan *chan;\n\n\tif (!conn)\n\t\treturn;\n\n\tBT_DBG(\"STR\", conn, status, encrypt);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tl2cap_chan_lock(chan);\n\n\t\tBT_DBG(\"STR\", chan, chan->scid,\n\t\t       state_to_string(chan->state));\n\n\t\tif (chan->scid == L2CAP_CID_A2MP) {\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!status && encrypt)\n\t\t\tchan->sec_level = hcon->sec_level;\n\n\t\tif (!__l2cap_no_conn_pending(chan)) {\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!status && (chan->state == BT_CONNECTED ||\n\t\t\t\tchan->state == BT_CONFIG)) {\n\t\t\tchan->ops->resume(chan);\n\t\t\tl2cap_check_encryption(chan, encrypt);\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (chan->state == BT_CONNECT) {\n\t\t\tif (!status)\n\t\t\t\tl2cap_start_connection(chan);\n\t\t\telse\n\t\t\t\t__set_chan_timer(chan, L2CAP_DISC_TIMEOUT);\n\t\t} else if (chan->state == BT_CONNECT2 &&\n\t\t\t   chan->mode != L2CAP_MODE_LE_FLOWCTL) {\n\t\t\tstruct l2cap_conn_rsp rsp;\n\t\t\t__u16 res, stat;\n\n\t\t\tif (!status) {\n\t\t\t\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\n\t\t\t\t\tres = L2CAP_CR_PEND;\n\t\t\t\t\tstat = L2CAP_CS_AUTHOR_PEND;\n\t\t\t\t\tchan->ops->defer(chan);\n\t\t\t\t} else {\n\t\t\t\t\tl2cap_state_change(chan, BT_CONFIG);\n\t\t\t\t\tres = L2CAP_CR_SUCCESS;\n\t\t\t\t\tstat = L2CAP_CS_NO_INFO;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tl2cap_state_change(chan, BT_DISCONN);\n\t\t\t\t__set_chan_timer(chan, L2CAP_DISC_TIMEOUT);\n\t\t\t\tres = L2CAP_CR_SEC_BLOCK;\n\t\t\t\tstat = L2CAP_CS_NO_INFO;\n\t\t\t}\n\n\t\t\trsp.scid   = cpu_to_le16(chan->dcid);\n\t\t\trsp.dcid   = cpu_to_le16(chan->scid);\n\t\t\trsp.result = cpu_to_le16(res);\n\t\t\trsp.status = cpu_to_le16(stat);\n\t\t\tl2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,\n\t\t\t\t       sizeof(rsp), &rsp);\n\n\t\t\tif (!test_bit(CONF_REQ_SENT, &chan->conf_state) &&\n\t\t\t    res == L2CAP_CR_SUCCESS) {\n\t\t\t\tchar buf[128];\n\t\t\t\tset_bit(CONF_REQ_SENT, &chan->conf_state);\n\t\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t\t       L2CAP_CONF_REQ,\n\t\t\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)),\n\t\t\t\t\t       buf);\n\t\t\t\tchan->num_conf_req++;\n\t\t\t}\n\t\t}\n\n\t\tl2cap_chan_unlock(chan);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n}","24985":"CURLcode Curl_build_unencoding_stack(struct Curl_easy *data,\n                                     const char *enclist, int maybechunked)\n{\n  struct SingleRequest *k = &data->req;\n\n  do {\n    const char *name;\n    size_t namelen;\n\n    \n    while(ISSPACE(*enclist) || *enclist == ',')\n      enclist++;\n\n    name = enclist;\n\n    for(namelen = 0; *enclist && *enclist != ','; enclist++)\n      if(!ISSPACE(*enclist))\n        namelen = enclist - name + 1;\n\n    \n    if(maybechunked && namelen == 7 && strncasecompare(name, \"STR\", 7)) {\n      k->chunk = TRUE;             \n      Curl_httpchunk_init(data);   \n    }\n    else if(namelen) {\n      const struct content_encoding *encoding = find_encoding(name, namelen);\n      struct contenc_writer *writer;\n\n      if(!k->writer_stack) {\n        k->writer_stack = new_unencoding_writer(data, &client_encoding, NULL);\n\n        if(!k->writer_stack)\n          return CURLE_OUT_OF_MEMORY;\n      }\n\n      if(!encoding)\n        encoding = &error_encoding;  \n\n      \n      writer = new_unencoding_writer(data, encoding, k->writer_stack);\n      if(!writer)\n        return CURLE_OUT_OF_MEMORY;\n      k->writer_stack = writer;\n    }\n  } while(*enclist);\n\n  return CURLE_OK;\n}","24843":"gerbv_gdk_draw_prim1(GdkPixmap *pixmap, GdkGC *gc, double *p, \n\t\t     double scale, gint x, gint y)\n{\n    const int exposure_idx = 0;\n    const int diameter_idx = 1;\n    const int x_offset_idx = 2;\n    const int y_offset_idx = 3;\n    const gint full_circle = 23360;\n    GdkGC *local_gc = gdk_gc_new(pixmap);\n    gint dia    = round(fabs(p[diameter_idx] * scale));\n    gint real_x = x - dia \/ 2;\n    gint real_y = y - dia \/ 2;\n    GdkColor color;\n\n    gdk_gc_copy(local_gc, gc);\n\n    real_x += (int)(p[x_offset_idx] * (double)scale);\n    real_y -= (int)(p[y_offset_idx] * (double)scale);\n\n    \n    if (p[exposure_idx] == 0.0) {\n\tcolor.pixel = 0;\n\tgdk_gc_set_foreground(local_gc, &color);\n    }\n\n    gdk_gc_set_line_attributes(local_gc, \n\t\t\t       1, \n\t\t\t       GDK_LINE_SOLID, \n\t\t\t       GDK_CAP_BUTT, \n\t\t\t       GDK_JOIN_MITER);\n\n    \n    gdk_draw_arc(pixmap, local_gc, 1, real_x, real_y, dia, dia, \n\t\t 0, full_circle);\n\n    gdk_gc_unref(local_gc);\n\n    return;\n} ","24230":"sraSpanListDup(const sraSpanList *src) {\n  sraSpanList *newlist;\n  sraSpan *newspan, *curr;\n\n  if (!src) return NULL;\n  newlist = sraSpanListCreate();\n  curr = src->front._next;\n  while (curr != &(src->back)) {\n    newspan = sraSpanDup(curr);\n    sraSpanInsertBefore(newspan, &(newlist->back));\n    curr = curr->_next;\n  }\n\n  return newlist;\n}","24646":"int create_symlink_lockfile(const char* lock_file, const char* pid)\n{\n    while (symlink(pid, lock_file) != 0)\n    {\n        if (errno != EEXIST)\n        {\n            if (errno != ENOENT && errno != ENOTDIR && errno != EACCES)\n            {\n                perror_msg(\"STR\", lock_file);\n                errno = 0;\n            }\n            return -1;\n        }\n\n        char pid_buf[sizeof(pid_t)*3 + 4];\n        ssize_t r = readlink(lock_file, pid_buf, sizeof(pid_buf) - 1);\n        if (r < 0)\n        {\n            if (errno == ENOENT)\n            {\n                \n                usleep(SYMLINK_RETRY_USLEEP); \n                continue;\n            }\n            perror_msg(\"STR\", lock_file);\n            errno = 0;\n            return -1;\n        }\n        pid_buf[r] = '\\0';\n\n        if (strcmp(pid_buf, pid) == 0)\n        {\n            log(\"STR\", lock_file);\n            return 0;\n        }\n        if (isdigit_str(pid_buf))\n        {\n            char pid_str[sizeof(\"STR\") + sizeof(pid_buf)];\n            snprintf(pid_str, sizeof(pid_str), \"STR\", pid_buf);\n            if (access(pid_str, F_OK) == 0)\n            {\n                log(\"STR\", lock_file, pid_buf);\n                return 0;\n            }\n            log(\"STR\", lock_file, pid_buf);\n        }\n        \n        if (unlink(lock_file) != 0 && errno != ENOENT)\n        {\n            perror_msg(\"STR\", lock_file);\n            errno = 0;\n            return -1;\n        }\n    }\n\n    log_info(\"STR\", lock_file);\n    return 1;\n}","25029":"asn1_get_octet_der (const unsigned char *der, int der_len,\n\t\t    int *ret_len, unsigned char *str, int str_size,\n\t\t    int *str_len)\n{\n  int len_len;\n\n  if (der_len <= 0)\n    return ASN1_GENERIC_ERROR;\n\n  \n  *str_len = asn1_get_length_der (der, der_len, &len_len);\n\n  if (*str_len < 0)\n    return ASN1_DER_ERROR;\n\n  *ret_len = *str_len + len_len;\n  if (str_size >= *str_len)\n    memcpy (str, der + len_len, *str_len);\n  else\n    {\n      return ASN1_MEM_ERROR;\n    }\n\n  return ASN1_SUCCESS;\n}","24690":"  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n    const Tensor& input_min_range = ctx->input(1);\n    const Tensor& input_max_range = ctx->input(2);\n\n    int num_slices = 1;\n    if (axis_ > -1) {\n      num_slices = input.dim_size(axis_);\n    }\n\n    const TensorShape& minmax_shape = ctx->input(1).shape();\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n\n    Tensor* output_min_tensor = nullptr;\n    Tensor* output_max_tensor = nullptr;\n\n    if (num_slices == 1) {\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(1, {}, &output_min_tensor));\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(2, {}, &output_max_tensor));\n      const float min_range = input_min_range.template flat<float>()(0);\n      const float max_range = input_max_range.template flat<float>()(0);\n      QuantizeTensor(ctx, input, min_range, max_range, output,\n                     output_min_tensor, output_max_tensor);\n      return;\n    }\n\n    OP_REQUIRES(ctx, mode_ != QUANTIZE_MODE_MIN_FIRST,\n                errors::Unimplemented(\"STR\"\n                                      \"STR\"));\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(1, minmax_shape, &output_min_tensor));\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(2, minmax_shape, &output_max_tensor));\n\n    auto input_tensor =\n        input.template flat_inner_outer_dims<float, 3>(axis_ - 1);\n    int64_t pre_dim = 1, post_dim = 1;\n    for (int i = 0; i < axis_; ++i) {\n      pre_dim *= output->dim_size(i);\n    }\n    for (int i = axis_ + 1; i < output->dims(); ++i) {\n      post_dim *= output->dim_size(i);\n    }\n    auto output_tensor = output->template bit_casted_shaped<T, 3>(\n        {pre_dim, num_slices, post_dim});\n    auto min_ranges = input_min_range.template vec<float>();\n    auto max_ranges = input_max_range.template vec<float>();\n    for (int i = 0; i < num_slices; ++i) {\n      QuantizeSlice(ctx->eigen_device<Device>(), ctx,\n                    input_tensor.template chip<1>(i), min_ranges(i),\n                    max_ranges(i), output_tensor.template chip<1>(i),\n                    &output_min_tensor->flat<float>()(i),\n                    &output_max_tensor->flat<float>()(i));\n    }\n  }","24059":"void unmap_hugepage_range(struct vm_area_struct *vma, unsigned long start,\n\t\t\t  unsigned long end, struct page *ref_page)\n{\n\tmutex_lock(&vma->vm_file->f_mapping->i_mmap_mutex);\n\t__unmap_hugepage_range(vma, start, end, ref_page);\n\tmutex_unlock(&vma->vm_file->f_mapping->i_mmap_mutex);\n}","24947":"static bool ok_jpg_read_dht(ok_jpg_decoder *decoder) {\n    \n    ok_jpg *jpg = decoder->jpg;\n    uint8_t buffer[17];\n    if (!ok_read(decoder, buffer, 2)) {\n        return false;\n    }\n    int length = readBE16(buffer) - 2;\n    while (length >= 17) {\n        if (!ok_read(decoder, buffer, 17)) {\n            return false;\n        }\n        length -= 17;\n\n        int Tc = buffer[0] >> 4;\n        int Th = buffer[0] & 0x0f;\n        if (Tc > 1 || Th > 3) {\n            ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, \"STR\");\n            return false;\n        }\n        ok_jpg_huffman_table *tables = (Tc == 0 ? decoder->dc_huffman_tables :\n                                        decoder->ac_huffman_tables);\n        ok_jpg_huffman_table *table = tables + Th;\n        ok_jpg_generate_huffman_table(table, buffer);\n        if (table->count > 0) {\n            if (table->count > 256 || table->count > length) {\n                ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, \"STR\");\n                return false;\n            }\n            if (!ok_read(decoder, table->val, (size_t)table->count)) {\n                return false;\n            }\n            length -= table->count;\n        }\n        bool is_ac_table = Tc == 1;\n        ok_jpg_generate_huffman_table_lookups(table, is_ac_table);\n    }\n    if (length != 0) {\n        ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, \"STR\");\n        return false;\n    } else {\n        return true;\n    }\n}","24160":"void PrintFormatNumber(void * ValuePtr, int Format, int ByteCount)\n{\n    int s,n;\n\n    for(n=0;n<16;n++){\n        switch(Format){\n            case FMT_SBYTE:\n            case FMT_BYTE:      printf(\"STR\",*(uchar *)ValuePtr); s=1;  break;\n            case FMT_USHORT:    printf(\"STR\",Get16u(ValuePtr)); s=2;      break;\n            case FMT_ULONG:     \n            case FMT_SLONG:     printf(\"STR\",Get32s(ValuePtr)); s=4;      break;\n            case FMT_SSHORT:    printf(\"STR\",(signed short)Get16u(ValuePtr)); s=2; break;\n            case FMT_URATIONAL:\n                printf(\"STR\",Get32s(ValuePtr), Get32s(4+(char *)ValuePtr)); \n                s = 8;\n                break;\n\n            case FMT_SRATIONAL: \n                printf(\"STR\",Get32s(ValuePtr), Get32s(4+(char *)ValuePtr)); \n                s = 8;\n                break;\n\n            case FMT_SINGLE:    printf(\"STR\",(double)*(float *)ValuePtr); s=8; break;\n            case FMT_DOUBLE:    printf(\"STR\",*(double *)ValuePtr);        s=8; break;\n            default: \n                printf(\"STR\", Format);\n                return;\n        }\n        ByteCount -= s;\n        if (ByteCount <= 0) break;\n        printf(\"STR\");\n        ValuePtr = (void *)((char *)ValuePtr + s);\n\n    }\n    if (n >= 16) printf(\"STR\");\n}","24011":"char *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}","23907":"void gf_isom_sample_entry_predestroy(GF_SampleEntryBox *ptr)\n{\n}","24530":"static coroutine_fn int nbd_negotiate(NBDClient *client, Error **errp)\n{\n    char buf[8 + 8 + 8 + 128];\n    int ret;\n    const uint16_t myflags = (NBD_FLAG_HAS_FLAGS | NBD_FLAG_SEND_TRIM |\n                              NBD_FLAG_SEND_FLUSH | NBD_FLAG_SEND_FUA |\n                              NBD_FLAG_SEND_WRITE_ZEROES);\n    bool oldStyle;\n\n    \n\n    qio_channel_set_blocking(client->ioc, false, NULL);\n\n    trace_nbd_negotiate_begin();\n    memset(buf, 0, sizeof(buf));\n    memcpy(buf, \"STR\", 8);\n\n    oldStyle = client->exp != NULL && !client->tlscreds;\n    if (oldStyle) {\n        trace_nbd_negotiate_old_style(client->exp->size,\n                                      client->exp->nbdflags | myflags);\n        stq_be_p(buf + 8, NBD_CLIENT_MAGIC);\n        stq_be_p(buf + 16, client->exp->size);\n        stw_be_p(buf + 26, client->exp->nbdflags | myflags);\n\n        if (nbd_write(client->ioc, buf, sizeof(buf), errp) < 0) {\n            error_prepend(errp, \"STR\");\n            return -EINVAL;\n        }\n    } else {\n        stq_be_p(buf + 8, NBD_OPTS_MAGIC);\n        stw_be_p(buf + 16, NBD_FLAG_FIXED_NEWSTYLE | NBD_FLAG_NO_ZEROES);\n\n        if (nbd_write(client->ioc, buf, 18, errp) < 0) {\n            error_prepend(errp, \"STR\");\n            return -EINVAL;\n        }\n        ret = nbd_negotiate_options(client, myflags, errp);\n        if (ret != 0) {\n            if (ret < 0) {\n                error_prepend(errp, \"STR\");\n            }\n            return ret;\n        }\n    }\n\n    trace_nbd_negotiate_success();\n\n    return 0;\n}","24873":"static u8 m4v_get_sar_idx(u32 w, u32 h)\n{\n\tu32 i;\n\tfor (i=0; i<6; i++) {\n\t\tif ((m4v_sar[i].w==w) && (m4v_sar[i].h==h)) return i;\n\t}\n\treturn 0xF;\n}","24376":"gimp_channel_flood (GimpChannel *channel,\n                    gboolean     push_undo)\n{\n  g_return_if_fail (GIMP_IS_CHANNEL (channel));\n\n  if (! gimp_item_is_attached (GIMP_ITEM (channel)))\n    push_undo = FALSE;\n\n  GIMP_CHANNEL_GET_CLASS (channel)->flood (channel, push_undo);\n}","23972":"static int handle_fastpath_set_x2apic_icr_irqoff(struct kvm_vcpu *vcpu, u64 data)\n{\n\tif (!lapic_in_kernel(vcpu) || !apic_x2apic_mode(vcpu->arch.apic))\n\t\treturn 1;\n\n\tif (((data & APIC_SHORT_MASK) == APIC_DEST_NOSHORT) &&\n\t    ((data & APIC_DEST_MASK) == APIC_DEST_PHYSICAL) &&\n\t    ((data & APIC_MODE_MASK) == APIC_DM_FIXED) &&\n\t    ((u32)(data >> 32) != X2APIC_BROADCAST))\n\t\treturn kvm_x2apic_icr_write(vcpu->arch.apic, data);\n\n\treturn 1;\n}","24581":"inline int Http2Session::OnFrameReceive(nghttp2_session* handle,\n                                        const nghttp2_frame* frame,\n                                        void* user_data) {\n  Http2Session* session = static_cast<Http2Session*>(user_data);\n  session->statistics_.frame_count++;\n  DEBUG_HTTP2SESSION2(session, \"STR\",\n                      frame->hd.type);\n  switch (frame->hd.type) {\n    case NGHTTP2_DATA:\n      session->HandleDataFrame(frame);\n      break;\n    case NGHTTP2_PUSH_PROMISE:\n      \n    case NGHTTP2_HEADERS:\n      session->HandleHeadersFrame(frame);\n      break;\n    case NGHTTP2_SETTINGS:\n      session->HandleSettingsFrame(frame);\n      break;\n    case NGHTTP2_PRIORITY:\n      session->HandlePriorityFrame(frame);\n      break;\n    case NGHTTP2_GOAWAY:\n      session->HandleGoawayFrame(frame);\n      break;\n    case NGHTTP2_PING:\n      session->HandlePingFrame(frame);\n    default:\n      break;\n  }\n  return 0;\n}","24208":"static int nl80211_get_ftm_responder_stats(struct sk_buff *skb,\n\t\t\t\t\t   struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct cfg80211_ftm_responder_stats ftm_stats = {};\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tstruct nlattr *ftm_stats_attr;\n\tint err;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP || !wdev->beacon_interval)\n\t\treturn -EOPNOTSUPP;\n\n\terr = rdev_get_ftm_responder_stats(rdev, dev, &ftm_stats);\n\tif (err)\n\t\treturn err;\n\n\tif (!ftm_stats.filled)\n\t\treturn -ENODATA;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_FTM_RESPONDER_STATS);\n\tif (!hdr)\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u32(msg, NL80211_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tftm_stats_attr = nla_nest_start_noflag(msg,\n\t\t\t\t\t       NL80211_ATTR_FTM_RESPONDER_STATS);\n\tif (!ftm_stats_attr)\n\t\tgoto nla_put_failure;\n\n\n\tdo { if ((ftm_stats.filled & BIT(NL80211_FTM_STATS_ ## name)) && \\\n\t    nla_put_ ## type(msg, NL80211_FTM_STATS_ ## name,\t\t \\\n\t\t\t     ftm_stats.field))\t\t\t\t \\\n\t\tgoto nla_put_failure; } while (0)\n\n\tdo { if ((ftm_stats.filled & BIT(NL80211_FTM_STATS_ ## name)) && \\\n\t    nla_put_u64_64bit(msg, NL80211_FTM_STATS_ ## name,\t\t \\\n\t\t\t      ftm_stats.field, NL80211_FTM_STATS_PAD))\t \\\n\t\tgoto nla_put_failure; } while (0)\n\n\tSET_FTM(success_num, SUCCESS_NUM, u32);\n\tSET_FTM(partial_num, PARTIAL_NUM, u32);\n\tSET_FTM(failed_num, FAILED_NUM, u32);\n\tSET_FTM(asap_num, ASAP_NUM, u32);\n\tSET_FTM(non_asap_num, NON_ASAP_NUM, u32);\n\tSET_FTM_U64(total_duration_ms, TOTAL_DURATION_MSEC);\n\tSET_FTM(unknown_triggers_num, UNKNOWN_TRIGGERS_NUM, u32);\n\tSET_FTM(reschedule_requests_num, RESCHEDULE_REQUESTS_NUM, u32);\n\tSET_FTM(out_of_window_triggers_num, OUT_OF_WINDOW_TRIGGERS_NUM, u32);\n#undef SET_FTM\n\n\tnla_nest_end(msg, ftm_stats_attr);\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\nnla_put_failure:\n\tnlmsg_free(msg);\n\treturn -ENOBUFS;\n}","24025":"static inline float reminder(float v, int x)\n{\n    return ((v \/ x) - floor(v \/ x)) * x;\n}","24715":"\nstatic int nl80211_get_power_save(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tenum nl80211_ps_state ps_state;\n\tstruct wireless_dev *wdev;\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tint err;\n\n\twdev = dev->ieee80211_ptr;\n\n\tif (!rdev->ops->set_power_mgmt)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = nl80211hdr_put(msg, info->snd_pid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_GET_POWER_SAVE);\n\tif (!hdr) {\n\t\terr = -ENOBUFS;\n\t\tgoto free_msg;\n\t}\n\n\tif (wdev->ps)\n\t\tps_state = NL80211_PS_ENABLED;\n\telse\n\t\tps_state = NL80211_PS_DISABLED;\n\n\tNLA_PUT_U32(msg, NL80211_ATTR_PS_STATE, ps_state);\n\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;","24574":"storagePoolDestroy(virStoragePoolPtr pool)\n{\n    virStoragePoolObj *obj;\n    virStoragePoolDef *def;\n    virStorageBackend *backend;\n    virObjectEvent *event = NULL;\n    int ret = -1;\n    g_autofree char *stateFile = NULL;\n\n    if (!(obj = storagePoolObjFindByUUID(pool->uuid, pool->name)))\n        goto cleanup;\n    def = virStoragePoolObjGetDef(obj);\n\n    if (virStoragePoolDestroyEnsureACL(pool->conn, def) < 0)\n        goto cleanup;\n\n    if ((backend = virStorageBackendForType(def->type)) == NULL)\n        goto cleanup;\n\n    VIR_INFO(\"STR\", def->name);\n\n    if (!virStoragePoolObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"STR\"), def->name);\n        goto cleanup;\n    }\n\n    if (virStoragePoolObjIsStarting(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"STR\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    if (virStoragePoolObjGetAsyncjobs(obj) > 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"STR\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    if (!(stateFile = virFileBuildPath(driver->stateDir, def->name, \"STR\")))\n        goto cleanup;\n\n    unlink(stateFile);\n\n    if (backend->stopPool &&\n        backend->stopPool(obj) < 0)\n        goto cleanup;\n\n    virStoragePoolObjClearVols(obj);\n\n    event = virStoragePoolEventLifecycleNew(def->name,\n                                            def->uuid,\n                                            VIR_STORAGE_POOL_EVENT_STOPPED,\n                                            0);\n\n    virStoragePoolObjSetActive(obj, false);\n\n    virStoragePoolUpdateInactive(obj);\n\n    ret = 0;\n\n cleanup:\n    virObjectEventStateQueue(driver->storageEventState, event);\n    virStoragePoolObjEndAPI(&obj);\n    return ret;\n}","24583":"\n\t\t\tgf_dynstrcat(&ds->rep->dasher_ctx->mux_pids, szMuxPID, NULL);\n\t\t}\n\n\t}\n}\n\nstatic GF_DashStream *dasher_get_stream(GF_DasherCtx *ctx, const char *src_url, u32 original_pid, u32 pid_id)\n{\n\tu32 i, count = gf_list_count(ctx->pids);","24072":"static void vmx_hwapic_isr_update(struct kvm *kvm, int isr)\n{\n\tu16 status;\n\tu8 old;\n\n\tif (isr == -1)\n\t\tisr = 0;\n\n\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\told = status >> 8;\n\tif (isr != old) {\n\t\tstatus &= 0xff;\n\t\tstatus |= isr << 8;\n\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t}\n}","24071":"int idr_get_new_above(struct idr *idp, void *ptr, int starting_id, int *id)\n{\n\tstruct idr_layer *pa[MAX_IDR_LEVEL + 1];\n\tint rv;\n\n\trv = idr_get_empty_slot(idp, starting_id, pa, 0, idp);\n\tif (rv < 0)\n\t\treturn rv == -ENOMEM ? -EAGAIN : rv;\n\n\tidr_fill_slot(ptr, rv, pa);\n\t*id = rv;\n\treturn 0;\n}","25050":"static int mp_get_lsr_info(struct sb_uart_state *state, unsigned int *value)\n{\n\tstruct sb_uart_port *port = state->port;\n\tunsigned int result;\n\n\tresult = port->ops->tx_empty(port);\n\n\tif (port->x_char ||\n\t\t\t((uart_circ_chars_pending(&state->info->xmit) > 0) &&\n\t\t\t\t!state->info->tty->stopped && !state->info->tty->hw_stopped))\n\t\tresult &= ~TIOCSER_TEMT;\n\n\treturn put_user(result, value);\n}","24970":"static void setup_object_debug(struct kmem_cache *s, struct page *page,\n\t\t\t\t\t\t\t\tvoid *object)\n{\n\tif (!(s->flags & (SLAB_STORE_USER|SLAB_RED_ZONE|__OBJECT_POISON)))\n\t\treturn;\n\n\tinit_object(s, object, SLUB_RED_INACTIVE);\n\tinit_tracking(s, object);\n}","24686":"\nstatic __cold int io_probe(struct io_ring_ctx *ctx, void __user *arg,\n\t\t\t   unsigned nr_args)\n{\n\tstruct io_uring_probe *p;\n\tsize_t size;\n\tint i, ret;\n\n\tsize = struct_size(p, ops, nr_args);\n\tif (size == SIZE_MAX)\n\t\treturn -EOVERFLOW;\n\tp = kzalloc(size, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tret = -EFAULT;\n\tif (copy_from_user(p, arg, size))\n\t\tgoto out;\n\tret = -EINVAL;\n\tif (memchr_inv(p, 0, size))\n\t\tgoto out;\n\n\tp->last_op = IORING_OP_LAST - 1;\n\tif (nr_args > IORING_OP_LAST)\n\t\tnr_args = IORING_OP_LAST;\n\n\tfor (i = 0; i < nr_args; i++) {\n\t\tp->ops[i].op = i;\n\t\tif (!io_op_defs[i].not_supported)\n\t\t\tp->ops[i].flags = IO_URING_OP_SUPPORTED;\n\t}\n\tp->ops_len = i;\n\n\tret = 0;\n\tif (copy_to_user(arg, p, size))\n\t\tret = -EFAULT;\nout:\n\tkfree(p);\n\treturn ret;","23878":"static void nsc_encode_subsampling(NSC_CONTEXT* context)\n{\n\tUINT16 x;\n\tUINT16 y;\n\tBYTE* co_dst;\n\tBYTE* cg_dst;\n\tINT8* co_src0;\n\tINT8* co_src1;\n\tINT8* cg_src0;\n\tINT8* cg_src1;\n\tUINT32 tempWidth;\n\tUINT32 tempHeight;\n\ttempWidth = ROUND_UP_TO(context->width, 8);\n\ttempHeight = ROUND_UP_TO(context->height, 2);\n\n\tfor (y = 0; y < tempHeight >> 1; y++)\n\t{\n\t\tco_dst = context->priv->PlaneBuffers[1] + y * (tempWidth >> 1);\n\t\tcg_dst = context->priv->PlaneBuffers[2] + y * (tempWidth >> 1);\n\t\tco_src0 = (INT8*) context->priv->PlaneBuffers[1] + (y << 1) * tempWidth;\n\t\tco_src1 = co_src0 + tempWidth;\n\t\tcg_src0 = (INT8*) context->priv->PlaneBuffers[2] + (y << 1) * tempWidth;\n\t\tcg_src1 = cg_src0 + tempWidth;\n\n\t\tfor (x = 0; x < tempWidth >> 1; x++)\n\t\t{\n\t\t\t*co_dst++ = (BYTE)(((INT16) * co_src0 + (INT16) * (co_src0 + 1) +\n\t\t\t                    (INT16) * co_src1 + (INT16) * (co_src1 + 1)) >> 2);\n\t\t\t*cg_dst++ = (BYTE)(((INT16) * cg_src0 + (INT16) * (cg_src0 + 1) +\n\t\t\t                    (INT16) * cg_src1 + (INT16) * (cg_src1 + 1)) >> 2);\n\t\t\tco_src0 += 2;\n\t\t\tco_src1 += 2;\n\t\t\tcg_src0 += 2;\n\t\t\tcg_src1 += 2;\n\t\t}\n\t}\n}","24687":"static int check_raw_mode(const struct bpf_func_proto *fn)\n{\n\tint count = 0;\n\n\tif (fn->arg1_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\tif (fn->arg2_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\tif (fn->arg3_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\tif (fn->arg4_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\tif (fn->arg5_type == ARG_PTR_TO_UNINIT_MEM)\n\t\tcount++;\n\n\treturn count > 1 ? -EINVAL : 0;\n}","24451":"static int selinux_cmp_sb_context(const struct super_block *oldsb,\n\t\t\t\t    const struct super_block *newsb)\n{\n\tstruct superblock_security_struct *old = oldsb->s_security;\n\tstruct superblock_security_struct *new = newsb->s_security;\n\tchar oldflags = old->flags & SE_MNTMASK;\n\tchar newflags = new->flags & SE_MNTMASK;\n\n\tif (oldflags != newflags)\n\t\tgoto mismatch;\n\tif ((oldflags & FSCONTEXT_MNT) && old->sid != new->sid)\n\t\tgoto mismatch;\n\tif ((oldflags & CONTEXT_MNT) && old->mntpoint_sid != new->mntpoint_sid)\n\t\tgoto mismatch;\n\tif ((oldflags & DEFCONTEXT_MNT) && old->def_sid != new->def_sid)\n\t\tgoto mismatch;\n\tif (oldflags & ROOTCONTEXT_MNT) {\n\t\tstruct inode_security_struct *oldroot = backing_inode_security(oldsb->s_root);\n\t\tstruct inode_security_struct *newroot = backing_inode_security(newsb->s_root);\n\t\tif (oldroot->sid != newroot->sid)\n\t\t\tgoto mismatch;\n\t}\n\treturn 0;\nmismatch:\n\tpr_warn(\"STR\"\n\t\t\t    \"STR\"\n\t\t\t    \"STR\", newsb->s_id, newsb->s_type->name);\n\treturn -EBUSY;\n}","24005":"void btrfs_trans_release_chunk_metadata(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\n\tif (!trans->chunk_bytes_reserved)\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&trans->new_bgs));\n\n\tbtrfs_block_rsv_release(fs_info, &fs_info->chunk_block_rsv,\n\t\t\t\ttrans->chunk_bytes_reserved, NULL);\n\tatomic64_sub(trans->chunk_bytes_reserved, &cur_trans->chunk_bytes_reserved);\n\tcond_wake_up(&cur_trans->chunk_reserve_wait);\n\ttrans->chunk_bytes_reserved = 0;\n}","24579":"static bool opt_is_good(DnsResourceRecord *rr, bool *rfc6975) {\n        const uint8_t* p;\n        bool found_dau_dhu_n3u = false;\n        size_t l;\n\n        \n\n        assert(rr);\n        assert(rr->key->type == DNS_TYPE_OPT);\n\n        \n        if (((rr->ttl >> 16) & UINT32_C(0xFF)) != 0) {\n                *rfc6975 = false;\n                return true; \n        }\n\n        p = rr->opt.data;\n        l = rr->opt.data_size;\n        while (l > 0) {\n                uint16_t option_code, option_length;\n\n                \n                if (l < 4U)\n                        return false;\n\n                option_code = unaligned_read_be16(p);\n                option_length = unaligned_read_be16(p + 2);\n\n                if (l < option_length + 4U)\n                        return false;\n\n                \n                if (IN_SET(option_code, 5, 6, 7))\n                        found_dau_dhu_n3u = true;\n\n                p += option_length + 4U;\n                l -= option_length + 4U;\n        }\n\n        *rfc6975 = found_dau_dhu_n3u;\n        return true;\n}","24945":"struct task_struct * __cpuinit fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\tstruct pt_regs regs;\n\n\ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n\t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task))\n\t\tinit_idle(task, cpu);\n\n\treturn task;\n}","23919":"uint16_t smb2cli_conn_server_security_mode(struct smbXcli_conn *conn)\n{\n\treturn conn->smb2.server.security_mode;\n}","24585":"xfs_icache_inode_is_allocated(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\txfs_ino_t\t\tino,\n\tbool\t\t\t*inuse)\n{\n\tstruct xfs_inode\t*ip;\n\tint\t\t\terror;\n\n\terror = xfs_iget(mp, tp, ino, XFS_IGET_INCORE, 0, &ip);\n\tif (error)\n\t\treturn error;\n\n\t*inuse = !!(VFS_I(ip)->i_mode);\n\tIRELE(ip);\n\treturn 0;\n}","24398":"pfm_uuid_cmp(pfm_uuid_t a, pfm_uuid_t b)\n{\n\treturn memcmp(a, b, sizeof(pfm_uuid_t));\n}","24454":"void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {\n    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) return;\n    zset *zset = zobj->ptr;\n\n    if (zset->zsl->length <= server.zset_max_ziplist_entries &&\n        maxelelen <= server.zset_max_ziplist_value)\n            zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);\n}","24902":"Server::Server(boost::asio::ip::tcp protocol, std::uint16_t port,\n               const fs::path& doc_root)\n    : protocol_(protocol),\n      port_(port),\n      doc_root_(doc_root),\n      acceptor_(io_context_),\n      signals_(io_context_) {\n  AddSignals();\n}","23912":"int ECDSA_verify(int type, const unsigned char *dgst, int dgst_len,\n\t\tconst unsigned char *sigbuf, int sig_len, EC_KEY *eckey)\n \t{\n\tECDSA_SIG *s;\n\tint ret=-1;\n\n\ts = ECDSA_SIG_new();\n\tif (s == NULL) return(ret);\n\tif (d2i_ECDSA_SIG(&s, &sigbuf, sig_len) == NULL) goto err;\n\tret=ECDSA_do_verify(dgst, dgst_len, s, eckey);\nerr:\n\tECDSA_SIG_free(s);\n\treturn(ret);\n\t}","24489":"int ssh_buffer_add_data(struct ssh_buffer_struct *buffer, const void *data, uint32_t len)\n{\n  buffer_verify(buffer);\n\n  if (data == NULL) {\n      return -1;\n  }\n\n  if (buffer->used + len < len) {\n    return -1;\n  }\n\n  if (buffer->allocated < (buffer->used + len)) {\n    if(buffer->pos > 0)\n      buffer_shift(buffer);\n    if (realloc_buffer(buffer, buffer->used + len) < 0) {\n      return -1;\n    }\n  }\n\n  memcpy(buffer->data+buffer->used, data, len);\n  buffer->used+=len;\n  buffer_verify(buffer);\n  return 0;\n}","23978":"g_tcp_can_send(int sck, int millis)\n{\n  fd_set wfds;\n  struct timeval time;\n  int rv;\n\n  time.tv_sec = millis \/ 1000;\n  time.tv_usec = (millis * 1000) % 1000000;\n  FD_ZERO(&wfds);\n  if (sck > 0)\n  {\n    FD_SET(((unsigned int)sck), &wfds);\n    rv = select(sck + 1, 0, &wfds, 0, &time);\n    if (rv > 0)\n    {\n      return g_tcp_socket_ok(sck);\n    }\n  }\n  return 0;\n}","24621":"HttpHeader::chunked() const\n{\n    return has(Http::HdrType::TRANSFER_ENCODING) &&\n           hasListMember(Http::HdrType::TRANSFER_ENCODING, \"STR\", ',');\n}","24738":"HttpHdrRange::contains(const HttpHdrRangeSpec& r) const\n{\n    assert(r.length >= 0);\n    HttpHdrRangeSpec::HttpRange rrange(r.offset, r.offset + r.length);\n\n    for (const_iterator i = begin(); i != end(); ++i) {\n        HttpHdrRangeSpec::HttpRange irange((*i)->offset, (*i)->offset + (*i)->length);\n        HttpHdrRangeSpec::HttpRange intersection = rrange.intersection(irange);\n\n        if (intersection.start == irange.start && intersection.size() == irange.size())\n            return true;\n    }\n\n    return false;\n}","23862":"static int php_openssl_load_rand_file(const char * file, int *egdsocket, int *seeded) \n{\n\tchar buffer[MAXPATHLEN];\n\n\t*egdsocket = 0;\n\t*seeded = 0;\n\n\tif (file == NULL) {\n\t\tfile = RAND_file_name(buffer, sizeof(buffer));\n#ifdef HAVE_RAND_EGD\n\t} else if (RAND_egd(file) > 0) {\n\t\t\n\t\t*egdsocket = 1;\n\t\treturn SUCCESS;\n#endif\n\t}\n\tif (file == NULL || !RAND_load_file(file, -1)) {\n\t\tif (RAND_status() == 0) {\n\t\t\tphp_openssl_store_errors();\n\t\t\tphp_error_docref(NULL, E_WARNING, \"STR\");\n\t\t\treturn FAILURE;\n\t\t}\n\t\treturn FAILURE;\n\t}\n\t*seeded = 1;\n\treturn SUCCESS;\n}","24303":"void ConnectionImpl::releaseOutboundFrame(const Buffer::OwnedBufferFragmentImpl* fragment) {\n  ASSERT(outbound_frames_ >= 1);\n  --outbound_frames_;\n  delete fragment;\n}","24132":"static inline struct f_midi_opts *to_f_midi_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_midi_opts,\n\t\t\t    func_inst.group);\n}","24701":"static int write_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t void *val, int bytes)\n{\n\treturn emulator_write_phys(vcpu, gpa, val, bytes);\n}","24923":"static void clone_update_extent_map(struct inode *inode,\n\t\t\t\t    const struct btrfs_trans_handle *trans,\n\t\t\t\t    const struct btrfs_path *path,\n\t\t\t\t    const u64 hole_offset,\n\t\t\t\t    const u64 hole_len)\n{\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct extent_map *em;\n\tint ret;\n\n\tem = alloc_extent_map();\n\tif (!em) {\n\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\treturn;\n\t}\n\n\tif (path) {\n\t\tstruct btrfs_file_extent_item *fi;\n\n\t\tfi = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tbtrfs_extent_item_to_extent_map(inode, path, fi, false, em);\n\t\tem->generation = -1;\n\t\tif (btrfs_file_extent_type(path->nodes[0], fi) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE)\n\t\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t} else {\n\t\tem->start = hole_offset;\n\t\tem->len = hole_len;\n\t\tem->ram_bytes = em->len;\n\t\tem->orig_start = hole_offset;\n\t\tem->block_start = EXTENT_MAP_HOLE;\n\t\tem->block_len = 0;\n\t\tem->orig_block_len = 0;\n\t\tem->compress_type = BTRFS_COMPRESS_NONE;\n\t\tem->generation = trans->transid;\n\t}\n\n\twhile (1) {\n\t\twrite_lock(&em_tree->lock);\n\t\tret = add_extent_mapping(em_tree, em, 1);\n\t\twrite_unlock(&em_tree->lock);\n\t\tif (ret != -EEXIST) {\n\t\t\tfree_extent_map(em);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_drop_extent_cache(inode, em->start,\n\t\t\t\t\tem->start + em->len - 1, 0);\n\t}\n\n\tif (ret)\n\t\tset_bit(BTRFS_INODE_NEEDS_FULL_SYNC,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n}","24332":"RefreshXtermOSC()\n{\n  int i;\n  struct win *p;\n\n  p = Layer2Window(D_forecv->c_layer);\n  for (i = 3; i >=0; i--)\n    SetXtermOSC(i, p ? p->w_xtermosc[i] : 0);\n}","24763":"static void nvme_req_clear(NvmeRequest *req)\n{\n    req->ns = NULL;\n    req->opaque = NULL;\n    req->aiocb = NULL;\n    memset(&req->cqe, 0x0, sizeof(req->cqe));\n    req->status = NVME_SUCCESS;\n}","24388":"gs_window_reset_background_surface (GSWindow *window)\n{\n        cairo_pattern_t *pattern;\n        pattern = cairo_pattern_create_for_surface (window->priv->background_surface);\n        gdk_window_set_background_pattern (gtk_widget_get_window (GTK_WIDGET (window)),\n                                           pattern);\n        cairo_pattern_destroy (pattern);\n        gtk_widget_queue_draw (GTK_WIDGET (window));\n}","24228":"ReturnCode_t DataWriterImpl::get_offered_deadline_missed_status(\n        OfferedDeadlineMissedStatus& status)\n{\n    if (writer_ == nullptr)\n    {\n        return ReturnCode_t::RETCODE_NOT_ENABLED;\n    }\n\n    std::unique_lock<RecursiveTimedMutex> lock(writer_->getMutex());\n\n    status = deadline_missed_status_;\n    deadline_missed_status_.total_count_change = 0;\n    return ReturnCode_t::RETCODE_OK;\n}","24184":"autoar_extractor_do_sanitize_pathname (AutoarExtractor *self,\n                                       const char      *pathname_bytes)\n{\n  GFile *extracted_filename;\n  gboolean valid_filename;\n  g_autofree char *sanitized_pathname;\n  g_autofree char *utf8_pathname;\n\n  utf8_pathname = autoar_common_get_utf8_pathname (pathname_bytes);\n  extracted_filename = g_file_get_child (self->destination_dir,\n                                         utf8_pathname ?  utf8_pathname : pathname_bytes);\n\n  valid_filename =\n    g_file_equal (extracted_filename, self->destination_dir) ||\n    g_file_has_prefix (extracted_filename, self->destination_dir);\n\n  if (!valid_filename) {\n    g_autofree char *basename;\n\n    basename = g_file_get_basename (extracted_filename);\n\n    g_object_unref (extracted_filename);\n\n    extracted_filename = g_file_get_child (self->destination_dir,\n                                           basename);\n  }\n\n  if (self->prefix != NULL && self->new_prefix != NULL) {\n    g_autofree char *relative_path;\n    \n    relative_path = g_file_get_relative_path (self->prefix,\n                                              extracted_filename);\n\n    relative_path = relative_path != NULL ? relative_path : g_strdup (\"\");\n\n    g_object_unref (extracted_filename);\n\n    extracted_filename = g_file_get_child (self->new_prefix,\n                                           relative_path);\n  }\n\n  sanitized_pathname = g_file_get_path (extracted_filename);\n\n  g_debug (\"STR\", sanitized_pathname);\n\n  return extracted_filename;\n}","24399":"    bool otherUpdateInFetchPhase() {\n        return _authzManager->_isFetchPhaseBusy;\n    }","24229":"char *Item_func_password::\n  create_password_hash_buffer(THD *thd, const char *password,  size_t pass_len)\n{\n  String *password_str= new (thd->mem_root)String(password, thd->variables.\n                                                    character_set_client);\n  check_password_policy(password_str);\n\n  char *buff= NULL;\n  if (thd->variables.old_passwords == 0)\n  {\n    \n    buff= (char *) thd->alloc(SCRAMBLED_PASSWORD_CHAR_LENGTH + 1);\n    my_make_scrambled_password_sha1(buff, password, pass_len);\n  }\n#if defined(HAVE_OPENSSL)\n  else\n  {\n    \n    buff= (char *) thd->alloc(CRYPT_MAX_PASSWORD_SIZE + 1);\n    my_make_scrambled_password(buff, password, pass_len);\n  }\n#endif\n  return buff;\n}","24309":"void smtp_server_cmd_starttls(struct smtp_server_cmd_ctx *cmd,\n\t\t\t      const char *params)\n{\n\tstruct smtp_server_connection *conn = cmd->conn;\n\tstruct smtp_server_command *command = cmd->cmd;\n\tenum smtp_capability capabilities = conn->set.capabilities;\n\n\tif (conn->ssl_secured) {\n\t\ti_assert((capabilities & SMTP_CAPABILITY_STARTTLS) == 0);\n\t\tsmtp_server_reply(cmd,\n\t\t\t502, \"STR\");\n\t\treturn;\n\t} else if ((capabilities & SMTP_CAPABILITY_STARTTLS) == 0) {\n\t\tsmtp_server_reply(cmd,\n\t\t\t502, \"STR\");\n\t\treturn;\n\t}\n\n\t\n\tif (*params != '\\0') {\n\t\tsmtp_server_reply(cmd,\n\t\t\t501, \"STR\");\n\t\treturn;\n\t}\n\n\tsmtp_server_command_input_lock(cmd);\n\tsmtp_server_connection_input_lock(conn);\n\n\tsmtp_server_command_add_hook(command, SMTP_SERVER_COMMAND_HOOK_NEXT,\n\t\t\t\t     cmd_starttls_next, NULL);\n}","24525":"static int http_buf_read(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int len;\n    \n    len = s->buf_end - s->buf_ptr;\n    if (len > 0) {\n        if (len > size)\n            len = size;\n        memcpy(buf, s->buf_ptr, len);\n        s->buf_ptr += len;\n    } else {\n        int64_t target_end = s->end_off ? s->end_off : s->filesize;\n        if ((!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off >= target_end)\n            return AVERROR_EOF;\n        len = ffurl_read(s->hd, buf, size);\n        if (!len && (!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off < target_end) {\n            av_log(h, AV_LOG_ERROR,\n                   \"STR\",\n                   s->off, target_end\n                  );\n            return AVERROR(EIO);\n        }\n    }\n    if (len > 0) {\n        s->off += len;\n        if (s->chunksize > 0)\n            s->chunksize -= len;\n    }\n    return len;\n}","24617":"static void cmd_parse_expunge (IMAP_DATA* idata, const char* s)\n{\n  unsigned int exp_msn, cur;\n  HEADER* h;\n\n  dprint (2, (debugfile, \"STR\"));\n\n  if (mutt_atoui (s, &exp_msn) < 0 ||\n      exp_msn < 1 || exp_msn > idata->max_msn)\n    return;\n\n  h = idata->msn_index[exp_msn - 1];\n  if (h)\n  {\n    \n    h->index = INT_MAX;\n    HEADER_DATA(h)->msn = 0;\n  }\n\n  \n  for (cur = exp_msn; cur < idata->max_msn; cur++)\n  {\n    h = idata->msn_index[cur];\n    if (h)\n      HEADER_DATA(h)->msn--;\n    idata->msn_index[cur - 1] = h;\n  }\n\n  idata->msn_index[idata->max_msn - 1] = NULL;\n  idata->max_msn--;\n\n  idata->reopen |= IMAP_EXPUNGE_PENDING;\n}","24811":"static int cmd_starttls_start(struct smtp_server_connection *conn)\n{\n\tconst struct smtp_server_callbacks *callbacks = conn->callbacks;\n\n\te_debug(conn->event, \"STR\");\n\n\tif (callbacks != NULL && callbacks->conn_start_tls != NULL) {\n\t\tstruct smtp_server_connection *tmp_conn = conn;\n\t\tstruct istream *input = conn->conn.input;\n\t\tstruct ostream *output = conn->conn.output;\n\t\tint ret;\n\n\t\tsmtp_server_connection_ref(tmp_conn);\n\t\tret = callbacks->conn_start_tls(tmp_conn->context,\n\t\t\t&input, &output);\n\t\tif (!smtp_server_connection_unref(&tmp_conn) || ret < 0)\n\t\t\treturn -1;\n\n\t\tsmtp_server_connection_set_ssl_streams(conn, input, output);\n\t} else if (smtp_server_connection_ssl_init(conn) < 0) {\n\t\tsmtp_server_connection_close(&conn,\n\t\t\t\"STR\");\n\t\treturn -1;\n\t}\n\n\t\n\tsmtp_server_connection_clear(conn);\n\tsmtp_server_connection_input_unlock(conn);\n\n\treturn 0;\n}","24087":"static GSList *caps_to_list(uint8_t *data, size_t size,\n\t\t\t\tstruct avdtp_service_capability **codec,\n\t\t\t\tgboolean *delay_reporting)\n{\n\tstruct avdtp_service_capability *cap;\n\tGSList *caps;\n\n\tif (delay_reporting)\n\t\t*delay_reporting = FALSE;\n\n\tif (size < sizeof(*cap))\n\t\treturn NULL;\n\n\tfor (caps = NULL; size >= sizeof(*cap);) {\n\t\tstruct avdtp_service_capability *cpy;\n\n\t\tcap = (struct avdtp_service_capability *)data;\n\n\t\tif (sizeof(*cap) + cap->length >= size) {\n\t\t\terror(\"STR\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cap->category == AVDTP_MEDIA_CODEC &&\n\t\t\t\t\tcap->length < sizeof(**codec)) {\n\t\t\terror(\"STR\");\n\t\t\tbreak;\n\t\t}\n\n\t\tcpy = btd_malloc(sizeof(*cpy) + cap->length);\n\t\tmemcpy(cpy, cap, sizeof(*cap) + cap->length);\n\n\t\tsize -= sizeof(*cap) + cap->length;\n\t\tdata += sizeof(*cap) + cap->length;\n\n\t\tcaps = g_slist_append(caps, cpy);\n\n\t\tswitch (cap->category) {\n\t\tcase AVDTP_MEDIA_CODEC:\n\t\t\tif (codec)\n\t\t\t\t*codec = cap;\n\t\t\tbreak;\n\t\tcase AVDTP_DELAY_REPORTING:\n\t\t\tif (delay_reporting)\n\t\t\t\t*delay_reporting = TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn caps;\n}","24955":"static void vnc_dpy_update(DisplayState *ds, int x, int y, int w, int h)\n{\n    int i;\n    VncDisplay *vd = ds->opaque;\n    struct VncSurface *s = &vd->guest;\n\n    h += y;\n\n    \n    w += (x % 16);\n    x -= (x % 16);\n\n    x = MIN(x, s->ds->width);\n    y = MIN(y, s->ds->height);\n    w = MIN(x + w, s->ds->width) - x;\n    h = MIN(h, s->ds->height);\n\n    for (; y < h; y++)\n        for (i = 0; i < w; i += 16)\n            set_bit((x + i) \/ 16, s->dirty[y]);\n}","24017":"juniper_mlppp_print(netdissect_options *ndo,\n                    const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n\n        l2info.pictype = DLT_JUNIPER_MLPPP;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n\n        \n        if (ndo->ndo_eflag &&\n            EXTRACT_16BITS(&l2info.cookie) != PPP_OSI &&\n            EXTRACT_16BITS(&l2info.cookie) !=  (PPP_ADDRESS << 8 | PPP_CONTROL))\n            ND_PRINT((ndo, \"STR\", l2info.bundle));\n\n        p+=l2info.header_len;\n\n        \n        switch(l2info.proto) {\n        case JUNIPER_LSQ_L3_PROTO_IPV4:\n            \n            if (l2info.cookie[4] == (JUNIPER_LSQ_COOKIE_RE|JUNIPER_LSQ_COOKIE_DIR))\n                ppp_print(ndo, p, l2info.length);\n            else\n                ip_print(ndo, p, l2info.length);\n            return l2info.header_len;\n        case JUNIPER_LSQ_L3_PROTO_IPV6:\n            ip6_print(ndo, p,l2info.length);\n            return l2info.header_len;\n        case JUNIPER_LSQ_L3_PROTO_MPLS:\n            mpls_print(ndo, p, l2info.length);\n            return l2info.header_len;\n        case JUNIPER_LSQ_L3_PROTO_ISO:\n            isoclns_print(ndo, p, l2info.length);\n            return l2info.header_len;\n        default:\n            break;\n        }\n\n        \n        switch (EXTRACT_16BITS(&l2info.cookie)) {\n        case PPP_OSI:\n            ppp_print(ndo, p - 2, l2info.length + 2);\n            break;\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): \n        default:\n            ppp_print(ndo, p, l2info.length);\n            break;\n        }\n\n        return l2info.header_len;\n}","24893":"static void qcow_header_bswap(struct qcow_header *be, struct qcow_header *dst)\n{\n\tdst->magic = be32toh(be->magic);\n\tdst->version = be32toh(be->version);\n\tdst->backing_file_offset = be64toh(be->backing_file_offset);\n\tdst->backing_file_size = be32toh(be->backing_file_size);\n\tdst->mtime = be32toh(be->mtime);\n\tdst->size = be64toh(be->size);\n\tdst->cluster_bits = be->cluster_bits;\n\tdst->l2_bits = be->l2_bits;\n\tdst->padding = be16toh(be->padding);\n\tdst->crypt_method = be32toh(be->crypt_method);\n\tdst->l1_table_offset = be64toh(be->l1_table_offset);\n}","24592":"void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,\n                                       CodeEmitInfo* info) {\n  if (address->type() == T_LONG) {\n    address = new LIR_Address(address->base(),\n                              address->index(), address->scale(),\n                              address->disp(), T_DOUBLE);\n    \n    \n    \n    \n    LIR_Opr temp_double = new_register(T_DOUBLE);\n    __ volatile_move(LIR_OprFact::address(address), temp_double, T_LONG, info);\n    __ volatile_move(temp_double, result, T_LONG);\n#ifndef _LP64\n    if (UseSSE < 2) {\n      \n      set_vreg_flag(result, must_start_in_memory);\n    }\n#endif \n  } else {\n    __ load(address, result, info);\n  }\n}","24737":"DECLAREContigPutFunc(putcontig8bitYCbCr21tile)\n{\n\t(void) y;\n\tfromskew = (fromskew * 4) \/ 2;\n\tdo {\n\t\tx = w>>1;\n\t\tdo {\n\t\t\tint32 Cb = pp[2];\n\t\t\tint32 Cr = pp[3];\n\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t\tYCbCrtoRGB(cp[1], pp[1]);\n\n\t\t\tcp += 2;\n\t\t\tpp += 4;\n\t\t} while (--x);\n\n\t\tif( (w&1) != 0 )\n\t\t{\n\t\t\tint32 Cb = pp[2];\n\t\t\tint32 Cr = pp[3];\n\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\n\t\t\tcp += 1;\n\t\t\tpp += 4;\n\t\t}\n\n\t\tcp += toskew;\n\t\tpp += fromskew;\n\t} while (--h);\n}","24367":"symbol_new (uniqstr tag, location loc)\n{\n  symbol *res = xmalloc (sizeof *res);\n  uniqstr_assert (tag);\n\n  \n  if (tag[0] != '\\\"' && tag[0] != '\\'' && strchr (tag, '-'))\n    complain (&loc, Wyacc,\n              _(\"STR\"), tag);\n\n  res->tag = tag;\n  res->location = loc;\n  res->translatable = false;\n  res->location_of_lhs = false;\n  res->alias = NULL;\n  res->content = sym_content_new (res);\n  res->is_alias = false;\n\n  if (nsyms == SYMBOL_NUMBER_MAXIMUM)\n    complain (NULL, fatal, _(\"STR\"),\n              SYMBOL_NUMBER_MAXIMUM);\n  nsyms++;\n  return res;\n}","24879":"void __audit_ptrace(struct task_struct *t)\n{\n\tstruct audit_context *context = current->audit_context;\n\n\tcontext->target_pid = task_pid_nr(t);\n\tcontext->target_auid = audit_get_loginuid(t);\n\tcontext->target_uid = task_uid(t);\n\tcontext->target_sessionid = audit_get_sessionid(t);\n\tsecurity_task_getsecid(t, &context->target_sid);\n\tmemcpy(context->target_comm, t->comm, TASK_COMM_LEN);\n}","24907":"Value ExpressionLet::serialize(bool explain) const {\n    MutableDocument vars;\n    for (VariableMap::const_iterator it = _variables.begin(), end = _variables.end(); it != end;\n         ++it) {\n        vars[it->second.name] = it->second.expression->serialize(explain);\n    }\n\n    return Value(\n        DOC(\"STR\" << _subExpression->serialize(explain))));\n}","23794":"static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb, u32 features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int mss;\n\tunsigned int unfrag_ip6hlen, unfrag_len;\n\tstruct frag_hdr *fptr;\n\tu8 *mac_start, *prevhdr;\n\tu8 nexthdr;\n\tu8 frag_hdr_sz = sizeof(struct frag_hdr);\n\tint offset;\n\t__wsum csum;\n\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (unlikely(skb->len <= mss))\n\t\tgoto out;\n\n\tif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\n\t\t\n\t\tint type = skb_shinfo(skb)->gso_type;\n\n\t\tif (unlikely(type & ~(SKB_GSO_UDP | SKB_GSO_DODGY) ||\n\t\t\t     !(type & (SKB_GSO_UDP))))\n\t\t\tgoto out;\n\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\n\n\t\tsegs = NULL;\n\t\tgoto out;\n\t}\n\n\t\n\toffset = skb->csum_start - skb_headroom(skb);\n\tcsum = skb_checksum(skb, offset, skb->len- offset, 0);\n\toffset += skb->csum_offset;\n\t*(__sum16 *)(skb->data + offset) = csum_fold(csum);\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\t\n\tif ((skb_headroom(skb) < frag_hdr_sz) &&\n\t    pskb_expand_head(skb, frag_hdr_sz, 0, GFP_ATOMIC))\n\t\tgoto out;\n\n\t\n\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\tnexthdr = *prevhdr;\n\t*prevhdr = NEXTHDR_FRAGMENT;\n\tunfrag_len = skb_network_header(skb) - skb_mac_header(skb) +\n\t\t     unfrag_ip6hlen;\n\tmac_start = skb_mac_header(skb);\n\tmemmove(mac_start-frag_hdr_sz, mac_start, unfrag_len);\n\n\tskb->mac_header -= frag_hdr_sz;\n\tskb->network_header -= frag_hdr_sz;\n\n\tfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\n\tfptr->nexthdr = nexthdr;\n\tfptr->reserved = 0;\n\tipv6_select_ident(fptr);\n\n\t\n\tsegs = skb_segment(skb, features);\n\nout:\n\treturn segs;\n}","23790":"ModuleExport size_t RegisterXWDImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"STR\");\n#if defined(MAGICKCORE_X11_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadXWDImage;\n  entry->encoder=(EncodeImageHandler *) WriteXWDImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsXWD;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}","24028":"static int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t      struct flowi *fl,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      enum tcp_synack_type synack_type)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_txoptions *opt;\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\n\t\n\tif (!dst && (dst = inet6_csk_route_req(sk, fl6, req,\n\t\t\t\t\t       IPPROTO_TCP)) == NULL)\n\t\tgoto done;\n\n\tskb = tcp_make_synack(sk, dst, req, foc, synack_type);\n\n\tif (skb) {\n\t\t__tcp_v6_send_check(skb, &ireq->ir_v6_loc_addr,\n\t\t\t\t    &ireq->ir_v6_rmt_addr);\n\n\t\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\t\tif (np->repflow && ireq->pktopts)\n\t\t\tfl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));\n\n\t\trcu_read_lock();\n\t\topt = ireq->ipv6_opt;\n\t\tif (!opt)\n\t\t\topt = rcu_dereference(np->opt);\n\t\terr = ip6_xmit(sk, skb, fl6, sk->sk_mark, opt, np->tclass);\n\t\trcu_read_unlock();\n\t\terr = net_xmit_eval(err);\n\t}\n\ndone:\n\treturn err;\n}","23820":"static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block)\n{\n    OPJ_UINT32 l_data_size;\n\n    \n    \n    l_data_size = 2 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                                   (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n\n    if (l_data_size > p_code_block->data_size) {\n        if (p_code_block->data) {\n            \n            opj_free(p_code_block->data - 1);\n        }\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n        if (! p_code_block->data) {\n            p_code_block->data_size = 0U;\n            return OPJ_FALSE;\n        }\n        p_code_block->data_size = l_data_size;\n\n        \n        \n        \n        \n        p_code_block->data[0] = 0;\n        p_code_block->data += 1; \n    }\n    return OPJ_TRUE;\n}","23872":"void SSL_SESSION::CopyX509(X509* x)\n{\n    if (x == 0) return;\n\n    X509_NAME* issuer   = x->GetIssuer();\n    X509_NAME* subject  = x->GetSubject();\n    ASN1_STRING* before = x->GetBefore();\n    ASN1_STRING* after  = x->GetAfter();\n\n    peerX509_ = NEW_YS X509(issuer->GetName(), issuer->GetLength(),\n        subject->GetName(), subject->GetLength(), (const char*) before->data,\n        before->length, (const char*) after->data, after->length);\n}","24824":"g_vfs_daemon_finalize (GObject *object)\n{\n  GVfsDaemon *daemon;\n\n  daemon = G_VFS_DAEMON (object);\n\n  \n  if (daemon->jobs)\n    g_warning (\"STR\");\n\n  if (daemon->name_watcher)\n    g_bus_unwatch_name (daemon->name_watcher);\n  \n  if (daemon->daemon_skeleton != NULL)\n    {\n      g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (daemon->daemon_skeleton));\n      g_object_unref (daemon->daemon_skeleton);\n    }\n  if (daemon->mountable_skeleton != NULL)\n    {\n      g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (daemon->mountable_skeleton));\n      g_object_unref (daemon->mountable_skeleton);\n    }\n  if (daemon->conn != NULL)\n    g_object_unref (daemon->conn);\n  \n  g_hash_table_destroy (daemon->registered_paths);\n  g_hash_table_destroy (daemon->client_connections);\n  g_mutex_clear (&daemon->lock);\n\n  if (G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize)\n    (*G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize) (object);\n}","24794":"static int clone_file(const char *from, const char *to,\n                      const char **err_status, int copy_if_rename_fails) {\n    FILE *from_fp = NULL, *to_fp = NULL;\n    char buf[BUFSIZ];\n    size_t len;\n    int result = -1;\n\n    if (rename(from, to) == 0)\n        return 0;\n    if ((errno != EXDEV && errno != EBUSY) || !copy_if_rename_fails) {\n        *err_status = \"STR\";\n        return -1;\n    }\n\n    \n    if (!(from_fp = fopen(from, \"STR\"))) {\n        *err_status = \"STR\";\n        goto done;\n    }\n\n    if (!(to_fp = fopen(to, \"STR\"))) {\n        *err_status = \"STR\";\n        goto done;\n    }\n\n    if (transfer_file_attrs(from, to, err_status) < 0)\n        goto done;\n\n    while ((len = fread(buf, 1, BUFSIZ, from_fp)) > 0) {\n        if (fwrite(buf, 1, len, to_fp) != len) {\n            *err_status = \"STR\";\n            goto done;\n        }\n    }\n    if (ferror(from_fp)) {\n        *err_status = \"STR\";\n        goto done;\n    }\n    if (fflush(to_fp) != 0) {\n        *err_status = \"STR\";\n        goto done;\n    }\n    if (fsync(fileno(to_fp)) < 0) {\n        *err_status = \"STR\";\n        goto done;\n    }\n    result = 0;\n done:\n    if (from_fp != NULL)\n        fclose(from_fp);\n    if (to_fp != NULL && fclose(to_fp) != 0)\n        result = -1;\n    if (result != 0)\n        unlink(to);\n    if (result == 0)\n        unlink(from);\n    return result;\n}","24865":"int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr_storage *address, int mode)\n{\n\tint size, ct, err;\n\n\tif (m->msg_namelen) {\n\t\tif (mode == VERIFY_READ) {\n\t\t\tvoid __user *namep;\n\t\t\tnamep = (void __user __force *) m->msg_name;\n\t\t\terr = move_addr_to_kernel(namep, m->msg_namelen,\n\t\t\t\t\t\t  address);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tm->msg_name = address;\n\t} else {\n\t\tm->msg_name = NULL;\n\t}\n\n\tsize = m->msg_iovlen * sizeof(struct iovec);\n\tif (copy_from_user(iov, (void __user __force *) m->msg_iov, size))\n\t\treturn -EFAULT;\n\n\tm->msg_iov = iov;\n\terr = 0;\n\n\tfor (ct = 0; ct < m->msg_iovlen; ct++) {\n\t\tsize_t len = iov[ct].iov_len;\n\n\t\tif (len > INT_MAX - err) {\n\t\t\tlen = INT_MAX - err;\n\t\t\tiov[ct].iov_len = len;\n\t\t}\n\t\terr += len;\n\t}\n\n\treturn err;\n}","24411":"static size_t read_test_file(char **buffer, char *basename)\n{\n    char *filename;\n    FILE *fp;\n    size_t exp_size, act_size;\n\n    filename = gdTestFilePath2(\"STR\", basename);\n    fp = fopen(filename, \"STR\");\n    gdTestAssert(fp != NULL);\n\n\tfseek(fp, 0, SEEK_END);\n\texp_size = ftell(fp);\n\tfseek(fp, 0, SEEK_SET);\n\n    *buffer = malloc(exp_size);\n    gdTestAssert(*buffer != NULL);\n    act_size = fread(*buffer, sizeof(**buffer), exp_size, fp);\n    gdTestAssert(act_size == exp_size);\n\n    fclose(fp);\n    free(filename);\n\n    return act_size;\n}","24942":"CheckSetDeviceIndicators(char *wire,\n                         DeviceIntPtr dev,\n                         int num, int *status_rtrn, ClientPtr client)\n{\n    xkbDeviceLedsWireDesc *ledWire;\n    int i;\n    XkbSrvLedInfoPtr sli;\n\n    ledWire = (xkbDeviceLedsWireDesc *) wire;\n    for (i = 0; i < num; i++) {\n        if (client->swapped) {\n            swaps(&ledWire->ledClass);\n            swaps(&ledWire->ledID);\n            swapl(&ledWire->namesPresent);\n            swapl(&ledWire->mapsPresent);\n            swapl(&ledWire->physIndicators);\n        }\n\n        sli = XkbFindSrvLedInfo(dev, ledWire->ledClass, ledWire->ledID,\n                                XkbXI_IndicatorsMask);\n        if (sli != NULL) {\n            register int n;\n            register unsigned bit;\n            int nMaps, nNames;\n            CARD32 *atomWire;\n            xkbIndicatorMapWireDesc *mapWire;\n\n            nMaps = nNames = 0;\n            for (n = 0, bit = 1; n < XkbNumIndicators; n++, bit <<= 1) {\n                if (ledWire->namesPresent & bit)\n                    nNames++;\n                if (ledWire->mapsPresent & bit)\n                    nMaps++;\n            }\n            atomWire = (CARD32 *) &ledWire[1];\n            if (nNames > 0) {\n                for (n = 0; n < nNames; n++) {\n                    if (client->swapped) {\n                        swapl(atomWire);\n                    }\n                    CHK_ATOM_OR_NONE3(((Atom) (*atomWire)), client->errorValue,\n                                      *status_rtrn, NULL);\n                    atomWire++;\n                }\n            }\n            mapWire = (xkbIndicatorMapWireDesc *) atomWire;\n            if (nMaps > 0) {\n                for (n = 0; n < nMaps; n++) {\n                    if (client->swapped) {\n                        swaps(&mapWire->virtualMods);\n                        swapl(&mapWire->ctrls);\n                    }\n                    CHK_MASK_LEGAL3(0x21, mapWire->whichGroups,\n                                    XkbIM_UseAnyGroup,\n                                    client->errorValue, *status_rtrn, NULL);\n                    CHK_MASK_LEGAL3(0x22, mapWire->whichMods, XkbIM_UseAnyMods,\n                                    client->errorValue, *status_rtrn, NULL);\n                    mapWire++;\n                }\n            }\n            ledWire = (xkbDeviceLedsWireDesc *) mapWire;\n        }\n        else {\n            \n            return (char *) ledWire;\n        }\n    }\n    return (char *) ledWire;\n}","24534":"    inline bool checkNoWait(int length) { return check(length, 1, false)!=0; }","24421":"crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted)\n{\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        cib_send_tls(session, msg);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        cib_send_plaintext(GPOINTER_TO_INT(session), msg);\n    }\n}","24508":"static void l2cap_chan_destroy(struct kref *kref)\n{\n\tstruct l2cap_chan *chan = container_of(kref, struct l2cap_chan, kref);\n\n\tBT_DBG(\"STR\", chan);\n\n\twrite_lock(&chan_list_lock);\n\tlist_del(&chan->global_l);\n\twrite_unlock(&chan_list_lock);\n\n\tkfree(chan);\n}","24548":"static int rbd_handle_request_lock(struct rbd_device *rbd_dev, u8 struct_v,\n\t\t\t\t   void **p)\n{\n\tstruct rbd_client_id my_cid = rbd_get_cid(rbd_dev);\n\tstruct rbd_client_id cid = { 0 };\n\tint result = 1;\n\n\tif (struct_v >= 2) {\n\t\tcid.gid = ceph_decode_64(p);\n\t\tcid.handle = ceph_decode_64(p);\n\t}\n\n\tdout(\"STR\", __func__, rbd_dev, cid.gid,\n\t     cid.handle);\n\tif (rbd_cid_equal(&cid, &my_cid))\n\t\treturn result;\n\n\tdown_read(&rbd_dev->lock_rwsem);\n\tif (__rbd_is_lock_owner(rbd_dev)) {\n\t\tif (rbd_dev->lock_state == RBD_LOCK_STATE_LOCKED &&\n\t\t    rbd_cid_equal(&rbd_dev->owner_cid, &rbd_empty_cid))\n\t\t\tgoto out_unlock;\n\n\t\t\n\t\tresult = 0;\n\n\t\tif (rbd_dev->lock_state == RBD_LOCK_STATE_LOCKED) {\n\t\t\tif (!rbd_dev->opts->exclusive) {\n\t\t\t\tdout(\"STR\",\n\t\t\t\t     __func__, rbd_dev);\n\t\t\t\tqueue_work(rbd_dev->task_wq,\n\t\t\t\t\t   &rbd_dev->unlock_work);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tresult = -EROFS;\n\t\t\t}\n\t\t}\n\t}\n\nout_unlock:\n\tup_read(&rbd_dev->lock_rwsem);\n\treturn result;\n}","24600":"function_call(int argc, VALUE argv[], VALUE self)\n{\n    struct nogvl_ffi_call_args args = { 0 };\n    fiddle_generic *generic_args;\n    VALUE cfunc, types, cPointer;\n    int i;\n    VALUE alloc_buffer = 0;\n\n    cfunc    = rb_iv_get(self, \"STR\");\n    types    = rb_iv_get(self, \"STR\");\n    cPointer = rb_const_get(mFiddle, rb_intern(\"STR\"));\n\n    Check_Max_Args(\"STR\", argc);\n    if (argc != (i = RARRAY_LENINT(types))) {\n\trb_error_arity(argc, i, i);\n    }\n\n    TypedData_Get_Struct(self, ffi_cif, &function_data_type, args.cif);\n\n    if (rb_safe_level() >= 1) {\n\tfor (i = 0; i < argc; i++) {\n\t    VALUE src = argv[i];\n\t    if (OBJ_TAINTED(src)) {\n\t\trb_raise(rb_eSecurityError, \"STR\");\n\t    }\n\t}\n    }\n\n    generic_args = ALLOCV(alloc_buffer,\n\t(size_t)(argc + 1) * sizeof(void *) + (size_t)argc * sizeof(fiddle_generic));\n    args.values = (void **)((char *)generic_args +\n\t\t\t    (size_t)argc * sizeof(fiddle_generic));\n\n    for (i = 0; i < argc; i++) {\n\tVALUE type = RARRAY_AREF(types, i);\n\tVALUE src = argv[i];\n\n\tif(NUM2INT(type) == TYPE_VOIDP) {\n\t    if(NIL_P(src)) {\n\t\tsrc = INT2FIX(0);\n\t    } else if(cPointer != CLASS_OF(src)) {\n\t\tsrc = rb_funcall(cPointer, rb_intern(\"STR\"), 1, src);\n\t    }\n\t    src = rb_Integer(src);\n\t}\n\n\tVALUE2GENERIC(NUM2INT(type), src, &generic_args[i]);\n\targs.values[i] = (void *)&generic_args[i];\n    }\n    args.values[argc] = NULL;\n    args.fn = NUM2PTR(rb_Integer(cfunc));\n\n    (void)rb_thread_call_without_gvl(nogvl_ffi_call, &args, 0, 0);\n\n    rb_funcall(mFiddle, rb_intern(\"STR\"), 1, INT2NUM(errno));\n#if defined(_WIN32)\n    rb_funcall(mFiddle, rb_intern(\"STR\"), 1, INT2NUM(errno));\n#endif\n\n    ALLOCV_END(alloc_buffer);\n\n    return GENERIC2VALUE(rb_iv_get(self, \"STR\"), args.retval);\n}","24312":"  LEX_STRING *make_lex_string(const char* str, uint length)\n  {\n    LEX_STRING *lex_str;\n    if (!(lex_str= (LEX_STRING *)alloc_root(mem_root, sizeof(LEX_STRING))))\n      return 0;\n    return make_lex_string(lex_str, str, length);\n  }","23882":"void CLASS phase_one_flat_field (int is_float, int nc)\n{\n  ushort head[8];\n  unsigned wide, y, x, c, rend, cend, row, col;\n  float *mrow, num, mult[4];\n\n  read_shorts (head, 8);\n  wide = head[2] \/ head[4];\n  mrow = (float *) calloc (nc*wide, sizeof *mrow);\n  merror (mrow, \"STR\");\n  for (y=0; y < head[3] \/ head[5]; y++) {\n    for (x=0; x < wide; x++)\n      for (c=0; c < nc; c+=2) {\n\tnum = is_float ? getreal(11) : get2()\/32768.0;\n\tif (y==0) mrow[c*wide+x] = num;\n\telse mrow[(c+1)*wide+x] = (num - mrow[c*wide+x]) \/ head[5];\n      }\n    if (y==0) continue;\n    rend = head[1] + y*head[5];\n    for (row = rend-head[5]; row < raw_height && row < rend; row++) {\n      for (x=1; x < wide; x++) {\n\tfor (c=0; c < nc; c+=2) {\n\t  mult[c] = mrow[c*wide+x-1];\n\t  mult[c+1] = (mrow[c*wide+x] - mult[c]) \/ head[4];\n\t}\n\tcend = head[0] + x*head[4];\n\tfor (col = cend-head[4]; col < raw_width && col < cend; col++) {\n\t  c = nc > 2 ? FC(row-top_margin,col-left_margin) : 0;\n\t  if (!(c & 1)) {\n\t    c = RAW(row,col) * mult[c];\n\t    RAW(row,col) = LIM(c,0,65535);\n\t  }\n\t  for (c=0; c < nc; c+=2)\n\t    mult[c] += mult[c+1];\n\t}\n      }\n      for (x=0; x < wide; x++)\n\tfor (c=0; c < nc; c+=2)\n\t  mrow[c*wide+x] += mrow[(c+1)*wide+x];\n    }\n  }\n  free (mrow);\n}","25041":"static void *find_audio_control_unit(struct mixer_build *state,\n\t\t\t\t     unsigned char unit)\n{\n\t\n\tstruct uac_feature_unit_descriptor *hdr = NULL;\n\n\twhile ((hdr = snd_usb_find_desc(state->buffer, state->buflen, hdr,\n\t\t\t\t\tUSB_DT_CS_INTERFACE)) != NULL) {\n\t\tif (hdr->bLength >= 4 &&\n\t\t    hdr->bDescriptorSubtype >= UAC_INPUT_TERMINAL &&\n\t\t    hdr->bDescriptorSubtype <= UAC2_SAMPLE_RATE_CONVERTER &&\n\t\t    hdr->bUnitID == unit)\n\t\t\treturn hdr;\n\t}\n\n\treturn NULL;\n}","24969":"   Returns TRUE if the alrogithm is a block algorithms *\/\nPHP_FUNCTION(mcrypt_enc_is_block_algorithm)\n{\n\tMCRYPT_GET_TD_ARG\n\n\tif (mcrypt_enc_is_block_algorithm(pm->td) == 1) {\n\t\tRETURN_TRUE \n\t} else {\n\t\tRETURN_FALSE\n\t}","23904":"Value ExpressionIndexOfBytes::evaluate(const Document& root, Variables* variables) const {\n    Value stringArg = _children[0]->evaluate(root, variables);\n\n    if (stringArg.nullish()) {\n        return Value(BSONNULL);\n    }\n\n    uassert(40091,\n            str::stream() << \"STR\"\n                          << typeName(stringArg.getType()),\n            stringArg.getType() == String);\n    const std::string& input = stringArg.getString();\n\n    Value tokenArg = _children[1]->evaluate(root, variables);\n    uassert(40092,\n            str::stream() << \"STR\"\n                          << typeName(tokenArg.getType()),\n            tokenArg.getType() == String);\n    const std::string& token = tokenArg.getString();\n\n    size_t startIndex = 0;\n    if (_children.size() > 2) {\n        Value startIndexArg = _children[2]->evaluate(root, variables);\n        uassertIfNotIntegralAndNonNegative(startIndexArg, getOpName(), \"STR\");\n        startIndex = static_cast<size_t>(startIndexArg.coerceToInt());\n    }\n\n    size_t endIndex = input.size();\n    if (_children.size() > 3) {\n        Value endIndexArg = _children[3]->evaluate(root, variables);\n        uassertIfNotIntegralAndNonNegative(endIndexArg, getOpName(), \"STR\");\n        \n        endIndex = std::min(input.size(), static_cast<size_t>(endIndexArg.coerceToInt()));\n    }\n\n    if (startIndex > input.length() || endIndex < startIndex) {\n        return Value(-1);\n    }\n\n    size_t position = input.substr(0, endIndex).find(token, startIndex);\n    if (position == std::string::npos) {\n        return Value(-1);\n    }\n\n    return Value(static_cast<int>(position));\n}","24213":"static int cac_process_ACA(sc_card_t *card, cac_private_data_t *priv)\n{\n\tint r;\n\tu8 *val = NULL;\n\tsize_t val_len;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t\n\tr = cac_get_acr(card, CAC_ACR_SERVICE, &val, &val_len);\n\tif (r < 0)\n\t\tgoto done;\n\n\tr = cac_parse_ACA_service(card, priv, val, val_len);\n        if (r == SC_SUCCESS) {\n\t\tpriv->aca_path = malloc(sizeof(sc_path_t));\n\t\tif (!priv->aca_path) {\n\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto done;\n\t\t}\n\t\tmemcpy(priv->aca_path, &cac_ACA_Path, sizeof(sc_path_t));\n\t}\ndone:\n\tif (val)\n\t\tfree(val);\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, r);\n}","24953":"filesystem_info_state_free (FilesystemInfoState *state)\n{\n\tg_object_unref (state->cancellable);\n\tg_free (state);\n}","24603":"size_t compile_tree(struct filter_op **fop)\n{\n   int i = 1;\n   struct filter_op *array = NULL;\n   struct unfold_elm *ue;\n\n   BUG_IF(tree_root == NULL);\n  \n   fprintf(stdout, \"STR\");\n   fflush(stdout);\n     \n   \n   unfold_blk(&tree_root);\n\n   fprintf(stdout, \"STR\");\n\n   \n   labels_to_offsets();\n   \n   \n   TAILQ_FOREACH(ue, &unfolded_tree, next) {\n\n      \n      if (ue->label == 0) {\n         SAFE_REALLOC(array, i * sizeof(struct filter_op));\n         memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op));\n         i++;\n      }\n   }\n   \n   \n   SAFE_REALLOC(array, i * sizeof(struct filter_op));\n   array[i - 1].opcode = FOP_EXIT;\n   \n   \n   *fop = array;\n   \n   return (i);\n}","24319":"oneright(void)\n{\n    char_u\t*ptr;\n    int\t\tl;\n\n    if (virtual_active())\n    {\n\tpos_T\tprevpos = curwin->w_cursor;\n\n\t\n\tptr = ml_get_cursor();\n\tcoladvance(getviscol() + ((*ptr != TAB\n\t\t\t\t\t  && vim_isprintc((*mb_ptr2char)(ptr)))\n\t\t    ? ptr2cells(ptr) : 1));\n\tcurwin->w_set_curswant = TRUE;\n\t\n\treturn (prevpos.col != curwin->w_cursor.col\n\t\t    || prevpos.coladd != curwin->w_cursor.coladd) ? OK : FAIL;\n    }\n\n    ptr = ml_get_cursor();\n    if (*ptr == NUL)\n\treturn FAIL;\t    \n\n    if (has_mbyte)\n\tl = (*mb_ptr2len)(ptr);\n    else\n\tl = 1;\n\n    \n    \n    if (ptr[l] == NUL && (ve_flags & VE_ONEMORE) == 0)\n\treturn FAIL;\n    curwin->w_cursor.col += l;\n\n    curwin->w_set_curswant = TRUE;\n    return OK;\n}","25060":"static int sr_fake_playtrkind(struct cdrom_device_info *cdi, struct cdrom_ti *ti)\n{\n\tstruct cdrom_tocentry trk0_te, trk1_te;\n\tstruct cdrom_tochdr tochdr;\n\tstruct packet_command cgc;\n\tint ntracks, ret;\n\n\tret = sr_read_tochdr(cdi, &tochdr);\n\tif (ret)\n\t\treturn ret;\n\n\tntracks = tochdr.cdth_trk1 - tochdr.cdth_trk0 + 1;\n\t\n\tif (ti->cdti_trk1 == ntracks) \n\t\tti->cdti_trk1 = CDROM_LEADOUT;\n\telse if (ti->cdti_trk1 != CDROM_LEADOUT)\n\t\tti->cdti_trk1 ++;\n\n\ttrk0_te.cdte_track = ti->cdti_trk0;\n\ttrk0_te.cdte_format = CDROM_MSF;\n\ttrk1_te.cdte_track = ti->cdti_trk1;\n\ttrk1_te.cdte_format = CDROM_MSF;\n\t\n\tret = sr_read_tocentry(cdi, &trk0_te);\n\tif (ret)\n\t\treturn ret;\n\tret = sr_read_tocentry(cdi, &trk1_te);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&cgc, 0, sizeof(struct packet_command));\n\tcgc.cmd[0] = GPCMD_PLAY_AUDIO_MSF;\n\tcgc.cmd[3] = trk0_te.cdte_addr.msf.minute;\n\tcgc.cmd[4] = trk0_te.cdte_addr.msf.second;\n\tcgc.cmd[5] = trk0_te.cdte_addr.msf.frame;\n\tcgc.cmd[6] = trk1_te.cdte_addr.msf.minute;\n\tcgc.cmd[7] = trk1_te.cdte_addr.msf.second;\n\tcgc.cmd[8] = trk1_te.cdte_addr.msf.frame;\n\tcgc.data_direction = DMA_NONE;\n\tcgc.timeout = IOCTL_TIMEOUT;\n\treturn sr_do_ioctl(cdi->handle, &cgc);\n}","24350":"\tstring createErrorPageFromStderrOutput(const string &msg,\n\t\tSpawnException::ErrorKind errorKind,\n\t\tconst string &stderrOutput)\n\t{\n\t\t\n\t\tassert(errorKind != SpawnException::PRELOADER_STARTUP_EXPLAINABLE_ERROR);\n\t\tassert(errorKind != SpawnException::APP_STARTUP_EXPLAINABLE_ERROR);\n\n\t\tstring result = escapeHTML(msg);\n\n\t\tif (errorKind == SpawnException::PRELOADER_STARTUP_TIMEOUT\n\t\t || errorKind == SpawnException::APP_STARTUP_TIMEOUT\n\t\t || errorKind == SpawnException::PRELOADER_STARTUP_ERROR\n\t\t || errorKind == SpawnException::APP_STARTUP_ERROR)\n\t\t{\n\t\t\tresult.append(\"STR\"\n\t\t\t\t\"STR\");\n\t\t}\n\t\tresult.append(\"STR\");\n\n\t\tif (strip(stderrOutput).empty()) {\n\t\t\tresult.append(\"STR\");\n\t\t} else {\n\t\t\tresult.append(\"STR\");\n\t\t\tresult.append(escapeHTML(stderrOutput));\n\t\t\tresult.append(\"STR\");\n\t\t}\n\n\t\treturn result;\n\t}","23827":"char *clock(char *buf, char *end, struct clk *clk, struct printf_spec spec,\n\t    const char *fmt)\n{\n\tif (!IS_ENABLED(CONFIG_HAVE_CLK) || !clk)\n\t\treturn string(buf, end, NULL, spec);\n\n\tswitch (fmt[1]) {\n\tcase 'r':\n\t\treturn number(buf, end, clk_get_rate(clk), spec);\n\n\tcase 'n':\n\tdefault:\n#ifdef CONFIG_COMMON_CLK\n\t\treturn string(buf, end, __clk_get_name(clk), spec);\n#else\n\t\treturn special_hex_number(buf, end, (unsigned long)clk, sizeof(unsigned long));\n#endif\n\t}\n}","24979":"usm_free_usmStateReference(void *old)\n{\n    struct usmStateReference *old_ref = (struct usmStateReference *) old;\n\n    if (old_ref) {\n\n        if (old_ref->usr_name_length)\n            SNMP_FREE(old_ref->usr_name);\n        if (old_ref->usr_engine_id_length)\n            SNMP_FREE(old_ref->usr_engine_id);\n        if (old_ref->usr_auth_protocol_length)\n            SNMP_FREE(old_ref->usr_auth_protocol);\n        if (old_ref->usr_priv_protocol_length)\n            SNMP_FREE(old_ref->usr_priv_protocol);\n\n        if (old_ref->usr_auth_key_length && old_ref->usr_auth_key) {\n            SNMP_ZERO(old_ref->usr_auth_key, old_ref->usr_auth_key_length);\n            SNMP_FREE(old_ref->usr_auth_key);\n        }\n        if (old_ref->usr_priv_key_length && old_ref->usr_priv_key) {\n            SNMP_ZERO(old_ref->usr_priv_key, old_ref->usr_priv_key_length);\n            SNMP_FREE(old_ref->usr_priv_key);\n        }\n\n        SNMP_ZERO(old_ref, sizeof(*old_ref));\n        SNMP_FREE(old_ref);\n\n    }\n\n}                               ","23939":"rb_str_buf_cat(str, ptr, len)\n    VALUE str;\n    const char *ptr;\n    long len;\n{\n    long capa, total;\n\n    if (len == 0) return str;\n    if (len < 0) {\n\trb_raise(rb_eArgError, \"STR\");\n    }\n    rb_str_modify(str);\n    if (FL_TEST(str, STR_ASSOC)) {\n\tFL_UNSET(str, STR_ASSOC);\n\tcapa = RSTRING(str)->aux.capa = RSTRING(str)->len;\n    }\n    else {\n\tcapa = RSTRING(str)->aux.capa;\n    }\n    total = RSTRING(str)->len+len;\n    if (capa <= total) {\n\twhile (total > capa) {\n\t    capa = (capa + 1) * 2;\n\t}\n\tRESIZE_CAPA(str, capa);\n    }\n    memcpy(RSTRING(str)->ptr + RSTRING(str)->len, ptr, len);\n    RSTRING(str)->len = total;\n    RSTRING(str)->ptr[total] = '\\0'; \n\n    return str;\n}","24409":"do_execstack(i_ctx_t *i_ctx_p, bool include_marks, os_ptr op1)\n{\n    os_ptr op = osp;\n    ref *arefs = op1->value.refs;\n    uint asize = r_size(op1);\n    uint i;\n    ref *rq;\n\n    \n    for (i = 0, rq = arefs + asize; rq != arefs; ++i) {\n        const ref *rp = ref_stack_index(&e_stack, (long)i);\n\n        if (r_has_type_attrs(rp, t_null, a_executable) && !include_marks)\n            continue;\n        --rq;\n        ref_assign_old(op1, rq, rp, \"STR\");\n        switch (r_type(rq)) {\n            case t_operator: {\n                uint opidx = op_index(rq);\n\n                if (opidx == 0 || op_def_is_internal(op_index_def(opidx)))\n                    r_clear_attrs(rq, a_executable);\n                break;\n            }\n            case t_struct:\n            case t_astruct: {\n                const char *tname = rq->value.pstruct ?\n                    gs_struct_type_name_string(\n                                gs_object_type(imemory, rq->value.pstruct))\n                    : \"STR\";\n\n                make_const_string(rq, a_readonly | avm_foreign,\n                                  strlen(tname), (const byte *)tname);\n                break;\n            }\n            default:\n                ;\n        }\n    }\n    pop(op - op1);\n    return 0;\n}","24628":"static void basic_globals_ctor(php_basic_globals *basic_globals_p TSRMLS_DC) \n{\n\tBG(rand_is_seeded) = 0;\n\tBG(mt_rand_is_seeded) = 0;\n\tBG(umask) = -1;\n\tBG(next) = NULL;\n\tBG(left) = -1;\n\tBG(user_tick_functions) = NULL;\n\tBG(user_filter_map) = NULL;\n\tBG(serialize_lock) = 0;\n\t\n\tmemset(&BG(serialize), 0, sizeof(BG(serialize)));\n\tmemset(&BG(unserialize), 0, sizeof(BG(unserialize)));\n\n\tmemset(&BG(url_adapt_state_ex), 0, sizeof(BG(url_adapt_state_ex)));\n\n#if defined(_REENTRANT) && defined(HAVE_MBRLEN) && defined(HAVE_MBSTATE_T)\n\tmemset(&BG(mblen_state), 0, sizeof(BG(mblen_state)));\n#endif\n\n\tBG(incomplete_class) = incomplete_class_entry;\n\tBG(page_uid) = -1;\n\tBG(page_gid) = -1;\n}","24205":"static void SFDGetSpiros(FILE *sfd,SplineSet *cur) {\n    int ch;\n    spiro_cp cp;\n\n    ch = nlgetc(sfd);\t\t\n    ch = nlgetc(sfd);\t\t\n    ch = nlgetc(sfd);\t\t\n    ch = nlgetc(sfd);\t\t\n    ch = nlgetc(sfd);\t\t\n    while ( fscanf(sfd,\"STR\", &cp.x, &cp.y, &cp.ty )==3 ) {\n\tif ( cur!=NULL ) {\n\t    if ( cur->spiro_cnt>=cur->spiro_max )\n\t\tcur->spiros = realloc(cur->spiros,(cur->spiro_max+=10)*sizeof(spiro_cp));\n\t    cur->spiros[cur->spiro_cnt++] = cp;\n\t}\n    }\n    if ( cur!=NULL && (cur->spiros[cur->spiro_cnt-1].ty&0x7f)!=SPIRO_END ) {\n\tif ( cur->spiro_cnt>=cur->spiro_max )\n\t    cur->spiros = realloc(cur->spiros,(cur->spiro_max+=1)*sizeof(spiro_cp));\n\tmemset(&cur->spiros[cur->spiro_cnt],0,sizeof(spiro_cp));\n\tcur->spiros[cur->spiro_cnt++].ty = SPIRO_END;\n    }\n    ch = nlgetc(sfd);\n    if ( ch=='E' ) {\n\tch = nlgetc(sfd);\t\t\n\tch = nlgetc(sfd);\t\t\n\tch = nlgetc(sfd);\t\t\n\tch = nlgetc(sfd);\t\t\n\tch = nlgetc(sfd);\t\t\n\tch = nlgetc(sfd);\t\t\n\tch = nlgetc(sfd);\t\t\n    } else\n\tungetc(ch,sfd);\n}","24112":"PHP_FUNCTION(curl_escape)\n{\n\tchar       *str = NULL, *res = NULL;\n\tint        str_len = 0;\n\tzval       *zid;\n\tphp_curl   *ch;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"STR\", &zid, &str, &str_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(ch, php_curl *, &zid, -1, le_curl_name, le_curl);\n\n\tif ((res = curl_easy_escape(ch->cp, str, str_len))) {\n\t\tRETVAL_STRING(res, 1);\n\t\tcurl_free(res);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}","24875":"read_and_discard_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)\n{\n  JDIMENSION n;\n  my_master_ptr master = (my_master_ptr)cinfo->master;\n  JSAMPARRAY scanlines = NULL;\n  void (*color_convert) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                         JDIMENSION input_row, JSAMPARRAY output_buf,\n                         int num_rows) = NULL;\n  void (*color_quantize) (j_decompress_ptr cinfo, JSAMPARRAY input_buf,\n                          JSAMPARRAY output_buf, int num_rows) = NULL;\n\n  if (cinfo->cconvert && cinfo->cconvert->color_convert) {\n    color_convert = cinfo->cconvert->color_convert;\n    cinfo->cconvert->color_convert = noop_convert;\n  }\n\n  if (cinfo->cquantize && cinfo->cquantize->color_quantize) {\n    color_quantize = cinfo->cquantize->color_quantize;\n    cinfo->cquantize->color_quantize = noop_quantize;\n  }\n\n  if (master->using_merged_upsample && cinfo->max_v_samp_factor == 2) {\n    my_merged_upsample_ptr upsample = (my_merged_upsample_ptr)cinfo->upsample;\n    scanlines = &upsample->spare_row;\n  }\n\n  for (n = 0; n < num_lines; n++)\n    jpeg_read_scanlines(cinfo, scanlines, 1);\n\n  if (color_convert)\n    cinfo->cconvert->color_convert = color_convert;\n\n  if (color_quantize)\n    cinfo->cquantize->color_quantize = color_quantize;\n}","24568":"  base::WeakPtr<ElectronBrowserHandlerImpl> GetWeakPtr() {\n    return weak_factory_.GetWeakPtr();\n  }","23892":"static void nft_chain_release_hook(struct nft_chain_hook *hook)\n{\n\tstruct nft_hook *h, *next;\n\n\tlist_for_each_entry_safe(h, next, &hook->list, list) {\n\t\tlist_del(&h->list);\n\t\tkfree(h);\n\t}\n\tmodule_put(hook->type->owner);\n}","24733":"MagickExport char **GetDelegateList(const char *pattern,\n  size_t *number_delegates,ExceptionInfo *exception)\n{\n  char\n    **delegates;\n\n  register const DelegateInfo\n    *p;\n\n  register ssize_t\n    i;\n\n  \n  assert(pattern != (char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"STR\",pattern);\n\n  assert(number_delegates != (size_t *) NULL);\n  *number_delegates=0;\n  p=GetDelegateInfo(\"STR\",exception);\n  if (p == (const DelegateInfo *) NULL)\n    return((char **) NULL);\n  delegates=(char **) AcquireQuantumMemory((size_t)\n    GetNumberOfElementsInLinkedList(delegate_cache)+1UL,sizeof(*delegates));\n  if (delegates == (char **) NULL)\n    return((char **) NULL);\n  LockSemaphoreInfo(delegate_semaphore);\n  ResetLinkedListIterator(delegate_cache);\n  p=(const DelegateInfo *) GetNextValueInLinkedList(delegate_cache);\n  for (i=0; p != (const DelegateInfo *) NULL; )\n  {\n    if( (p->stealth == MagickFalse) &&\n        GlobExpression(p->decode,pattern,MagickFalse) != MagickFalse )\n      delegates[i++]=ConstantString(p->decode);\n    if( (p->stealth == MagickFalse) &&\n        GlobExpression(p->encode,pattern,MagickFalse) != MagickFalse )\n      delegates[i++]=ConstantString(p->encode);\n    p=(const DelegateInfo *) GetNextValueInLinkedList(delegate_cache);\n  }\n  UnlockSemaphoreInfo(delegate_semaphore);\n  qsort((void *) delegates,(size_t) i,sizeof(*delegates),DelegateCompare);\n  delegates[i]=(char *) NULL;\n  *number_delegates=(size_t) i;\n  return(delegates);\n}","24708":"bool Scanner::fill(size_t need)\n{\n    if (eof) return false;\n\n    pop_finished_files();\n\n    DASSERT(bot <= tok && tok <= lim);\n    size_t free = static_cast<size_t>(tok - bot);\n    size_t copy = static_cast<size_t>(lim - tok);\n\n    if (free >= need) {\n        memmove(bot, tok, copy);\n        shift_ptrs_and_fpos(-static_cast<ptrdiff_t>(free));\n    }\n    else {\n        BSIZE += std::max(BSIZE, need);\n        char * buf = new char[BSIZE + YYMAXFILL];\n        if (!buf) fatal(\"STR\");\n\n        memmove(buf, tok, copy);\n        shift_ptrs_and_fpos(buf - bot);\n        delete [] bot;\n        bot = buf;\n\n        free = BSIZE - copy;\n    }\n\n    if (!read(free)) {\n        eof = lim;\n        memset(lim, 0, YYMAXFILL);\n        lim += YYMAXFILL;\n    }\n\n    return true;\n}","24949":"static inline int rtnetlink_fill_iwinfo(struct sk_buff *\tskb,\n\t\t\t\t\tstruct net_device *\tdev,\n\t\t\t\t\tint\t\t\ttype,\n\t\t\t\t\tchar *\t\t\tevent,\n\t\t\t\t\tint\t\t\tevent_len)\n{\n\tstruct ifinfomsg *r;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\n\tnlh = NLMSG_PUT(skb, 0, 0, type, sizeof(*r));\n\tr = NLMSG_DATA(nlh);\n\tr->ifi_family = AF_UNSPEC;\n\tr->ifi_type = dev->type;\n\tr->ifi_index = dev->ifindex;\n\tr->ifi_flags = dev->flags;\n\tr->ifi_change = 0;\t\n\n\t\n\tRTA_PUT(skb, IFLA_WIRELESS,\n\t\tevent_len, event);\n\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\n\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}","24884":"static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\t\n\tpmd_t pmdval = *pmd;\n\t\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}","24959":"  Item_string_ascii(THD *thd, const char *str, uint length):\n    Item_string(thd, str, length, &my_charset_latin1,\n                DERIVATION_COERCIBLE, MY_REPERTOIRE_ASCII)\n  { }","24135":"parser_tagged_template_literal_append_strings (parser_context_t *context_p, \n                                               ecma_object_t *template_obj_p, \n                                               ecma_object_t *raw_strings_p, \n                                               uint32_t prop_idx) \n{\n  lexer_lit_location_t *lit_loc_p = &context_p->token.lit_location;\n\n  if (lit_loc_p->length == 0 && !(lit_loc_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE))\n  {\n    ecma_builtin_helper_def_prop_by_index (template_obj_p,\n                                           prop_idx,\n                                           ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY),\n                                           ECMA_PROPERTY_FLAG_ENUMERABLE);\n\n    ecma_builtin_helper_def_prop_by_index (raw_strings_p,\n                                           prop_idx,\n                                           ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY),\n                                           ECMA_PROPERTY_FLAG_ENUMERABLE);\n    return;\n  }\n\n  uint8_t local_byte_array[LEXER_MAX_LITERAL_LOCAL_BUFFER_SIZE];\n  const uint8_t *source_p = lexer_convert_literal_to_chars (context_p,\n                                                            &context_p->token.lit_location,\n                                                            local_byte_array,\n                                                            LEXER_STRING_NO_OPTS);\n\n  ecma_string_t *raw_str_p;\n  ecma_string_t *cooked_str_p = ((lit_loc_p->status_flags & LEXER_FLAG_ASCII)\n                                  ? ecma_new_ecma_string_from_ascii (source_p, lit_loc_p->length)\n                                  : ecma_new_ecma_string_from_utf8 (source_p, lit_loc_p->length));\n\n  parser_free_allocated_buffer (context_p);\n\n  if (lit_loc_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)\n  {\n    context_p->source_p = context_p->token.lit_location.char_p - 1;\n    lexer_parse_string (context_p, LEXER_STRING_RAW);\n    source_p = lexer_convert_literal_to_chars (context_p,\n                                               &context_p->token.lit_location,\n                                               local_byte_array,\n                                               LEXER_STRING_RAW);\n\n    raw_str_p = ((lit_loc_p->status_flags & LEXER_FLAG_ASCII)\n                  ? ecma_new_ecma_string_from_ascii (source_p, lit_loc_p->length)\n                  : ecma_new_ecma_string_from_utf8 (source_p, lit_loc_p->length));\n\n    parser_free_allocated_buffer (context_p);\n  }\n  else\n  {\n    ecma_ref_ecma_string (cooked_str_p);\n    raw_str_p = cooked_str_p;\n  }\n\n  ecma_builtin_helper_def_prop_by_index (template_obj_p,\n                                         prop_idx,\n                                         ecma_make_string_value (cooked_str_p),\n                                         ECMA_PROPERTY_FLAG_ENUMERABLE);\n\n  ecma_builtin_helper_def_prop_by_index (raw_strings_p,\n                                         prop_idx,\n                                         ecma_make_string_value (raw_str_p),\n                                         ECMA_PROPERTY_FLAG_ENUMERABLE);\n\n  ecma_deref_ecma_string (cooked_str_p);\n  ecma_deref_ecma_string (raw_str_p);\n} ","25017":"big5_is_allowed_reverse_match(const UChar* s, const UChar* end ARG_UNUSED)\n{\n  const UChar c = *s;\n\n  return (BIG5_ISMB_TRAIL(c) ? FALSE : TRUE);\n}","23835":"static struct btrfs_device *find_device(struct btrfs_fs_devices *fs_devices,\n\t\tu64 devid, const u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}","24965":"PicklerMemoProxy_dealloc(PicklerMemoProxyObject *self)\n{\n    PyObject_GC_UnTrack(self);\n    Py_XDECREF(self->pickler);\n    PyObject_GC_Del((PyObject *)self);\n}","24819":"static int ZEND_FASTCALL  ZEND_SR_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tzend_op *opline = EX(opline);\n\tzend_free_op free_op2;\n\n\tshift_right_function(&EX_T(opline->result.u.var).tmp_var,\n\t\t_get_zval_ptr_cv(&opline->op1, EX(Ts), BP_VAR_R TSRMLS_CC),\n\t\t_get_zval_ptr_tmp(&opline->op2, EX(Ts), &free_op2 TSRMLS_CC) TSRMLS_CC);\n\n\tzval_dtor(free_op2.var);\n\tZEND_VM_NEXT_OPCODE();\n}","24222":"static int rsa_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)\n{\n    unsigned char *rk = NULL;\n    int rklen;\n    rklen = i2d_RSAPrivateKey(pkey->pkey.rsa, &rk);\n\n    if (rklen <= 0) {\n        RSAerr(RSA_F_RSA_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    if (!PKCS8_pkey_set0(p8, OBJ_nid2obj(NID_rsaEncryption), 0,\n                         V_ASN1_NULL, NULL, rk, rklen)) {\n        RSAerr(RSA_F_RSA_PRIV_ENCODE, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    return 1;\n}","24262":"static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,\n\t\t\t      struct dentry *dentry, struct path *lowerpath,\n\t\t\t      struct kstat *stat, struct iattr *attr,\n\t\t\t      const char *link)\n{\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry = NULL;\n\tstruct dentry *upper = NULL;\n\tumode_t mode = stat->mode;\n\tint err;\n\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out;\n\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out1;\n\n\t\n\tstat->mode &= S_IFMT;\n\terr = ovl_create_real(wdir, newdentry, stat, link, NULL, true);\n\tstat->mode = mode;\n\tif (err)\n\t\tgoto out2;\n\n\tif (S_ISREG(stat->mode)) {\n\t\tstruct path upperpath;\n\t\tovl_path_upper(dentry, &upperpath);\n\t\tBUG_ON(upperpath.dentry != NULL);\n\t\tupperpath.dentry = newdentry;\n\n\t\terr = ovl_copy_up_data(lowerpath, &upperpath, stat->size);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\n\terr = ovl_copy_xattr(lowerpath->dentry, newdentry);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tmutex_lock(&newdentry->d_inode->i_mutex);\n\terr = ovl_set_attr(newdentry, stat);\n\tif (!err && attr)\n\t\terr = notify_change(newdentry, attr, NULL);\n\tmutex_unlock(&newdentry->d_inode->i_mutex);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\tif (err)\n\t\tgoto out_cleanup;\n\n\tovl_dentry_update(dentry, newdentry);\n\tnewdentry = NULL;\n\n\t\n\tif (!S_ISDIR(stat->mode))\n\t\tovl_dentry_set_opaque(dentry, true);\nout2:\n\tdput(upper);\nout1:\n\tdput(newdentry);\nout:\n\treturn err;\n\nout_cleanup:\n\tovl_cleanup(wdir, newdentry);\n\tgoto out;\n}","24483":"static bool bad_domain(const char *domain)\n{\n  return !strchr(domain, '.') && !strcasecompare(domain, \"STR\");\n}","23946":"hugetlb_vmdelete_list(struct rb_root *root, pgoff_t start, pgoff_t end)\n{\n\tstruct vm_area_struct *vma;\n\n\t\n\tvma_interval_tree_foreach(vma, root, start, end ? end : ULONG_MAX) {\n\t\tunsigned long v_offset;\n\n\t\t\n\t\tif (vma->vm_pgoff < start)\n\t\t\tv_offset = (start - vma->vm_pgoff) << PAGE_SHIFT;\n\t\telse\n\t\t\tv_offset = 0;\n\n\t\tif (end) {\n\t\t\tend = ((end - start) << PAGE_SHIFT) +\n\t\t\t       vma->vm_start + v_offset;\n\t\t\tif (end > vma->vm_end)\n\t\t\t\tend = vma->vm_end;\n\t\t} else\n\t\t\tend = vma->vm_end;\n\n\t\tunmap_hugepage_range(vma, vma->vm_start + v_offset, end, NULL);\n\t}\n}","24164":"build_insert_string(void)\n{\n  char       buf[HUGE_STRING_LENGTH];\n  unsigned int        col_count;\n  statement *ptr;\n  DYNAMIC_STRING insert_string;\n  DBUG_ENTER(\"STR\");\n\n  init_dynamic_string(&insert_string, \"\", 1024, 1024);\n\n  dynstr_append(&insert_string, \"STR\");\n\n  if (auto_generate_sql_autoincrement)\n  {\n    dynstr_append(&insert_string, \"STR\");\n\n    if (num_int_cols || num_char_cols)\n      dynstr_append(&insert_string, \"STR\");\n  }\n\n  if (auto_generate_sql_guid_primary)\n  {\n    dynstr_append(&insert_string, \"STR\");\n\n    if (num_int_cols || num_char_cols)\n      dynstr_append(&insert_string, \"STR\");\n  }\n\n  if (auto_generate_sql_secondary_indexes)\n  {\n    unsigned int count;\n\n    for (count= 0; count < auto_generate_sql_secondary_indexes; count++)\n    {\n      if (count) \n        dynstr_append(&insert_string, \"STR\");\n\n      dynstr_append(&insert_string, \"STR\");\n    }\n\n    if (num_int_cols || num_char_cols)\n      dynstr_append(&insert_string, \"STR\");\n  }\n\n  if (num_int_cols)\n    for (col_count= 1; col_count <= num_int_cols; col_count++)\n    {\n      if (snprintf(buf, HUGE_STRING_LENGTH, \"STR\", random()) > HUGE_STRING_LENGTH)\n      {\n        fprintf(stderr, \"STR\");\n        exit(1);\n      }\n      dynstr_append(&insert_string, buf);\n\n      if (col_count < num_int_cols || num_char_cols > 0)\n        dynstr_append_mem(&insert_string, \"STR\", 1);\n    }\n\n  if (num_char_cols)\n    for (col_count= 1; col_count <= num_char_cols; col_count++)\n    {\n      int buf_len= get_random_string(buf);\n      dynstr_append_mem(&insert_string, \"STR\", 1);\n      dynstr_append_mem(&insert_string, buf, buf_len);\n      dynstr_append_mem(&insert_string, \"STR\", 1);\n\n      if (col_count < num_char_cols)\n        dynstr_append_mem(&insert_string, \"STR\", 1);\n    }\n\n  dynstr_append_mem(&insert_string, \"STR\", 1);\n\n  ptr= (statement *)my_malloc(PSI_NOT_INSTRUMENTED,\n                              sizeof(statement),\n                              MYF(MY_ZEROFILL|MY_FAE|MY_WME));\n  ptr->string= (char *)my_malloc(PSI_NOT_INSTRUMENTED,\n                                 insert_string.length + 1,\n                              MYF(MY_ZEROFILL|MY_FAE|MY_WME));\n  ptr->length= insert_string.length+1;\n  ptr->type= INSERT_TYPE;\n  my_stpcpy(ptr->string, insert_string.str);\n  dynstr_free(&insert_string);\n  DBUG_RETURN(ptr);\n}","23947":"void ProtocolV2::connect() {\n  ldout(cct, 1) << __func__ << dendl;\n  state = START_CONNECT;\n  pre_auth.enabled = true;\n}","23836":"int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g) {\n    if(!p || !g) \n        return 0;\n    BN_free(dh->p);\n    BN_free(dh->q);\n    BN_free(dh->g);\n    dh->p = p;\n    dh->q = q;\n    dh->g = g;\n    if(q)\n        dh->length = BN_num_bits(q);\n    return 1;\n}","24396":"void fileblobPartialSet(fileblob *fb, const char *fullname, const char *arg)\n{\n    UNUSEDPARAM(arg);\n\n    if (fb->b.name)\n        return;\n\n    assert(fullname != NULL);\n\n    cli_dbgmsg(\"STR\", fullname);\n\n    fb->fd = open(fullname, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY | O_EXCL, 0600);\n    if (fb->fd < 0) {\n        cli_errmsg(\"STR\", fullname);\n        return;\n    }\n    fb->fp = fdopen(fb->fd, \"STR\");\n\n    if (fb->fp == NULL) {\n        cli_errmsg(\"STR\");\n        close(fb->fd);\n        return;\n    }\n    blobSetFilename(&fb->b, fb->ctx ? fb->ctx->engine->tmpdir : NULL, fullname);\n    if (fb->b.data)\n        if (fileblobAddData(fb, fb->b.data, fb->b.len) == 0) {\n            free(fb->b.data);\n            fb->b.data = NULL;\n            fb->b.len = fb->b.size = 0;\n            fb->isNotEmpty         = 1;\n        }\n    fb->fullname = cli_strdup(fullname);\n}","24703":"context_length_arg (char const *str, int *out)\n{\n  uintmax_t value;\n  if (! (xstrtoumax (str, 0, 10, &value, \"\") == LONGINT_OK\n         && 0 <= (*out = value)\n         && *out == value))\n    {\n      error (EXIT_TROUBLE, 0, \"STR\", str,\n             _(\"STR\"));\n    }\n}","24437":"void IDLParserErrorContext::appendGenericCommandArguments(\n    const BSONObj& commandPassthroughFields,\n    const std::vector<StringData>& knownFields,\n    BSONObjBuilder* builder) {\n\n    for (const auto& element : commandPassthroughFields) {\n\n        StringData name = element.fieldNameStringData();\n        \n        if (Command::isGenericArgument(name) &&\n            std::find(knownFields.begin(), knownFields.end(), name) == knownFields.end()) {\n            builder->append(element);\n        }\n    }\n}","24535":"static ScreenCell *realloc_buffer(VTermScreen *screen, ScreenCell *buffer, int new_rows, int new_cols)\n{\n  ScreenCell *new_buffer = vterm_allocator_malloc(screen->vt, sizeof(ScreenCell) * new_rows * new_cols);\n  int row, col;\n\n  for(row = 0; row < new_rows; row++) {\n    for(col = 0; col < new_cols; col++) {\n      ScreenCell *new_cell = new_buffer + row*new_cols + col;\n\n      if(buffer && row < screen->rows && col < screen->cols)\n        *new_cell = buffer[row * screen->cols + col];\n      else {\n        new_cell->chars[0] = 0;\n        new_cell->pen = screen->pen;\n      }\n    }\n  }\n\n  if(buffer)\n    vterm_allocator_free(screen->vt, buffer);\n\n  return new_buffer;\n}","24111":"static void handle_PASS(ctrl_t *ctrl, char *pass)\n{\n\tif (!ctrl->name[0]) {\n\t\tsend_msg(ctrl->sd, \"STR\");\n\t\treturn;\n\t}\n\n\tstrlcpy(ctrl->pass, pass, sizeof(ctrl->pass));\n\tif (check_user_pass(ctrl) < 0) {\n\t\tLOG(\"STR\", ctrl->name, ctrl->clientaddr);\n\t\tsend_msg(ctrl->sd, \"STR\");\n\t\treturn;\n\t}\n\n\tINFO(\"STR\", ctrl->name, ctrl->clientaddr);\n\tsend_msg(ctrl->sd, \"STR\");\n}","24113":"write_vector_int(BitWriter& w, int nitems, std::vector<T>& vec,\n\t\t int bits, int_type T::*field)\n{\n    \n    \n\n    for (int i = 0; i < nitems; ++i)\n    {\n\tw.writeBits(vec.at(i).*field, bits);\n    }\n    \n    \n    w.flush();\n}","24999":"do_trustkey(\n\tsockaddr_u *srcadr,\n\tendpt *inter,\n\tstruct req_pkt *inpkt,\n\tu_long trust\n\t)\n{\n\tregister u_long *kp;\n\tregister int items;\n\n\titems = INFO_NITEMS(inpkt->err_nitems);\n\tkp = (u_long *)&inpkt->u;\n\twhile (items-- > 0) {\n\t\tauthtrust(*kp, trust);\n\t\tkp++;\n\t}\n\n\treq_ack(srcadr, inter, inpkt, INFO_OKAY);\n}","23858":"static int crt_to_pubkey(const gnutls_datum_t *raw_crt, gnutls_datum_t * out)\n{\ngnutls_pubkey_t pub = NULL;\ngnutls_x509_crt_t crt = NULL;\nint ret;\n\n\tout->data = NULL;\n\n\tret = gnutls_x509_crt_init(&crt);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(DANE_E_PUBKEY_ERROR);\n\n\tret = gnutls_pubkey_init( &pub);\n\tif (ret < 0) {\n\t        gnutls_assert();\n\t\tret = DANE_E_PUBKEY_ERROR;\n\t\tgoto cleanup;\n\t}\n\t\t\n\tret = gnutls_x509_crt_import(crt, raw_crt, GNUTLS_X509_FMT_DER);\n\tif (ret < 0) {\n\t        gnutls_assert();\n\t\tret = DANE_E_PUBKEY_ERROR;\n\t\tgoto cleanup;\n\t}\n\n\tret = gnutls_pubkey_import_x509(pub, crt, 0);\n\tif (ret < 0) {\n\t        gnutls_assert();\n\t\tret = DANE_E_PUBKEY_ERROR;\n\t\tgoto cleanup;\n\t}\n\n\tret = gnutls_pubkey_export2(pub, GNUTLS_X509_FMT_DER, out);\n\tif (ret < 0) {\n\t        gnutls_assert();\n\t\tret = DANE_E_PUBKEY_ERROR;\n\t\tgoto cleanup;\n\t}\n\t\n\tret = 0;\n\tgoto clean_certs;\n\ncleanup:\n\tfree(out->data);\n\tout->data = NULL;\nclean_certs:\n\tif (pub)\n\t\tgnutls_pubkey_deinit(pub);\n\tif (crt)\n\t\tgnutls_x509_crt_deinit(crt);\n\n\treturn ret;\n}","24662":"  void print_point_impl(std::ostream& out, const CGAL::Point_3<R>& p) {\n    out << p;\n  }","24807":"TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                        int index) {\n  if (context->tensors != nullptr) {\n    return &context->tensors[node->outputs->data[index]];\n  } else {\n    return context->GetTensor(context, node->outputs->data[index]);\n  }\n}","24543":"_rsa_blind (const struct rsa_public_key *pub,\n\t    void *random_ctx, nettle_random_func *random,\n\t    mpz_t c, mpz_t ri)\n{\n  mpz_t r;\n\n  mpz_init(r);\n\n  \n  do \n    {\n      nettle_mpz_random(r, random_ctx, random, pub->n);\n      \n    }\n  while (!mpz_invert (ri, r, pub->n));\n\n  \n  mpz_powm(r, r, pub->e, pub->n);\n  mpz_mul(c, c, r);\n  mpz_fdiv_r(c, c, pub->n);\n\n  mpz_clear(r);\n}","25003":"int main()\n{\n    gdImagePtr im;\n    char *buffer;\n    size_t size;\n\n    size = read_test_file(&buffer, \"STR\");\n    im = gdImageCreateFromTgaPtr(size, (void *) buffer);\n    gdTestAssert(im == NULL);\n    free(buffer);\n\n    return gdNumFailures();\n}","24827":"int WriteNamedColorCRD(cmsIOHANDLER* m, cmsHPROFILE hNamedColor, cmsUInt32Number Intent, cmsUInt32Number dwFlags)\n{\n    cmsHTRANSFORM xform;\n    cmsUInt32Number i, nColors, nColorant;\n    cmsUInt32Number OutputFormat;\n    char ColorName[cmsMAX_PATH];\n    char Colorant[128];\n    cmsNAMEDCOLORLIST* NamedColorList;\n\n\n    OutputFormat = cmsFormatterForColorspaceOfProfile(hNamedColor, 2, FALSE);\n    nColorant    = T_CHANNELS(OutputFormat);\n\n\n    xform = cmsCreateTransform(hNamedColor, TYPE_NAMED_COLOR_INDEX, NULL, OutputFormat, Intent, dwFlags);\n    if (xform == NULL) return 0;\n\n\n    NamedColorList = cmsGetNamedColorList(xform);\n    if (NamedColorList == NULL) return 0;\n\n    _cmsIOPrintf(m, \"STR\");\n    _cmsIOPrintf(m, \"STR\");\n    _cmsIOPrintf(m, \"STR\");\n    _cmsIOPrintf(m, \"STR\");\n\n    nColors   = cmsNamedColorCount(NamedColorList);\n\n    for (i=0; i < nColors; i++) {\n\n        cmsUInt16Number In[1];\n        cmsUInt16Number Out[cmsMAXCHANNELS];\n\n        In[0] = (cmsUInt16Number) i;\n\n        if (!cmsNamedColorInfo(NamedColorList, i, ColorName, NULL, NULL, NULL, NULL))\n                continue;\n\n        cmsDoTransform(xform, In, Out, 1);\n        BuildColorantList(Colorant, nColorant, Out);\n        _cmsIOPrintf(m, \"STR\", ColorName, Colorant);\n    }\n\n    _cmsIOPrintf(m, \"STR\");\n\n    if (!(dwFlags & cmsFLAGS_NODEFAULTRESOURCEDEF)) {\n\n    _cmsIOPrintf(m, \"STR\");\n    }\n\n    cmsDeleteTransform(xform);\n    return 1;\n}","24002":"static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\n\txfrm_probe_algs();\n\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\n\t\treturn -ENOBUFS;\n\t}\n\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}","24413":"int ha_partition::set_up_table_before_create(TABLE *tbl,\n                    const char *partition_name_with_path, \n                    HA_CREATE_INFO *info,\n                    uint part_id,\n                    partition_element *part_elem)\n{\n  int error= 0;\n  const char *partition_name;\n  THD *thd= ha_thd();\n  DBUG_ENTER(\"STR\");\n\n  if (!part_elem)\n  {\n    part_elem= find_partition_element(part_id);\n    if (!part_elem)\n      DBUG_RETURN(1);                             \n  }\n  tbl->s->max_rows= part_elem->part_max_rows;\n  tbl->s->min_rows= part_elem->part_min_rows;\n  partition_name= strrchr(partition_name_with_path, FN_LIBCHAR);\n  if ((part_elem->index_file_name &&\n      (error= append_file_to_dir(thd,\n                                 (const char**)&part_elem->index_file_name,\n                                 partition_name+1))) ||\n      (part_elem->data_file_name &&\n      (error= append_file_to_dir(thd,\n                                 (const char**)&part_elem->data_file_name,\n                                 partition_name+1))))\n  {\n    DBUG_RETURN(error);\n  }\n  info->index_file_name= part_elem->index_file_name;\n  info->data_file_name= part_elem->data_file_name;\n  DBUG_RETURN(0);\n}","23799":"hermesBuiltinApply(void *, Runtime *runtime, NativeArgs args) {\n  GCScopeMarkerRAII marker{runtime};\n\n  Handle<Callable> fn = args.dyncastArg<Callable>(0);\n  if (LLVM_UNLIKELY(!fn)) {\n    return runtime->raiseTypeErrorForValue(\n        args.getArgHandle(0), \"STR\");\n  }\n\n  Handle<JSArray> argArray = args.dyncastArg<JSArray>(1);\n  if (LLVM_UNLIKELY(!argArray)) {\n    return runtime->raiseTypeError(\"STR\");\n  }\n\n  uint32_t len = JSArray::getLength(*argArray);\n\n  bool isConstructor = args.getArgCount() == 2;\n\n  MutableHandle<> thisVal{runtime};\n  if (isConstructor) {\n    auto thisValRes = Callable::createThisForConstruct(fn, runtime);\n    if (LLVM_UNLIKELY(thisValRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    thisVal = *thisValRes;\n  } else {\n    thisVal = args.getArg(2);\n  }\n\n  ScopedNativeCallFrame newFrame{\n      runtime, len, *fn, isConstructor, thisVal.getHermesValue()};\n  for (uint32_t i = 0; i < len; ++i) {\n    newFrame->getArgRef(i) = argArray->at(runtime, i);\n  }\n  return isConstructor ? Callable::construct(fn, runtime, thisVal)\n                       : Callable::call(fn, runtime);\n}","24596":"TPMI_RH_HIERARCHY_Marshal(TPMI_RH_HIERARCHY *source, BYTE **buffer, INT32 *size)\n{\n    UINT16 written = 0;\n    written += TPM_HANDLE_Marshal(source, buffer, size);\n    return written;\n}","24242":"char *\nextract_arithmetic_subst (string, sindex)\n     char *string;\n     int *sindex;\n{\n  return (extract_delimited_string (string, sindex, \"STR\", 0)); ","24034":"chpass_principal3_2_svc(chpass3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = chpass_principal_wrapper_3((void *)handle, arg->princ,\n                                              arg->keepold,\n                                              arg->n_ks_tuple,\n                                              arg->ks_tuple,\n                                              arg->pass);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_chpass_principal_3((void *)handle, arg->princ,\n                                            arg->keepold,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->pass);\n    } else {\n        log_unauth(\"STR\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n\n    if(ret.code != KADM5_AUTH_CHANGEPW) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"STR\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","23932":"inline int nci_request(struct nci_dev *ndev,\n\t\t       void (*req)(struct nci_dev *ndev,\n\t\t\t\t   const void *opt),\n\t\t       const void *opt, __u32 timeout)\n{\n\tint rc;\n\n\tif (!test_bit(NCI_UP, &ndev->flags))\n\t\treturn -ENETDOWN;\n\n\t\n\tmutex_lock(&ndev->req_lock);\n\trc = __nci_request(ndev, req, opt, timeout);\n\tmutex_unlock(&ndev->req_lock);\n\n\treturn rc;\n}","24547":"new_type_comment(const char *s, struct compiling *c)\n{\n    PyObject *res = PyUnicode_DecodeUTF8(s, strlen(s), NULL);\n    if (res == NULL)\n        return NULL;\n    if (PyArena_AddPyObject(c->c_arena, res) < 0) {\n        Py_DECREF(res);\n        return NULL;\n    }\n    return res;\n}","24544":"g_tls_connection_base_dtls_set_advertised_protocols (GDtlsConnection     *conn,\n                                                     const gchar * const *protocols)\n{\n  g_object_set (conn, \"STR\", protocols, NULL);\n}","25035":"static int put_v4l2_window32(struct v4l2_window *kp, struct v4l2_window32 __user *up)\n{\n\tif (copy_to_user(&up->w, &kp->w, sizeof(kp->w)) ||\n\t    put_user(kp->field, &up->field) ||\n\t    put_user(kp->chromakey, &up->chromakey) ||\n\t    put_user(kp->clipcount, &up->clipcount) ||\n\t    put_user(kp->global_alpha, &up->global_alpha))\n\t\treturn -EFAULT;\n\treturn 0;\n}","24805":"rsvg_filter_render (RsvgFilter * self, GdkPixbuf * source,\n                    RsvgDrawingCtx * context, RsvgBbox * bounds, char *channelmap)\n{\n    RsvgFilterContext *ctx;\n    RsvgFilterPrimitive *current;\n    guint i;\n    GdkPixbuf *out;\n\n\n    ctx = g_new (RsvgFilterContext, 1);\n    ctx->filter = self;\n    ctx->source = source;\n    ctx->bg = NULL;\n    ctx->results = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, rsvg_filter_free_pair);\n    ctx->ctx = context;\n\n    g_object_ref (source);\n\n    rsvg_filter_fix_coordinate_system (ctx, rsvg_current_state (context), *bounds);\n\n    ctx->lastresult.result = source;\n    ctx->lastresult.Rused = 1;\n    ctx->lastresult.Gused = 1;\n    ctx->lastresult.Bused = 1;\n    ctx->lastresult.Aused = 1;\n    ctx->lastresult.bounds = rsvg_filter_primitive_get_bounds (NULL, ctx);\n\n    for (i = 0; i < 4; i++)\n        ctx->channelmap[i] = channelmap[i] - '0';\n\n    for (i = 0; i < self->super.children->len; i++) {\n        current = g_ptr_array_index (self->super.children, i);\n        if (!strncmp (current->super.type->str, \"STR\", 2))\n            rsvg_filter_primitive_render (current, ctx);\n    }\n\n    out = ctx->lastresult.result;\n\n    g_hash_table_destroy (ctx->results);\n\n    rsvg_filter_context_free (ctx);\n\n    return out;\n}","24373":"rad_get_vendor_attr(u_int32_t *vendor, const void **data, size_t *len)\n{\n\tstruct vendor_attribute *attr;\n\n\tattr = (struct vendor_attribute *)*data;\n\t*vendor = ntohl(attr->vendor_value);\n\t*data = attr->attrib_data;\n\t*len = attr->attrib_len - 2;\n\n\treturn (attr->attrib_type);\n}","24337":"static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tunsigned long limit;\n\tshort sel;\n\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn 0;\n\n\tif (user_64bit_mode(regs) || v8086_mode(regs))\n\t\treturn -1L;\n\n\tif (!sel)\n\t\treturn 0;\n\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn 0;\n\n\t\n\tlimit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tlimit = (limit << 12) + 0xfff;\n\n\treturn limit;\n}","24362":"void altivec_unavailable_exception(struct pt_regs *regs)\n{\n#if !defined(CONFIG_ALTIVEC)\n\tif (user_mode(regs)) {\n\t\t\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n#endif\n\tprintk(KERN_EMERG \"STR\"\n\t\t\t\"STR\", regs->trap, regs->nip);\n\tdie(\"STR\", regs, SIGABRT);\n}","24393":"  const HeaderEntry& pathHeaderEntry(const std::string& path_value) {\n    headers_.setPath(path_value);\n    return *headers_.Path();\n  }","24500":"PHP_HASH_API void PHP_HAVAL256Final(unsigned char *digest, PHP_HAVAL_CTX * context)\n{\n\tunsigned char bits[10];\n\tunsigned int index, padLen;\n\n\t\n\tbits[0] =\t(PHP_HASH_HAVAL_VERSION & 0x07) |\n\t\t\t\t((context->passes & 0x07) << 3) |\n\t\t\t\t((context->output & 0x03) << 6);\n\tbits[1] = (context->output >> 2);\n\n\t\n\tEncode(bits + 2, context->count, 8);\n\n\t\n\tindex = (unsigned int) ((context->count[0] >> 3) & 0x3f);\n\tpadLen = (index < 118) ? (118 - index) : (246 - index);\n\tPHP_HAVALUpdate(context, PADDING, padLen);\n\n\t\n\tPHP_HAVALUpdate(context, bits, 10);\n\n\t\n\tEncode(digest, context->state, 32);\n\n\t\n\tmemset((unsigned char*) context, 0, sizeof(*context));\n}","23921":"rfbSetClientColourMapBGR233(rfbClientPtr cl)\n{\n    char buf[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];\n    rfbSetColourMapEntriesMsg *scme = (rfbSetColourMapEntriesMsg *)buf;\n    uint16_t *rgb = (uint16_t *)(&buf[sz_rfbSetColourMapEntriesMsg]);\n    int i, len;\n    int r, g, b;\n\n    if (cl->format.bitsPerPixel != 8 ) {\n        rfbErr(\"STR\",\n                \"STR\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    \n    scme->type = rfbSetColourMapEntries;\n\n    scme->firstColour = Swap16IfLE(0);\n    scme->nColours = Swap16IfLE(256);\n\n    len = sz_rfbSetColourMapEntriesMsg;\n\n    i = 0;\n\n    for (b = 0; b < 4; b++) {\n        for (g = 0; g < 8; g++) {\n            for (r = 0; r < 8; r++) {\n                rgb[i++] = Swap16IfLE(r * 65535 \/ 7);\n                rgb[i++] = Swap16IfLE(g * 65535 \/ 7);\n                rgb[i++] = Swap16IfLE(b * 65535 \/ 3);\n            }\n        }\n    }\n\n    len += 256 * 3 * 2;\n\n    if (rfbWriteExact(cl, buf, len) < 0) {\n        rfbLogPerror(\"STR\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    return TRUE;\n}","23829":"static int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\n\tif (action & CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"STR\", delta->old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (action & ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"STR\", delta->new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}","24124":"write_out_new_ascii_header (const char *magic_string,\n\t\t\t    struct cpio_file_stat *file_hdr, int out_des)\n{\n  char ascii_header[110];\n  char *p;\n\n  p = stpcpy (ascii_header, magic_string);\n  to_ascii_or_warn (p, file_hdr->c_ino, 8, LG_16,\n\t\t    file_hdr->c_name, _(\"STR\"));\n  p += 8;\n  to_ascii_or_warn (p, file_hdr->c_mode, 8, LG_16, file_hdr->c_name,\n\t\t    _(\"STR\"));\n  p += 8;\n  to_ascii_or_warn (p, file_hdr->c_uid, 8, LG_16, file_hdr->c_name,\n\t\t    _(\"STR\"));\n  p += 8;\n  to_ascii_or_warn (p, file_hdr->c_gid, 8, LG_16, file_hdr->c_name,\n\t\t    _(\"STR\"));\n  p += 8;\n  to_ascii_or_warn (p, file_hdr->c_nlink, 8, LG_16, file_hdr->c_name,\n\t\t    _(\"STR\"));\n  p += 8;\n  to_ascii_or_warn (p, file_hdr->c_mtime, 8, LG_16, file_hdr->c_name,\n\t\t    _(\"STR\"));\n  p += 8;\n  if (to_ascii_or_error (p, file_hdr->c_filesize, 8, LG_16, file_hdr->c_name,\n\t\t\t _(\"STR\")))\n    return 1;\n  p += 8;\n  if (to_ascii_or_error (p, file_hdr->c_dev_maj, 8, LG_16, file_hdr->c_name,\n\t\t\t _(\"STR\")))\n    return 1;\n  p += 8;\n  if (to_ascii_or_error (p, file_hdr->c_dev_min, 8, LG_16, file_hdr->c_name,\n\t\t\t _(\"STR\")))\n    return 1;\n  p += 8;\n  if (to_ascii_or_error (p, file_hdr->c_rdev_maj, 8, LG_16, file_hdr->c_name,\n\t\t\t _(\"STR\")))\n    return 1;\n  p += 8;\n  if (to_ascii_or_error (p, file_hdr->c_rdev_min, 8, LG_16, file_hdr->c_name,\n\t\t\t _(\"STR\")))\n    return 1;\n  p += 8;\n  if (to_ascii_or_error (p, file_hdr->c_namesize, 8, LG_16, file_hdr->c_name,\n\t\t\t _(\"STR\")))\n    return 1;\n  p += 8;\n  to_ascii (p, file_hdr->c_chksum & 0xffffffff, 8, LG_16, false);\n\n  tape_buffered_write (ascii_header, out_des, sizeof ascii_header);\n\n  \n  tape_buffered_write (file_hdr->c_name, out_des, (long) file_hdr->c_namesize);\n  tape_pad_output (out_des, file_hdr->c_namesize + sizeof ascii_header);\n  return 0;\n}  ","24792":"WandExport char *DrawGetFontFamily(const DrawingWand *wand)\n{\n  assert(wand != (const DrawingWand *) NULL);\n  assert(wand->signature == MagickWandSignature);\n  if (wand->debug != MagickFalse)\n    (void) LogMagickEvent(WandEvent,GetMagickModule(),\"STR\",wand->name);\n  if (CurrentContext->family != NULL)\n    return(AcquireString(CurrentContext->family));\n  return((char *) NULL);\n}","24138":"  char * get_nb_line(IStream & in, String & buf)\n  {\n    char * p;\n    \n    do {\n      if (!in.getline(buf)) return 0;\n      p = buf.mstr();\n      while (*p == ' ' || *p == '\\t') ++p;\n    } while (*p == '#' || *p == '\\0');\n    return p;\n  }","24963":"_rl_read_file (filename, sizep)\n     char *filename;\n     size_t *sizep;\n{\n  struct stat finfo;\n  size_t file_size;\n  char *buffer;\n  int i, file;\n\n  if ((stat (filename, &finfo) < 0) || (file = open (filename, O_RDONLY, 0666)) < 0)\n    return ((char *)NULL);\n\n  file_size = (size_t)finfo.st_size;\n\n  \n  if (file_size != finfo.st_size || file_size + 1 < file_size)\n    {\n      if (file >= 0)\n\tclose (file);\n#if defined (EFBIG)\n      errno = EFBIG;\n#endif\n      return ((char *)NULL);\n    }\n\n  \n  buffer = (char *)xmalloc (file_size + 1);\n  i = read (file, buffer, file_size);\n  close (file);\n\n  if (i < 0)\n    {\n      xfree (buffer);\n      return ((char *)NULL);\n    }\n\n  RL_CHECK_SIGNALS ();\n\n  buffer[i] = '\\0';\n  if (sizep)\n    *sizep = i;\n\n  return (buffer);\n}","24561":"yang_check_container(struct lys_module *module, struct lys_node_container *cont, struct lys_node **child,\n                     int options, struct unres_schema *unres)\n{\n    if (yang_check_typedef(module, (struct lys_node *)cont, unres)) {\n        goto error;\n    }\n\n    if (yang_check_iffeatures(module, NULL, cont, CONTAINER_KEYWORD, unres)) {\n        goto error;\n    }\n\n    if (yang_check_nodes(module, (struct lys_node *)cont, *child, options, unres)) {\n        *child = NULL;\n        goto error;\n    }\n    *child = NULL;\n\n    if (cont->when && yang_check_ext_instance(module, &cont->when->ext, cont->when->ext_size, cont->when, unres)) {\n        goto error;\n    }\n    if (yang_check_must(module, cont->must, cont->must_size, unres)) {\n        goto error;\n    }\n\n    \n    if (!(module->ctx->models.flags & LY_CTX_TRUSTED) && (cont->when || cont->must_size)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax((struct lys_node *)cont)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, cont, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\nerror:\n\n    return EXIT_FAILURE;\n}","24513":"    bool run(OperationContext* txn,\n             const string& dbname,\n             BSONObj& cmdObj,\n             int options,\n             string& errmsg,\n             BSONObjBuilder& result) {\n        auth::CreateOrUpdateRoleArgs args;\n        Status status = auth::parseCreateOrUpdateRoleCommands(cmdObj, \"STR\", dbname, &args);\n        if (!status.isOK()) {\n            return appendCommandStatus(result, status);\n        }\n\n        if (args.roleName.getRole().empty()) {\n            return appendCommandStatus(result,\n                                       Status(ErrorCodes::BadValue, \"STR\"));\n        }\n\n        if (args.roleName.getDB() == \"STR\") {\n            return appendCommandStatus(\n                result, Status(ErrorCodes::BadValue, \"STR\"));\n        }\n\n        if (args.roleName.getDB() == \"STR\") {\n            return appendCommandStatus(\n                result,\n                Status(ErrorCodes::BadValue, \"STR\"));\n        }\n\n        if (RoleGraph::isBuiltinRole(args.roleName)) {\n            return appendCommandStatus(\n                result,\n                Status(ErrorCodes::BadValue,\n                       \"STR\"));\n        }\n\n        if (!args.hasRoles) {\n            return appendCommandStatus(\n                result,\n                Status(ErrorCodes::BadValue, \"STR\"));\n        }\n\n        if (!args.hasPrivileges) {\n            return appendCommandStatus(\n                result,\n                Status(ErrorCodes::BadValue,\n                       \"STR\"));\n        }\n\n        BSONObjBuilder roleObjBuilder;\n\n        roleObjBuilder.append(\n            \"STR\" << args.roleName.getRole());\n        roleObjBuilder.append(AuthorizationManager::ROLE_NAME_FIELD_NAME, args.roleName.getRole());\n        roleObjBuilder.append(AuthorizationManager::ROLE_DB_FIELD_NAME, args.roleName.getDB());\n\n        BSONArray privileges;\n        status = privilegeVectorToBSONArray(args.privileges, &privileges);\n        if (!status.isOK()) {\n            return appendCommandStatus(result, status);\n        }\n        roleObjBuilder.append(\"STR\", privileges);\n\n        roleObjBuilder.append(\"STR\", rolesVectorToBSONArray(args.roles));\n\n        ServiceContext* serviceContext = txn->getClient()->getServiceContext();\n        stdx::lock_guard<stdx::mutex> lk(getAuthzDataMutex(serviceContext));\n\n        AuthorizationManager* authzManager = AuthorizationManager::get(serviceContext);\n        status = requireAuthSchemaVersion26Final(txn, authzManager);\n        if (!status.isOK()) {\n            return appendCommandStatus(result, status);\n        }\n\n        \n        status = checkOkayToGrantRolesToRole(txn, args.roleName, args.roles, authzManager);\n        if (!status.isOK()) {\n            return appendCommandStatus(result, status);\n        }\n\n        status = checkOkayToGrantPrivilegesToRole(args.roleName, args.privileges);\n        if (!status.isOK()) {\n            return appendCommandStatus(result, status);\n        }\n\n        audit::logCreateRole(Client::getCurrent(), args.roleName, args.roles, args.privileges);\n\n        status = insertRoleDocument(txn, roleObjBuilder.done());\n        return appendCommandStatus(result, status);\n    }","23986":"static unsigned long kvm_get_wallclock(void)\n{\n\tstruct pvclock_vcpu_time_info *vcpu_time;\n\tstruct timespec ts;\n\tint low, high;\n\n\tlow = (int)__pa_symbol(&wall_clock);\n\thigh = ((u64)__pa_symbol(&wall_clock) >> 32);\n\n\tnative_write_msr(msr_kvm_wall_clock, low, high);\n\n\tvcpu_time = &get_cpu_var(hv_clock);\n\tpvclock_read_wallclock(&wall_clock, vcpu_time, &ts);\n\tput_cpu_var(hv_clock);\n\n\treturn ts.tv_sec;\n}","24921":"  void Compute(OpKernelContext* ctx) override {\n    const Tensor& in0 = ctx->input(0);\n    const Tensor& in1 = ctx->input(1);\n    auto in0_flat = in0.flat<Tin>();\n    auto in1_flat = in1.flat<Tin>();\n    const Device& eigen_device = ctx->eigen_device<Device>();\n\n    Tensor* out = nullptr;\n    if (std::is_same<Tin, Tout>::value) {\n      OP_REQUIRES_OK(ctx, ctx->forward_input_or_allocate_output(\n                              {0, 1}, 0, in0.shape(), &out));\n    } else {\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(0, in0.shape(), &out));\n    }\n    auto out_flat = out->flat<Tout>();\n    functor::SimpleBinaryFunctor<Device, Functor>()(eigen_device, out_flat,\n                                                    in0_flat, in1_flat);\n  }","24801":"CURLcode Curl_close(struct Curl_easy *data)\n{\n  struct Curl_multi *m;\n\n  if(!data)\n    return CURLE_OK;\n\n  Curl_expire_clear(data); \n\n  m = data->multi;\n  if(m)\n    \n    curl_multi_remove_handle(data->multi, data);\n\n  if(data->multi_easy)\n    \n    curl_multi_cleanup(data->multi_easy);\n\n  \n  Curl_llist_destroy(&data->state.timeoutlist, NULL);\n\n  data->magic = 0; \n\n  if(data->state.rangestringalloc)\n    free(data->state.range);\n\n  \n  Curl_free_request_state(data);\n\n  \n  Curl_ssl_close_all(data);\n  Curl_safefree(data->state.first_host);\n  Curl_safefree(data->state.scratch);\n  Curl_ssl_free_certinfo(data);\n\n  \n  free(data->req.newurl);\n  data->req.newurl = NULL;\n\n  if(data->change.referer_alloc) {\n    Curl_safefree(data->change.referer);\n    data->change.referer_alloc = FALSE;\n  }\n  data->change.referer = NULL;\n\n  Curl_up_free(data);\n  Curl_safefree(data->state.buffer);\n  Curl_safefree(data->state.headerbuff);\n  Curl_safefree(data->state.ulbuf);\n  Curl_flush_cookies(data, 1);\n  Curl_digest_cleanup(data);\n  Curl_safefree(data->info.contenttype);\n  Curl_safefree(data->info.wouldredirect);\n\n  \n  Curl_resolver_cleanup(data->state.resolver);\n\n  Curl_http2_cleanup_dependencies(data);\n  Curl_convert_close(data);\n\n  \n  if(data->share) {\n    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);\n    data->share->dirty--;\n    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);\n  }\n\n  \n  Curl_wildcard_dtor(&data->wildcard);\n  Curl_freeset(data);\n  free(data);\n  return CURLE_OK;\n}","24343":"void KrecipesView::closeRecipe( void )\n{\n\tslotSetPanel( m_previousActivePanel, true );\n}","23911":"static int ext4_end_io_nolock(ext4_io_end_t *io)\n{\n\tstruct inode *inode = io->inode;\n\tloff_t offset = io->offset;\n\tssize_t size = io->size;\n\tint ret = 0;\n\n\text4_debug(\"STR\"\n\t\t   \"STR\",\n\t           io, inode->i_ino, io->list.next, io->list.prev);\n\n\tif (list_empty(&io->list))\n\t\treturn ret;\n\n\tif (io->flag != EXT4_IO_UNWRITTEN)\n\t\treturn ret;\n\n\tif (offset + size <= i_size_read(inode))\n\t\tret = ext4_convert_unwritten_extents(inode, offset, size);\n\n\tif (ret < 0) {\n\t\tprintk(KERN_EMERG \"STR\"\n\t\t\t\"STR\"\n\t\t\t\"STR\",\n                       __func__, ret, inode->i_ino);\n\t\treturn ret;\n\t}\n\n\t\n\tio->flag = 0;\n\treturn ret;\n}","24154":"folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n\n  TLSMessage msg;\n  \n  \n  \n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"STR\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"STR\",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n\n  if (!msg.fragment) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"STR\");\n    }\n  }\n\n  return msg;\n}","24775":"gimp_channel_convert (GimpItem  *item,\n                      GimpImage *dest_image,\n                      GType      old_type)\n{\n  GimpChannel  *channel  = GIMP_CHANNEL (item);\n  GimpDrawable *drawable = GIMP_DRAWABLE (item);\n\n  if (! gimp_drawable_is_gray (drawable))\n    {\n      gimp_drawable_convert_type (drawable, dest_image,\n                                  GIMP_GRAY,\n                                  gimp_image_get_precision (dest_image),\n                                  gimp_drawable_has_alpha (drawable),\n                                  NULL,\n                                  GEGL_DITHER_NONE, GEGL_DITHER_NONE,\n                                  FALSE, NULL);\n    }\n\n  if (gimp_drawable_has_alpha (drawable))\n    {\n      GeglBuffer *new_buffer;\n      const Babl *format;\n      GimpRGB     background;\n\n      format = gimp_drawable_get_format_without_alpha (drawable);\n\n      new_buffer =\n        gegl_buffer_new (GEGL_RECTANGLE (0, 0,\n                                         gimp_item_get_width (item),\n                                         gimp_item_get_height (item)),\n                         format);\n\n      gimp_rgba_set (&background, 0.0, 0.0, 0.0, 0.0);\n\n      gimp_gegl_apply_flatten (gimp_drawable_get_buffer (drawable),\n                               NULL, NULL,\n                               new_buffer, &background,\n                               GIMP_LAYER_COLOR_SPACE_RGB_LINEAR);\n\n      gimp_drawable_set_buffer_full (drawable, FALSE, NULL,\n                                     new_buffer,\n                                     GEGL_RECTANGLE (\n                                       gimp_item_get_offset_x (item),\n                                       gimp_item_get_offset_y (item),\n                                       0, 0),\n                                     TRUE);\n      g_object_unref (new_buffer);\n    }\n\n  if (G_TYPE_FROM_INSTANCE (channel) == GIMP_TYPE_CHANNEL)\n    {\n      gint width  = gimp_image_get_width  (dest_image);\n      gint height = gimp_image_get_height (dest_image);\n\n      gimp_item_set_offset (item, 0, 0);\n\n      if (gimp_item_get_width  (item) != width ||\n          gimp_item_get_height (item) != height)\n        {\n          gimp_item_resize (item, gimp_get_user_context (dest_image->gimp),\n                            GIMP_FILL_TRANSPARENT,\n                            width, height, 0, 0);\n        }\n    }\n\n  GIMP_ITEM_CLASS (parent_class)->convert (item, dest_image, old_type);\n}","24866":"int ssl3_send_alert(SSL *s, int level, int desc)\n{\n    \n    desc = s->method->ssl3_enc->alert_value(desc);\n    if (s->version == SSL3_VERSION && desc == SSL_AD_PROTOCOL_VERSION)\n        desc = SSL_AD_HANDSHAKE_FAILURE; \n    if (desc < 0)\n        return -1;\n    \n    if ((level == 2) && (s->session != NULL))\n        SSL_CTX_remove_session(s->session_ctx, s->session);\n\n    s->s3->alert_dispatch = 1;\n    s->s3->send_alert[0] = level;\n    s->s3->send_alert[1] = desc;\n    if (s->s3->wbuf.left == 0)  \n        return s->method->ssl_dispatch_alert(s);\n    \n    return -1;\n}","24432":"LuacBinInfo *luac_build_info(LuaProto *proto) {\n\tif (!proto) {\n\t\tRZ_LOG_ERROR(\"STR\");\n\t\treturn NULL;\n\t}\n\n\tLuacBinInfo *ret = RZ_NEW0(LuacBinInfo);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tret->entry_list = rz_list_newf((RzListFree)free_rz_addr);\n\tret->symbol_list = rz_list_newf((RzListFree)rz_bin_symbol_free);\n\tret->section_list = rz_list_newf((RzListFree)free_rz_section);\n\tret->string_list = rz_list_newf((RzListFree)free_rz_string);\n\n\tif (!(ret->entry_list && ret->symbol_list && ret->section_list && ret->string_list)) {\n\t\ttry_free_empty_list(ret->entry_list);\n\t\ttry_free_empty_list(ret->symbol_list);\n\t\ttry_free_empty_list(ret->section_list);\n\t\ttry_free_empty_list(ret->string_list);\n\t}\n\n\t_luac_build_info(proto, ret);\n\n\t\n\tut64 main_entry_offset;\n\tmain_entry_offset = proto->code_offset + proto->code_skipped;\n\tluac_add_entry(ret->entry_list, main_entry_offset, RZ_BIN_ENTRY_TYPE_PROGRAM);\n\n\treturn ret;\n}","24714":"    \n    static void wait(CImgDisplay& disp1, CImgDisplay& disp2, CImgDisplay& disp3, CImgDisplay& disp4) {\n      disp1._is_event = disp2._is_event = disp3._is_event = disp4._is_event = false;\n      while ((!disp1._is_closed || !disp2._is_closed || !disp3._is_closed || !disp4._is_closed) &&\n             !disp1._is_event && !disp2._is_event && !disp3._is_event && !disp4._is_event) wait_all();","24224":"  void allocHeaders() override {\n    ASSERT(nullptr == absl::get<RequestHeaderMapPtr>(headers_or_trailers_));\n    headers_or_trailers_.emplace<RequestHeaderMapPtr>(RequestHeaderMapImpl::create());\n  }","24318":"static int orinoco_ioctl_set_genie(struct net_device *dev,\n\t\t\t\t   struct iw_request_info *info,\n\t\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tu8 *buf;\n\tunsigned long flags;\n\n\t\n\tif ((wrqu->data.length > IEEE80211_MAX_DATA_LEN) ||\n\t    (wrqu->data.length && (extra == NULL)))\n\t\treturn -EINVAL;\n\n\tif (wrqu->data.length) {\n\t\tbuf = kmemdup(extra, wrqu->data.length, GFP_KERNEL);\n\t\tif (buf == NULL)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tbuf = NULL;\n\n\tif (orinoco_lock(priv, &flags) != 0) {\n\t\tkfree(buf);\n\t\treturn -EBUSY;\n\t}\n\n\tkfree(priv->wpa_ie);\n\tpriv->wpa_ie = buf;\n\tpriv->wpa_ie_len = wrqu->data.length;\n\n\tif (priv->wpa_ie) {\n\t\t\n\t}\n\n\torinoco_unlock(priv, &flags);\n\treturn 0;\n}","24622":"static int setup_config(int type)\n{\n\tint rv;\n\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\n\tif (is_auth_req()) {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"STR\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\n\t\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"STR\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\n\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\n\n\t\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"STR\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\n\nout:\n\treturn rv;\n}","24655":"SPL_METHOD(SplFileInfo, __construct)\n{\n\tspl_filesystem_object *intern;\n\tchar *path;\n\tint len;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"STR\", &path, &len) == FAILURE) {\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\treturn;\n\t}\n\n\tintern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tspl_filesystem_info_set_filename(intern, path, len, 1 TSRMLS_CC);\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\n\t\n}","23961":"static u64 tcp_compute_delivery_rate(const struct tcp_sock *tp)\n{\n\tu32 rate = READ_ONCE(tp->rate_delivered);\n\tu32 intv = READ_ONCE(tp->rate_interval_us);\n\tu64 rate64 = 0;\n\n\tif (rate && intv) {\n\t\trate64 = (u64)rate * tp->mss_cache * USEC_PER_SEC;\n\t\tdo_div(rate64, intv);\n\t}\n\treturn rate64;\n}","24878":"static bool virtio_net_can_receive(NetClientState *nc)\n{\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    VirtIONetQueue *q = virtio_net_get_subqueue(nc);\n\n    if (!vdev->vm_running) {\n        return false;\n    }\n\n    if (nc->queue_index >= n->curr_queue_pairs) {\n        return false;\n    }\n\n    if (!virtio_queue_ready(q->rx_vq) ||\n        !(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK)) {\n        return false;\n    }\n\n    return true;\n}","24240":"tcp_sequence_number_analysis_print_lost(packet_info * pinfo,\n                    proto_item * flags_item,\n                    struct tcp_acked *ta\n                    )\n{\n    \n    if (ta->flags & TCP_A_LOST_PACKET) {\n        expert_add_info(pinfo, flags_item, &ei_tcp_analysis_lost_packet);\n        col_prepend_fence_fstr(pinfo->cinfo, COL_INFO,\n                               \"STR\");\n    }\n    \n    if (ta->flags & TCP_A_ACK_LOST_PACKET) {\n        expert_add_info(pinfo, flags_item, &ei_tcp_analysis_ack_lost_packet);\n        col_prepend_fence_fstr(pinfo->cinfo, COL_INFO,\n                               \"STR\");\n    }\n}","24772":"void auth_policy_create_json(struct policy_lookup_ctx *context,\n\tconst char *password, bool include_success)\n{\n\tconst struct var_expand_table *var_table;\n\tcontext->json = str_new(context->pool, 64);\n\tunsigned char *ptr;\n\tconst struct hash_method *digest = hash_method_lookup(context->set->policy_hash_mech);\n\n\ti_assert(digest != NULL);\n\n\tvoid *ctx = t_malloc(digest->context_size);\n\tstring_t *buffer = t_str_new(64);\n\n\tdigest->init(ctx);\n\tdigest->loop(ctx,\n\t\tcontext->set->policy_hash_nonce,\n\t\tstrlen(context->set->policy_hash_nonce));\n\t\n\tdigest->loop(ctx, context->request->user, strlen(context->request->user) + 1);\n\tif (password != NULL)\n\t\tdigest->loop(ctx, password, strlen(password));\n\tptr = (unsigned char*)str_c_modifiable(buffer);\n\tdigest->result(ctx, ptr);\n\tstr_truncate(buffer, digest->digest_size);\n\tif (context->set->policy_hash_truncate > 0) {\n\t\tbuffer_truncate_rshift_bits(buffer, context->set->policy_hash_truncate);\n\t}\n\tconst char *hashed_password = binary_to_hex(str_data(buffer), str_len(buffer));\n\tstr_append_c(context->json, '{');\n\tvar_table = policy_get_var_expand_table(context->request, hashed_password);\n\tauth_request_var_expand_with_table(context->json, auth_policy_json_template,\n\t\t\t\t\t   context->request, var_table,\n\t\t\t\t\t   auth_policy_escape_function);\n\tif (include_success) {\n\t\tstr_append(context->json, \"STR\");\n\t\tif (!context->request->failed && context->request->successful &&\n\t\t    !context->request->internal_failure)\n\t\t\tstr_append(context->json, \"STR\");\n\t\telse\n\t\t\tstr_append(context->json, \"STR\");\n\t\tstr_append(context->json, \"STR\");\n\t\tstr_append(context->json, context->request->policy_refusal ? \"STR\");\n\t}\n\tstr_append_c(context->json, '}');\n\tauth_request_log_debug(context->request, \"STR\",\n\t\t\"STR\", str_c(context->json));\n}","24748":"static inline void ModulateHCL(const double percent_hue,\n  const double percent_chroma,const double percent_luma,double *red,\n  double *green,double *blue)\n{\n  double\n    hue,\n    luma,\n    chroma;\n\n  \n  ConvertRGBToHCL(*red,*green,*blue,&hue,&chroma,&luma);\n  hue+=0.5*(0.01*percent_hue-1.0);\n  while (hue < 0.0)\n    hue+=1.0;\n  while (hue > 1.0)\n    hue-=1.0;\n  chroma*=0.01*percent_chroma;\n  luma*=0.01*percent_luma;\n  ConvertHCLToRGB(hue,chroma,luma,red,green,blue);\n}","24458":"_copyLockStmt(const LockStmt *from)\n{\n\tLockStmt   *newnode = makeNode(LockStmt);\n\n\tCOPY_NODE_FIELD(relations);\n\tCOPY_SCALAR_FIELD(mode);\n\tCOPY_SCALAR_FIELD(nowait);\n\n\treturn newnode;\n}","24640":"void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\n\tif (!handle)\n\t\treturn NULL;\n\n\tpointer = (void*) ~((size_t) handle->dwLower);\n\n\treturn pointer;\n}","24173":"isdn_net_addphone(isdn_net_ioctl_phone * phone)\n{\n\tisdn_net_dev *p = isdn_net_findif(phone->name);\n\tisdn_net_phone *n;\n\n\tif (p) {\n\t\tif (!(n = kmalloc(sizeof(isdn_net_phone), GFP_KERNEL)))\n\t\t\treturn -ENOMEM;\n\t\tstrcpy(n->num, phone->phone);\n\t\tn->next = p->local->phone[phone->outgoing & 1];\n\t\tp->local->phone[phone->outgoing & 1] = n;\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}","24353":"static ssize_t _consolefs_write(oe_fd_t* file_, const void* buf, size_t count)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(file_);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_write_ocall(&ret, file->host_fd, buf, count) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}","24689":"static int fuse_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\t\n\tstruct inode *inode = vma->vm_file->f_mapping->host;\n\n\tfuse_wait_on_page_writeback(inode, page->index);\n\treturn 0;\n}","24193":"void AuthorizationManager::invalidateUsersFromDB(const std::string& dbname) {\n    CacheGuard guard(this, CacheGuard::fetchSynchronizationManual);\n    _updateCacheGeneration_inlock();\n    unordered_map<UserName, User*>::iterator it = _userCache.begin();\n    while (it != _userCache.end()) {\n        User* user = it->second;\n        if (user->getName().getDB() == dbname) {\n            _userCache.erase(it++);\n            user->invalidate();\n        } else {\n            ++it;\n        }\n    }\n}","24043":"void wsrep_plugins_post_init()\n{\n  THD *thd;\n  I_List_iterator<THD> it(threads);\n\n  while ((thd= it++))\n  {\n    if (IF_WSREP(thd->wsrep_applier,1))\n    {\n      \n      ulonglong option_bits_saved= thd->variables.option_bits;\n\n      plugin_thdvar_init(thd);\n\n      \n      thd->variables.option_bits= option_bits_saved;\n    }\n  }\n\n  return;\n}","24905":"static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,\n                                      X509_ALGOR **pmaskHash)\n{\n    const unsigned char *p;\n    int plen;\n    RSA_PSS_PARAMS *pss;\n\n    *pmaskHash = NULL;\n\n    if (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)\n        return NULL;\n    p = alg->parameter->value.sequence->data;\n    plen = alg->parameter->value.sequence->length;\n    pss = d2i_RSA_PSS_PARAMS(NULL, &p, plen);\n\n    if (!pss)\n        return NULL;\n\n    if (pss->maskGenAlgorithm) {\n        ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;\n        if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_mgf1\n            && param->type == V_ASN1_SEQUENCE) {\n            p = param->value.sequence->data;\n            plen = param->value.sequence->length;\n            *pmaskHash = d2i_X509_ALGOR(NULL, &p, plen);\n        }\n    }\n\n    return pss;\n}","24931":"void Statement::CloseCallback(uv_handle_t* handle) {\n    assert(handle != NULL);\n    assert(handle->data != NULL);\n    Async* async = static_cast<Async*>(handle->data);\n    delete async;\n}","24934":"static bool qxl_get_check_slot_offset(PCIQXLDevice *qxl, QXLPHYSICAL pqxl,\n                                      uint32_t *s, uint64_t *o)\n{\n    uint64_t phys   = le64_to_cpu(pqxl);\n    uint32_t slot   = (phys >> (64 -  8)) & 0xff;\n    uint64_t offset = phys & 0xffffffffffff;\n\n    if (slot >= NUM_MEMSLOTS) {\n        qxl_set_guest_bug(qxl, \"STR\", slot,\n                          NUM_MEMSLOTS);\n        return false;\n    }\n    if (!qxl->guest_slots[slot].active) {\n        qxl_set_guest_bug(qxl, \"STR\", slot);\n        return false;\n    }\n    if (offset < qxl->guest_slots[slot].delta) {\n        qxl_set_guest_bug(qxl,\n                          \"STR\",\n                          slot, offset, qxl->guest_slots[slot].delta);\n        return false;\n    }\n    offset -= qxl->guest_slots[slot].delta;\n    if (offset > qxl->guest_slots[slot].size) {\n        qxl_set_guest_bug(qxl,\n                          \"STR\",\n                          slot, offset, qxl->guest_slots[slot].size);\n        return false;\n    }\n\n    *s = slot;\n    *o = offset;\n    return true;\n}","24494":"static int update_modify_target(struct libmnt_update *upd, struct libmnt_lock *lc)\n{\n\tstruct libmnt_table *tb = NULL;\n\tint rc = 0, u_lc = -1;\n\n\tDBG(UPDATE, mnt_debug_h(upd, \"STR\", upd->filename));\n\n\tif (lc)\n\t\tmnt_lock_file(lc);\n\telse if (upd->userspace_only)\n\t\tu_lc = utab_lock(upd->filename);\n\n\ttb = __mnt_new_table_from_file(upd->filename,\n\t\t\tupd->userspace_only ? MNT_FMT_UTAB : MNT_FMT_MTAB);\n\tif (tb) {\n\t\tstruct libmnt_fs *cur = mnt_table_find_target(tb,\n\t\t\t\tmnt_fs_get_srcpath(upd->fs), MNT_ITER_BACKWARD);\n\t\tif (cur) {\n\t\t\trc = mnt_fs_set_target(cur, mnt_fs_get_target(upd->fs));\n\t\t\tif (!rc)\n\t\t\t\trc = update_table(upd, tb);\n\t\t}\n\t}\n\tif (lc)\n\t\tmnt_unlock_file(lc);\n\telse if (u_lc != -1)\n\t\tutab_unlock(u_lc);\n\n\tmnt_free_table(tb);\n\treturn rc;\n}","24195":"PHP_METHOD(snmp, setSecurity)\n{\n\tphp_snmp_object *snmp_object;\n\tzval *object = getThis();\n\tchar *a1 = \"STR\";\n\tint a1_len = 0, a2_len = 0, a3_len = 0, a4_len = 0, a5_len = 0, a6_len = 0, a7_len = 0;\n\tint argc = ZEND_NUM_ARGS();\n\n\tsnmp_object = (php_snmp_object *)zend_object_store_get_object(object TSRMLS_CC);\n\t\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"STR\", &a1, &a1_len, &a2, &a2_len, &a3, &a3_len,\n\t\t&a4, &a4_len, &a5, &a5_len, &a6, &a6_len, &a7, &a7_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (netsnmp_session_set_security(snmp_object->session, a1, a2, a3, a4, a5, a6, a7 TSRMLS_CC)) {\n\t\t\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;\n}","24348":"OPJ_BOOL opj_j2k_write_cbd( opj_j2k_t *p_j2k,\n                                                struct opj_stream_private *p_stream,\n                                                struct opj_event_mgr * p_manager )\n{\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_cbd_size;\n        OPJ_BYTE * l_current_data = 00;\n        opj_image_t *l_image = 00;\n        opj_image_comp_t * l_comp = 00;\n\n        \n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        assert(p_stream != 00);\n\n        l_image = p_j2k->m_private_image;\n        l_cbd_size = 6 + p_j2k->m_private_image->numcomps;\n\n        if (l_cbd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {\n                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_cbd_size);\n                if (! new_header_tile_data) {\n                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;\n                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;\n                        opj_event_msg(p_manager, EVT_ERROR, \"STR\");\n                        return OPJ_FALSE;\n                }\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;\n                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_cbd_size;\n        }\n\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;\n\n        opj_write_bytes(l_current_data,J2K_MS_CBD,2);                   \n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_cbd_size-2,2);                 \n        l_current_data += 2;\n\n        opj_write_bytes(l_current_data,l_image->numcomps, 2);           \n        l_current_data+=2;\n\n        l_comp = l_image->comps;\n\n        for (i=0;i<l_image->numcomps;++i) {\n                opj_write_bytes(l_current_data, (l_comp->sgnd << 7) | (l_comp->prec - 1), 1);           \n                ++l_current_data;\n\n                ++l_comp;\n        }\n\n        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_cbd_size,p_manager) != l_cbd_size) {\n                return OPJ_FALSE;\n        }\n\n        return OPJ_TRUE;\n}","24504":"inline int TensorProtoDataSize<qint32>(const TensorProto& t) {\n  return t.int_val_size();\n}","24828":"xdiff_out(\n\tlong start_a,\n\tlong count_a,\n\tlong start_b,\n\tlong count_b,\n\tvoid *priv)\n{\n    diffout_T\t*dout = (diffout_T *)priv;\n    diffhunk_T *p = ALLOC_ONE(diffhunk_T);\n\n    if (p == NULL)\n\treturn -1;\n\n    if (ga_grow(&dout->dout_ga, 1) == FAIL)\n    {\n\tvim_free(p);\n\treturn -1;\n    }\n\n    p->lnum_orig  = start_a + 1;\n    p->count_orig = count_a;\n    p->lnum_new   = start_b + 1;\n    p->count_new  = count_b;\n    ((diffhunk_T **)dout->dout_ga.ga_data)[dout->dout_ga.ga_len++] = p;\n    return 0;\n}","24545":"ext4_xattr_ibody_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\tsize_t size;\n\tvoid *end;\n\tint error;\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn -ENODATA;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext4_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\terror = xattr_check_inode(inode, header, end);\n\tif (error)\n\t\tgoto cleanup;\n\tentry = IFIRST(header);\n\terror = xattr_find_entry(inode, &entry, end, name_index, name, 0);\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tif (entry->e_value_inum) {\n\t\t\terror = ext4_xattr_inode_get(inode, entry, buffer,\n\t\t\t\t\t\t     size);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t} else {\n\t\t\tmemcpy(buffer, (void *)IFIRST(header) +\n\t\t\t       le16_to_cpu(entry->e_value_offs), size);\n\t\t}\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}","24214":"fingerprint_from_pk (PKT_public_key *pk, byte *array, size_t *ret_len)\n{\n  const byte *dp;\n  size_t len;\n  gcry_md_hd_t md;\n\n  md = do_fingerprint_md(pk);\n  dp = gcry_md_read( md, 0 );\n  len = gcry_md_get_algo_dlen (gcry_md_get_algo (md));\n  assert( len <= MAX_FINGERPRINT_LEN );\n  if (!array)\n    array = xmalloc ( len );\n  memcpy (array, dp, len );\n  pk->keyid[0] = buf32_to_u32 (dp+12);\n  pk->keyid[1] = buf32_to_u32 (dp+16);\n  gcry_md_close( md);\n\n  if (ret_len)\n    *ret_len = len;\n  return array;\n}","24178":"int agp_generic_insert_memory(struct agp_memory * mem, off_t pg_start, int type)\n{\n\tint num_entries;\n\tsize_t i;\n\toff_t j;\n\tvoid *temp;\n\tstruct agp_bridge_data *bridge;\n\tint mask_type;\n\n\tbridge = mem->bridge;\n\tif (!bridge)\n\t\treturn -EINVAL;\n\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\n\ttemp = bridge->current_size;\n\n\tswitch (bridge->driver->size_type) {\n\tcase U8_APER_SIZE:\n\t\tnum_entries = A_SIZE_8(temp)->num_entries;\n\t\tbreak;\n\tcase U16_APER_SIZE:\n\t\tnum_entries = A_SIZE_16(temp)->num_entries;\n\t\tbreak;\n\tcase U32_APER_SIZE:\n\t\tnum_entries = A_SIZE_32(temp)->num_entries;\n\t\tbreak;\n\tcase FIXED_APER_SIZE:\n\t\tnum_entries = A_SIZE_FIX(temp)->num_entries;\n\t\tbreak;\n\tcase LVL2_APER_SIZE:\n\t\t\n\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tnum_entries = 0;\n\t\tbreak;\n\t}\n\n\tnum_entries -= agp_memory_reserved\/PAGE_SIZE;\n\tif (num_entries < 0) num_entries = 0;\n\n\tif (type != mem->type)\n\t\treturn -EINVAL;\n\n\tmask_type = bridge->driver->agp_type_to_mask_type(bridge, type);\n\tif (mask_type != 0) {\n\t\t\n\t\treturn -EINVAL;\n\t}\n\n\t\n\tif ((pg_start + mem->page_count) > num_entries)\n\t\treturn -EINVAL;\n\n\tj = pg_start;\n\n\twhile (j < (pg_start + mem->page_count)) {\n\t\tif (!PGE_EMPTY(bridge, readl(bridge->gatt_table+j)))\n\t\t\treturn -EBUSY;\n\t\tj++;\n\t}\n\n\tif (!mem->is_flushed) {\n\t\tbridge->driver->cache_flush();\n\t\tmem->is_flushed = true;\n\t}\n\n\tfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\n\t\twritel(bridge->driver->mask_memory(bridge,\n\t\t\t\t\t\t   page_to_phys(mem->pages[i]),\n\t\t\t\t\t\t   mask_type),\n\t\t       bridge->gatt_table+j);\n\t}\n\treadl(bridge->gatt_table+j-1);\t\n\n\tbridge->driver->tlb_flush(mem);\n\treturn 0;\n}","24799":"void OGRKMLLayer::SetLayerNumber( int nLayer )\n{\n    nLayerNumber_ = nLayer;\n}","24101":"libxlDomainStartRestore(libxlDriverPrivate *driver,\n                        virDomainObj *vm,\n                        bool start_paused,\n                        int restore_fd,\n                        uint32_t restore_ver)\n{\n    return libxlDomainStart(driver, vm, start_paused,\n                            restore_fd, restore_ver);\n}","24282":"PHPAPI void var_destroy(php_unserialize_data_t *var_hashx)\n{\n\tvoid *next;\n\tlong i;\n\tvar_entries *var_hash = (*var_hashx)->first;\n#if VAR_ENTRIES_DBG\n\tfprintf(stderr, \"STR\", var_hash?var_hash->used_slots:-1L);\n#endif\n\n\twhile (var_hash) {\n\t\tnext = var_hash->next;\n\t\tefree(var_hash);\n\t\tvar_hash = next;\n\t}\n\n\tvar_hash = (*var_hashx)->first_dtor;\n\n\twhile (var_hash) {\n\t\tfor (i = 0; i < var_hash->used_slots; i++) {\n\t\t\tzval_ptr_dtor(&var_hash->data[i]);\n\t\t}\n\t\tnext = var_hash->next;\n\t\tefree(var_hash);\n\t\tvar_hash = next;\n\t}\n}","23842":"void Item::push_note_converted_to_negative_complement(THD *thd)\n{\n  push_warning(thd, Sql_condition::WARN_LEVEL_NOTE, ER_UNKNOWN_ERROR,\n               \"STR\"\n               \"STR\");\n}","24013":"static __always_inline u32 __flow_hash_words(const u32 *words, u32 length,\n\t\t\t\t\t     u32 keyval)\n{\n\treturn jhash2(words, length, keyval);\n}","24745":"INST_HANDLER (eijmp) {\t\n\tut64 z, eind;\n\t\n\tr_anal_esil_reg_read (anal->esil, \"STR\",    &z,    NULL);\n\tr_anal_esil_reg_read (anal->esil, \"STR\", &eind, NULL);\n\t\n\t\n\top->jump = ((eind << 16) + z) << 1;\n\t\n\tESIL_A (\"STR\");\n\t\n\top->cycles = 2;\n}","23985":"void ssl3_clear(SSL *s)\n\t{\n\tunsigned char *rp,*wp;\n\tsize_t rlen, wlen;\n\n#ifdef TLSEXT_TYPE_opaque_prf_input\n\tif (s->s3->client_opaque_prf_input != NULL)\n\t\tOPENSSL_free(s->s3->client_opaque_prf_input);\n\ts->s3->client_opaque_prf_input = NULL;\n\tif (s->s3->server_opaque_prf_input != NULL)\n\t\tOPENSSL_free(s->s3->server_opaque_prf_input);\n\ts->s3->server_opaque_prf_input = NULL;\n#endif\n\n\tssl3_cleanup_key_block(s);\n\tif (s->s3->tmp.ca_names != NULL)\n\t\tsk_X509_NAME_pop_free(s->s3->tmp.ca_names,X509_NAME_free);\n\n\tif (s->s3->rrec.comp != NULL)\n\t\t{\n\t\tOPENSSL_free(s->s3->rrec.comp);\n\t\ts->s3->rrec.comp=NULL;\n\t\t}\n#ifndef OPENSSL_NO_DH\n\tif (s->s3->tmp.dh != NULL)\n\t\tDH_free(s->s3->tmp.dh);\n#endif\n#ifndef OPENSSL_NO_ECDH\n\tif (s->s3->tmp.ecdh != NULL)\n\t\tEC_KEY_free(s->s3->tmp.ecdh);\n#endif\n\n\trp = s->s3->rbuf.buf;\n\twp = s->s3->wbuf.buf;\n\trlen = s->s3->rbuf.len;\n \twlen = s->s3->wbuf.len;\n\tif (s->s3->handshake_buffer) {\n\t\tBIO_free(s->s3->handshake_buffer);\n\t\ts->s3->handshake_buffer = NULL;\n\t}\n\tif (s->s3->handshake_dgst) {\n\t\tssl3_free_digest_list(s);\n\t}\t\n\tmemset(s->s3,0,sizeof *s->s3);\n\ts->s3->rbuf.buf = rp;\n\ts->s3->wbuf.buf = wp;\n\ts->s3->rbuf.len = rlen;\n \ts->s3->wbuf.len = wlen;\n\n\tssl_free_wbio_buffer(s);\n\n\ts->packet_length=0;\n\ts->s3->renegotiate=0;\n\ts->s3->total_renegotiations=0;\n\ts->s3->num_renegotiations=0;\n\ts->s3->in_read_app_data=0;\n\ts->version=SSL3_VERSION;\n\t}","24503":"  int64 FeatureCount(int64 batch) const override {\n    return row_splits_(batch + 1) - row_splits_(batch);\n  }","24986":"parser_compiled_code_set_function_name (parser_context_t *context_p, \n                                        ecma_compiled_code_t *bytecode_p, \n                                        uint16_t name_index, \n                                        uint32_t status_flags) \n{\n  ecma_value_t *func_name_start_p;\n  func_name_start_p = ecma_compiled_code_resolve_function_name ((const ecma_compiled_code_t *) bytecode_p);\n\n  if (JERRY_UNLIKELY (!ecma_is_value_magic_string (*func_name_start_p, LIT_MAGIC_STRING__EMPTY)))\n  {\n    return;\n  }\n\n  parser_scope_stack_t *scope_stack_start_p = context_p->scope_stack_p;\n  parser_scope_stack_t *scope_stack_p = scope_stack_start_p + context_p->scope_stack_top;\n\n  while (scope_stack_p > scope_stack_start_p)\n  {\n    scope_stack_p--;\n\n    if (scope_stack_p->map_from != PARSER_SCOPE_STACK_FUNC\n        && scanner_decode_map_to (scope_stack_p) == name_index)\n    {\n      name_index = scope_stack_p->map_from;\n      break;\n    }\n  }\n\n  lexer_literal_t *name_lit_p = (lexer_literal_t *) PARSER_GET_LITERAL (name_index);\n\n  if (name_lit_p->type != LEXER_IDENT_LITERAL && name_lit_p->type != LEXER_STRING_LITERAL)\n  {\n    return;\n  }\n\n  uint8_t *name_buffer_p = (uint8_t *) name_lit_p->u.char_p;\n  uint32_t name_length = name_lit_p->prop.length;\n\n  if (status_flags & (PARSER_IS_PROPERTY_GETTER | PARSER_IS_PROPERTY_SETTER))\n  {\n    name_length += 4;\n    name_buffer_p = (uint8_t *) parser_malloc (context_p, name_length * sizeof (uint8_t));\n    char *prefix_p = (status_flags & PARSER_IS_PROPERTY_GETTER) ? \"STR\";\n    memcpy (name_buffer_p, prefix_p, 4);\n    memcpy (name_buffer_p + 4, name_lit_p->u.char_p, name_lit_p->prop.length);\n  }\n\n  *func_name_start_p = ecma_find_or_create_literal_string (name_buffer_p, name_length);\n\n  if (name_buffer_p != name_lit_p->u.char_p)\n  {\n    parser_free (name_buffer_p, name_length);\n  }\n} ","24614":"rsvg_cairo_new_drawing_ctx (cairo_t * cr, RsvgHandle * handle)\n{\n    RsvgDimensionData data;\n    RsvgDrawingCtx *draw;\n    RsvgCairoRender *render;\n    RsvgState *state;\n    cairo_matrix_t affine;\n    double bbx0, bby0, bbx1, bby1;\n\n    rsvg_handle_get_dimensions (handle, &data);\n    if (data.width == 0 || data.height == 0)\n        return NULL;\n\n    draw = g_new (RsvgDrawingCtx, 1);\n\n    cairo_get_matrix (cr, &affine);\n\n    \n    rsvg_cairo_transformed_image_bounding_box (&affine,\n                                               data.width, data.height,\n                                               &bbx0, &bby0, &bbx1, &bby1);\n\n    render = rsvg_cairo_render_new (cr, bbx1 - bbx0, bby1 - bby0);\n\n    if (!render)\n        return NULL;\n\n    draw->render = (RsvgRender *) render;\n    render->offset_x = bbx0;\n    render->offset_y = bby0;\n\n    draw->state = NULL;\n\n    draw->defs = handle->priv->defs;\n    draw->base_uri = g_strdup (handle->priv->base_uri);\n    draw->dpi_x = handle->priv->dpi_x;\n    draw->dpi_y = handle->priv->dpi_y;\n    draw->vb.rect.width = data.em;\n    draw->vb.rect.height = data.ex;\n    draw->pango_context = NULL;\n    draw->drawsub_stack = NULL;\n    draw->ptrs = NULL;\n\n    rsvg_state_push (draw);\n    state = rsvg_current_state (draw);\n\n    \n    cairo_matrix_multiply (&state->affine, &affine, &state->affine);\n\n    \n    cairo_matrix_init_scale (&affine, data.width \/ data.em, data.height \/ data.ex);\n    cairo_matrix_multiply (&state->affine, &affine, &state->affine);\n\n    \n    state->affine.x0 -= render->offset_x;\n    state->affine.y0 -= render->offset_y;\n\n    rsvg_bbox_init (&((RsvgCairoRender *) draw->render)->bbox, &state->affine);\n\n    return draw;\n}","25047":"static bool is_legal_file(const std::string &filename)\n{\n\tDBG_FS << \"STR\";\n\n\tif (filename.empty()) {\n\t\tLOG_FS << \"STR\";\n\t\treturn false;\n\t}\n\n\tif (filename.find(\"STR\") != std::string::npos) {\n\t\tERR_FS << \"STR\";\n\t\treturn false;\n\t}\n\n\treturn true;\n}","24558":"set_string_2_svc(sstring_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                               arg->princ, NULL)) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(\"STR\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_set_string((void *)handle, arg->princ, arg->key,\n                                    arg->value);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"STR\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","24493":"_PyString_Join(PyObject *sep, PyObject *x)\n{\n    assert(sep != NULL && PyString_Check(sep));\n    assert(x != NULL);\n    return string_join((PyStringObject *)sep, x);\n}","23893":"        static int on_message_complete(http_parser* self_)\n        {\n            HTTPParser* self = static_cast<HTTPParser*>(self_);\n\n            self->process_message();\n            return 0;\n        }","24358":"init_ext2_xattr(void)\n{\n\treturn 0;\n}","24129":"  void Compute(OpKernelContext* c) override {\n    const Tensor& tag = c->input(0);\n    OP_REQUIRES(c, TensorShapeUtils::IsScalar(tag.shape()),\n                errors::InvalidArgument(\"STR\"));\n    const Tensor& tensor = c->input(1);\n    const Tensor& serialized_summary_metadata_tensor = c->input(2);\n\n    Summary s;\n    Summary::Value* v = s.add_value();\n    v->set_tag(string(tag.scalar<tstring>()()));  \n\n    if (tensor.dtype() == DT_STRING) {\n      \n      tensor.AsProtoField(v->mutable_tensor());\n    } else {\n      tensor.AsProtoTensorContent(v->mutable_tensor());\n    }\n\n    ParseFromTString(serialized_summary_metadata_tensor.scalar<tstring>()(),\n                     v->mutable_metadata());\n\n    Tensor* summary_tensor = nullptr;\n    OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape({}), &summary_tensor));\n    CHECK(SerializeToTString(s, &summary_tensor->scalar<tstring>()()));\n  }","24994":"static int keyring_search_iterator(const void *object, void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tunsigned long kflags = key->flags;\n\n\tkenter(\"STR\", key->serial);\n\n\t\n\tif (key->type != ctx->index_key.type) {\n\t\tkleave(\"STR\");\n\t\treturn 0;\n\t}\n\n\t\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\tif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED))) {\n\t\t\tctx->result = ERR_PTR(-EKEYREVOKED);\n\t\t\tkleave(\"STR\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\n\t\tif (key->expiry && ctx->now.tv_sec >= key->expiry) {\n\t\t\tif (!(ctx->flags & KEYRING_SEARCH_SKIP_EXPIRED))\n\t\t\t\tctx->result = ERR_PTR(-EKEYEXPIRED);\n\t\t\tkleave(\"STR\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t\n\tif (!ctx->match_data.cmp(key, &ctx->match_data)) {\n\t\tkleave(\"STR\");\n\t\treturn 0;\n\t}\n\n\t\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0) {\n\t\tctx->result = ERR_PTR(-EACCES);\n\t\tkleave(\"STR\", ctx->skipped_ret);\n\t\tgoto skipped;\n\t}\n\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\t\n\t\tif (kflags & (1 << KEY_FLAG_NEGATIVE)) {\n\t\t\tsmp_rmb();\n\t\t\tctx->result = ERR_PTR(key->reject_error);\n\t\t\tkleave(\"STR\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t\n\tctx->result = make_key_ref(key, ctx->possessed);\n\tkleave(\"STR\");\n\treturn 1;\n\nskipped:\n\treturn ctx->skipped_ret;\n}","24798":"  ptr_t GC_wince_get_mem(word bytes)\n  {\n    ptr_t result = 0; \n    word i;\n\n    bytes = ROUNDUP_PAGESIZE(bytes);\n\n    \n    for (i = 0; i < GC_n_heap_bases; i++) {\n        if (((word)(-(signed_word)GC_heap_lengths[i])\n             & (GC_sysinfo.dwAllocationGranularity-1))\n            >= bytes) {\n            result = GC_heap_bases[i] + GC_heap_lengths[i];\n            break;\n        }\n    }\n\n    if (i == GC_n_heap_bases) {\n        \n        word res_bytes = (bytes + GC_sysinfo.dwAllocationGranularity-1)\n                         & ~(GC_sysinfo.dwAllocationGranularity-1);\n        \n        \n        \n        \n        result = (ptr_t) VirtualAlloc(NULL, res_bytes,\n                                MEM_RESERVE | MEM_TOP_DOWN,\n                                GC_pages_executable ? PAGE_EXECUTE_READWRITE :\n                                                      PAGE_READWRITE);\n        if (HBLKDISPL(result) != 0) ABORT(\"STR\");\n            \n            \n        if (GC_n_heap_bases >= MAX_HEAP_SECTS) ABORT(\"STR\");\n        if (result == NULL) return NULL;\n        GC_heap_bases[GC_n_heap_bases] = result;\n        GC_heap_lengths[GC_n_heap_bases] = 0;\n        GC_n_heap_bases++;\n    }\n\n    \n    result = (ptr_t) VirtualAlloc(result, bytes, MEM_COMMIT,\n                              GC_pages_executable ? PAGE_EXECUTE_READWRITE :\n                                                    PAGE_READWRITE);\n#   undef IGNORE_PAGES_EXECUTABLE\n\n    if (result != NULL) {\n        if (HBLKDISPL(result) != 0) ABORT(\"STR\");\n        GC_heap_lengths[i] += bytes;\n    }\n\n    return(result);\n  }","24668":"static int usb_raremono_probe(struct usb_interface *intf,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct raremono_device *radio;\n\tint retval = 0;\n\n\tradio = devm_kzalloc(&intf->dev, sizeof(struct raremono_device), GFP_KERNEL);\n\tif (radio)\n\t\tradio->buffer = devm_kmalloc(&intf->dev, BUFFER_LENGTH, GFP_KERNEL);\n\n\tif (!radio || !radio->buffer)\n\t\treturn -ENOMEM;\n\n\tradio->usbdev = interface_to_usbdev(intf);\n\tradio->intf = intf;\n\n\t\n\tmsleep(20);\n\tretval = usb_control_msg(radio->usbdev,\n\t\tusb_rcvctrlpipe(radio->usbdev, 0),\n\t\tHID_REQ_GET_REPORT,\n\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t1, 2,\n\t\tradio->buffer, 3, 500);\n\tif (retval != 3 ||\n\t    (get_unaligned_be16(&radio->buffer[1]) & 0xfff) == 0x0242) {\n\t\tdev_info(&intf->dev, \"STR\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(&intf->dev, \"STR\",\n\t\t\tid->idVendor, id->idProduct);\n\n\tretval = v4l2_device_register(&intf->dev, &radio->v4l2_dev);\n\tif (retval < 0) {\n\t\tdev_err(&intf->dev, \"STR\");\n\t\treturn retval;\n\t}\n\n\tmutex_init(&radio->lock);\n\n\tstrscpy(radio->vdev.name, radio->v4l2_dev.name,\n\t\tsizeof(radio->vdev.name));\n\tradio->vdev.v4l2_dev = &radio->v4l2_dev;\n\tradio->vdev.fops = &usb_raremono_fops;\n\tradio->vdev.ioctl_ops = &usb_raremono_ioctl_ops;\n\tradio->vdev.lock = &radio->lock;\n\tradio->vdev.release = video_device_release_empty;\n\tradio->vdev.device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;\n\n\tusb_set_intfdata(intf, &radio->v4l2_dev);\n\n\tvideo_set_drvdata(&radio->vdev, radio);\n\n\traremono_cmd_main(radio, BAND_FM, 95160);\n\n\tretval = video_register_device(&radio->vdev, VFL_TYPE_RADIO, -1);\n\tif (retval == 0) {\n\t\tdev_info(&intf->dev, \"STR\",\n\t\t\t\tvideo_device_node_name(&radio->vdev));\n\t\treturn 0;\n\t}\n\tdev_err(&intf->dev, \"STR\");\n\tv4l2_device_unregister(&radio->v4l2_dev);\n\treturn retval;\n}","24378":"static int htc_config_pipe_credits(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_config_pipe_msg *cp_msg;\n\tint ret;\n\tunsigned long time_left;\n\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"STR\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\n\tcp_msg = skb_put(skb, sizeof(struct htc_config_pipe_msg));\n\n\tcp_msg->message_id = cpu_to_be16(HTC_MSG_CONFIG_PIPE_ID);\n\tcp_msg->pipe_id = USB_WLAN_TX_PIPE;\n\tcp_msg->credits = target->credits;\n\n\ttarget->htc_flags |= HTC_OP_CONFIG_PIPE_CREDITS;\n\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"STR\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}","24176":"static inline const unsigned char *ReadResourceShort(const unsigned char *p,\n  unsigned short *quantum)\n{\n  *quantum=(unsigned short) (*p++ << 8);\n  *quantum|=(unsigned short) (*p++ << 0);\n  return(p);\n}static inline void WriteResourceLong(unsigned char *p,","24201":"void kvm_arch_crypto_clear_masks(struct kvm *kvm)\n{\n\tmutex_lock(&kvm->lock);\n\tkvm_s390_vcpu_block_all(kvm);\n\n\tmemset(&kvm->arch.crypto.crycb->apcb0, 0,\n\t       sizeof(kvm->arch.crypto.crycb->apcb0));\n\tmemset(&kvm->arch.crypto.crycb->apcb1, 0,\n\t       sizeof(kvm->arch.crypto.crycb->apcb1));\n\n\tVM_EVENT(kvm, 3, \"STR\");\n\t\n\tkvm_s390_sync_request_broadcast(kvm, KVM_REQ_VSIE_RESTART);\n\tkvm_s390_vcpu_unblock_all(kvm);\n\tmutex_unlock(&kvm->lock);\n}","24698":"static inline int ieee802154_match_sock(u8 *hw_addr, u16 pan_id,\n\t\tu16 short_addr, struct dgram_sock *ro)\n{\n\tif (!ro->bound)\n\t\treturn 1;\n\n\tif (ro->src_addr.addr_type == IEEE802154_ADDR_LONG &&\n\t    !memcmp(ro->src_addr.hwaddr, hw_addr, IEEE802154_ADDR_LEN))\n\t\treturn 1;\n\n\tif (ro->src_addr.addr_type == IEEE802154_ADDR_SHORT &&\n\t\t     pan_id == ro->src_addr.pan_id &&\n\t\t     short_addr == ro->src_addr.short_addr)\n\t\treturn 1;\n\n\treturn 0;\n}","24221":"safe_delay_store(struct mddev *mddev, const char *cbuf, size_t len)\n{\n\tunsigned long msec;\n\n\tif (strict_strtoul_scaled(cbuf, &msec, 3) < 0)\n\t\treturn -EINVAL;\n\tif (msec == 0)\n\t\tmddev->safemode_delay = 0;\n\telse {\n\t\tunsigned long old_delay = mddev->safemode_delay;\n\t\tunsigned long new_delay = (msec*HZ)\/1000;\n\n\t\tif (new_delay == 0)\n\t\t\tnew_delay = 1;\n\t\tmddev->safemode_delay = new_delay;\n\t\tif (new_delay < old_delay || old_delay == 0)\n\t\t\tmod_timer(&mddev->safemode_timer, jiffies+1);\n\t}\n\treturn len;\n}","24991":"GF_Err gf_isom_text_get_encoded_tx3g(GF_ISOFile *file, u32 track, u32 sidx, u32 sidx_offset, u8 **tx3g, u32 *tx3g_size)\n{\n\tGF_BitStream *bs;\n\tGF_TrackBox *trak;\n\tGF_Tx3gSampleEntryBox *a;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\ta = (GF_Tx3gSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sidx-1);\n\tif (!a) return GF_BAD_PARAM;\n\tif ((a->type != GF_ISOM_BOX_TYPE_TX3G) && (a->type != GF_ISOM_BOX_TYPE_TEXT)) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_write_tx3g(a, bs, sidx, sidx_offset);\n\t*tx3g = NULL;\n\t*tx3g_size = 0;\n\tgf_bs_get_content(bs, tx3g, tx3g_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}","24217":"mwifiex_set_uap_rates(struct mwifiex_uap_bss_param *bss_cfg,\n\t\t      struct cfg80211_ap_settings *params)\n{\n\tstruct ieee_types_header *rate_ie;\n\tint var_offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tconst u8 *var_pos = params->beacon.head + var_offset;\n\tint len = params->beacon.head_len - var_offset;\n\tu8 rate_len = 0;\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len);\n\tif (rate_ie) {\n\t\tmemcpy(bss_cfg->rates, rate_ie + 1, rate_ie->len);\n\t\trate_len = rate_ie->len;\n\t}\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t   params->beacon.tail,\n\t\t\t\t\t   params->beacon.tail_len);\n\tif (rate_ie)\n\t\tmemcpy(bss_cfg->rates + rate_len, rate_ie + 1, rate_ie->len);\n\n\treturn;\n}","24871":"bytesPerDeepLineTable (const Header &header,\n                       int minY, int maxY,\n                       const char* base,\n                       int xStride,\n                       int yStride,\n                       vector<size_t> &bytesPerLine)\n{\n    const Box2i &dataWindow = header.dataWindow();\n    const ChannelList &channels = header.channels();\n\n    for (ChannelList::ConstIterator c = channels.begin();\n         c != channels.end();\n         ++c)\n    {\n        const int ySampling = abs(c.channel().ySampling);\n        const int xSampling = abs(c.channel().xSampling);\n        const int pixelSize = pixelTypeSize (c.channel().type);\n\n        \n        \n        \n        \n        \n        \n        \n        \n        const int sampleMinY = roundToNextMultiple(minY, ySampling);\n        const int sampleMaxY = roundToPrevMultiple(maxY, ySampling);\n        const int sampleMinX = roundToNextMultiple(dataWindow.min.x, xSampling);\n        const int sampleMaxX = roundToPrevMultiple(dataWindow.max.x, xSampling);\n\n        for (int y = sampleMinY; y <= sampleMaxY; y+=ySampling)\n        {\n            int nBytes = 0;\n            for (int x = sampleMinX; x <= sampleMaxX; x += xSampling)\n            {\n                nBytes += pixelSize *\n                          sampleCount(base, xStride, yStride, x, y);\n            }\n            bytesPerLine[y - dataWindow.min.y] += nBytes;\n        }\n    }\n\n    size_t maxBytesPerLine = 0;\n\n    for (int y = minY; y <= maxY; ++y)\n        if (maxBytesPerLine < bytesPerLine[y - dataWindow.min.y])\n            maxBytesPerLine = bytesPerLine[y - dataWindow.min.y];\n\n    return maxBytesPerLine;\n}","24400":"static int pam_get_pwd(pam_handle_t *pamh, char **pwd, char *text, int oitem, int nitem)\n{\n  int rv;\n  const char *old_pwd;\n  struct pam_conv *conv;\n  struct pam_message msg;\n  struct pam_response *resp;\n  \n  const struct pam_message *(msgp[1]);\n  msgp[0] = &msg;\n\n  \n  if ((oitem == PAM_AUTHTOK) || (oitem == PAM_OLDAUTHTOK)) {\n    \n    rv = pam_get_item(pamh, oitem, &old_pwd);\n    if (rv != PAM_SUCCESS)\n      return rv;\n    if (old_pwd != NULL) {\n      *pwd = strdup(old_pwd);\n      return PAM_SUCCESS;\n    }\n  }\n\n  \n  if (text != NULL) {\n    msg.msg_style = PAM_PROMPT_ECHO_OFF;\n    msg.msg = text;\n    rv = pam_get_item(pamh, PAM_CONV, &conv);\n    if (rv != PAM_SUCCESS)\n      return rv;\n    if ((conv == NULL) || (conv->conv == NULL))\n      return PAM_CRED_INSUFFICIENT;\n    rv = conv->conv(1, msgp, &resp, conv->appdata_ptr);\n    if (rv != PAM_SUCCESS)\n      return rv;\n    if ((resp == NULL) || (resp[0].resp == NULL))\n      return PAM_CRED_INSUFFICIENT;\n    *pwd = strdup(resp[0].resp);\n    \n    cleanse(resp[0].resp, strlen(resp[0].resp));\n    free(&resp[0]);\n    \n    if ((nitem == PAM_AUTHTOK) || (nitem == PAM_OLDAUTHTOK)) {\n      rv = pam_set_item(pamh, nitem, *pwd);\n      if (rv != PAM_SUCCESS)\n        return rv;\n    }\n    return PAM_SUCCESS;\n  }\n  return PAM_CRED_INSUFFICIENT;\n}","25010":"static void ZRLE_ENCODE (int x, int y, int w, int h,\n\t\t  zrleOutStream* os, void* buf\n                  EXTRA_ARGS\n                  )\n{\n  int ty;\n  for (ty = y; ty < y+h; ty += rfbZRLETileHeight) {\n    int tx, th = rfbZRLETileHeight;\n    if (th > y+h-ty) th = y+h-ty;\n    for (tx = x; tx < x+w; tx += rfbZRLETileWidth) {\n      int tw = rfbZRLETileWidth;\n      if (tw > x+w-tx) tw = x+w-tx;\n\n      GET_IMAGE_INTO_BUF(tx,ty,tw,th,buf);\n\n      ZRLE_ENCODE_TILE((PIXEL_T*)buf, tw, th, os,\n\t\t      cl->zywrleLevel, cl->zywrleBuf);\n    }\n  }\n  zrleOutStreamFlush(os);\n}","24374":"tiff_error_handler (const char *mod, const char *fmt, va_list ap)\n{\n        if (global_error) {                \n                \n                return;\n        }\n\n        global_error = g_strdup_vprintf (fmt, ap);\n}","24707":"void LinkResolver::resolve_handle_call(CallInfo& result, KlassHandle resolved_klass,\n                                       Symbol* method_name, Symbol* method_signature,\n                                       KlassHandle current_klass,\n                                       TRAPS) {\n  \n  assert(resolved_klass() == SystemDictionary::MethodHandle_klass(), \"\");\n  assert(MethodHandles::is_signature_polymorphic_name(method_name), \"\");\n  methodHandle resolved_method;\n  Handle       resolved_appendix;\n  Handle       resolved_method_type;\n  lookup_polymorphic_method(resolved_method, resolved_klass,\n                            method_name, method_signature,\n                            current_klass, &resolved_appendix, &resolved_method_type, CHECK);\n  result.set_handle(resolved_method, resolved_appendix, resolved_method_type, CHECK);\n}","24306":"static int check_clock(const clockid_t which_clock)\n{\n\tint error = 0;\n\tstruct task_struct *p;\n\tconst pid_t pid = CPUCLOCK_PID(which_clock);\n\n\tif (CPUCLOCK_WHICH(which_clock) >= CPUCLOCK_MAX)\n\t\treturn -EINVAL;\n\n\tif (pid == 0)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (!p || !(CPUCLOCK_PERTHREAD(which_clock) ?\n\t\t   same_thread_group(p, current) : has_group_leader_pid(p))) {\n\t\terror = -EINVAL;\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}","23928":"xmlSetBufferAllocationScheme(xmlBufferAllocationScheme scheme) {\n    if ((scheme == XML_BUFFER_ALLOC_EXACT) ||\n        (scheme == XML_BUFFER_ALLOC_DOUBLEIT) ||\n        (scheme == XML_BUFFER_ALLOC_HYBRID))\n\txmlBufferAllocScheme = scheme;\n}","24922":"static int ext4_xattr_make_inode_space(handle_t *handle, struct inode *inode,\n\t\t\t\t       struct ext4_inode *raw_inode,\n\t\t\t\t       int isize_diff, size_t ifree,\n\t\t\t\t       size_t bfree, int *total_ino)\n{\n\tstruct ext4_xattr_ibody_header *header = IHDR(inode, raw_inode);\n\tstruct ext4_xattr_entry *small_entry;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_xattr_entry *last;\n\tunsigned int entry_size;\t\n\tunsigned int total_size;\t\n\tunsigned int min_total_size;\n\tint error;\n\n\twhile (isize_diff > ifree) {\n\t\tentry = NULL;\n\t\tsmall_entry = NULL;\n\t\tmin_total_size = ~0U;\n\t\tlast = IFIRST(header);\n\t\t\n\t\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\t\ttotal_size = EXT4_XATTR_LEN(last->e_name_len);\n\t\t\tif (!last->e_value_inum)\n\t\t\t\ttotal_size += EXT4_XATTR_SIZE(\n\t\t\t\t\t       le32_to_cpu(last->e_value_size));\n\t\t\tif (total_size <= bfree &&\n\t\t\t    total_size < min_total_size) {\n\t\t\t\tif (total_size + ifree < isize_diff) {\n\t\t\t\t\tsmall_entry = last;\n\t\t\t\t} else {\n\t\t\t\t\tentry = last;\n\t\t\t\t\tmin_total_size = total_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (entry == NULL) {\n\t\t\tif (small_entry == NULL)\n\t\t\t\treturn -ENOSPC;\n\t\t\tentry = small_entry;\n\t\t}\n\n\t\tentry_size = EXT4_XATTR_LEN(entry->e_name_len);\n\t\ttotal_size = entry_size;\n\t\tif (!entry->e_value_inum)\n\t\t\ttotal_size += EXT4_XATTR_SIZE(\n\t\t\t\t\t      le32_to_cpu(entry->e_value_size));\n\t\terror = ext4_xattr_move_to_block(handle, inode, raw_inode,\n\t\t\t\t\t\t entry);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t*total_ino -= entry_size;\n\t\tifree += total_size;\n\t\tbfree -= total_size;\n\t}\n\n\treturn 0;\n}","24236":"httpRead(http_t *http,\t\t\t\n         char   *buffer,\t\t\n\t int    length)\t\t\t\n{\n  return ((int)httpRead2(http, buffer, (size_t)length));\n}","25025":"isint_w(const wchar_t *start, const wchar_t *end, int *result)\n{\n\tint n = 0;\n\tif (start >= end)\n\t\treturn (0);\n\twhile (start < end) {\n\t\tif (*start < '0' || *start > '9')\n\t\t\treturn (0);\n\t\tif (n > (INT_MAX \/ 10) ||\n\t\t    (n == INT_MAX \/ 10 && (*start - '0') > INT_MAX % 10)) {\n\t\t\tn = INT_MAX;\n\t\t} else {\n\t\t\tn *= 10;\n\t\t\tn += *start - '0';\n\t\t}\n\t\tstart++;\n\t}\n\t*result = n;\n\treturn (1);\n}","23917":"static int sd_remove(struct device *dev)\n{\n\tstruct scsi_disk *sdkp;\n\n\tsdkp = dev_get_drvdata(dev);\n\tscsi_autopm_get_device(sdkp->device);\n\n\tasync_synchronize_full();\n\tblk_queue_prep_rq(sdkp->device->request_queue, scsi_prep_fn);\n\tblk_queue_unprep_rq(sdkp->device->request_queue, NULL);\n\tdevice_del(&sdkp->dev);\n\tdel_gendisk(sdkp->disk);\n\tsd_shutdown(dev);\n\n\tmutex_lock(&sd_ref_mutex);\n\tdev_set_drvdata(dev, NULL);\n\tput_device(&sdkp->dev);\n\tmutex_unlock(&sd_ref_mutex);\n\n\treturn 0;\n}","25021":"int compat_dccp_getsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, int __user *optlen)\n{\n\tif (level != SOL_DCCP)\n\t\treturn inet_csk_compat_getsockopt(sk, level, optname,\n\t\t\t\t\t\t  optval, optlen);\n\treturn do_dccp_getsockopt(sk, level, optname, optval, optlen);\n}","24064":"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_nack(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tunsigned *nack_cnt,\n\t\t\t\t\tpjmedia_rtcp_fb_nack nack[])\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    unsigned cnt, i;\n\n    PJ_ASSERT_RETURN(buf && nack_cnt && nack, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n\n    \n    if (hdr->pt != RTCP_RTPFB || hdr->count != 1)\n\treturn PJ_ENOTFOUND;\n\n    cnt = pj_ntohs((pj_uint16_t)hdr->length) - 2;\n    if (length < (cnt+3)*4)\n\treturn PJ_ETOOSMALL;\n\n    *nack_cnt = PJ_MIN(*nack_cnt, cnt);\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < *nack_cnt; ++i) {\n\tpj_uint16_t val;\n\n\tpj_memcpy(&val, p, 2);\n\tnack[i].pid = pj_ntohs(val);\n\tpj_memcpy(&val, p+2, 2);\n\tnack[i].blp = pj_ntohs(val);\n\tp += 4;\n    }\n\n    return PJ_SUCCESS;\n}","24658":"get_next_file(FILE *VFile, char *ptr)\n{\n\tchar *ret;\n\n\tret = fgets(ptr, PATH_MAX, VFile);\n\tif (!ret)\n\t\treturn NULL;\n\n\tif (ptr[strlen(ptr) - 1] == '\\n')\n\t\tptr[strlen(ptr) - 1] = '\\0';\n\n\treturn ret;\n}","23848":"_client_protocol_timeout (GsmXSMPClient *client)\n{\n        g_debug (\"STR\",\n                 client->priv->description,\n                 IceConnectionStatus (client->priv->ice_connection));\n\n        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);\n        gsm_client_disconnected (GSM_CLIENT (client));\n\n        return FALSE;\n}","24755":"int kvm_arch_vcpu_ioctl_get_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tstruct desc_ptr dt;\n\n\tkvm_get_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_get_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_get_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_get_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_get_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_get_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_get_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_get_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\tkvm_x86_ops->get_idt(vcpu, &dt);\n\tsregs->idt.limit = dt.size;\n\tsregs->idt.base = dt.address;\n\tkvm_x86_ops->get_gdt(vcpu, &dt);\n\tsregs->gdt.limit = dt.size;\n\tsregs->gdt.base = dt.address;\n\n\tsregs->cr0 = kvm_read_cr0(vcpu);\n\tsregs->cr2 = vcpu->arch.cr2;\n\tsregs->cr3 = kvm_read_cr3(vcpu);\n\tsregs->cr4 = kvm_read_cr4(vcpu);\n\tsregs->cr8 = kvm_get_cr8(vcpu);\n\tsregs->efer = vcpu->arch.efer;\n\tsregs->apic_base = kvm_get_apic_base(vcpu);\n\n\tmemset(sregs->interrupt_bitmap, 0, sizeof sregs->interrupt_bitmap);\n\n\tif (vcpu->arch.interrupt.pending && !vcpu->arch.interrupt.soft)\n\t\tset_bit(vcpu->arch.interrupt.nr,\n\t\t\t(unsigned long *)sregs->interrupt_bitmap);\n\n\treturn 0;\n}","24202":"  virtual void initializeServerHandshake() override {\n    fakeHandshake = new FakeServerHandshake(\n        server->getNonConstConn(),\n        FizzServerQuicHandshakeContext::Builder().build(),\n        false,\n        false,\n        GetParam().clientSentActiveConnIdTransportParam);\n  }","24140":"void addDbAdminAnyDbPrivileges(PrivilegeVector* privileges) {\n    Privilege::addPrivilegeToPrivilegeVector(\n        privileges, Privilege(ResourcePattern::forClusterResource(), ActionType::listDatabases));\n    Privilege::addPrivilegeToPrivilegeVector(\n        privileges, Privilege(ResourcePattern::forAnyNormalResource(), dbAdminRoleActions));\n    Privilege::addPrivilegeToPrivilegeVector(\n        privileges,\n        Privilege(ResourcePattern::forCollectionName(\"STR\"), readRoleActions));\n    Privilege::addPrivilegeToPrivilegeVector(\n        privileges,\n        Privilege(ResourcePattern::forCollectionName(\"STR\"), readRoleActions));\n    ActionSet profileActions = readRoleActions;\n    profileActions.addAction(ActionType::convertToCapped);\n    profileActions.addAction(ActionType::createCollection);\n    profileActions.addAction(ActionType::dropCollection);\n    Privilege::addPrivilegeToPrivilegeVector(\n        privileges,\n        Privilege(ResourcePattern::forCollectionName(\"STR\"), profileActions));\n}","24564":"static bool unreserve_highatomic_pageblock(const struct alloc_context *ac,\n\t\t\t\t\t\tbool force)\n{\n\tstruct zonelist *zonelist = ac->zonelist;\n\tunsigned long flags;\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tstruct page *page;\n\tint order;\n\tbool ret;\n\n\tfor_each_zone_zonelist_nodemask(zone, z, zonelist, ac->high_zoneidx,\n\t\t\t\t\t\t\t\tac->nodemask) {\n\t\t\n\t\tif (!force && zone->nr_reserved_highatomic <=\n\t\t\t\t\tpageblock_nr_pages)\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&zone->lock, flags);\n\t\tfor (order = 0; order < MAX_ORDER; order++) {\n\t\t\tstruct free_area *area = &(zone->free_area[order]);\n\n\t\t\tpage = list_first_entry_or_null(\n\t\t\t\t\t&area->free_list[MIGRATE_HIGHATOMIC],\n\t\t\t\t\tstruct page, lru);\n\t\t\tif (!page)\n\t\t\t\tcontinue;\n\n\t\t\t\n\t\t\tif (is_migrate_highatomic_page(page)) {\n\t\t\t\t\n\t\t\t\tzone->nr_reserved_highatomic -= min(\n\t\t\t\t\t\tpageblock_nr_pages,\n\t\t\t\t\t\tzone->nr_reserved_highatomic);\n\t\t\t}\n\n\t\t\t\n\t\t\tset_pageblock_migratetype(page, ac->migratetype);\n\t\t\tret = move_freepages_block(zone, page, ac->migratetype,\n\t\t\t\t\t\t\t\t\tNULL);\n\t\t\tif (ret) {\n\t\t\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&zone->lock, flags);\n\t}\n\n\treturn false;\n}","23948":"CAMLprim value caml_alloc_dummy(value size)\n{\n  mlsize_t wosize = Int_val(size);\n\n  if (wosize == 0) return Atom(0);\n  return caml_alloc (wosize, 0);\n}","23817":"int tcp_fragment(struct sock *sk, enum tcp_queue tcp_queue,\n\t\t struct sk_buff *skb, u32 len,\n\t\t unsigned int mss_now, gfp_t gfp)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *buff;\n\tint nsize, old_factor;\n\tint nlen;\n\tu8 flags;\n\n\tif (WARN_ON(len > skb->len))\n\t\treturn -EINVAL;\n\n\tnsize = skb_headlen(skb) - len;\n\tif (nsize < 0)\n\t\tnsize = 0;\n\n\tif (skb_unclone(skb, gfp))\n\t\treturn -ENOMEM;\n\n\t\n\tbuff = sk_stream_alloc_skb(sk, nsize, gfp, true);\n\tif (!buff)\n\t\treturn -ENOMEM; \n\n\tsk->sk_wmem_queued += buff->truesize;\n\tsk_mem_charge(sk, buff->truesize);\n\tnlen = skb->len - len - nsize;\n\tbuff->truesize += nlen;\n\tskb->truesize -= nlen;\n\n\t\n\tTCP_SKB_CB(buff)->seq = TCP_SKB_CB(skb)->seq + len;\n\tTCP_SKB_CB(buff)->end_seq = TCP_SKB_CB(skb)->end_seq;\n\tTCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(buff)->seq;\n\n\t\n\tflags = TCP_SKB_CB(skb)->tcp_flags;\n\tTCP_SKB_CB(skb)->tcp_flags = flags & ~(TCPHDR_FIN | TCPHDR_PSH);\n\tTCP_SKB_CB(buff)->tcp_flags = flags;\n\tTCP_SKB_CB(buff)->sacked = TCP_SKB_CB(skb)->sacked;\n\ttcp_skb_fragment_eor(skb, buff);\n\n\tskb_split(skb, buff, len);\n\n\tbuff->ip_summed = CHECKSUM_PARTIAL;\n\n\tbuff->tstamp = skb->tstamp;\n\ttcp_fragment_tstamp(skb, buff);\n\n\told_factor = tcp_skb_pcount(skb);\n\n\t\n\ttcp_set_skb_tso_segs(skb, mss_now);\n\ttcp_set_skb_tso_segs(buff, mss_now);\n\n\t\n\tTCP_SKB_CB(buff)->tx = TCP_SKB_CB(skb)->tx;\n\n\t\n\tif (!before(tp->snd_nxt, TCP_SKB_CB(buff)->end_seq)) {\n\t\tint diff = old_factor - tcp_skb_pcount(skb) -\n\t\t\ttcp_skb_pcount(buff);\n\n\t\tif (diff)\n\t\t\ttcp_adjust_pcount(sk, skb, diff);\n\t}\n\n\t\n\t__skb_header_release(buff);\n\ttcp_insert_write_queue_after(skb, buff, sk, tcp_queue);\n\tif (tcp_queue == TCP_FRAG_IN_RTX_QUEUE)\n\t\tlist_add(&buff->tcp_tsorted_anchor, &skb->tcp_tsorted_anchor);\n\n\treturn 0;\n}","24925":"xt_replace_table(struct xt_table *table,\n\t      unsigned int num_counters,\n\t      struct xt_table_info *newinfo,\n\t      int *error)\n{\n\tstruct xt_table_info *private;\n\tunsigned int cpu;\n\tint ret;\n\n\tret = xt_jumpstack_alloc(newinfo);\n\tif (ret < 0) {\n\t\t*error = ret;\n\t\treturn NULL;\n\t}\n\n\t\n\tlocal_bh_disable();\n\tprivate = table->private;\n\n\t\n\tif (num_counters != private->number) {\n\t\tpr_debug(\"STR\",\n\t\t\t num_counters, private->number);\n\t\tlocal_bh_enable();\n\t\t*error = -EAGAIN;\n\t\treturn NULL;\n\t}\n\n\tnewinfo->initial_entries = private->initial_entries;\n\t\n\tsmp_wmb();\n\ttable->private = newinfo;\n\n\t\n\tsmp_wmb();\n\n\t\n\tlocal_bh_enable();\n\n\t\n\tfor_each_possible_cpu(cpu) {\n\t\tseqcount_t *s = &per_cpu(xt_recseq, cpu);\n\t\tu32 seq = raw_read_seqcount(s);\n\n\t\tif (seq & 1) {\n\t\t\tdo {\n\t\t\t\tcond_resched();\n\t\t\t\tcpu_relax();\n\t\t\t} while (seq == raw_read_seqcount(s));\n\t\t}\n\t}\n\n\taudit_log_nfcfg(table->name, table->af, private->number,\n\t\t\t!private->number ? AUDIT_XT_OP_REGISTER :\n\t\t\t\t\t   AUDIT_XT_OP_REPLACE,\n\t\t\tGFP_KERNEL);\n\treturn private;\n}","23831":"merge (position_set const *s1, position_set const *s2, position_set *m)\n{\n  int i = 0, j = 0;\n\n  REALLOC_IF_NECESSARY(m->elems, m->alloc, s1->nelem + s2->nelem);\n  m->nelem = 0;\n  while (i < s1->nelem && j < s2->nelem)\n    if (s1->elems[i].index > s2->elems[j].index)\n      m->elems[m->nelem++] = s1->elems[i++];\n    else if (s1->elems[i].index < s2->elems[j].index)\n      m->elems[m->nelem++] = s2->elems[j++];\n    else\n      {\n        m->elems[m->nelem] = s1->elems[i++];\n        m->elems[m->nelem++].constraint |= s2->elems[j++].constraint;\n      }\n  while (i < s1->nelem)\n    m->elems[m->nelem++] = s1->elems[i++];\n  while (j < s2->nelem)\n    m->elems[m->nelem++] = s2->elems[j++];\n}","24231":"static NTSTATUS dcesrv_lsa_Close(struct dcesrv_call_state *dce_call, TALLOC_CTX *mem_ctx,\n\t\t\t  struct lsa_Close *r)\n{\n\tenum dcerpc_transport_t transport =\n\t\tdcerpc_binding_get_transport(dce_call->conn->endpoint->ep_description);\n\tstruct dcesrv_handle *h;\n\n\tif (transport != NCACN_NP && transport != NCALRPC) {\n\t\tDCESRV_FAULT(DCERPC_FAULT_ACCESS_DENIED);\n\t}\n\n\t*r->out.handle = *r->in.handle;\n\n\tDCESRV_PULL_HANDLE(h, r->in.handle, DCESRV_HANDLE_ANY);\n\n\ttalloc_free(h);\n\n\tZERO_STRUCTP(r->out.handle);\n\n\treturn NT_STATUS_OK;\n}","24238":"build_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(full_path, vol->UNC, unc_len);\n\tpos = full_path + unc_len;\n\n\tif (pplen) {\n\t\t*pos++ = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos, vol->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t*pos = '\\0'; \n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"STR\", __func__, full_path);\n\treturn full_path;\n}","23838":"stack_param_list_read(stack_param_list * plist, ref_stack_t * pstack,\n                      uint skip, const ref * ppolicies, bool require_all,\n                      gs_ref_memory_t *imem)\n{\n    iparam_list *const iplist = (iparam_list *) plist;\n    uint count = ref_stack_counttomark(pstack);\n\n    if (count == 0)\n        return_error(gs_error_unmatchedmark);\n    count -= skip + 1;\n    if (count & 1)\n        return_error(gs_error_rangecheck);\n    plist->u.r.read = stack_param_read;\n    plist->enumerate = stack_param_enumerate;\n    plist->pstack = pstack;\n    plist->skip = skip;\n    return ref_param_read_init(iplist, count >> 1, ppolicies, require_all, imem);\n}","24998":"void pointZZ_pDouble(PointZZ_p * rop, const PointZZ_p * op, const CurveZZ_p * curve) {\n    mpz_t numer, denom, lambda;\n    mpz_inits(numer, denom, lambda, NULL);\n\n    \n    mpz_mul(numer, op->x, op->x);\n    mpz_mul_ui(numer, numer, 3);\n    mpz_add(numer, numer, curve->a);\n    mpz_mul_ui(denom, op->y, 2);\n    mpz_invert(denom, denom, curve->p);  \n    mpz_mul(lambda, numer, denom);\n    mpz_mod(lambda, lambda, curve->p);\n\n    \n    mpz_mul(rop->x, lambda, lambda);\n    mpz_sub(rop->x, rop->x, op->x);\n    mpz_sub(rop->x, rop->x, op->x);\n    mpz_mod(rop->x, rop->x, curve->p);\n\n    \n    mpz_sub(rop->y, op->x, rop->x);\n    mpz_mul(rop->y, lambda, rop->y);\n    mpz_sub(rop->y, rop->y, op->y);\n    mpz_mod(rop->y, rop->y, curve->p);\n\n    mpz_clears(numer, denom, lambda, NULL);\n}","24383":"reverseSamplesBytes (uint16 spp, uint16 bps, uint32 width, \n                     uint8 *src, uint8 *dst)\n  {\n  int i;\n  uint32  col, bytes_per_pixel, col_offset;\n  uint8   bytebuff1;\n  unsigned char swapbuff[32];\n  \n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"STR\");\n    return (1);\n    }\n\n  bytes_per_pixel  = ((bps * spp) + 7) \/ 8;\n  switch (bps \/ 8)\n     {\n     case 8:  \n     case 4:\n     case 3:\n     case 2: for (col = 0; col < (width \/ 2); col++)\n               {\n\t       col_offset = col * bytes_per_pixel;                     \n\t       _TIFFmemcpy (swapbuff, src + col_offset, bytes_per_pixel);\n\t       _TIFFmemcpy (src + col_offset, dst - col_offset - bytes_per_pixel, bytes_per_pixel);\n\t       _TIFFmemcpy (dst - col_offset - bytes_per_pixel, swapbuff, bytes_per_pixel);\n               }\n\t     break;\n     case 1: \n             for (col = 0; col < (width \/ 2); col++)\n               { \n\t       for (i = 0; i < spp; i++)\n                  {\n\t\t  bytebuff1 = *src;\n\t\t  *src++ = *(dst - spp + i);\n                  *(dst - spp + i) = bytebuff1;\n\t\t  }\n\t\tdst -= spp;\n                }\n\t     break;\n     default: TIFFError(\"STR\", bps);\n       return (1);\n     }\n  return (0);\n  } ","24826":"address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,\n                                 hwaddr *plen, bool resolve_subpage)\n{\n    MemoryRegionSection *section;\n    Int128 diff;\n\n    section = address_space_lookup_region(d, addr, resolve_subpage);\n    \n    addr -= section->offset_within_address_space;\n\n    \n    *xlat = addr + section->offset_within_region;\n\n    diff = int128_sub(section->mr->size, int128_make64(addr));\n    *plen = int128_get64(int128_min(diff, int128_make64(*plen)));\n    return section;\n}","24964":"static char *handle_new_problem(GVariant *problem_info, uid_t caller_uid, char **error)\n{\n    problem_data_t *pd = problem_data_new();\n\n    GVariantIter *iter;\n    g_variant_get(problem_info, \"STR\", &iter);\n    gchar *key, *value;\n    while (g_variant_iter_loop(iter, \"STR\", &key, &value))\n    {\n        problem_data_add_text_editable(pd, key, value);\n    }\n\n    if (caller_uid != 0 || problem_data_get_content_or_NULL(pd, FILENAME_UID) == NULL)\n    {   \n        log_info(\"STR\", caller_uid);\n        char buf[sizeof(uid_t) * 3 + 2];\n        snprintf(buf, sizeof(buf), \"STR\", caller_uid);\n        problem_data_add_text_noteditable(pd, FILENAME_UID, buf);\n    }\n\n    \n    problem_data_add_basics(pd);\n\n    char *problem_id = problem_data_save(pd);\n    if (problem_id)\n        notify_new_path(problem_id);\n    else if (error)\n        *error = xasprintf(\"STR\");\n\n    problem_data_free(pd);\n    return problem_id;\n}","24691":"XML_SetCdataSectionHandler(XML_Parser parser,\n                           XML_StartCdataSectionHandler start,\n                           XML_EndCdataSectionHandler end) {\n  if (parser == NULL)\n    return;\n  parser->m_startCdataSectionHandler = start;\n  parser->m_endCdataSectionHandler = end;\n}","25054":"static void mntput_no_expire(struct mount *mnt)\n{\n\trcu_read_lock();\n\tmnt_add_count(mnt, -1);\n\tif (likely(mnt->mnt_ns)) { \n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tlock_mount_hash();\n\tif (mnt_get_count(mnt)) {\n\t\trcu_read_unlock();\n\t\tunlock_mount_hash();\n\t\treturn;\n\t}\n\tif (unlikely(mnt->mnt.mnt_flags & MNT_DOOMED)) {\n\t\trcu_read_unlock();\n\t\tunlock_mount_hash();\n\t\treturn;\n\t}\n\tmnt->mnt.mnt_flags |= MNT_DOOMED;\n\trcu_read_unlock();\n\n\tlist_del(&mnt->mnt_instance);\n\tunlock_mount_hash();\n\n\tif (likely(!(mnt->mnt.mnt_flags & MNT_INTERNAL))) {\n\t\tstruct task_struct *task = current;\n\t\tif (likely(!(task->flags & PF_KTHREAD))) {\n\t\t\tinit_task_work(&mnt->mnt_rcu, __cleanup_mnt);\n\t\t\tif (!task_work_add(task, &mnt->mnt_rcu, true))\n\t\t\t\treturn;\n\t\t}\n\t\tif (llist_add(&mnt->mnt_llist, &delayed_mntput_list))\n\t\t\tschedule_delayed_work(&delayed_mntput_work, 1);\n\t\treturn;\n\t}\n\tcleanup_mnt(mnt);\n}","23823":"QPDF::pipeStreamData(int objid, int generation,\n\t\t     qpdf_offset_t offset, size_t length,\n\t\t     QPDFObjectHandle stream_dict,\n\t\t     Pipeline* pipeline,\n                     bool suppress_warnings,\n                     bool will_retry)\n{\n    bool is_attachment_stream = this->m->attachment_streams.count(\n        QPDFObjGen(objid, generation));\n    return pipeStreamData(\n        this->m->encp, this->m->file, *this,\n        objid, generation, offset, length,\n        stream_dict, is_attachment_stream,\n        pipeline, suppress_warnings, will_retry);\n}","24575":"static SymbolsMetadata parseMetadata(RBuffer *buf, int off) {\n\tSymbolsMetadata sm = {0};\n\tut8 b[0x100] = {0};\n\t(void)r_buf_read_at (buf, off, b, sizeof (b));\n\tsm.addr = off;\n\tsm.cputype = r_read_le32 (b);\n\tsm.arch = typeString (sm.cputype, &sm.bits);\n\t\n\t\n\tsm.subtype = r_read_le32 (b + 4);\n\tsm.cpu = subtypeString (sm.subtype);\n\t\n\tsm.n_segments = r_read_le32 (b + 8);\n\t\n\tsm.namelen = r_read_le32 (b + 0xc);\n\t\n\t\n\t\n\tint delta = 16;\n\t\n\tsm.size = (sm.n_segments * 32) + sm.namelen + delta;\n\n\t\n\tut32 nm, nm2, nm3;\n\tr_buf_read_at (buf, off + sm.size, (ut8 *)&nm, sizeof (nm));\n\tr_buf_read_at (buf, off + sm.size + 4, (ut8 *)&nm2, sizeof (nm2));\n\tr_buf_read_at (buf, off + sm.size + 8, (ut8 *)&nm3, sizeof (nm3));\n\t\n\tif (r_read_le32 (&nm3) != 0xa1b22b1a) {\n\t\tsm.size -= 8;\n\t\t\n\t}\n\treturn sm;\n}","24858":"int regset_tls_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tstruct user_desc infobuf[GDT_ENTRY_TLS_ENTRIES];\n\tconst struct user_desc *info;\n\n\tif (pos >= GDT_ENTRY_TLS_ENTRIES * sizeof(struct user_desc) ||\n\t    (pos % sizeof(struct user_desc)) != 0 ||\n\t    (count % sizeof(struct user_desc)) != 0)\n\t\treturn -EINVAL;\n\n\tif (kbuf)\n\t\tinfo = kbuf;\n\telse if (__copy_from_user(infobuf, ubuf, count))\n\t\treturn -EFAULT;\n\telse\n\t\tinfo = infobuf;\n\n\tset_tls_desc(target,\n\t\t     GDT_ENTRY_TLS_MIN + (pos \/ sizeof(struct user_desc)),\n\t\t     info, count \/ sizeof(struct user_desc));\n\n\treturn 0;\n}","24752":"gs_grab_get_mouse (GSGrab    *grab,\n                   GdkWindow *window,\n                   GdkScreen *screen,\n                   gboolean   hide_cursor)\n{\n        GdkGrabStatus status;\n        GdkCursor    *cursor;\n\n        g_return_val_if_fail (window != NULL, FALSE);\n        g_return_val_if_fail (screen != NULL, FALSE);\n\n        cursor = get_cursor ();\n\n        gs_debug (\"STR\", (guint32) GDK_WINDOW_XID (window));\n        status = gdk_pointer_grab (window, TRUE, 0, NULL,\n                                   (hide_cursor ? cursor : NULL),\n                                   GDK_CURRENT_TIME);\n\n        if (status == GDK_GRAB_SUCCESS) {\n                grab->priv->mouse_grab_window = window;\n                grab->priv->mouse_grab_screen = screen;\n                grab->priv->mouse_hide_cursor = hide_cursor;\n        }\n\n        gdk_cursor_unref (cursor);\n\n        return status;\n}","24924":"char *jas_image_fmttostr(int fmt)\n{\n\tjas_image_fmtinfo_t *fmtinfo;\n\tif (!(fmtinfo = jas_image_lookupfmtbyid(fmt))) {\n\t\treturn 0;\n\t}\n\treturn fmtinfo->name;\n}","24909":"static inline int PixelsEqual(const Quantum *source1,ssize_t offset1,\n  const Quantum *source2,ssize_t offset2,const size_t channels)\n{\n  register ssize_t\n    i;\n\n  offset1*=channels;\n  offset2*=channels;\n  for (i=0; i < (ssize_t) channels; i++)\n    if (source1[offset1+i] != source2[offset2+i])\n      return(0);\n  return(1);\n}","24430":"int tls1_save_sigalgs(SSL *s, const unsigned char *data, int dsize)\n{\n    CERT *c = s->cert;\n    \n    if (!SSL_USE_SIGALGS(s))\n        return 1;\n    \n    if (!c)\n        return 0;\n\n    OPENSSL_free(s->s3->tmp.peer_sigalgs);\n    s->s3->tmp.peer_sigalgs = OPENSSL_malloc(dsize);\n    if (s->s3->tmp.peer_sigalgs == NULL)\n        return 0;\n    s->s3->tmp.peer_sigalgslen = dsize;\n    memcpy(s->s3->tmp.peer_sigalgs, data, dsize);\n    return 1;\n}","24774":"SYSCALL_DEFINE1(epoll_create, int, size)\n{\n\tif (size <= 0)\n\t\treturn -EINVAL;\n\n\treturn sys_epoll_create1(0);\n}","24336":"static int netbk_count_requests(struct xenvif *vif,\n\t\t\t\tstruct xen_netif_tx_request *first,\n\t\t\t\tstruct xen_netif_tx_request *txp,\n\t\t\t\tint work_to_do)\n{\n\tRING_IDX cons = vif->tx.req_cons;\n\tint frags = 0;\n\n\tif (!(first->flags & XEN_NETTXF_more_data))\n\t\treturn 0;\n\n\tdo {\n\t\tif (frags >= work_to_do) {\n\t\t\tnetdev_dbg(vif->dev, \"STR\");\n\t\t\treturn -frags;\n\t\t}\n\n\t\tif (unlikely(frags >= MAX_SKB_FRAGS)) {\n\t\t\tnetdev_dbg(vif->dev, \"STR\");\n\t\t\treturn -frags;\n\t\t}\n\n\t\tmemcpy(txp, RING_GET_REQUEST(&vif->tx, cons + frags),\n\t\t       sizeof(*txp));\n\t\tif (txp->size > first->size) {\n\t\t\tnetdev_dbg(vif->dev, \"STR\");\n\t\t\treturn -frags;\n\t\t}\n\n\t\tfirst->size -= txp->size;\n\t\tfrags++;\n\n\t\tif (unlikely((txp->offset + txp->size) > PAGE_SIZE)) {\n\t\t\tnetdev_dbg(vif->dev, \"STR\",\n\t\t\t\t txp->offset, txp->size);\n\t\t\treturn -frags;\n\t\t}\n\t} while ((txp++)->flags & XEN_NETTXF_more_data);\n\treturn frags;\n}","24645":"term_and_job_init(\n\tterm_T\t    *term,\n\ttypval_T    *argvar,\n\tchar\t    **argv,\n\tjobopt_T    *opt,\n\tjobopt_T    *orig_opt UNUSED)\n{\n    create_vterm(term, term->tl_rows, term->tl_cols);\n\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n    if (opt->jo_set2 & JO2_ANSI_COLORS)\n\tset_vterm_palette(term->tl_vterm, opt->jo_ansi_colors);\n    else\n\tinit_vterm_ansi_colors(term->tl_vterm);\n#endif\n\n    \n    term->tl_job = job_start(argvar, argv, opt, TRUE);\n    if (term->tl_job != NULL)\n\t++term->tl_job->jv_refcount;\n\n    return term->tl_job != NULL\n\t&& term->tl_job->jv_channel != NULL\n\t&& term->tl_job->jv_status != JOB_FAILED ? OK : FAIL;\n}","24857":"  event_size_change( int  delta )\n  {\n    status.ptsize += delta;\n\n    if ( status.ptsize < 64 * 1 )\n      status.ptsize = 1 * 64;\n    else if ( status.ptsize > MAXPTSIZE * 64 )\n      status.ptsize = MAXPTSIZE * 64;\n\n    FTDemo_Set_Current_Charsize( handle, status.ptsize, status.res );\n  }","24832":"static unsigned int sfq_hash(const struct sfq_sched_data *q,\n\t\t\t     const struct sk_buff *skb)\n{\n\treturn skb_get_hash_perturb(skb, q->perturbation) & (q->divisor - 1);\n}","23934":"static void get_futex_key_refs(union futex_key *key)\n{\n\tif (!key->both.ptr)\n\t\treturn;\n\n\t\n\tif (!IS_ENABLED(CONFIG_MMU)) {\n\t\tsmp_mb(); \n\t\treturn;\n\t}\n\n\tswitch (key->both.offset & (FUT_OFF_INODE|FUT_OFF_MMSHARED)) {\n\tcase FUT_OFF_INODE:\n\t\tihold(key->shared.inode); \n\t\tbreak;\n\tcase FUT_OFF_MMSHARED:\n\t\tfutex_get_mm(key); \n\t\tbreak;\n\tdefault:\n\t\t\n\t\tsmp_mb(); \n\t}\n}","24407":"__rta_reserve(struct sk_buff *skb, int attrtype, int attrlen)\n{\n\tstruct rtattr *rta;\n\tint size = RTA_LENGTH(attrlen);\n\n\trta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));\n\trta->rta_type = attrtype;\n\trta->rta_len = size;\n\tmemset(RTA_DATA(rta) + attrlen, 0, RTA_ALIGN(size) - size);\n\treturn rta;\n}","24724":"ReceiveCopyBegin(CopyState cstate)\n{\n\tif (PG_PROTOCOL_MAJOR(FrontendProtocol) >= 3)\n\t{\n\t\t\n\t\tStringInfoData buf;\n\t\tint\t\t\tnatts = list_length(cstate->attnumlist);\n\t\tint16\t\tformat = (cstate->binary ? 1 : 0);\n\t\tint\t\t\ti;\n\n\t\tpq_beginmessage(&buf, 'G');\n\t\tpq_sendbyte(&buf, format);\t\t\n\t\tpq_sendint(&buf, natts, 2);\n\t\tfor (i = 0; i < natts; i++)\n\t\t\tpq_sendint(&buf, format, 2);\t\t\n\t\tpq_endmessage(&buf);\n\t\tcstate->copy_dest = COPY_NEW_FE;\n\t\tcstate->fe_msgbuf = makeStringInfo();\n\t}\n\telse if (PG_PROTOCOL_MAJOR(FrontendProtocol) >= 2)\n\t{\n\t\t\n\t\tif (cstate->binary)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\terrmsg(\"STR\")));\n\t\tpq_putemptymessage('G');\n\t\tcstate->copy_dest = COPY_OLD_FE;\n\t}\n\telse\n\t{\n\t\t\n\t\tif (cstate->binary)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\terrmsg(\"STR\")));\n\t\tpq_putemptymessage('D');\n\t\tcstate->copy_dest = COPY_OLD_FE;\n\t}\n\t\n\tpq_flush();\n}","24267":"static bool l2cap_check_enc_key_size(struct hci_conn *hcon)\n{\n\t\n\treturn (!test_bit(HCI_CONN_ENCRYPT, &hcon->flags) ||\n\t\thcon->enc_key_size > HCI_MIN_ENC_KEY_SIZE);\n}","24528":"static int encode_compound_hdr(struct xdr_stream *xdr, struct compound_hdr *hdr)\n{\n\t__be32 *p;\n\n\tdprintk(\"STR\", (int)hdr->taglen, hdr->tag);\n\tBUG_ON(hdr->taglen > NFS4_MAXTAGLEN);\n\tRESERVE_SPACE(12+(XDR_QUADLEN(hdr->taglen)<<2));\n\tWRITE32(hdr->taglen);\n\tWRITEMEM(hdr->tag, hdr->taglen);\n\tWRITE32(NFS4_MINOR_VERSION);\n\tWRITE32(hdr->nops);\n\treturn 0;\n}","24676":"int dd_exist(const struct dump_dir *dd, const char *path)\n{\n    if (!str_is_correct_filename(path))\n        error_msg_and_die(\"STR\", path);\n\n    char *full_path = concat_path_file(dd->dd_dirname, path);\n    int ret = exist_file_dir(full_path);\n    free(full_path);\n    return ret;\n}","24665":"long dd_get_item_size(struct dump_dir *dd, const char *name)\n{\n    long size = -1;\n    char *iname = concat_path_file(dd->dd_dirname, name);\n    struct stat statbuf;\n\n    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))\n        size = statbuf.st_size;\n    else\n    {\n        if (errno == ENOENT)\n            size = 0;\n        else\n            perror_msg(\"STR\", iname);\n    }\n\n    free(iname);\n\n    return size;\n}","23861":"static void iommu_enable_dev_iotlb(struct device_domain_info *info)\n{\n\tstruct pci_dev *pdev;\n\n\tassert_spin_locked(&device_domain_lock);\n\n\tif (!info || !dev_is_pci(info->dev))\n\t\treturn;\n\n\tpdev = to_pci_dev(info->dev);\n\t\n\tif (!ecap_dit(info->iommu->ecap))\n\t\tinfo->pfsid = 0;\n\telse {\n\t\tstruct pci_dev *pf_pdev;\n\n\t\t\n\t\tpf_pdev = pci_physfn(pdev);\n\t\tinfo->pfsid = PCI_DEVID(pf_pdev->bus->number, pf_pdev->devfn);\n\t}\n\n#ifdef CONFIG_INTEL_IOMMU_SVM\n\t\n\tif (info->pasid_supported && !pci_enable_pasid(pdev, info->pasid_supported & ~1))\n\t\tinfo->pasid_enabled = 1;\n\n\tif (info->pri_supported && !pci_reset_pri(pdev) && !pci_enable_pri(pdev, 32))\n\t\tinfo->pri_enabled = 1;\n#endif\n\tif (info->ats_supported && !pci_enable_ats(pdev, VTD_PAGE_SHIFT)) {\n\t\tinfo->ats_enabled = 1;\n\t\tdomain_update_iotlb(info->domain);\n\t\tinfo->ats_qdep = pci_ats_queue_depth(pdev);\n\t}\n}","24450":"static int init_rmode_tss(struct kvm *kvm)\n{\n\tgfn_t fn;\n\tu16 data = 0;\n\tint idx, r;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tfn = kvm->arch.tss_addr >> PAGE_SHIFT;\n\tr = kvm_clear_guest_page(kvm, fn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tdata = TSS_BASE_SIZE + TSS_REDIRECTION_SIZE;\n\tr = kvm_write_guest_page(kvm, fn++, &data,\n\t\t\tTSS_IOPB_BASE_OFFSET, sizeof(u16));\n\tif (r < 0)\n\t\tgoto out;\n\tr = kvm_clear_guest_page(kvm, fn++, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tr = kvm_clear_guest_page(kvm, fn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tdata = ~0;\n\tr = kvm_write_guest_page(kvm, fn, &data,\n\t\t\t\t RMODE_TSS_SIZE - 2 * PAGE_SIZE - 1,\n\t\t\t\t sizeof(u8));\nout:\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\treturn r;\n}","23903":"bool ParseMessageSetItemImpl(io::CodedInputStream* input, MS ms) {\n  \n  \n  \n\n  uint32_t last_type_id = 0;\n\n  \n  \n  std::string message_data;\n\n  while (true) {\n    const uint32_t tag = input->ReadTagNoLastTag();\n    if (tag == 0) return false;\n\n    switch (tag) {\n      case WireFormatLite::kMessageSetTypeIdTag: {\n        uint32_t type_id;\n        if (!input->ReadVarint32(&type_id)) return false;\n        last_type_id = type_id;\n\n        if (!message_data.empty()) {\n          \n          \n          io::CodedInputStream sub_input(\n              reinterpret_cast<const uint8_t*>(message_data.data()),\n              static_cast<int>(message_data.size()));\n          sub_input.SetRecursionLimit(input->RecursionBudget());\n          if (!ms.ParseField(last_type_id, &sub_input)) {\n            return false;\n          }\n          message_data.clear();\n        }\n\n        break;\n      }\n\n      case WireFormatLite::kMessageSetMessageTag: {\n        if (last_type_id == 0) {\n          \n          uint32_t length;\n          if (!input->ReadVarint32(&length)) return false;\n          if (static_cast<int32_t>(length) < 0) return false;\n          uint32_t size = static_cast<uint32_t>(\n              length + io::CodedOutputStream::VarintSize32(length));\n          message_data.resize(size);\n          auto ptr = reinterpret_cast<uint8_t*>(&message_data[0]);\n          ptr = io::CodedOutputStream::WriteVarint32ToArray(length, ptr);\n          if (!input->ReadRaw(ptr, length)) return false;\n        } else {\n          \n          if (!ms.ParseField(last_type_id, input)) {\n            return false;\n          }\n        }\n\n        break;\n      }\n\n      case WireFormatLite::kMessageSetItemEndTag: {\n        return true;\n      }\n\n      default: {\n        if (!ms.SkipField(tag, input)) return false;\n      }\n    }\n  }\n}","24768":"MagickExport MagickBooleanType AutoLevelImage(Image *image,\n  ExceptionInfo *exception)\n{\n  return(MinMaxStretchImage(image,0.0,0.0,1.0,exception));\n}","24375":"GF_Err tfhd_box_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackFragmentHeaderBox *p;\n\tp = (GF_TrackFragmentHeaderBox *)a;\n\tgf_isom_box_dump_start(a, \"STR\", trace);\n\tgf_fprintf(trace, \"STR\", p->trackID);\n\n\tif (p->flags & GF_ISOM_TRAF_BASE_OFFSET) {\n\t\tgf_fprintf(trace, \"STR\", p->base_data_offset);\n\t} else {\n\t\tgf_fprintf(trace, \"STR\");\n\t}\n\n\tif (p->flags & GF_ISOM_TRAF_SAMPLE_DESC)\n\t\tgf_fprintf(trace, \"STR\", p->sample_desc_index);\n\tif (p->flags & GF_ISOM_TRAF_SAMPLE_DUR)\n\t\tgf_fprintf(trace, \"STR\", p->def_sample_duration);\n\tif (p->flags & GF_ISOM_TRAF_SAMPLE_SIZE)\n\t\tgf_fprintf(trace, \"STR\", p->def_sample_size);\n\n\tif (p->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) {\n\t\tfrag_dump_sample_flags(trace, p->def_sample_flags, 3);\n\t}\n\n\tgf_fprintf(trace, \"STR\");\n\n\tgf_isom_box_dump_done(\"STR\", a, trace);\n\treturn GF_OK;\n}","24928":"void color_cmyk_to_rgb(opj_image_t *image)\n{\n\tfloat C, M, Y, K;\n\tfloat sC, sM, sY, sK;\n\tunsigned int w, h, max, i;\n\n\tw = image->comps[0].w;\n\th = image->comps[0].h;\n\n\tif(image->numcomps < 4) return;\n\n\tmax = w * h;\n\t\n\tsC = 1.0F \/ (float)((1 << image->comps[0].prec) - 1);\n\tsM = 1.0F \/ (float)((1 << image->comps[1].prec) - 1);\n\tsY = 1.0F \/ (float)((1 << image->comps[2].prec) - 1);\n\tsK = 1.0F \/ (float)((1 << image->comps[3].prec) - 1);\n\n\tfor(i = 0; i < max; ++i)\n\t{\n\t\t\n\t\tC = (float)(image->comps[0].data[i]) * sC;\n\t\tM = (float)(image->comps[1].data[i]) * sM;\n\t\tY = (float)(image->comps[2].data[i]) * sY;\n\t\tK = (float)(image->comps[3].data[i]) * sK;\n\t\t\n\t\t\n\t\tC = 1.0F - C;\n\t\tM = 1.0F - M;\n\t\tY = 1.0F - Y;\n\t\tK = 1.0F - K;\n\n\t\t\n\t\timage->comps[0].data[i] = (int)(255.0F * C * K); \n\t\timage->comps[1].data[i] = (int)(255.0F * M * K); \n\t\timage->comps[2].data[i] = (int)(255.0F * Y * K); \n\t}\n\n\tfree(image->comps[3].data); image->comps[3].data = NULL;\n\timage->comps[0].prec = 8;\n\timage->comps[1].prec = 8;\n\timage->comps[2].prec = 8;\n\timage->numcomps -= 1;\n\timage->color_space = OPJ_CLRSPC_SRGB;\n\t\n\tfor (i = 3; i < image->numcomps; ++i) {\n\t\tmemcpy(&(image->comps[i]), &(image->comps[i+1]), sizeof(image->comps[i]));\n\t}\n\n}","24387":"static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)\n{\n\tstruct serial_icounter_struct icount;\n\tstruct sb_uart_icount cnow;\n\tstruct sb_uart_port *port = state->port;\n\n\tspin_lock_irq(&port->lock);\n\tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));\n\tspin_unlock_irq(&port->lock);\n\n\ticount.cts         = cnow.cts;\n\ticount.dsr         = cnow.dsr;\n\ticount.rng         = cnow.rng;\n\ticount.dcd         = cnow.dcd;\n\ticount.rx          = cnow.rx;\n\ticount.tx          = cnow.tx;\n\ticount.frame       = cnow.frame;\n\ticount.overrun     = cnow.overrun;\n\ticount.parity      = cnow.parity;\n\ticount.brk         = cnow.brk;\n\ticount.buf_overrun = cnow.buf_overrun;\n\n\treturn copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;\n}","24191":"static int calipso_doi_remove(u32 doi, struct netlbl_audit *audit_info)\n{\n\tint ret_val;\n\tstruct calipso_doi *doi_def;\n\tstruct audit_buffer *audit_buf;\n\n\tspin_lock(&calipso_doi_list_lock);\n\tdoi_def = calipso_doi_search(doi);\n\tif (!doi_def) {\n\t\tspin_unlock(&calipso_doi_list_lock);\n\t\tret_val = -ENOENT;\n\t\tgoto doi_remove_return;\n\t}\n\tif (!refcount_dec_and_test(&doi_def->refcount)) {\n\t\tspin_unlock(&calipso_doi_list_lock);\n\t\tret_val = -EBUSY;\n\t\tgoto doi_remove_return;\n\t}\n\tlist_del_rcu(&doi_def->list);\n\tspin_unlock(&calipso_doi_list_lock);\n\n\tcall_rcu(&doi_def->rcu, calipso_doi_free_rcu);\n\tret_val = 0;\n\ndoi_remove_return:\n\taudit_buf = netlbl_audit_start(AUDIT_MAC_CALIPSO_DEL, audit_info);\n\tif (audit_buf) {\n\t\taudit_log_format(audit_buf,\n\t\t\t\t \"STR\",\n\t\t\t\t doi, ret_val == 0 ? 1 : 0);\n\t\taudit_log_end(audit_buf);\n\t}\n\n\treturn ret_val;\n}","24075":"static char *theme_format_compress_colors(THEME_REC *theme, const char *format)\n{\n\tGString *str;\n\tchar *ret;\n\tchar last_fg, last_bg;\n\n\tstr = g_string_new(NULL);\n\n\tlast_fg = last_bg = '\\0';\n\twhile (*format != '\\0') {\n\t\tif (*format == '$') {\n                        \n\t\t\ttheme_format_append_variable(str, &format);\n                        last_fg = last_bg = '\\0';\n\t\t} else if (*format != '%') {\n\t\t\t\n\t\t\tg_string_append_c(str, *format);\n\t\t\tformat++;\n\t\t} else {\n\t\t\t\n\t\t\tformat++;\n\t\t\tif (IS_OLD_FORMAT(*format, last_fg, last_bg)) {\n\t\t\t\t\n\t\t\t} else if (IS_FGCOLOR_FORMAT(*format) &&\n\t\t\t\t   format[1] == '%' &&\n\t\t\t\t   IS_FGCOLOR_FORMAT(format[2]) &&\n\t\t\t\t   (*format != 'n' || format[2] == 'n')) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tg_string_append_c(str, '%');\n\t\t\t\tg_string_append_c(str, *format);\n\n\t\t\t\tif (IS_FGCOLOR_FORMAT(*format))\n\t\t\t\t\tlast_fg = *format;\n\t\t\t\telse if (*format == 'Z' || *format == 'X')\n\t\t\t\t\tlast_fg = '\\0';\n\t\t\t\tif (IS_BGCOLOR_FORMAT(*format))\n\t\t\t\t\tlast_bg = *format;\n\t\t\t\telse if (*format == 'z' || *format == 'x')\n\t\t\t\t\tlast_bg = '\\0';\n\t\t\t}\n\t\t\tformat++;\n\t\t}\n\t}\n\n\tret = str->str;\n        g_string_free(str, FALSE);\n        return ret;\n}","25027":"int read_print_config_dir(void)\n{\n    return 0;\n}","23819":"static int user_reset_fdc(int drive, int arg, bool interruptible)\n{\n\tint ret;\n\n\tif (lock_fdc(drive, interruptible))\n\t\treturn -EINTR;\n\n\tif (arg == FD_RESET_ALWAYS)\n\t\tFDCS->reset = 1;\n\tif (FDCS->reset) {\n\t\tcont = &reset_cont;\n\t\tret = wait_til_done(reset_fdc, interruptible);\n\t\tif (ret == -EINTR)\n\t\t\treturn -EINTR;\n\t}\n\tprocess_fd_request();\n\treturn 0;\n}","24225":"static unsigned int help(struct sk_buff *skb,\n\t\t\t enum ip_conntrack_info ctinfo,\n\t\t\t unsigned int protoff,\n\t\t\t unsigned int matchoff,\n\t\t\t unsigned int matchlen,\n\t\t\t struct nf_conntrack_expect *exp)\n{\n\tchar buffer[sizeof(\"STR\")];\n\tu_int16_t port;\n\tunsigned int ret;\n\n\t\n\texp->saved_proto.tcp.port = exp->tuple.dst.u.tcp.port;\n\texp->dir = IP_CT_DIR_REPLY;\n\texp->expectfn = nf_nat_follow_master;\n\n\t\n\tfor (port = ntohs(exp->saved_proto.tcp.port); port != 0; port++) {\n\t\tint ret;\n\n\t\texp->tuple.dst.u.tcp.port = htons(port);\n\t\tret = nf_ct_expect_related(exp);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\telse if (ret != -EBUSY) {\n\t\t\tport = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (port == 0) {\n\t\tnf_ct_helper_log(skb, exp->master, \"STR\");\n\t\treturn NF_DROP;\n\t}\n\n\tret = nf_nat_mangle_tcp_packet(skb, exp->master, ctinfo,\n\t\t\t\t       protoff, matchoff, matchlen, buffer,\n\t\t\t\t       strlen(buffer));\n\tif (ret != NF_ACCEPT) {\n\t\tnf_ct_helper_log(skb, exp->master, \"STR\");\n\t\tnf_ct_unexpect_related(exp);\n\t}\n\treturn ret;\n}","24523":"static void gx_ttfReader__Read(ttfReader *self, void *p, int n)\n{\n    gx_ttfReader *r = (gx_ttfReader *)self;\n    const byte *q;\n\n    if (!r->error) {\n        if (r->extra_glyph_index != -1) {\n            q = r->glyph_data.bits.data + r->pos;\n            r->error = (r->glyph_data.bits.size - r->pos < n ?\n                            gs_note_error(gs_error_invalidfont) : 0);\n            if (r->error == 0)\n                memcpy(p, q, n);\n        } else {\n            unsigned int cnt;\n\n            for (cnt = 0; cnt < (uint)n; cnt += r->error) {\n                r->error = r->pfont->data.string_proc(r->pfont, (ulong)r->pos + cnt, (ulong)n - cnt, &q);\n                if (r->error < 0)\n                    break;\n                else if ( r->error == 0) {\n                    memcpy((char *)p + cnt, q, n - cnt);\n                    break;\n                } else {\n                    memcpy((char *)p + cnt, q, r->error);\n                }\n            }\n        }\n    }\n    if (r->error) {\n        memset(p, 0, n);\n        return;\n    }\n    r->pos += n;\n}","24911":"static void vnc_refresh(DisplayChangeListener *dcl)\n{\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n    VncState *vs, *vn;\n    int has_dirty, rects = 0;\n\n    if (QTAILQ_EMPTY(&vd->clients)) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_MAX);\n        return;\n    }\n\n    graphic_hw_update(vd->dcl.con);\n\n    if (vnc_trylock_display(vd)) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n        return;\n    }\n\n    has_dirty = vnc_refresh_server_surface(vd);\n    vnc_unlock_display(vd);\n\n    QTAILQ_FOREACH_SAFE(vs, &vd->clients, next, vn) {\n        rects += vnc_update_client(vs, has_dirty, false);\n        \n    }\n\n    if (has_dirty && rects) {\n        vd->dcl.update_interval \/= 2;\n        if (vd->dcl.update_interval < VNC_REFRESH_INTERVAL_BASE) {\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_BASE;\n        }\n    } else {\n        vd->dcl.update_interval += VNC_REFRESH_INTERVAL_INC;\n        if (vd->dcl.update_interval > VNC_REFRESH_INTERVAL_MAX) {\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_MAX;\n        }\n    }\n}","23935":"static ZIPARCHIVE_METHOD(getStatusString)\n{\n\tstruct zip *intern;\n\tzval *this = getThis();\n\tint zep, syp, len;\n\tchar error_string[128];\n\n\tif (!this) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, this);\n\n\tzip_error_get(intern, &zep, &syp);\n\n\tlen = zip_error_to_str(error_string, 128, zep, syp);\n\tRETVAL_STRINGL(error_string, len, 1); \n}","25037":"stl_update_connects_remove_1(stl_file *stl, int facet_num) {\n  int j;\n\n  if (stl->error) return;\n  \n  j = ((stl->neighbors_start[facet_num].neighbor[0] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[1] == -1) +\n       (stl->neighbors_start[facet_num].neighbor[2] == -1));\n  if(j == 0) {\t\t       \n    stl->stats.connected_facets_3_edge -= 1;\n  } else if(j == 1) {\t     \n    stl->stats.connected_facets_2_edge -= 1;\n  } else if(j == 2) {\t     \n    stl->stats.connected_facets_1_edge -= 1;\n  }\n}","23896":"void ClientConnectionImpl::onResetStream(StreamResetReason reason) {\n  \n  if (!pending_responses_.empty()) {\n    pending_responses_.clear();\n    request_encoder_->runResetCallbacks(reason);\n  }\n}","24664":"listener_remove_ref_entry (GSListener *listener,\n                           int         entry_type,\n                           guint32     cookie)\n{\n        GHashTable         *hash;\n        gboolean            removed;\n        GSListenerRefEntry *entry;\n\n        removed = FALSE;\n\n        hash = get_hash_for_entry_type (listener, entry_type);\n\n        entry = g_hash_table_lookup (hash, &cookie);\n        if (entry == NULL) {\n                goto out;\n        }\n\n        gs_debug (\"STR\",\n                  get_name_for_entry_type (entry_type),\n                  entry->application,\n                  entry->reason,\n                  entry->connection);\n\n        if (entry_type == REF_ENTRY_TYPE_INHIBIT) {\n                \n                remove_session_inhibit (listener, entry);\n        }\n\n        removed = g_hash_table_remove (hash, &cookie);\n out:\n        if (removed) {\n                listener_ref_entry_check (listener, entry_type);\n        } else {\n                gs_debug (\"STR\", cookie);\n        }\n\n        return removed;\n}","24837":"cleanup(void)\n{\n    int rc;\n\n#if NO_LEAKS\n    free_namelist(namelst);\n    _nc_leaks_dump_entry();\n#endif\n    if (tmp_fp != 0)\n\tfclose(tmp_fp);\n    if (to_remove != 0) {\n#if HAVE_REMOVE\n\trc = remove(to_remove);\n#else\n\trc = unlink(to_remove);\n#endif\n\tif (rc != 0)\n\t    perror(to_remove);\n    }\n}","24044":"static int ptrace_check_attach(struct task_struct *child, bool ignore_state)\n{\n\tint ret = -ESRCH;\n\n\t\n\tread_lock(&tasklist_lock);\n\tif (child->ptrace && child->parent == current) {\n\t\tWARN_ON(READ_ONCE(child->__state) == __TASK_TRACED);\n\t\t\n\t\tif (ignore_state || ptrace_freeze_traced(child))\n\t\t\tret = 0;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tif (!ret && !ignore_state) {\n\t\tif (!wait_task_inactive(child, __TASK_TRACED)) {\n\t\t\t\n\t\t\tWARN_ON(READ_ONCE(child->__state) == __TASK_TRACED);\n\t\t\tret = -ESRCH;\n\t\t}\n\t}\n\n\treturn ret;\n}","24767":"save_text(const char *fmt, const char *s, int len)\n{\n    size_t s_len = strlen(s);\n    if (len > (int) s_len)\n\ts_len = (size_t) len;\n\n    get_space(s_len + 1);\n\n    _nc_SPRINTF(TPS(out_buff) + TPS(out_used),\n\t\t_nc_SLIMIT(TPS(out_size) - TPS(out_used))\n\t\tfmt, s);\n    TPS(out_used) += strlen(TPS(out_buff) + TPS(out_used));\n}","24237":"conntrack_flush(struct conntrack *ct, const uint16_t *zone)\n{\n    struct conn *conn;\n\n    ovs_mutex_lock(&ct->ct_lock);\n    CMAP_FOR_EACH (conn, cm_node, &ct->conns) {\n        if (!zone || *zone == conn->key.zone) {\n            conn_clean_one(ct, conn);\n        }\n    }\n    ovs_mutex_unlock(&ct->ct_lock);\n\n    return 0;\n}","24661":"BufferInputSource::findAndSkipNextEOL()\n{\n    if (this->cur_offset < 0)\n    {\n        throw std::logic_error(\"STR\");\n    }\n    qpdf_offset_t end_pos = this->buf->getSize();\n    if (this->cur_offset >= end_pos)\n    {\n\tthis->last_offset = end_pos;\n        this->cur_offset = end_pos;\n\treturn end_pos;\n    }\n\n    qpdf_offset_t result = 0;\n    size_t len = end_pos - this->cur_offset;\n    unsigned char const* buffer = this->buf->getBuffer();\n\n    void* start = const_cast<unsigned char*>(buffer) + this->cur_offset;\n    unsigned char* p1 = static_cast<unsigned char*>(memchr(start, '\\r', len));\n    unsigned char* p2 = static_cast<unsigned char*>(memchr(start, '\\n', len));\n    unsigned char* p = (p1 && p2) ? std::min(p1, p2) : p1 ? p1 : p2;\n    if (p)\n    {\n        result = p - buffer;\n        this->cur_offset = result + 1;\n        ++p;\n        while ((this->cur_offset < end_pos) &&\n               ((*p == '\\r') || (*p == '\\n')))\n        {\n            ++p;\n            ++this->cur_offset;\n        }\n    }\n    else\n    {\n        this->cur_offset = end_pos;\n        result = end_pos;\n    }\n    return result;\n}","23803":"void CompressTest::testManipulator()\n{\n\t{\n\t\tstd::ofstream out(\"STR\", std::ios::binary);\n\t\tPoco::Path theFile(ZipTest::getTestFile(\"STR\"));\n\t\tCompress c(out, true);\n\t\tc.addFile(theFile, theFile.getFileName());\n\t\tZipArchive a(c.close());\n\t}\n\tZipManipulator zm(\"STR\", true);\n\tzm.renameFile(\"STR\");\n\tzm.addFile(\"STR\"));\n\tZipArchive archive=zm.commit();\n\tassert (archive.findHeader(\"STR\") != archive.headerEnd());\n}","23931":"int CLASS parse_jpeg(int offset)\n{\n  int len, save, hlen, mark;\n  fseek(ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n    return 0;\n\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda)\n  {\n    order = 0x4d4d;\n    len = get2() - 2;\n    save = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9)\n    {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width = get2();\n    }\n    order = get2();\n    hlen = get4();\n    if (get4() == 0x48454150\n#ifdef LIBRAW_LIBRARY_BUILD\n        && (save + hlen) >= 0 && (save + hlen) <= ifp->size()\n#endif\n            ) \n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(save + hlen, len - hlen, 0);\n    }\n    if (parse_tiff(save + 6))\n      apply_tiff();\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  return 1;\n}","24967":"cmsBool  Read16bitTables(cmsContext ContextID, cmsIOHANDLER* io, cmsPipeline* lut, int nChannels, int nEntries)\n{\n    cmsStage* mpe;\n    int i;\n    cmsToneCurve* Tables[cmsMAXCHANNELS];\n\n    \n    if (nEntries <= 0) return TRUE;\n\n    \n    if (nEntries < 2) return FALSE;\n    if (nChannels > cmsMAXCHANNELS) return FALSE;\n\n    \n    memset(Tables, 0, sizeof(Tables));\n\n    for (i=0; i < nChannels; i++) {\n\n        Tables[i] = cmsBuildTabulatedToneCurve16(ContextID, nEntries, NULL);\n        if (Tables[i] == NULL) goto Error;\n\n        if (!_cmsReadUInt16Array(io, nEntries, Tables[i]->Table16)) goto Error;\n    }\n\n\n    \n    mpe = cmsStageAllocToneCurves(ContextID, nChannels, Tables);\n    if (mpe == NULL) goto Error;\n\n    cmsPipelineInsertStage(lut, cmsAT_END, mpe);\n\n    for (i=0; i < nChannels; i++)\n        cmsFreeToneCurve(Tables[i]);\n\n    return TRUE;\n\nError:\n    for (i=0; i < nChannels; i++) {\n        if (Tables[i]) cmsFreeToneCurve(Tables[i]);\n    }\n\n    return FALSE;\n}","24780":"gs_window_destroy (GSWindow *window)\n{\n        g_return_if_fail (GS_IS_WINDOW (window));\n\n        gtk_widget_destroy (GTK_WIDGET (window));\n}","24448":"static int switch_user_back_permanently(void) {\n    gid_t tmp_egid = save_egid;\n    uid_t tmp_euid = save_euid;\n    int ret = switch_user(save_euid, save_egid);\n    save_euid = tmp_euid;\n    save_egid = tmp_egid;\n    return ret;\n}","24671":"static void parse_rtcp_bye(pjmedia_rtcp_session *sess,\n\t\t\t   const void *pkt,\n\t\t\t   pj_size_t size)\n{\n    pj_str_t reason = {\"STR\", 1};\n\n    \n    if (size > 8) {\n\treason.slen = PJ_MIN(sizeof(sess->stat.peer_sdes_buf_),\n                             *((pj_uint8_t*)pkt+8));\n\tpj_memcpy(sess->stat.peer_sdes_buf_, ((pj_uint8_t*)pkt+9),\n\t\t  reason.slen);\n\treason.ptr = sess->stat.peer_sdes_buf_;\n    }\n\n    \n    PJ_LOG(5, (sess->name, \"STR\",\n\t       reason.slen, reason.ptr));\n}","24560":"int stopThreadedIOIfNeeded(void) {\n    int pending = listLength(server.clients_pending_write);\n\n    \n    if (server.io_threads_num == 1) return 1;\n\n    if (pending < (server.io_threads_num*2)) {\n        if (server.io_threads_active) stopThreadedIO();\n        return 1;\n    } else {\n        return 0;\n    }\n}","24080":"  Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        CalculateOutputIndexValueRowID(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      case RowPartitionType::ROW_SPLITS:\n        CalculateOutputIndexRowSplit(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"STR\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }","24571":"perf_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct perf_event *event = file->private_data;\n\n\treturn perf_read_hw(event, buf, count);\n}","24426":"compile_length_string_crude_node(StrNode* sn, regex_t* reg)\n{\n  if (sn->end <= sn->s)\n    return 0;\n\n  return add_compile_string_length(sn->s, 1 , (int )(sn->end - sn->s),\n                                   reg);\n}","24434":"StartDA(qqueue_t *pThis)\n{\n\tDEFiRet;\n\tuchar pszDAQName[128];\n\n\tISOBJ_TYPE_assert(pThis, qqueue);\n\n\t\n\tCHKiRet(qqueueConstruct(&pThis->pqDA, QUEUETYPE_DISK , 1, 0, pThis->pConsumer));\n\n\t\n\tsnprintf((char*) pszDAQName, sizeof(pszDAQName)\/sizeof(uchar), \"STR\", obj.GetName((obj_t*) pThis));\n\tobj.SetName((obj_t*) pThis->pqDA, pszDAQName);\n\n\t\n\tpThis->pqDA->pqParent = pThis;\n\n\tCHKiRet(qqueueSetpUsr(pThis->pqDA, pThis->pUsr));\n\tCHKiRet(qqueueSetsizeOnDiskMax(pThis->pqDA, pThis->sizeOnDiskMax));\n\tCHKiRet(qqueueSetiDeqSlowdown(pThis->pqDA, pThis->iDeqSlowdown));\n\tCHKiRet(qqueueSetMaxFileSize(pThis->pqDA, pThis->iMaxFileSize));\n\tCHKiRet(qqueueSetFilePrefix(pThis->pqDA, pThis->pszFilePrefix, pThis->lenFilePrefix));\n\tCHKiRet(qqueueSetiPersistUpdCnt(pThis->pqDA, pThis->iPersistUpdCnt));\n\tCHKiRet(qqueueSetbSyncQueueFiles(pThis->pqDA, pThis->bSyncQueueFiles));\n\tCHKiRet(qqueueSettoActShutdown(pThis->pqDA, pThis->toActShutdown));\n\tCHKiRet(qqueueSettoEnq(pThis->pqDA, pThis->toEnq));\n\tCHKiRet(qqueueSetiDeqtWinFromHr(pThis->pqDA, pThis->iDeqtWinFromHr));\n\tCHKiRet(qqueueSetiDeqtWinToHr(pThis->pqDA, pThis->iDeqtWinToHr));\n\tCHKiRet(qqueueSettoQShutdown(pThis->pqDA, pThis->toQShutdown));\n\tCHKiRet(qqueueSetiHighWtrMrk(pThis->pqDA, 0));\n\tCHKiRet(qqueueSetiDiscardMrk(pThis->pqDA, 0));\n\n\tiRet = qqueueStart(pThis->pqDA);\n\t\n\tif(iRet != RS_RET_OK && iRet != RS_RET_FILE_NOT_FOUND) {\n\t\terrno = 0; \n\t\terrmsg.LogError(errno, iRet, \"STR\");\n\t\tpThis->bIsDA = 0;\t\n\t\tFINALIZE; \n\t}\n\n\tDBGOPRINT((obj_t*) pThis, \"STR\",\n\t\t  qqueueGetID(pThis->pqDA));\n\nfinalize_it:\n\tif(iRet != RS_RET_OK) {\n\t\tif(pThis->pqDA != NULL) {\n\t\t\tqqueueDestruct(&pThis->pqDA);\n\t\t}\n\t\tDBGOPRINT((obj_t*) pThis, \"STR\", iRet);\n\t\tpThis->bIsDA = 0;\n\t}\n\n\tRETiRet;\n}","24551":"  void Compute(OpKernelContext* context) override {\n    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"STR\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"STR\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"STR\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"STR\", &dense_list_in));\n\n    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in));\n\n    std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns =\n        GenerateColumnsFromInput<InternalType>(indices_list_in, values_list_in,\n                                               shapes_list_in, dense_list_in);\n\n    const tstring k_feature_separator = \"STR\";\n    typename CrossTraits<HASHED_OUTPUT, InternalType>::Crosser crosser(\n        columns, num_buckets_, hash_key_, k_feature_separator);\n    Tensor* indices_out;\n    Tensor* values_out;\n    Tensor* shape_out;\n    const int64 batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);\n    std::vector<int64> output_start_indices(batch_size);\n    OP_REQUIRES_OK(\n        context,\n        CreateOutputTensors(columns, batch_size, context, &indices_out,\n                            &values_out, &shape_out, &output_start_indices));\n\n    typename CrossTraits<HASHED_OUTPUT, InternalType>::Updater updater(\n        output_start_indices, indices_out, values_out);\n    auto do_work = [&columns, crosser, updater](int64 begin, int64 end) {\n      for (int b = begin; b < end; b++) {\n        ProductIterator<InternalType> product_iterator(columns, b);\n        int64 cross_count = 0;\n        while (product_iterator.HasNext()) {\n          const auto permutation = product_iterator.Next();\n          updater.Update(b, cross_count,\n                         crosser.Generate(b, permutation, false));\n          cross_count++;\n        }\n      }\n    };\n\n    auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();\n    \n    const int kCostPerUnit = 5000 * indices_list_in.size();\n    Shard(worker_threads->num_threads, worker_threads->workers, batch_size,\n          kCostPerUnit, do_work);\n  }","24354":"  absl::optional<uint64_t> upstreamConnectionId() const override { return upstream_connection_id_; }","24705":"static void test_long_data()\n{\n  MYSQL_STMT *stmt;\n  int        rc, int_data;\n  char       *data= NullS;\n  MYSQL_RES  *result;\n  MYSQL_BIND my_bind[3];\n  char query[MAX_TEST_QUERY_LENGTH];\n\n  myheader(\"STR\");\n\n  rc= mysql_autocommit(mysql, TRUE);\n  myquery(rc);\n\n  rc= mysql_query(mysql, \"STR\");\n  myquery(rc);\n\n  rc= mysql_query(mysql, \"STR\"\n                         \"STR\");\n  myquery(rc);\n\n  my_stpcpy(query, \"STR\");\n  stmt= mysql_simple_prepare(mysql, query);\n  check_stmt_r(stmt);\n\n  my_stpcpy(query, \"STR\");\n  stmt= mysql_simple_prepare(mysql, query);\n  check_stmt(stmt);\n\n  verify_param_count(stmt, 3);\n\n  \n  memset(my_bind, 0, sizeof(my_bind));\n\n  my_bind[0].buffer= (void *)&int_data;\n  my_bind[0].buffer_type= MYSQL_TYPE_LONG;\n\n  my_bind[1].buffer_type= MYSQL_TYPE_STRING;\n\n  my_bind[2]= my_bind[1];\n  rc= mysql_stmt_bind_param(stmt, my_bind);\n  check_execute(stmt, rc);\n\n  int_data= 999;\n  data= (char *)\"STR\";\n\n  \n  rc= mysql_stmt_send_long_data(stmt, 1, data, strlen(data));\n  data= (char *)\"STR\";\n  rc= mysql_stmt_send_long_data(stmt, 1, data, strlen(data));\n  check_execute(stmt, rc);\n  rc= mysql_stmt_send_long_data(stmt, 2, \"STR\", 4);\n  check_execute(stmt, rc);\n\n  \n  rc= mysql_stmt_execute(stmt);\n  if (!opt_silent)\n    fprintf(stdout, \"STR\", rc);\n  check_execute(stmt, rc);\n\n  rc= mysql_commit(mysql);\n  myquery(rc);\n\n  \n  rc= mysql_query(mysql, \"STR\");\n  myquery(rc);\n\n  \n  result= mysql_store_result(mysql);\n  mytest(result);\n\n  rc= my_process_result_set(result);\n  DIE_UNLESS(rc == 1);\n  mysql_free_result(result);\n\n  verify_col_data(\"STR\");\n  verify_col_data(\"STR\");\n  verify_col_data(\"STR\");\n  mysql_stmt_close(stmt);\n}","24283":"std::string get_wml_location(const std::string &filename, const std::string &current_dir)\n{\n\tDBG_FS << \"STR\" << std::endl;\n\n\tassert(game_config::path.empty() == false);\n\n\tstd::string result;\n\n\tif (filename.empty()) {\n\t\tLOG_FS << \"STR\" << std::endl;\n\t\treturn result;\n\t}\n\n\tif (filename.find(\"STR\") != std::string::npos) {\n\t\tERR_FS << \"STR\" << std::endl;\n\t\treturn result;\n\t}\n\n\tif (ends_with(filename, \"STR\")) {\n\t\tERR_FS << \"STR\" << std::endl;\n\t\treturn result;\n\t}\n\n\tbool already_found = false;\n\n\tif (filename[0] == '~')\n\t{\n\t\t\n\t\tresult = get_user_data_dir() + \"STR\" + filename.substr(1);\n\t\tDBG_FS << \"STR\" << std::endl;\n\n\t\talready_found = file_exists(result) || is_directory(result);\n\t}\n\telse if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '\/')\n\t{\n\t\t\n\t\t\n\n\t\tif (!current_dir.empty())\n\t\t{\n\t\t\tresult = current_dir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = game_config::path;\n\t\t}\n\n\t\tresult += filename.substr(2);\n\t}\n\telse if (!game_config::path.empty())\n\t\tresult = game_config::path + \"STR\" + filename;\n\n\tDBG_FS << \"STR\" << std::endl;\n\n\tif (result.empty() ||\n\t    (!already_found && !file_exists(result) && !is_directory(result)))\n\t{\n\t\tDBG_FS << \"STR\" << std::endl;\n\t\tresult.clear();\n\t}\n\telse\n\t\tDBG_FS << \"STR\" << std::endl;\n\n\treturn result;\n}","24272":"header_put_marker (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\t} ;\n} ","24747":"static void scrub_put_ctx(struct scrub_ctx *sctx)\n{\n\tif (refcount_dec_and_test(&sctx->refs))\n\t\tscrub_free_ctx(sctx);\n}","24607":"relate_masters (gpointer key,\n                gpointer value,\n                gpointer data)\n{\n  ClutterDeviceManagerXI2 *manager_xi2 = data;\n  ClutterInputDevice *device, *relative;\n\n  device = g_hash_table_lookup (manager_xi2->devices_by_id, key);\n  relative = g_hash_table_lookup (manager_xi2->devices_by_id, value);\n\n  _clutter_input_device_set_associated_device (device, relative);\n  _clutter_input_device_set_associated_device (relative, device);\n}","24816":"static void freeze_page(struct page *page)\n{\n\tenum ttu_flags ttu_flags = TTU_IGNORE_MLOCK | TTU_IGNORE_ACCESS |\n\t\tTTU_RMAP_LOCKED | TTU_SPLIT_HUGE_PMD;\n\tbool unmap_success;\n\n\tVM_BUG_ON_PAGE(!PageHead(page), page);\n\n\tif (PageAnon(page))\n\t\tttu_flags |= TTU_SPLIT_FREEZE;\n\n\tunmap_success = try_to_unmap(page, ttu_flags);\n\tVM_BUG_ON_PAGE(!unmap_success, page);\n}","24604":"static void xen_netbk_tx_submit(struct xen_netbk *netbk)\n{\n\tstruct gnttab_copy *gop = netbk->tx_copy_ops;\n\tstruct sk_buff *skb;\n\n\twhile ((skb = __skb_dequeue(&netbk->tx_queue)) != NULL) {\n\t\tstruct xen_netif_tx_request *txp;\n\t\tstruct xenvif *vif;\n\t\tu16 pending_idx;\n\t\tunsigned data_len;\n\n\t\tpending_idx = *((u16 *)skb->data);\n\t\tvif = netbk->pending_tx_info[pending_idx].vif;\n\t\ttxp = &netbk->pending_tx_info[pending_idx].req;\n\n\t\t\n\t\tif (unlikely(xen_netbk_tx_check_gop(netbk, skb, &gop))) {\n\t\t\tnetdev_dbg(vif->dev, \"STR\");\n\t\t\tskb_shinfo(skb)->nr_frags = 0;\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata_len = skb->len;\n\t\tmemcpy(skb->data,\n\t\t       (void *)(idx_to_kaddr(netbk, pending_idx)|txp->offset),\n\t\t       data_len);\n\t\tif (data_len < txp->size) {\n\t\t\t\n\t\t\ttxp->offset += data_len;\n\t\t\ttxp->size -= data_len;\n\t\t} else {\n\t\t\t\n\t\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\t}\n\n\t\tif (txp->flags & XEN_NETTXF_csum_blank)\n\t\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\telse if (txp->flags & XEN_NETTXF_data_validated)\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\t\txen_netbk_fill_frags(netbk, skb);\n\n\t\t\n\t\tif (skb_headlen(skb) < PKT_PROT_LEN && skb_is_nonlinear(skb)) {\n\t\t\tint target = min_t(int, skb->len, PKT_PROT_LEN);\n\t\t\t__pskb_pull_tail(skb, target - skb_headlen(skb));\n\t\t}\n\n\t\tskb->dev      = vif->dev;\n\t\tskb->protocol = eth_type_trans(skb, skb->dev);\n\n\t\tif (checksum_setup(vif, skb)) {\n\t\t\tnetdev_dbg(vif->dev,\n\t\t\t\t   \"STR\");\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tvif->dev->stats.rx_bytes += skb->len;\n\t\tvif->dev->stats.rx_packets++;\n\n\t\txenvif_receive_skb(vif, skb);\n\t}\n}","23902":"void suhosin_hook_header_handler()\n{\n\tif (orig_header_handler == NULL) {\n\t\torig_header_handler = sapi_module.header_handler;\n\t\tsapi_module.header_handler = suhosin_header_handler;\n\t}\n}","24051":"static zval **php_zip_get_property_ptr_ptr(zval *object, zval *member, const zend_literal *key TSRMLS_DC) \n{\n\tze_zip_object *obj;\n\tzval tmp_member;\n\tzval **retval = NULL;\n\n\tzip_prop_handler *hnd;\n\tzend_object_handlers *std_hnd;\n\tint ret;\n\n\tif (member->type != IS_STRING) {\n\t\ttmp_member = *member;\n\t\tzval_copy_ctor(&tmp_member);\n\t\tconvert_to_string(&tmp_member);\n\t\tmember = &tmp_member;\n\t\tkey = NULL;\n\t}\n\n\tret = FAILURE;\n\tobj = (ze_zip_object *)zend_objects_get_address(object TSRMLS_CC);\n\n\tif (obj->prop_handler != NULL) {\n\t\tif (key) {\n\t\t\tret = zend_hash_quick_find(obj->prop_handler, Z_STRVAL_P(member), Z_STRLEN_P(member)+1, key->hash_value, (void **) &hnd);\n\t\t} else {\t\n\t\t\tret = zend_hash_find(obj->prop_handler, Z_STRVAL_P(member), Z_STRLEN_P(member)+1, (void **) &hnd);\n\t\t}\n\t}\n\n\n\tif (ret == FAILURE) {\n\t\tstd_hnd = zend_get_std_object_handlers();\n\t\tretval = std_hnd->get_property_ptr_ptr(object, member, key TSRMLS_CC);\n\t}\n\n\tif (member == &tmp_member) {\n\t\tzval_dtor(member);\n\t}\n\treturn retval;\n}","24987":"static struct nfs4_state *nfs4_opendata_to_nfs4_state(struct nfs4_opendata *data)\n{\n\tstruct inode *inode;\n\tstruct nfs4_state *state = NULL;\n\tstruct nfs_delegation *delegation;\n\tint ret;\n\n\tif (!data->rpc_done) {\n\t\tstate = nfs4_try_open_cached(data);\n\t\tgoto out;\n\t}\n\n\tret = -EAGAIN;\n\tif (!(data->f_attr.valid & NFS_ATTR_FATTR))\n\t\tgoto err;\n\tinode = nfs_fhget(data->dir->d_sb, &data->o_res.fh, &data->f_attr);\n\tret = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto err;\n\tret = -ENOMEM;\n\tstate = nfs4_get_open_state(inode, data->owner);\n\tif (state == NULL)\n\t\tgoto err_put_inode;\n\tif (data->o_res.delegation_type != 0) {\n\t\tint delegation_flags = 0;\n\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\t\tif (delegation)\n\t\t\tdelegation_flags = delegation->flags;\n\t\trcu_read_unlock();\n\t\tif ((delegation_flags & 1UL<<NFS_DELEGATION_NEED_RECLAIM) == 0)\n\t\t\tnfs_inode_set_delegation(state->inode,\n\t\t\t\t\tdata->owner->so_cred,\n\t\t\t\t\t&data->o_res);\n\t\telse\n\t\t\tnfs_inode_reclaim_delegation(state->inode,\n\t\t\t\t\tdata->owner->so_cred,\n\t\t\t\t\t&data->o_res);\n\t}\n\n\tupdate_open_stateid(state, &data->o_res.stateid, NULL,\n\t\t\tdata->o_arg.open_flags);\n\tiput(inode);\nout:\n\treturn state;\nerr_put_inode:\n\tiput(inode);\nerr:\n\treturn ERR_PTR(ret);\n}","24721":"static int ParseServerInstruction( TidyDocImpl* doc )\n{\n    Lexer* lexer = doc->lexer;\n    uint c;\n    int delim = '\"';\n    Bool isrule = no;\n\n    c = TY_(ReadChar)(doc->docIn);\n    TY_(AddCharToLexer)(lexer, c);\n\n    \n    if (c == '%' || c == '?' || c == '@')\n        isrule = yes;\n\n    for (;;)\n    {\n        c = TY_(ReadChar)(doc->docIn);\n\n        if (c == EndOfStream)\n            break;\n\n        if (c == '>')\n        {\n            if (isrule)\n                TY_(AddCharToLexer)(lexer, c);\n            else\n                TY_(UngetChar)(c, doc->docIn);\n\n            break;\n        }\n\n        \n        \n        if (!isrule)\n        {\n            if (TY_(IsWhite)(c))\n                break;\n        }\n\n        TY_(AddCharToLexer)(lexer, c);\n\n        if (c == '\"')\n        {\n            do\n            {\n                c = TY_(ReadChar)(doc->docIn);\n                if (c == EndOfStream) \n                {\n                    TY_(ReportAttrError)( doc, lexer->token, NULL, UNEXPECTED_END_OF_FILE_ATTR );\n                    TY_(UngetChar)(c, doc->docIn);\n                    return 0;\n                }\n                if (c == '>') \n                {\n                    TY_(UngetChar)(c, doc->docIn);\n                    TY_(ReportAttrError)( doc, lexer->token, NULL, UNEXPECTED_GT );\n                    return 0;\n                }\n                TY_(AddCharToLexer)(lexer, c);\n            }\n            while (c != '\"');\n            delim = '\\'';\n            continue;\n        }\n\n        if (c == '\\'')\n        {\n            do\n            {\n                c = TY_(ReadChar)(doc->docIn);\n                if (c == EndOfStream) \n                {\n                    TY_(ReportAttrError)( doc, lexer->token, NULL, UNEXPECTED_END_OF_FILE_ATTR );\n                    TY_(UngetChar)(c, doc->docIn);\n                    return 0;\n                }\n                if (c == '>') \n                {\n                    TY_(UngetChar)(c, doc->docIn);\n                    TY_(ReportAttrError)( doc, lexer->token, NULL, UNEXPECTED_GT );\n                    return 0;\n                }\n                TY_(AddCharToLexer)(lexer, c);\n            }\n            while (c != '\\'');\n        }\n    }\n\n    return delim;\n}","24485":"inline void update_rq_clock(struct rq *rq)\n{\n\tif (!rq->skip_clock_update) {\n\t\tint cpu = cpu_of(rq);\n\t\tu64 irq_time;\n\n\t\trq->clock = sched_clock_cpu(cpu);\n\t\tirq_time = irq_time_cpu(cpu);\n\t\tif (rq->clock - irq_time > rq->clock_task)\n\t\t\trq->clock_task = rq->clock - irq_time;\n\n\t\tsched_irq_time_avg_update(rq, irq_time);\n\t}\n}","24308":"TEST_P(QuicServerTransportAllowMigrationTest, MigrateToStaleValidatedPeer) {\n  folly::SocketAddress newPeer(\"STR\", 23456);\n  server->getNonConstConn().migrationState.previousPeerAddresses.push_back(\n      newPeer);\n  CongestionAndRttState state;\n  state.peerAddress = newPeer;\n  state.recordTime = Clock::now() - 2 * kTimeToRetainLastCongestionAndRttState;\n  state.congestionController = ccFactory_->makeCongestionController(\n      server->getNonConstConn(),\n      server->getNonConstConn().transportSettings.defaultCongestionController);\n  state.srtt = 1000us;\n  state.lrtt = 2000us;\n  state.rttvar = 3000us;\n  state.srtt = 800us;\n  server->getNonConstConn().migrationState.lastCongestionAndRtt =\n      std::move(state);\n\n  auto data = IOBuf::copyBuffer(\"STR\");\n  auto packetData = packetToBuf(createStreamPacket(\n      *clientConnectionId,\n      *server->getConn().serverConnectionId,\n      clientNextAppDataPacketNum++,\n      2,\n      *data,\n      0 ,\n      0 ));\n\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n\n  auto peerAddress = server->getConn().peerAddress;\n  auto congestionController = server->getConn().congestionController.get();\n  auto srtt = server->getConn().lossState.srtt;\n  auto lrtt = server->getConn().lossState.lrtt;\n  auto rttvar = server->getConn().lossState.rttvar;\n  auto mrtt = server->getConn().lossState.mrtt;\n\n  deliverData(std::move(packetData), false, &newPeer);\n\n  EXPECT_FALSE(server->getConn().pendingEvents.pathChallenge);\n  EXPECT_EQ(server->getConn().peerAddress, newPeer);\n  EXPECT_EQ(server->getConn().migrationState.previousPeerAddresses.size(), 1);\n  EXPECT_EQ(\n      server->getConn().migrationState.previousPeerAddresses.back(),\n      peerAddress);\n  EXPECT_EQ(server->getConn().lossState.srtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.lrtt, 0us);\n  EXPECT_EQ(server->getConn().lossState.rttvar, 0us);\n  EXPECT_EQ(server->getConn().lossState.mrtt, kDefaultMinRtt);\n  EXPECT_NE(server->getConn().congestionController.get(), nullptr);\n  EXPECT_NE(server->getConn().congestionController.get(), congestionController);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->peerAddress,\n      clientAddr);\n  EXPECT_EQ(\n      server->getConn()\n          .migrationState.lastCongestionAndRtt->congestionController.get(),\n      congestionController);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->srtt, srtt);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->lrtt, lrtt);\n  EXPECT_EQ(\n      server->getConn().migrationState.lastCongestionAndRtt->rttvar, rttvar);\n  EXPECT_EQ(server->getConn().migrationState.lastCongestionAndRtt->mrtt, mrtt);\n}","24712":"iakerb_gss_unwrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                  gss_buffer_t input_message_buffer,\n                  gss_buffer_t output_message_buffer, int *conf_state,\n                  gss_qop_t *qop_state)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_unwrap(minor_status, ctx->gssc, input_message_buffer,\n                           output_message_buffer, conf_state, qop_state);\n}","24562":"rsvg_style_handler_free (RsvgSaxHandler * self)\n{\n    RsvgSaxHandlerStyle *z = (RsvgSaxHandlerStyle *) self;\n    RsvgHandle *ctx = z->ctx;\n\n    if (z->is_text_css)\n        rsvg_parse_cssbuffer (ctx, z->style->str, z->style->len);\n\n    g_string_free (z->style, TRUE);\n    g_free (z);\n}","24590":"save_abbr (timezone_t tz, struct tm *tm)\n{\n#if HAVE_TM_ZONE || HAVE_TZNAME\n  char const *zone = NULL;\n  char *zone_copy = (char *) \"\";\n\n# if HAVE_TZNAME\n  int tzname_index = -1;\n# endif\n\n# if HAVE_TM_ZONE\n  zone = tm->tm_zone;\n# endif\n\n# if HAVE_TZNAME\n  if (! (zone && *zone) && 0 <= tm->tm_isdst)\n    {\n      tzname_index = tm->tm_isdst != 0;\n      zone = tzname[tzname_index];\n    }\n# endif\n\n  \n  if (!zone || ((char *) tm <= zone && zone < (char *) (tm + 1)))\n    return true;\n\n  if (*zone)\n    {\n      zone_copy = tz->abbrs;\n\n      while (strcmp (zone_copy, zone) != 0)\n        {\n          if (! (*zone_copy || (zone_copy == tz->abbrs && tz->tz_is_set)))\n            {\n              size_t zone_size = strlen (zone) + 1;\n              if (zone_size < tz->abbrs + ABBR_SIZE_MIN - zone_copy)\n                extend_abbrs (zone_copy, zone, zone_size);\n              else\n                {\n                  tz = tz->next = tzalloc (zone);\n                  if (!tz)\n                    return false;\n                  tz->tz_is_set = 0;\n                  zone_copy = tz->abbrs;\n                }\n              break;\n            }\n\n          zone_copy += strlen (zone_copy) + 1;\n          if (!*zone_copy && tz->next)\n            {\n              tz = tz->next;\n              zone_copy = tz->abbrs;\n            }\n        }\n    }\n\n  \n# if HAVE_TM_ZONE\n  tm->tm_zone = zone_copy;\n# else\n  if (0 <= tzname_index)\n    tz->tzname_copy[tzname_index] = zone_copy;\n# endif\n#endif\n\n  return true;\n}","24435":"static void test_fetch_null()\n{\n  MYSQL_STMT *stmt;\n  int        rc;\n  int        i, nData;\n  MYSQL_BIND my_bind[11];\n  ulong      length[11];\n  my_bool    is_null[11];\n  char query[MAX_TEST_QUERY_LENGTH];\n\n  myheader(\"STR\");\n\n  rc= mysql_query(mysql, \"STR\");\n  myquery(rc);\n\n  rc= mysql_query(mysql, \"STR\"\n                         \"STR\"\n                         \"STR\"\n                         \"STR\"\n                         \"STR\"\n                         \"STR\"\n                         \"STR\"\n                         \"STR\");\n  myquery(rc);\n\n  rc= mysql_query(mysql, \"STR\"\n                         \"STR\");\n  myquery(rc);\n\n  rc= mysql_commit(mysql);\n  myquery(rc);\n\n  \n  memset(my_bind, 0, sizeof(my_bind));\n  for (i= 0; i < (int) array_elements(my_bind); i++)\n  {\n    my_bind[i].buffer_type= MYSQL_TYPE_LONG;\n    my_bind[i].is_null= &is_null[i];\n    my_bind[i].length= &length[i];\n  }\n  my_bind[i-1].buffer= (void *)&nData;              \n\n  my_stpcpy((char *)query , \"STR\");\n\n  rc= my_stmt_result(query);\n  DIE_UNLESS(rc == 3);\n\n  stmt= mysql_simple_prepare(mysql, query);\n  check_stmt(stmt);\n\n  rc= mysql_stmt_bind_result(stmt, my_bind);\n  check_execute(stmt, rc);\n\n  rc= mysql_stmt_execute(stmt);\n  check_execute(stmt, rc);\n\n  rc= 0;\n  while (mysql_stmt_fetch(stmt) != MYSQL_NO_DATA)\n  {\n    rc++;\n    for (i= 0; i < 10; i++)\n    {\n      if (!opt_silent)\n        fprintf(stdout, \"STR\", i,\n                is_null[i] ? \"STR\");\n      DIE_UNLESS(is_null[i]);\n    }\n    if (!opt_silent)\n      fprintf(stdout, \"STR\", i, nData);\n    DIE_UNLESS(nData == 1000 || nData == 88 || nData == 389789);\n    DIE_UNLESS(is_null[i] == 0);\n    DIE_UNLESS(length[i] == 4);\n  }\n  DIE_UNLESS(rc == 3);\n  mysql_stmt_close(stmt);\n}","24779":"GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)\n{\n\tgit_buf *reserved = git_repository__reserved_names_win32;\n\tsize_t reserved_len = git_repository__reserved_names_win32_len;\n\tsize_t start = 0, i;\n\n\tif (repo)\n\t\tgit_repository__reserved_names(&reserved, &reserved_len, repo, true);\n\n\tfor (i = 0; i < reserved_len; i++) {\n\t\tgit_buf *r = &reserved[i];\n\n\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!start)\n\t\treturn true;\n\n\t\n\tif (path[start] == '\\\\')\n\t\treturn false;\n\n\t\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}","24552":"int usb_function_activate(struct usb_function *function)\n{\n\tstruct usb_composite_dev\t*cdev = function->config->cdev;\n\tunsigned long\t\t\tflags;\n\tint\t\t\t\tstatus = 0;\n\n\tspin_lock_irqsave(&cdev->lock, flags);\n\n\tif (WARN_ON(cdev->deactivations == 0))\n\t\tstatus = -EINVAL;\n\telse {\n\t\tcdev->deactivations--;\n\t\tif (cdev->deactivations == 0) {\n\t\t\tspin_unlock_irqrestore(&cdev->lock, flags);\n\t\t\tstatus = usb_gadget_activate(cdev->gadget);\n\t\t\tspin_lock_irqsave(&cdev->lock, flags);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&cdev->lock, flags);\n\treturn status;\n}","24422":"static zend_never_inline zval* ZEND_FASTCALL _zendi_convert_scalar_to_number_noisy(zval *op, zval *holder) \n{\n\treturn _zendi_convert_scalar_to_number_ex(op, holder, 0);\n}","24989":"TEST_F(Http1ClientConnectionImplTest, 204Response) {\n  initialize();\n\n  NiceMock<MockResponseDecoder> response_decoder;\n  Http::RequestEncoder& request_encoder = codec_->newStream(response_decoder);\n  TestRequestHeaderMapImpl headers{{\"STR\"}};\n  request_encoder.encodeHeaders(headers, true);\n\n  EXPECT_CALL(response_decoder, decodeHeaders_(_, true));\n  Buffer::OwnedImpl response(\"STR\");\n  auto status = codec_->dispatch(response);\n  EXPECT_TRUE(status.ok());\n}","24271":"void *Type_NamedColor_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsUInt32Number* nItems, cmsUInt32Number SizeOfTag)\n{\n\n    cmsUInt32Number      vendorFlag;     \n    cmsUInt32Number      count;          \n    cmsUInt32Number      nDeviceCoords;  \n    char                 prefix[32];     \n    char                 suffix[32];     \n    cmsNAMEDCOLORLIST*  v;\n    cmsUInt32Number i;\n\n\n    *nItems = 0;\n    if (!_cmsReadUInt32Number(io, &vendorFlag)) return NULL;\n    if (!_cmsReadUInt32Number(io, &count)) return NULL;\n    if (!_cmsReadUInt32Number(io, &nDeviceCoords)) return NULL;\n\n    if (io -> Read(io, prefix, 32, 1) != 1) return NULL;\n    if (io -> Read(io, suffix, 32, 1) != 1) return NULL;\n\n    prefix[31] = suffix[31] = 0;\n\n    v = cmsAllocNamedColorList(self ->ContextID, count, nDeviceCoords, prefix, suffix);\n    if (v == NULL) {\n        cmsSignalError(self->ContextID, cmsERROR_RANGE, \"STR\", count);\n        return NULL;\n    }\n\n    if (nDeviceCoords > cmsMAXCHANNELS) {\n        cmsSignalError(self->ContextID, cmsERROR_RANGE, \"STR\", nDeviceCoords);\n        return 0;\n    }\n    for (i=0; i < count; i++) {\n\n        cmsUInt16Number PCS[3];\n        cmsUInt16Number Colorant[cmsMAXCHANNELS];\n        char Root[33];\n\n        memset(Colorant, 0, sizeof(Colorant));\n        if (io -> Read(io, Root, 32, 1) != 1) return NULL;\n        Root[32] = 0;  \n\n        if (!_cmsReadUInt16Array(io, 3, PCS)) goto Error;\n        if (!_cmsReadUInt16Array(io, nDeviceCoords, Colorant)) goto Error;\n\n        if (!cmsAppendNamedColor(v, Root, PCS, Colorant)) goto Error;\n    }\n\n    *nItems = 1;\n    return (void*) v ;\n\nError:\n    cmsFreeNamedColorList(v);\n    return NULL;\n\n    cmsUNUSED_PARAMETER(SizeOfTag);\n}","24389":"show_hidden_files_changed_callback (gpointer callback_data)\n{\n\tshow_hidden_files = eel_preferences_get_boolean (NAUTILUS_PREFERENCES_SHOW_HIDDEN_FILES);\n}","24190":"longlong Item_func_is_free_lock::val_int()\n{\n  DBUG_ASSERT(fixed == 1);\n  String *res= args[0]->val_str(&value);\n  THD *thd= current_thd;\n  null_value= 1;\n\n  if (!ull_name_ok(res))\n    return 0;\n\n  MDL_key ull_key;\n  ull_key.mdl_key_init(MDL_key::USER_LOCK, res->c_ptr_safe(), \"\");\n\n  null_value= 0;\n  return thd->mdl_context.get_lock_owner(&ull_key) == 0;\n}","24889":"inline size_t WireFormatLite::StringSize(const std::string& value) {\n  return LengthDelimitedSize(value.size());\n}","24446":"static int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\n\tauthkey = kmalloc(optlen, GFP_KERNEL);\n\tif (!authkey)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(authkey, optval, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\nout:\n\tkfree(authkey);\n\treturn ret;\n}","25002":"static int macsec_add_dev(struct net_device *dev, sci_t sci, u8 icv_len)\n{\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\tstruct macsec_secy *secy = &macsec->secy;\n\n\tmacsec->stats = netdev_alloc_pcpu_stats(struct pcpu_secy_stats);\n\tif (!macsec->stats)\n\t\treturn -ENOMEM;\n\n\tsecy->tx_sc.stats = netdev_alloc_pcpu_stats(struct pcpu_tx_sc_stats);\n\tif (!secy->tx_sc.stats) {\n\t\tfree_percpu(macsec->stats);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (sci == MACSEC_UNDEF_SCI)\n\t\tsci = dev_to_sci(dev, MACSEC_PORT_ES);\n\n\tsecy->netdev = dev;\n\tsecy->operational = true;\n\tsecy->key_len = DEFAULT_SAK_LEN;\n\tsecy->icv_len = icv_len;\n\tsecy->validate_frames = MACSEC_VALIDATE_DEFAULT;\n\tsecy->protect_frames = true;\n\tsecy->replay_protect = false;\n\n\tsecy->sci = sci;\n\tsecy->tx_sc.active = true;\n\tsecy->tx_sc.encoding_sa = DEFAULT_ENCODING_SA;\n\tsecy->tx_sc.encrypt = DEFAULT_ENCRYPT;\n\tsecy->tx_sc.send_sci = DEFAULT_SEND_SCI;\n\tsecy->tx_sc.end_station = false;\n\tsecy->tx_sc.scb = false;\n\n\treturn 0;\n}","23868":"static unsigned int fanout_demux_lb(struct packet_fanout *f,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    unsigned int num)\n{\n\tint cur, old;\n\n\tcur = atomic_read(&f->rr_cur);\n\twhile ((old = atomic_cmpxchg(&f->rr_cur, cur,\n\t\t\t\t     fanout_rr_next(f, num))) != cur)\n\t\tcur = old;\n\treturn cur;\n}","24137":"void smb2cli_req_set_notify_async(struct tevent_req *req)\n{\n\tstruct smbXcli_req_state *state =\n\t\ttevent_req_data(req,\n\t\tstruct smbXcli_req_state);\n\n\tstate->smb2.notify_async = true;\n}","24070":"GF_Err tims_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TSHintEntryBox *p;\n\tp = (GF_TSHintEntryBox *)a;\n\tgf_isom_box_dump_start(a, \"STR\", trace);\n\tfprintf(trace, \"STR\", p->timeScale);\n\tgf_isom_box_dump_done(\"STR\", a, trace);\n\treturn GF_OK;\n}","23981":"expand_dfs_referral(const unsigned int xid, struct cifs_ses *ses,\n\t\t    struct smb_vol *volume_info, struct cifs_sb_info *cifs_sb,\n\t\t    int check_prefix)\n{\n\tint rc;\n\tunsigned int num_referrals = 0;\n\tstruct dfs_info3_param *referrals = NULL;\n\tchar *full_path = NULL, *ref_path = NULL, *mdata = NULL;\n\n\tfull_path = build_unc_path_to_root(volume_info, cifs_sb);\n\tif (IS_ERR(full_path))\n\t\treturn PTR_ERR(full_path);\n\n\t\n\tref_path = check_prefix ? full_path + 1 : volume_info->UNC + 1;\n\n\trc = get_dfs_path(xid, ses, ref_path, cifs_sb->local_nls,\n\t\t\t  &num_referrals, &referrals,\n\t\t\t  cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\n\tif (!rc && num_referrals > 0) {\n\t\tchar *fake_devname = NULL;\n\n\t\tmdata = cifs_compose_mount_options(cifs_sb->mountdata,\n\t\t\t\t\t\t   full_path + 1, referrals,\n\t\t\t\t\t\t   &fake_devname);\n\n\t\tfree_dfs_info_array(referrals, num_referrals);\n\n\t\tif (IS_ERR(mdata)) {\n\t\t\trc = PTR_ERR(mdata);\n\t\t\tmdata = NULL;\n\t\t} else {\n\t\t\tcleanup_volume_info_contents(volume_info);\n\t\t\trc = cifs_setup_volume_info(volume_info, mdata,\n\t\t\t\t\t\t\tfake_devname);\n\t\t}\n\t\tkfree(fake_devname);\n\t\tkfree(cifs_sb->mountdata);\n\t\tcifs_sb->mountdata = mdata;\n\t}\n\tkfree(full_path);\n\treturn rc;\n}","24782":"  uint32 max_display_length() const { return field_length - 1; }","24613":"QPDFWriter::write()\n{\n    doWriteSetup();\n\n    \n    \n    \n    \n    \n    \n    this->m->events_expected = (\n        this->m->pdf.getObjectCount() * (this->m->linearized ? 3 : 2));\n\n    prepareFileForWrite();\n\n    if (this->m->linearized)\n    {\n\twriteLinearized();\n    }\n    else\n    {\n\twriteStandard();\n    }\n\n    this->m->pipeline->finish();\n    if (this->m->close_file)\n    {\n\tfclose(this->m->file);\n    }\n    this->m->file = 0;\n    if (this->m->buffer_pipeline)\n    {\n\tthis->m->output_buffer = this->m->buffer_pipeline->getBuffer();\n\tthis->m->buffer_pipeline = 0;\n    }\n    indicateProgress(false, true);\n}","24484":"auth_pin_is_verified(struct sc_card *card, int pin_reference, int *tries_left)\n{\n\tstruct sc_apdu apdu;\n\tint rv;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x20, 0, pin_reference);\n\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(card->ctx, rv, \"STR\");\n\n\tif (tries_left && apdu.sw1 == 0x63 && (apdu.sw2 & 0xF0) == 0xC0)\n\t\t*tries_left = apdu.sw2 & 0x0F;\n\n\t\n\tif (apdu.sw1 == 0x63 && apdu.sw2 == 0xC0)    {\n\t\tapdu.sw1 = 0x69;\n\t\tapdu.sw2 = 0x83;\n\t}\n\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\n\treturn rv;\n}","24277":"TEST_F(StreamInfoImplTest, MiscSettersAndGetters) {\n  {\n    StreamInfoImpl stream_info(Http::Protocol::Http2, test_time_.timeSystem(), nullptr);\n\n    EXPECT_EQ(nullptr, stream_info.upstreamInfo());\n    EXPECT_EQ(Http::Protocol::Http2, stream_info.protocol().value());\n    stream_info.setUpstreamInfo(std::make_shared<UpstreamInfoImpl>());\n\n    stream_info.protocol(Http::Protocol::Http10);\n    EXPECT_EQ(Http::Protocol::Http10, stream_info.protocol().value());\n\n    EXPECT_FALSE(stream_info.responseCode());\n    stream_info.response_code_ = 200;\n    ASSERT_TRUE(stream_info.responseCode());\n    EXPECT_EQ(200, stream_info.responseCode().value());\n\n    EXPECT_FALSE(stream_info.attemptCount().has_value());\n    stream_info.setAttemptCount(93);\n    ASSERT_TRUE(stream_info.attemptCount().has_value());\n    EXPECT_EQ(stream_info.attemptCount().value(), 93);\n\n    EXPECT_FALSE(stream_info.responseCodeDetails().has_value());\n    stream_info.setResponseCodeDetails(ResponseCodeDetails::get().ViaUpstream);\n    ASSERT_TRUE(stream_info.responseCodeDetails().has_value());\n    EXPECT_EQ(ResponseCodeDetails::get().ViaUpstream, stream_info.responseCodeDetails().value());\n\n    EXPECT_FALSE(stream_info.connectionTerminationDetails().has_value());\n    stream_info.setConnectionTerminationDetails(\"STR\");\n    ASSERT_TRUE(stream_info.connectionTerminationDetails().has_value());\n    EXPECT_EQ(\"STR\", stream_info.connectionTerminationDetails().value());\n\n    EXPECT_EQ(nullptr, stream_info.upstreamInfo()->upstreamHost());\n    Upstream::HostDescriptionConstSharedPtr host(new NiceMock<Upstream::MockHostDescription>());\n    stream_info.upstreamInfo()->setUpstreamHost(host);\n    EXPECT_EQ(host, stream_info.upstreamInfo()->upstreamHost());\n\n    EXPECT_FALSE(stream_info.healthCheck());\n    stream_info.healthCheck(true);\n    EXPECT_TRUE(stream_info.healthCheck());\n\n    EXPECT_EQ(nullptr, stream_info.route());\n    std::shared_ptr<NiceMock<Router::MockRoute>> route =\n        std::make_shared<NiceMock<Router::MockRoute>>();\n    stream_info.route_ = route;\n    EXPECT_EQ(route, stream_info.route());\n\n    stream_info.filterState()->setData(\"STR\", std::make_unique<TestIntAccessor>(1),\n                                       FilterState::StateType::ReadOnly,\n                                       FilterState::LifeSpan::FilterChain);\n    EXPECT_EQ(1, stream_info.filterState()->getDataReadOnly<TestIntAccessor>(\"STR\")->access());\n\n    stream_info.upstreamInfo()->setUpstreamFilterState(stream_info.filterState());\n    EXPECT_EQ(1, stream_info.upstreamInfo()\n                     ->upstreamFilterState()\n                     ->getDataReadOnly<TestIntAccessor>(\"STR\")\n                     ->access());\n\n    EXPECT_EQ(absl::nullopt, stream_info.upstreamClusterInfo());\n    Upstream::ClusterInfoConstSharedPtr cluster_info(new NiceMock<Upstream::MockClusterInfo>());\n    stream_info.setUpstreamClusterInfo(cluster_info);\n    EXPECT_NE(absl::nullopt, stream_info.upstreamClusterInfo());\n    EXPECT_EQ(\"STR\", stream_info.upstreamClusterInfo().value()->name());\n\n    const std::string session_id =\n        \"STR\";\n    auto ssl_info = std::make_shared<Ssl::MockConnectionInfo>();\n    EXPECT_CALL(*ssl_info, sessionId()).WillRepeatedly(testing::ReturnRef(session_id));\n    stream_info.upstreamInfo()->setUpstreamSslConnection(ssl_info);\n    EXPECT_EQ(session_id, stream_info.upstreamInfo()->upstreamSslConnection()->sessionId());\n\n    EXPECT_FALSE(stream_info.upstreamInfo()->upstreamConnectionId().has_value());\n    stream_info.upstreamInfo()->setUpstreamConnectionId(12345);\n    ASSERT_TRUE(stream_info.upstreamInfo()->upstreamConnectionId().has_value());\n    EXPECT_EQ(12345, stream_info.upstreamInfo()->upstreamConnectionId().value());\n\n    EXPECT_FALSE(stream_info.upstreamInfo()->upstreamInterfaceName().has_value());\n    stream_info.upstreamInfo()->setUpstreamInterfaceName(\"STR\");\n    ASSERT_TRUE(stream_info.upstreamInfo()->upstreamInterfaceName().has_value());\n    EXPECT_EQ(\"STR\", stream_info.upstreamInfo()->upstreamInterfaceName().value());\n\n    std::shared_ptr<UpstreamInfo> new_info = std::make_shared<UpstreamInfoImpl>();\n    EXPECT_NE(stream_info.upstreamInfo(), new_info);\n    stream_info.setUpstreamInfo(new_info);\n    EXPECT_EQ(stream_info.upstreamInfo(), new_info);\n  }\n}","23837":"nfs4_free_slot(struct nfs4_slot_table *tbl, u8 free_slotid)\n{\n\tint slotid = free_slotid;\n\n\tBUG_ON(slotid < 0 || slotid >= NFS4_MAX_SLOT_TABLE);\n\t\n\t__clear_bit(slotid, tbl->used_slots);\n\n\t\n\tif (slotid == tbl->highest_used_slotid) {\n\t\tslotid = find_last_bit(tbl->used_slots, tbl->max_slots);\n\t\tif (slotid < tbl->max_slots)\n\t\t\ttbl->highest_used_slotid = slotid;\n\t\telse\n\t\t\ttbl->highest_used_slotid = -1;\n\t}\n\tdprintk(\"STR\", __func__,\n\t\tfree_slotid, tbl->highest_used_slotid);\n}","24074":"nautilus_file_is_directory (NautilusFile *file)\n{\n\treturn nautilus_file_get_file_type (file) == G_FILE_TYPE_DIRECTORY;\n}","24672":"GF_Err free_Size(GF_Box *s)\n{\n\tGF_FreeSpaceBox *ptr = (GF_FreeSpaceBox *)s;\n\tptr->size += ptr->dataSize;\n\treturn GF_OK;\n}","24352":"cmsPipeline* _cmsLinkProfiles(cmsContext     ContextID,\n                              cmsUInt32Number nProfiles,\n                              cmsUInt32Number TheIntents[],\n                              cmsHPROFILE     hProfiles[],\n                              cmsBool         BPC[],\n                              cmsFloat64Number AdaptationStates[],\n                              cmsUInt32Number dwFlags)\n{\n    cmsUInt32Number i;\n    cmsIntentsList* Intent;\n\n    \n    if (nProfiles <= 0 || nProfiles > 255) {\n         cmsSignalError(ContextID, cmsERROR_RANGE, \"STR\", nProfiles);\n        return NULL;\n    }\n\n    for (i=0; i < nProfiles; i++) {\n\n        \n        \n        \n        \n\n        if (TheIntents[i] == INTENT_ABSOLUTE_COLORIMETRIC)\n            BPC[i] = FALSE;\n\n        if (TheIntents[i] == INTENT_PERCEPTUAL || TheIntents[i] == INTENT_SATURATION) {\n\n            \n            if (cmsGetProfileVersion(hProfiles[i]) >= 4.0)\n                BPC[i] = TRUE;\n        }\n    }\n\n    \n    \n    \n    \n\n    Intent = SearchIntent(TheIntents[0]);\n    if (Intent == NULL) {\n        cmsSignalError(ContextID, cmsERROR_UNKNOWN_EXTENSION, \"STR\", TheIntents[0]);\n        return NULL;\n    }\n\n    \n    return Intent ->Link(ContextID, nProfiles, TheIntents, hProfiles, BPC, AdaptationStates, dwFlags);\n}","23897":"static bool wake_up_full_nohz_cpu(int cpu)\n{\n\tif (tick_nohz_full_cpu(cpu)) {\n\t\tif (cpu != smp_processor_id() ||\n\t\t    tick_nohz_tick_stopped())\n\t\t\tsmp_send_reschedule(cpu);\n\t\treturn true;\n\t}\n\n\treturn false;\n}","24338":"psutil_per_cpu_times(PyObject *self, PyObject *args) {\n    double idle, kernel, systemt, user, interrupt, dpc;\n    NTSTATUS status;\n    _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *sppi = NULL;\n    UINT i;\n    unsigned int ncpus;\n    PyObject *py_tuple = NULL;\n    PyObject *py_retlist = PyList_New(0);\n\n    if (py_retlist == NULL)\n        return NULL;\n\n    \n    ncpus = psutil_get_num_cpus(1);\n    if (ncpus == 0)\n        goto error;\n\n    \n    \n    sppi = (_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *) \\\n        malloc(ncpus * sizeof(_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION));\n    if (sppi == NULL) {\n        PyErr_NoMemory();\n        goto error;\n    }\n\n    \n    status = psutil_NtQuerySystemInformation(\n        SystemProcessorPerformanceInformation,\n        sppi,\n        ncpus * sizeof(_SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION),\n        NULL);\n    if (! NT_SUCCESS(status)) {\n        psutil_SetFromNTStatusErr(\n            status,\n            \"STR\"\n        );\n        goto error;\n    }\n\n    \n    \n    idle = user = kernel = interrupt = dpc = 0;\n    for (i = 0; i < ncpus; i++) {\n        py_tuple = NULL;\n        user = (double)((HI_T * sppi[i].UserTime.HighPart) +\n                       (LO_T * sppi[i].UserTime.LowPart));\n        idle = (double)((HI_T * sppi[i].IdleTime.HighPart) +\n                       (LO_T * sppi[i].IdleTime.LowPart));\n        kernel = (double)((HI_T * sppi[i].KernelTime.HighPart) +\n                         (LO_T * sppi[i].KernelTime.LowPart));\n        interrupt = (double)((HI_T * sppi[i].InterruptTime.HighPart) +\n                            (LO_T * sppi[i].InterruptTime.LowPart));\n        dpc = (double)((HI_T * sppi[i].DpcTime.HighPart) +\n                      (LO_T * sppi[i].DpcTime.LowPart));\n\n        \n        \n        \n        systemt = kernel - idle;\n        py_tuple = Py_BuildValue(\n            \"STR\",\n            user,\n            systemt,\n            idle,\n            interrupt,\n            dpc\n        );\n        if (!py_tuple)\n            goto error;\n        if (PyList_Append(py_retlist, py_tuple))\n            goto error;\n        Py_DECREF(py_tuple);\n    }\n\n    free(sppi);\n    return py_retlist;\n\nerror:\n    Py_XDECREF(py_tuple);\n    Py_DECREF(py_retlist);\n    if (sppi)\n        free(sppi);\n    return NULL;\n}","24012":"void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n{\n\tgdImagePtr pim = 0, tim = im;\n\tint interlace, BitsPerPixel;\n\tinterlace = im->interlace;\n\tif (im->trueColor) {\n\t\t\n\t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n\t\tif (!pim) {\n\t\t\treturn;\n\t\t}\n\t\ttim = pim;\n\t}\n\tBitsPerPixel = colorstobpp(tim->colorsTotal);\n\t\n\tGIFEncode(\n\t\tout, tim->sx, tim->sy, tim->interlace, 0, tim->transparent, BitsPerPixel,\n\t\ttim->red, tim->green, tim->blue, tim);\n\tif (pim) {\n\t\t\n\t\tgdImageDestroy(\tpim);\n\t}\n}","24258":"static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\n\terr = -ENAMETOOLONG;\n\tif (outarg.namelen > FUSE_NAME_MAX)\n\t\tgoto err;\n\n\tname.name = buf;\n\tname.len = outarg.namelen;\n\terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\n\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}","24675":"void Context::onDone() {\n  if (wasm_->onDone_) {\n    wasm_->onDone_(this, id_);\n  }\n}","24329":"static int uvc_scan_chain_forward(struct uvc_video_chain *chain,\n\tstruct uvc_entity *entity, struct uvc_entity *prev)\n{\n\tstruct uvc_entity *forward;\n\tint found;\n\n\t\n\tforward = NULL;\n\tfound = 0;\n\n\twhile (1) {\n\t\tforward = uvc_entity_by_reference(chain->dev, entity->id,\n\t\t\tforward);\n\t\tif (forward == NULL)\n\t\t\tbreak;\n\t\tif (forward == prev)\n\t\t\tcontinue;\n\n\t\tswitch (UVC_ENTITY_TYPE(forward)) {\n\t\tcase UVC_VC_EXTENSION_UNIT:\n\t\t\tif (forward->bNrInPins != 1) {\n\t\t\t\tuvc_trace(UVC_TRACE_DESCR, \"STR\"\n\t\t\t\t\t  \"STR\",\n\t\t\t\t\t  entity->id);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tlist_add_tail(&forward->chain, &chain->entities);\n\t\t\tif (uvc_trace_param & UVC_TRACE_PROBE) {\n\t\t\t\tif (!found)\n\t\t\t\t\tprintk(KERN_CONT \"STR\");\n\n\t\t\t\tprintk(KERN_CONT \"STR\", forward->id);\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase UVC_OTT_VENDOR_SPECIFIC:\n\t\tcase UVC_OTT_DISPLAY:\n\t\tcase UVC_OTT_MEDIA_TRANSPORT_OUTPUT:\n\t\tcase UVC_TT_STREAMING:\n\t\t\tif (UVC_ENTITY_IS_ITERM(forward)) {\n\t\t\t\tuvc_trace(UVC_TRACE_DESCR, \"STR\"\n\t\t\t\t\t\"STR\", forward->id);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tlist_add_tail(&forward->chain, &chain->entities);\n\t\t\tif (uvc_trace_param & UVC_TRACE_PROBE) {\n\t\t\t\tif (!found)\n\t\t\t\t\tprintk(KERN_CONT \"STR\");\n\n\t\t\t\tprintk(KERN_CONT \"STR\", forward->id);\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found)\n\t\tprintk(KERN_CONT \"STR\");\n\n\treturn 0;\n}","24908":"void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tpreempt_disable();\n\n\tif (current->active_mm == mm) {\n\t\tif (current->mm)\n\t\t\t__flush_tlb_one(start);\n\t\telse\n\t\t\tleave_mm(smp_processor_id());\n\t}\n\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, start, 0UL);\n\n\tpreempt_enable();\n}","24119":"e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)\n{\n    return core->mac[r->dh] == core->mac[r->dt] ||\n                core->mac[r->dt] >= core->mac[r->dlen] \/ E1000_RING_DESC_LEN;\n}","24764":"static int generate_key(DH *dh)\n{\n    int ok = 0;\n    int generate_new_key = 0;\n    unsigned l;\n    BN_CTX *ctx;\n    BN_MONT_CTX *mont = NULL;\n    BIGNUM *pub_key = NULL, *priv_key = NULL;\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto err;\n\n    if (dh->priv_key == NULL) {\n        priv_key = BN_new();\n        if (priv_key == NULL)\n            goto err;\n        generate_new_key = 1;\n    } else\n        priv_key = dh->priv_key;\n\n    if (dh->pub_key == NULL) {\n        pub_key = BN_new();\n        if (pub_key == NULL)\n            goto err;\n    } else\n        pub_key = dh->pub_key;\n\n    if (dh->flags & DH_FLAG_CACHE_MONT_P) {\n        mont = BN_MONT_CTX_set_locked(&dh->method_mont_p,\n                                      CRYPTO_LOCK_DH, dh->p, ctx);\n        if (!mont)\n            goto err;\n    }\n\n    if (generate_new_key) {\n        if (dh->q) {\n            do {\n                if (!BN_rand_range(priv_key, dh->q))\n                    goto err;\n            }\n            while (BN_is_zero(priv_key) || BN_is_one(priv_key));\n        } else {\n            \n            l = dh->length ? dh->length : BN_num_bits(dh->p) - 1;\n            if (!BN_rand(priv_key, l, 0, 0))\n                goto err;\n        }\n    }\n\n    {\n        BIGNUM local_prk;\n        BIGNUM *prk;\n\n        if ((dh->flags & DH_FLAG_NO_EXP_CONSTTIME) == 0) {\n            BN_init(&local_prk);\n            prk = &local_prk;\n            BN_with_flags(prk, priv_key, BN_FLG_CONSTTIME);\n        } else\n            prk = priv_key;\n\n        if (!dh->meth->bn_mod_exp(dh, pub_key, dh->g, prk, dh->p, ctx, mont))\n            goto err;\n    }\n\n    dh->pub_key = pub_key;\n    dh->priv_key = priv_key;\n    ok = 1;\n err:\n    if (ok != 1)\n        DHerr(DH_F_GENERATE_KEY, ERR_R_BN_LIB);\n\n    if ((pub_key != NULL) && (dh->pub_key == NULL))\n        BN_free(pub_key);\n    if ((priv_key != NULL) && (dh->priv_key == NULL))\n        BN_free(priv_key);\n    BN_CTX_free(ctx);\n    return (ok);\n}","24915":"__dma_device_satisfies_mask(struct dma_device *device,\n\t\t\t    const dma_cap_mask_t *want)\n{\n\tdma_cap_mask_t has;\n\n\tbitmap_and(has.bits, want->bits, device->cap_mask.bits,\n\t\tDMA_TX_TYPE_END);\n\treturn bitmap_equal(want->bits, has.bits, DMA_TX_TYPE_END);\n}","24050":"pkinit_fini_pkcs11(pkinit_identity_crypto_context ctx)\n{\n#ifndef WITHOUT_PKCS11\n    if (ctx == NULL)\n        return;\n\n    if (ctx->p11 != NULL) {\n        if (ctx->session != CK_INVALID_HANDLE) {\n            ctx->p11->C_CloseSession(ctx->session);\n            ctx->session = CK_INVALID_HANDLE;\n        }\n        ctx->p11->C_Finalize(NULL_PTR);\n        ctx->p11 = NULL;\n    }\n    if (ctx->p11_module != NULL) {\n        pkinit_C_UnloadModule(ctx->p11_module);\n        ctx->p11_module = NULL;\n    }\n    free(ctx->p11_module_name);\n    free(ctx->token_label);\n    free(ctx->cert_id);\n    free(ctx->cert_label);\n#endif\n}","24266":"virDomainChrTargetDefFormat(virBufferPtr buf,\n                            const virDomainChrDef *def,\n                            unsigned int flags)\n{\n    const char *targetType = virDomainChrTargetTypeToString(def->deviceType,\n                                                            def->targetType);\n\n    switch ((virDomainChrDeviceType) def->deviceType) {\n    case VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL: {\n        if (!targetType) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"STR\",\n                           _(\"STR\"));\n            return -1;\n        }\n        virBufferAsprintf(buf, \"STR\", targetType);\n\n        switch (def->targetType) {\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_GUESTFWD: {\n            int port = virSocketAddrGetPort(def->target.addr);\n            g_autofree char *addr = NULL;\n            if (port < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"STR\",\n                               _(\"STR\"));\n                return -1;\n            }\n\n            addr = virSocketAddrFormat(def->target.addr);\n            if (addr == NULL)\n                return -1;\n\n            virBufferAsprintf(buf, \"STR\",\n                              addr, port);\n            break;\n        }\n\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN:\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO:\n            if (def->target.name)\n                virBufferEscapeString(buf, \"STR\", def->target.name);\n\n            if (def->targetType == VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO &&\n                def->state != VIR_DOMAIN_CHR_DEVICE_STATE_DEFAULT &&\n                !(flags & VIR_DOMAIN_DEF_PARSE_INACTIVE)) {\n                virBufferAsprintf(buf, \"STR\",\n                                  virDomainChrDeviceStateTypeToString(def->state));\n            }\n            break;\n        }\n\n        virBufferAddLit(buf, \"STR\");\n        break;\n    }\n\n    case VIR_DOMAIN_CHR_DEVICE_TYPE_CONSOLE:\n        if (!targetType) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"STR\",\n                           _(\"STR\"));\n            return -1;\n        }\n\n        virBufferAsprintf(buf,\n                          \"STR\",\n                          targetType, def->target.port);\n        break;\n\n    case VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL:\n        if (!targetType) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"STR\",\n                           _(\"STR\"));\n            return -1;\n        }\n\n        virBufferAddLit(buf, \"STR\");\n\n        if (def->targetType != VIR_DOMAIN_CHR_SERIAL_TARGET_TYPE_NONE) {\n            virBufferAsprintf(buf,\n                              \"STR\",\n                              targetType);\n        }\n\n        virBufferAsprintf(buf,\n                          \"STR\",\n                          def->target.port);\n\n        if (def->targetModel != VIR_DOMAIN_CHR_SERIAL_TARGET_MODEL_NONE) {\n            virBufferAddLit(buf, \"STR\");\n\n            virBufferAdjustIndent(buf, 2);\n            virBufferAsprintf(buf,\n                              \"STR\",\n                              virDomainChrSerialTargetModelTypeToString(def->targetModel));\n            virBufferAdjustIndent(buf, -2);\n\n            virBufferAddLit(buf, \"STR\");\n        } else {\n            virBufferAddLit(buf, \"STR\");\n        }\n\n        break;\n\n    case VIR_DOMAIN_CHR_DEVICE_TYPE_PARALLEL:\n        virBufferAsprintf(buf, \"STR\",\n                          def->target.port);\n        break;\n\n    case VIR_DOMAIN_CHR_DEVICE_TYPE_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"STR\"),\n                       def->deviceType);\n        return -1;\n    }\n\n    return 0;\n}","24126":"bool ElectronBrowserClient::BindAssociatedReceiverFromFrame(\n    content::RenderFrameHost* render_frame_host,\n    const std::string& interface_name,\n    mojo::ScopedInterfaceEndpointHandle* handle) {\n  if (interface_name == mojom::ElectronAutofillDriver::Name_) {\n    AutofillDriverFactory::BindAutofillDriver(\n        mojo::PendingAssociatedReceiver<mojom::ElectronAutofillDriver>(\n            std::move(*handle)),\n        render_frame_host);\n    return true;\n  }\n  if (interface_name == electron::mojom::ElectronBrowser::Name_) {\n    BindElectronBrowser(\n        mojo::PendingAssociatedReceiver<electron::mojom::ElectronBrowser>(\n            std::move(*handle)),\n        render_frame_host);\n    return true;\n  }\n#if BUILDFLAG(ENABLE_PRINTING)\n  if (interface_name == printing::mojom::PrintManagerHost::Name_) {\n    mojo::PendingAssociatedReceiver<printing::mojom::PrintManagerHost> receiver(\n        std::move(*handle));\n    PrintViewManagerElectron::BindPrintManagerHost(std::move(receiver),\n                                                   render_frame_host);\n    return true;\n  }\n#endif\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  if (interface_name == extensions::mojom::LocalFrameHost::Name_) {\n    extensions::ExtensionWebContentsObserver::BindLocalFrameHost(\n        mojo::PendingAssociatedReceiver<extensions::mojom::LocalFrameHost>(\n            std::move(*handle)),\n        render_frame_host);\n    return true;\n  }\n#endif\n#if BUILDFLAG(ENABLE_PDF_VIEWER)\n  if (interface_name == pdf::mojom::PdfService::Name_) {\n    pdf::PDFWebContentsHelper::BindPdfService(\n        mojo::PendingAssociatedReceiver<pdf::mojom::PdfService>(\n            std::move(*handle)),\n        render_frame_host);\n    return true;\n  }\n#endif\n\n  return false;\n}","23942":"dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)\n\t{\n\tDTLS1_RECORD_DATA *rdata;\n\tpitem *item;\n\n\t\n\tif (pqueue_size(queue->q) >= 100)\n\t\treturn 0;\n\t\t\n\trdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));\n\titem = pitem_new(priority, rdata);\n\tif (rdata == NULL || item == NULL)\n\t\t{\n\t\tif (rdata != NULL) OPENSSL_free(rdata);\n\t\tif (item != NULL) pitem_free(item);\n\t\t\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\treturn(0);\n\t\t}\n\t\n\trdata->packet = s->packet;\n\trdata->packet_length = s->packet_length;\n\tmemcpy(&(rdata->rbuf), &(s->s3->rbuf), sizeof(SSL3_BUFFER));\n\tmemcpy(&(rdata->rrec), &(s->s3->rrec), sizeof(SSL3_RECORD));\n\n\titem->data = rdata;\n\n#ifndef OPENSSL_NO_SCTP\n\t\n\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t    (s->state == SSL3_ST_SR_FINISHED_A || s->state == SSL3_ST_CR_FINISHED_A)) {\n\t\tBIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_GET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo);\n\t}\n#endif\n\n\ts->packet = NULL;\n\ts->packet_length = 0;\n\tmemset(&(s->s3->rbuf), 0, sizeof(SSL3_BUFFER));\n\tmemset(&(s->s3->rrec), 0, sizeof(SSL3_RECORD));\n\t\n\tif (!ssl3_setup_buffers(s))\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(0);\n\t\t}\n\n\t\n\tif (pqueue_insert(queue->q, item) == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(0);\n\t\t}\n\n\treturn(1);\n\t}","24116":"open_exfile(\n    char_u\t*fname,\n    int\t\tforceit,\n    char\t*mode)\t    \n{\n    FILE\t*fd;\n\n#ifdef UNIX\n    \n    if (mch_isdir(fname))\n    {\n\tsemsg(_(e_src_is_directory), fname);\n\treturn NULL;\n    }\n#endif\n    if (!forceit && *mode != 'a' && vim_fexists(fname))\n    {\n\tsemsg(_(\"STR\"), fname);\n\treturn NULL;\n    }\n\n    if ((fd = mch_fopen((char *)fname, mode)) == NULL)\n\tsemsg(_(\"STR\"), fname);\n\n    return fd;\n}","24447":"static int _hostfs_release(oe_device_t* device)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n\n    if (!fs)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    oe_free(fs);\n    ret = 0;\n\ndone:\n    return ret;\n}","23930":"void fslib_copy_libs(const char *full_path) {\n\tassert(full_path);\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"STR\", full_path);\n\n\t\n\t\n\tif (access(full_path, R_OK)) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"STR\", full_path);\n\t\treturn;\n\t}\n\n\t\n\tunlink(RUN_LIB_FILE);\t\t\t  \n\tcreate_empty_file_as_root(RUN_LIB_FILE, 0644);\n\tif (chown(RUN_LIB_FILE, getuid(), getgid()))\n\t\terrExit(\"STR\");\n\n\t\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"STR\", full_path);\n\tsbox_run(SBOX_USER | SBOX_SECCOMP | SBOX_CAPS_NONE, 3, PATH_FLDD, full_path, RUN_LIB_FILE);\n\n\t\n\tFILE *fp = fopen(RUN_LIB_FILE, \"STR\");\n\tif (!fp)\n\t\terrExit(\"STR\");\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\t\tfslib_duplicate(buf);\n\t}\n\tfclose(fp);\n}","24479":"static struct aead_request *macsec_alloc_req(struct crypto_aead *tfm,\n\t\t\t\t\t     unsigned char **iv,\n\t\t\t\t\t     struct scatterlist **sg)\n{\n\tsize_t size, iv_offset, sg_offset;\n\tstruct aead_request *req;\n\tvoid *tmp;\n\n\tsize = sizeof(struct aead_request) + crypto_aead_reqsize(tfm);\n\tiv_offset = size;\n\tsize += GCM_AES_IV_LEN;\n\n\tsize = ALIGN(size, __alignof__(struct scatterlist));\n\tsg_offset = size;\n\tsize += sizeof(struct scatterlist) * (MAX_SKB_FRAGS + 1);\n\n\ttmp = kmalloc(size, GFP_ATOMIC);\n\tif (!tmp)\n\t\treturn NULL;\n\n\t*iv = (unsigned char *)(tmp + iv_offset);\n\t*sg = (struct scatterlist *)(tmp + sg_offset);\n\treq = tmp;\n\n\taead_request_set_tfm(req, tfm);\n\n\treturn req;\n}","24557":"static int arc_emac_tx(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct arc_emac_priv *priv = netdev_priv(ndev);\n\tunsigned int len, *txbd_curr = &priv->txbd_curr;\n\tstruct net_device_stats *stats = &ndev->stats;\n\t__le32 *info = &priv->txbd[*txbd_curr].info;\n\tdma_addr_t addr;\n\n\tif (skb_padto(skb, ETH_ZLEN))\n\t\treturn NETDEV_TX_OK;\n\n\tlen = max_t(unsigned int, ETH_ZLEN, skb->len);\n\n\tif (unlikely(!arc_emac_tx_avail(priv))) {\n\t\tnetif_stop_queue(ndev);\n\t\tnetdev_err(ndev, \"STR\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\taddr = dma_map_single(&ndev->dev, (void *)skb->data, len,\n\t\t\t      DMA_TO_DEVICE);\n\n\tif (unlikely(dma_mapping_error(&ndev->dev, addr))) {\n\t\tstats->tx_dropped++;\n\t\tstats->tx_errors++;\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tdma_unmap_addr_set(&priv->tx_buff[*txbd_curr], addr, addr);\n\tdma_unmap_len_set(&priv->tx_buff[*txbd_curr], len, len);\n\n\tpriv->tx_buff[*txbd_curr].skb = skb;\n\tpriv->txbd[*txbd_curr].data = cpu_to_le32(addr);\n\n\t\n\twmb();\n\n\tskb_tx_timestamp(skb);\n\n\t*info = cpu_to_le32(FOR_EMAC | FIRST_OR_LAST_MASK | len);\n\n\t\n\t*txbd_curr = (*txbd_curr + 1) % TX_BD_NUM;\n\n\t\n\tsmp_mb();\n\n\tif (!arc_emac_tx_avail(priv)) {\n\t\tnetif_stop_queue(ndev);\n\t\t\n\t\tsmp_mb();\n\t\tif (arc_emac_tx_avail(priv))\n\t\t\tnetif_start_queue(ndev);\n\t}\n\n\tarc_reg_set(priv, R_STATUS, TXPL_MASK);\n\n\treturn NETDEV_TX_OK;\n}","24300":"static struct fpm_child_s *fpm_resources_prepare(struct fpm_worker_pool_s *wp) \n{\n\tstruct fpm_child_s *c;\n\n\tc = fpm_child_alloc();\n\n\tif (!c) {\n\t\tzlog(ZLOG_ERROR, \"STR\", wp->config->name);\n\t\treturn 0;\n\t}\n\n\tc->wp = wp;\n\tc->fd_stdout = -1; c->fd_stderr = -1;\n\n\tif (0 > fpm_stdio_prepare_pipes(c)) {\n\t\tfpm_child_free(c);\n\t\treturn 0;\n\t}\n\n\tif (0 > fpm_scoreboard_proc_alloc(wp->scoreboard, &c->scoreboard_i)) {\n\t\tfpm_stdio_discard_pipes(c);\n\t\tfpm_child_free(c);\n\t\treturn 0;\n\t}\n\n\treturn c;\n}","24440":"DefragVlanQinQTest(void)\n{\n    Packet *p1 = NULL, *p2 = NULL, *r = NULL;\n    int ret = 0;\n\n    DefragInit();\n\n    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n    if (p1 == NULL)\n        goto end;\n    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n    if (p2 == NULL)\n        goto end;\n\n    \n    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)\n        goto end;\n    if ((r = Defrag(NULL, NULL, p2, NULL)) == NULL)\n        goto end;\n    SCFree(r);\n\n    \n    p1->vlan_id[0] = 1;\n    p2->vlan_id[0] = 1;\n    p1->vlan_id[1] = 1;\n    p2->vlan_id[1] = 2;\n    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)\n        goto end;\n    if ((r = Defrag(NULL, NULL, p2, NULL)) != NULL)\n        goto end;\n\n    \n    ret = 1;\n\nend:\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    DefragDestroy();\n\n    return ret;\n}","24778":"static Image *ReadVIDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n\n\n  char\n    **filelist,\n    *label,\n    **list;\n\n  Image\n    *image,\n    *images,\n    *montage_image,\n    *next_image,\n    *thumbnail_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    number_files;\n\n  MagickBooleanType\n    status;\n\n  MontageInfo\n    *montage_info;\n\n  RectangleInfo\n    geometry;\n\n  register ssize_t\n    i;\n\n  \n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"STR\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info);\n  list=(char **) AcquireMagickMemory(sizeof(*filelist));\n  if (list == (char **) NULL)\n    ThrowReaderException(ResourceLimitError,\"STR\");\n  list[0]=ConstantString(image_info->filename);\n  filelist=list;\n  number_files=1;\n  status=ExpandFilenames(&number_files,&filelist);\n  list[0]=DestroyString(list[0]);\n  list=(char **) RelinquishMagickMemory(list);\n  if ((status == MagickFalse) || (number_files == 0))\n    ThrowReaderException(ResourceLimitError,\"STR\");\n  image=DestroyImage(image);\n  \n  images=NewImageList();\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  if (read_info->size == (char *) NULL)\n    (void) CloneString(&read_info->size,DefaultTileGeometry);\n  for (i=0; i < (ssize_t) number_files; i++)\n  {\n    if (image_info->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"STR\",\n        filelist[i]);\n    (void) CopyMagickString(read_info->filename,filelist[i],MaxTextExtent);\n    filelist[i]=DestroyString(filelist[i]);\n    *read_info->magick='\\0';\n    next_image=ReadImage(read_info,exception);\n    CatchException(exception);\n    if (next_image == (Image *) NULL)\n      break;\n    label=InterpretImageProperties(image_info,next_image,DefaultTileLabel);\n    (void) SetImageProperty(next_image,\"STR\",label);\n    label=DestroyString(label);\n    if (image_info->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"STR\",(double) next_image->columns,(double)\n        next_image->rows);\n    SetGeometry(next_image,&geometry);\n    (void) ParseMetaGeometry(read_info->size,&geometry.x,&geometry.y,\n      &geometry.width,&geometry.height);\n    thumbnail_image=ThumbnailImage(next_image,geometry.width,geometry.height,\n      exception);\n    if (thumbnail_image != (Image *) NULL)\n      {\n        next_image=DestroyImage(next_image);\n        next_image=thumbnail_image;\n      }\n    if (image_info->debug != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"STR\",(double) next_image->columns,(double)\n        next_image->rows);\n    AppendImageToList(&images,next_image);\n    status=SetImageProgress(images,LoadImagesTag,i,number_files);\n    if (status == MagickFalse)\n      break;\n  }\n  read_info=DestroyImageInfo(read_info);\n  filelist=(char **) RelinquishMagickMemory(filelist);\n  if (images == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\n      \"STR\");\n  \n  montage_info=CloneMontageInfo(image_info,(MontageInfo *) NULL);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"STR\");\n  montage_image=MontageImageList(image_info,montage_info,\n    GetFirstImageInList(images),exception);\n  montage_info=DestroyMontageInfo(montage_info);\n  images=DestroyImageList(images);\n  return(montage_image);\n}","24770":"static void DumpBIH(unsigned char *BIH)\n{\t\t\t\t\n\tprintf(\"STR\",\n\t       (int)(BIH[3] << 24) + (BIH[2] << 16) + (BIH[1] << 8) + (BIH[0]));\n\tprintf(\"STR\",\n\t       (int)(BIH[7] << 24) + (BIH[6] << 16) + (BIH[5] << 8) + (BIH[4]));\n\tprintf(\"STR\",\n\t       (int)(BIH[11] << 24) + (BIH[10] << 16) + (BIH[9] << 8) +\n\t       (BIH[8]));\n\tprintf(\"STR\", (int)(BIH[13] << 8) + (BIH[12]));\n\tprintf(\"STR\", (int)(BIH[15] << 8) + (BIH[14]));\n\tprintf(\"STR\",\n\t       (int)(BIH[19] << 24) + (BIH[18] << 16) + (BIH[17] << 8) +\n\t       (BIH[16]));\n\tprintf(\"STR\",\n\t       (int)(BIH[23] << 24) + (BIH[22] << 16) + (BIH[21] << 8) +\n\t       (BIH[20]));\n\tprintf(\"STR\",\n\t       (int)(BIH[27] << 24) + (BIH[26] << 16) + (BIH[25] << 8) +\n\t       (BIH[24]));\n\tprintf(\"STR\",\n\t       (int)(BIH[31] << 24) + (BIH[30] << 16) + (BIH[29] << 8) +\n\t       (BIH[28]));\n\tprintf(\"STR\",\n\t       (int)(BIH[35] << 24) + (BIH[34] << 16) + (BIH[33] << 8) +\n\t       (BIH[32]));\n\tprintf(\"STR\",\n\t       (int)(BIH[39] << 24) + (BIH[38] << 16) + (BIH[37] << 8) +\n\t       (BIH[36]));\n}","23967":"request_env(agooReq req, VALUE self) {\n    if (Qnil == (VALUE)req->env) {\n\tvolatile VALUE\tenv = rb_hash_new();\n\n\t\n\t\n\t\n\n\trb_hash_aset(env, request_method_val, req_method(req));\n\trb_hash_aset(env, script_name_val, req_script_name(req));\n\trb_hash_aset(env, path_info_val, req_path_info(req));\n\trb_hash_aset(env, query_string_val, req_query_string(req));\n\trb_hash_aset(env, server_name_val, req_server_name(req));\n\trb_hash_aset(env, server_port_val, req_server_port(req));\n\tfill_headers(req, env);\n\trb_hash_aset(env, rack_version_val, rack_version_val_val);\n\trb_hash_aset(env, rack_url_scheme_val, req_rack_url_scheme(req));\n\trb_hash_aset(env, rack_input_val, req_rack_input(req));\n\trb_hash_aset(env, rack_errors_val, req_rack_errors(req));\n\trb_hash_aset(env, rack_multithread_val, req_rack_multithread(req));\n\trb_hash_aset(env, rack_multiprocess_val, Qfalse);\n\trb_hash_aset(env, rack_run_once_val, Qfalse);\n\trb_hash_aset(env, rack_logger_val, req_rack_logger(req));\n\trb_hash_aset(env, rack_upgrade_val, req_rack_upgrade(req));\n\trb_hash_aset(env, rack_hijackq_val, Qtrue);\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\trb_hash_aset(env, rack_hijack_val, self);\n\trb_hash_aset(env, rack_hijack_io_val, Qnil);\n\n\tif (agoo_server.rack_early_hints) {\n\t    volatile VALUE\teh = agoo_early_hints_new(req);\n\n\t    rb_hash_aset(env, early_hints_val, eh);\n\t}\n\treq->env = (void*)env;\n    }\n    return (VALUE)req->env;\n}","24418":"binder_enqueue_work_ilocked(struct binder_work *work,\n\t\t\t   struct list_head *target_list)\n{\n\tBUG_ON(target_list == NULL);\n\tBUG_ON(work->entry.next && !list_empty(&work->entry));\n\tlist_add_tail(&work->entry, target_list);\n}","24305":"header_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)\n{\n  struct ImapMbox mx;\n  struct Url url;\n  char cachepath[PATH_MAX];\n  char mbox[PATH_MAX];\n\n  if (path)\n    imap_cachepath(idata, path, mbox, sizeof(mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path(idata->ctx->path, &mx) < 0)\n      return NULL;\n\n    imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox));\n    FREE(&mx.mbox);\n  }\n\n  mutt_account_tourl(&idata->conn->account, &url);\n  url.path = mbox;\n  url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);\n\n  return mutt_hcache_open(HeaderCache, cachepath, imap_hcache_namer);\n}","24161":"void create_subpartition_name(char *out, const char *in1,\n                              const char *in2, const char *in3,\n                              uint name_variant)\n{\n  char transl_part_name[FN_REFLEN], transl_subpart_name[FN_REFLEN];\n\n  tablename_to_filename(in2, transl_part_name, FN_REFLEN);\n  tablename_to_filename(in3, transl_subpart_name, FN_REFLEN);\n  if (name_variant == NORMAL_PART_NAME)\n    strxmov(out, in1, \"STR\", transl_part_name,\n            \"STR\", transl_subpart_name, NullS);\n  else if (name_variant == TEMP_PART_NAME)\n    strxmov(out, in1, \"STR\", transl_part_name,\n            \"STR\", NullS);\n  else if (name_variant == RENAMED_PART_NAME)\n    strxmov(out, in1, \"STR\", transl_part_name,\n            \"STR\", NullS);\n}","24259":"X509::X509(const char* i, size_t iSz, const char* s, size_t sSz,\n           const char* b, int bSz, const char* a, int aSz)\n    : issuer_(i, iSz), subject_(s, sSz),\n      beforeDate_(b, bSz), afterDate_(a, aSz)\n{}","24533":"static inline int cpu_has_secondary_exec_ctrls(void)\n{\n\treturn (vmcs_config.cpu_based_exec_ctrl &\n\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS);\n}","24347":"const char *module_address_lookup(unsigned long addr,\n\t\t\t    unsigned long *size,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname,\n\t\t\t    char *namebuf)\n{\n\tconst char *ret = NULL;\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tmod = __module_address(addr);\n\tif (mod) {\n\t\tif (modname)\n\t\t\t*modname = mod->name;\n\n\t\tret = find_kallsyms_symbol(mod, addr, size, offset);\n\t}\n\t\n\tif (ret) {\n\t\tstrncpy(namebuf, ret, KSYM_NAME_LEN - 1);\n\t\tret = namebuf;\n\t}\n\tpreempt_enable();\n\n\treturn ret;\n}","24102":"free_connection (struct connection *conn)\n{\n  if (!conn)\n    return;\n\n  threadlocal_set_conn (NULL);\n  conn->close (conn);\n  if (listen_stdin) {\n    int fd;\n\n    \n    fd = open (\"STR\", O_WRONLY | O_CLOEXEC);\n    assert (fd == 0);\n    fd = open (\"STR\", O_RDONLY | O_CLOEXEC);\n    assert (fd == 1);\n  }\n\n  \n  if (!quit) {\n    if (conn->nr_handles > 0 && conn->handles[0]) {\n      lock_request (conn);\n      backend->close (backend, conn);\n      unlock_request (conn);\n    }\n  }\n\n  if (conn->status_pipe[0] >= 0) {\n    close (conn->status_pipe[0]);\n    close (conn->status_pipe[1]);\n  }\n\n  pthread_mutex_destroy (&conn->request_lock);\n  pthread_mutex_destroy (&conn->read_lock);\n  pthread_mutex_destroy (&conn->write_lock);\n  pthread_mutex_destroy (&conn->status_lock);\n\n  free (conn->handles);\n  free (conn);\n}","24189":"static rfbBool rectSwapIfLEAndClip(uint16_t* x,uint16_t* y,uint16_t* w,uint16_t* h,\n\t\trfbClientPtr cl)\n{\n\tint x1=Swap16IfLE(*x);\n\tint y1=Swap16IfLE(*y);\n\tint w1=Swap16IfLE(*w);\n\tint h1=Swap16IfLE(*h);\n\n\trfbScaledCorrection(cl->scaledScreen, cl->screen, &x1, &y1, &w1, &h1, \"STR\");\n\t*x = x1;\n\t*y = y1;\n\t*w = w1;\n\t*h = h1;\n\n\tif(*w>cl->screen->width-*x)\n\t\t*w=cl->screen->width-*x;\n\t\n\tif(*w>cl->screen->width-*x)\n\t\treturn FALSE;\n\tif(*h>cl->screen->height-*y)\n\t\t*h=cl->screen->height-*y;\n\tif(*h>cl->screen->height-*y)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}","24390":"int ssl3_do_change_cipher_spec(SSL *s)\n\t{\n\tint i;\n\tconst char *sender;\n\tint slen;\n\n\tif (s->state & SSL_ST_ACCEPT)\n\t\ti=SSL3_CHANGE_CIPHER_SERVER_READ;\n\telse\n\t\ti=SSL3_CHANGE_CIPHER_CLIENT_READ;\n\n\tif (s->s3->tmp.key_block == NULL)\n\t\t{\n\t\tif (s->session == NULL) \n\t\t\t{\n\t\t\t\n\t\t\tSSLerr(SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC,SSL_R_CCS_RECEIVED_EARLY);\n\t\t\treturn (0);\n\t\t\t}\n\n\t\ts->session->cipher=s->s3->tmp.new_cipher;\n\t\tif (!s->method->ssl3_enc->setup_key_block(s)) return(0);\n\t\t}\n\n\tif (!s->method->ssl3_enc->change_cipher_state(s,i))\n\t\treturn(0);\n\n\t\n\tif (s->state & SSL_ST_CONNECT)\n\t\t{\n\t\tsender=s->method->ssl3_enc->server_finished_label;\n\t\tslen=s->method->ssl3_enc->server_finished_label_len;\n\t\t}\n\telse\n\t\t{\n\t\tsender=s->method->ssl3_enc->client_finished_label;\n\t\tslen=s->method->ssl3_enc->client_finished_label_len;\n\t\t}\n\n\ts->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s,\n\t\t&(s->s3->finish_dgst1),\n\t\t&(s->s3->finish_dgst2),\n\t\tsender,slen,s->s3->tmp.peer_finish_md);\n\n\treturn(1);\n\t}","24472":"static char *ask_new_field(struct chfn_control *ctl, const char *question,\n\t\t\t   char *def_val)\n{\n\tint len;\n\tchar *buf = NULL; \n#ifndef HAVE_LIBREADLINE\n\tsize_t dummy = 0;\n#endif\n\n\tif (!def_val)\n\t\tdef_val = \"\";\n\twhile (true) {\n\t\tprintf(\"STR\", question, def_val);\n\t\t__fpurge(stdin);\n#ifdef HAVE_LIBREADLINE\n\t\trl_bind_key('\\t', rl_insert);\n\t\tif ((buf = readline(\"STR\")) == NULL)\n#else\n\t\tputchar(' ');\n\t\tfflush(stdout);\n\t\tif (getline(&buf, &dummy, stdin) < 0)\n#endif\n\t\t\terrx(EXIT_FAILURE, _(\"STR\"));\n\t\t\n\t\tltrim_whitespace((unsigned char *) buf);\n\t\tlen = rtrim_whitespace((unsigned char *) buf);\n\t\tif (len == 0) {\n\t\t\tfree(buf);\n\t\t\treturn xstrdup(def_val);\n\t\t}\n\t\tif (!strcasecmp(buf, \"STR\")) {\n\t\t\tfree(buf);\n\t\t\tctl->changed = 1;\n\t\t\treturn xstrdup(\"\");\n\t\t}\n\t\tif (check_gecos_string(question, buf) >= 0)\n\t\t\tbreak;\n\t}\n\tctl->changed = 1;\n\treturn buf;\n}","24711":"int sqlite3Fts3PendingTermsFlush(Fts3Table *p){\n  int rc = SQLITE_OK;\n  int i;\n        \n  for(i=0; rc==SQLITE_OK && i<p->nIndex; i++){\n    rc = fts3SegmentMerge(p, p->iPrevLangid, i, FTS3_SEGCURSOR_PENDING);\n    if( rc==SQLITE_DONE ) rc = SQLITE_OK;\n  }\n  sqlite3Fts3PendingTermsClear(p);\n\n  \n  if( rc==SQLITE_OK && p->bHasStat\n   && p->nAutoincrmerge==0xff && p->nLeafAdd>0\n  ){\n    sqlite3_stmt *pStmt = 0;\n    rc = fts3SqlStmt(p, SQL_SELECT_STAT, &pStmt, 0);\n    if( rc==SQLITE_OK ){\n      sqlite3_bind_int(pStmt, 1, FTS_STAT_AUTOINCRMERGE);\n      rc = sqlite3_step(pStmt);\n      if( rc==SQLITE_ROW ){\n        p->nAutoincrmerge = sqlite3_column_int(pStmt, 0);\n        if( p->nAutoincrmerge==1 ) p->nAutoincrmerge = 8;\n      }else if( rc==SQLITE_DONE ){\n        p->nAutoincrmerge = 0;\n      }\n      rc = sqlite3_reset(pStmt);\n    }\n  }\n  return rc;\n}","24288":"lib_set_system_encoding(self, enc_name)\n    VALUE self;\n    VALUE enc_name;\n{\n#if TCL_MAJOR_VERSION > 8 || (TCL_MAJOR_VERSION == 8 && TCL_MINOR_VERSION > 0)\n    tcl_stubs_check();\n\n    if (NIL_P(enc_name)) {\n        Tcl_SetSystemEncoding((Tcl_Interp *)NULL, (CONST char *)NULL);\n        return lib_get_system_encoding(self);\n    }\n\n    enc_name = rb_funcallv(enc_name, ID_to_s, 0, 0);\n    if (Tcl_SetSystemEncoding((Tcl_Interp *)NULL,\n                              StringValuePtr(enc_name)) != TCL_OK) {\n        rb_raise(rb_eArgError, \"STR\",\n                 RSTRING_PTR(enc_name));\n    }\n\n    return enc_name;\n#else\n    return Qnil;\n#endif\n}","24885":"int htc_connect_service(struct htc_target *target,\n\t\t     struct htc_service_connreq *service_connreq,\n\t\t     enum htc_endpoint_id *conn_rsp_epid)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_conn_svc_msg *conn_msg;\n\tint ret;\n\tunsigned long time_left;\n\n\t\n\tendpoint = get_next_avail_ep(target->endpoint);\n\tif (!endpoint) {\n\t\tdev_err(target->dev, \"STR\",\n\t\t\tservice_connreq->service_id);\n\t\treturn -EINVAL;\n\t}\n\n\tendpoint->service_id = service_connreq->service_id;\n\tendpoint->max_txqdepth = service_connreq->max_send_qdepth;\n\tendpoint->ul_pipeid = service_to_ulpipe(service_connreq->service_id);\n\tendpoint->dl_pipeid = service_to_dlpipe(service_connreq->service_id);\n\tendpoint->ep_callbacks = service_connreq->ep_callbacks;\n\n\tskb = alloc_skb(sizeof(struct htc_conn_svc_msg) +\n\t\t\t    sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"STR\"\n\t\t\t\"STR\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\n\tconn_msg = skb_put(skb, sizeof(struct htc_conn_svc_msg));\n\tconn_msg->service_id = cpu_to_be16(service_connreq->service_id);\n\tconn_msg->msg_id = cpu_to_be16(HTC_MSG_CONNECT_SERVICE_ID);\n\tconn_msg->con_flags = cpu_to_be16(service_connreq->con_flags);\n\tconn_msg->dl_pipeid = endpoint->dl_pipeid;\n\tconn_msg->ul_pipeid = endpoint->ul_pipeid;\n\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"STR\",\n\t\t\tservice_connreq->service_id);\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t*conn_rsp_epid = target->conn_rsp_epid;\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn ret;\n}","23962":"static int mif_hdr_growcmpts(mif_hdr_t *hdr, int maxcmpts)\n{\n\tint cmptno;\n\tmif_cmpt_t **newcmpts;\n\tassert(maxcmpts >= hdr->numcmpts);\n\tnewcmpts = (!hdr->cmpts) ? jas_malloc(maxcmpts * sizeof(mif_cmpt_t *)) :\n\t  jas_realloc(hdr->cmpts, maxcmpts * sizeof(mif_cmpt_t *));\n\tif (!newcmpts) {\n\t\treturn -1;\n\t}\n\thdr->maxcmpts = maxcmpts;\n\thdr->cmpts = newcmpts;\n\tfor (cmptno = hdr->numcmpts; cmptno < hdr->maxcmpts; ++cmptno) {\n\t\thdr->cmpts[cmptno] = 0;\n\t}\n\treturn 0;\n}","24685":"static inline void drbg_set_testdata(struct drbg_state *drbg,\n\t\t\t\t     struct drbg_test_data *test_data)\n{\n\tif (!test_data || !test_data->testentropy)\n\t\treturn;\n\tmutex_lock(&drbg->drbg_mutex);;\n\tdrbg->test_data = test_data;\n\tmutex_unlock(&drbg->drbg_mutex);\n}","24452":"int luaSetResp(lua_State *lua) {\n    int argc = lua_gettop(lua);\n\n    if (argc != 1) {\n        lua_pushstring(lua, \"STR\");\n        return lua_error(lua);\n    }\n\n    int resp = lua_tonumber(lua,-argc);\n    if (resp != 2 && resp != 3) {\n        lua_pushstring(lua, \"STR\");\n        return lua_error(lua);\n    }\n\n    server.lua_client->resp = resp;\n    return 0;\n}","24639":"xmlBufCreateSize(size_t size) {\n    xmlBufPtr ret;\n\n    ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));\n    if (ret == NULL) {\n\txmlBufMemoryError(NULL, \"STR\");\n        return(NULL);\n    }\n    ret->use = 0;\n    ret->error = 0;\n    ret->buffer = NULL;\n    ret->alloc = xmlBufferAllocScheme;\n    ret->size = (size ? size+2 : 0);         \n    UPDATE_COMPAT(ret);\n    if (ret->size){\n        ret->content = (xmlChar *) xmlMallocAtomic(ret->size * sizeof(xmlChar));\n        if (ret->content == NULL) {\n\t    xmlBufMemoryError(ret, \"STR\");\n            xmlFree(ret);\n            return(NULL);\n        }\n        ret->content[0] = 0;\n    } else\n\tret->content = NULL;\n    ret->contentIO = NULL;\n    return(ret);\n}","24359":"_parsedURL2Str(ParsedURL *pu, int pass)\n{\n    Str tmp;\n    static char *scheme_str[] = {\n\t\"STR\",\n\t\"STR\",\n#ifdef USE_SSL\n\t\"STR\",\n#endif\t\t\t\t\n    };\n\n    if (pu->scheme == SCM_MISSING) {\n\treturn Strnew_charp(\"STR\");\n    }\n    else if (pu->scheme == SCM_UNKNOWN) {\n\treturn Strnew_charp(pu->file);\n    }\n    if (pu->host == NULL && pu->file == NULL && pu->label != NULL) {\n\t\n\treturn Sprintf(\"STR\", pu->label);\n    }\n    if (pu->scheme == SCM_LOCAL && !strcmp(pu->file, \"STR\")) {\n\ttmp = Strnew_charp(\"STR\");\n\tif (pu->label) {\n\t    Strcat_char(tmp, '#');\n\t    Strcat_charp(tmp, pu->label);\n\t}\n\treturn tmp;\n    }\n    tmp = Strnew_charp(scheme_str[pu->scheme]);\n    Strcat_char(tmp, ':');\n#ifndef USE_W3MMAILER\n    if (pu->scheme == SCM_MAILTO) {\n\tStrcat_charp(tmp, pu->file);\n\tif (pu->query) {\n\t    Strcat_char(tmp, '?');\n\t    Strcat_charp(tmp, pu->query);\n\t}\n\treturn tmp;\n    }\n#endif\n    if (pu->scheme == SCM_DATA) {\n\tStrcat_charp(tmp, pu->file);\n\treturn tmp;\n    }\n#ifdef USE_NNTP\n    if (pu->scheme != SCM_NEWS && pu->scheme != SCM_NEWS_GROUP)\n#endif\t\t\t\t\n    {\n\tStrcat_charp(tmp, \"STR\");\n    }\n    if (pu->user) {\n\tStrcat_charp(tmp, pu->user);\n\tif (pass && pu->pass) {\n\t    Strcat_char(tmp, ':');\n\t    Strcat_charp(tmp, pu->pass);\n\t}\n\tStrcat_char(tmp, '@');\n    }\n    if (pu->host) {\n\tStrcat_charp(tmp, pu->host);\n\tif (pu->port != DefaultPort[pu->scheme]) {\n\t    Strcat_char(tmp, ':');\n\t    Strcat(tmp, Sprintf(\"STR\", pu->port));\n\t}\n    }\n    if (\n#ifdef USE_NNTP\n\t   pu->scheme != SCM_NEWS && pu->scheme != SCM_NEWS_GROUP &&\n#endif\t\t\t\t\n\t   (pu->file == NULL || (pu->file[0] != '\/'\n#ifdef SUPPORT_DOS_DRIVE_PREFIX\n\t\t\t\t && !(IS_ALPHA(pu->file[0])\n\t\t\t\t      && pu->file[1] == ':'\n\t\t\t\t      && pu->host == NULL)\n#endif\n\t    )))\n\tStrcat_char(tmp, '\/');\n    Strcat_charp(tmp, pu->file);\n    if (pu->scheme == SCM_FTPDIR && Strlastchar(tmp) != '\/')\n\tStrcat_char(tmp, '\/');\n    if (pu->query) {\n\tStrcat_char(tmp, '?');\n\tStrcat_charp(tmp, pu->query);\n    }\n    if (pu->label) {\n\tStrcat_char(tmp, '#');\n\tStrcat_charp(tmp, pu->label);\n    }\n    return tmp;\n}","24680":"static int _rbd_dev_v2_snap_size(struct rbd_device *rbd_dev, u64 snap_id,\n\t\t\t\tu8 *order, u64 *snap_size)\n{\n\t__le64 snapid = cpu_to_le64(snap_id);\n\tint ret;\n\tstruct {\n\t\tu8 order;\n\t\t__le64 size;\n\t} __attribute__ ((packed)) size_buf = { 0 };\n\n\tret = rbd_obj_method_sync(rbd_dev, &rbd_dev->header_oid,\n\t\t\t\t  &rbd_dev->header_oloc, \"STR\",\n\t\t\t\t  &snapid, sizeof(snapid),\n\t\t\t\t  &size_buf, sizeof(size_buf));\n\tdout(\"STR\", __func__, ret);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret < sizeof (size_buf))\n\t\treturn -ERANGE;\n\n\tif (order) {\n\t\t*order = size_buf.order;\n\t\tdout(\"STR\", (unsigned int)*order);\n\t}\n\t*snap_size = le64_to_cpu(size_buf.size);\n\n\tdout(\"STR\",\n\t\t(unsigned long long)snap_id,\n\t\t(unsigned long long)*snap_size);\n\n\treturn 0;\n}","24569":"crm_send_remote_msg_raw(void *session, const char *buf, size_t len, gboolean encrypted)\n{\n    int rc = -1;\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        rc = crm_send_tls(session, buf, len);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        rc = crm_send_plaintext(GPOINTER_TO_INT(session), buf, len);\n    }\n    return rc;\n}","24844":"static BROTLI_INLINE uint32_t BlockLengthPrefixCode(uint32_t len) {\n  uint32_t code = (len >= 177) ? (len >= 753 ? 20 : 14) : (len >= 41 ? 7 : 0);\n  while (code < (BROTLI_NUM_BLOCK_LEN_SYMBOLS - 1) &&\n      len >= kBlockLengthPrefixCode[code + 1].offset) ++code;\n  return code;\n}","23960":"u64 get_jiffies_64(void)\n{\n\tunsigned long seq;\n\tu64 ret;\n\n\tdo {\n\t\tseq = read_seqbegin(&xtime_lock);\n\t\tret = jiffies_64;\n\t} while (read_seqretry(&xtime_lock, seq));\n\treturn ret;\n}","24203":"init_syntax_once ()\n{\n   register int c;\n   static int done;\n\n   if (done)\n     return;\n\n   bzero (re_syntax_table, sizeof re_syntax_table);\n\n   for (c = 'a'; c <= 'z'; c++)\n     re_syntax_table[c] = Sword;\n\n   for (c = 'A'; c <= 'Z'; c++)\n     re_syntax_table[c] = Sword;\n\n   for (c = '0'; c <= '9'; c++)\n     re_syntax_table[c] = Sword;\n\n   re_syntax_table['_'] = Sword;\n\n   done = 1;\n}","24744":"xfs_alloc_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\t\n\txfs_agblock_t\t\tbno,\t\n\txfs_extlen_t\t\tlen,\t\n\tint\t\t\t*stat)\t\n{\n\tint\t\t\terror;\n\n\tcur->bc_rec.a.ar_startblock = bno;\n\tcur->bc_rec.a.ar_blockcount = len;\n\terror = xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n\tcur->bc_private.a.priv.abt.active = (*stat == 1);\n\treturn error;\n}","24541":"\nstatic int kvm_init_mmu_notifier(struct kvm *kvm)\n{\n\treturn 0;","24067":"int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_sregs *sregs)\n{\n\tint mmu_reset_needed = 0;\n\tint i, pending_vec, max_bits;\n\tstruct descriptor_table dt;\n\n\tvcpu_load(vcpu);\n\n\tdt.limit = sregs->idt.limit;\n\tdt.base = sregs->idt.base;\n\tkvm_x86_ops->set_idt(vcpu, &dt);\n\tdt.limit = sregs->gdt.limit;\n\tdt.base = sregs->gdt.base;\n\tkvm_x86_ops->set_gdt(vcpu, &dt);\n\n\tvcpu->arch.cr2 = sregs->cr2;\n\tmmu_reset_needed |= vcpu->arch.cr3 != sregs->cr3;\n\tvcpu->arch.cr3 = sregs->cr3;\n\n\tkvm_set_cr8(vcpu, sregs->cr8);\n\n\tmmu_reset_needed |= vcpu->arch.shadow_efer != sregs->efer;\n\tkvm_x86_ops->set_efer(vcpu, sregs->efer);\n\tkvm_set_apic_base(vcpu, sregs->apic_base);\n\n\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\n\tmmu_reset_needed |= vcpu->arch.cr0 != sregs->cr0;\n\tkvm_x86_ops->set_cr0(vcpu, sregs->cr0);\n\tvcpu->arch.cr0 = sregs->cr0;\n\n\tmmu_reset_needed |= vcpu->arch.cr4 != sregs->cr4;\n\tkvm_x86_ops->set_cr4(vcpu, sregs->cr4);\n\tif (!is_long_mode(vcpu) && is_pae(vcpu))\n\t\tload_pdptrs(vcpu, vcpu->arch.cr3);\n\n\tif (mmu_reset_needed)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif (!irqchip_in_kernel(vcpu->kvm)) {\n\t\tmemcpy(vcpu->arch.irq_pending, sregs->interrupt_bitmap,\n\t\t       sizeof vcpu->arch.irq_pending);\n\t\tvcpu->arch.irq_summary = 0;\n\t\tfor (i = 0; i < ARRAY_SIZE(vcpu->arch.irq_pending); ++i)\n\t\t\tif (vcpu->arch.irq_pending[i])\n\t\t\t\t__set_bit(i, &vcpu->arch.irq_summary);\n\t} else {\n\t\tmax_bits = (sizeof sregs->interrupt_bitmap) << 3;\n\t\tpending_vec = find_first_bit(\n\t\t\t(const unsigned long *)sregs->interrupt_bitmap,\n\t\t\tmax_bits);\n\t\t\n\t\tif (pending_vec < max_bits) {\n\t\t\tkvm_x86_ops->set_irq(vcpu, pending_vec);\n\t\t\tpr_debug(\"STR\",\n\t\t\t\t pending_vec);\n\t\t}\n\t\tkvm_pic_clear_isr_ack(vcpu->kvm);\n\t}\n\n\tkvm_set_segment(vcpu, &sregs->cs, VCPU_SREG_CS);\n\tkvm_set_segment(vcpu, &sregs->ds, VCPU_SREG_DS);\n\tkvm_set_segment(vcpu, &sregs->es, VCPU_SREG_ES);\n\tkvm_set_segment(vcpu, &sregs->fs, VCPU_SREG_FS);\n\tkvm_set_segment(vcpu, &sregs->gs, VCPU_SREG_GS);\n\tkvm_set_segment(vcpu, &sregs->ss, VCPU_SREG_SS);\n\n\tkvm_set_segment(vcpu, &sregs->tr, VCPU_SREG_TR);\n\tkvm_set_segment(vcpu, &sregs->ldt, VCPU_SREG_LDTR);\n\n\t\n\tif (vcpu->vcpu_id == 0 && kvm_rip_read(vcpu) == 0xfff0 &&\n\t    sregs->cs.selector == 0xf000 && sregs->cs.base == 0xffff0000 &&\n\t    !(vcpu->arch.cr0 & X86_CR0_PE))\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\n\tvcpu_put(vcpu);\n\n\treturn 0;\n}","24936":"    static Value performCastDoubleToLong(ExpressionContext* const expCtx, Value inputValue) {\n        double inputDouble = inputValue.getDouble();\n        validateDoubleValueIsFinite(inputDouble);\n\n        uassert(ErrorCodes::ConversionFailure,\n                str::stream()\n                    << \"STR\"\n                    << inputDouble,\n                inputDouble >= std::numeric_limits<long long>::lowest() &&\n                    inputDouble < BSONElement::kLongLongMaxPlusOneAsDouble);\n\n        return Value(static_cast<long long>(inputDouble));\n    }","24474":"const char *ssh_scp_request_get_warning(ssh_scp scp){\n  if(scp==NULL)\n      return NULL;\n\treturn scp->warning;\n}","24364":"static CPLXMLNode* FLTFindGeometryNode(CPLXMLNode* psXMLNode,\n                                       int* pbPoint,\n                                       int* pbLine,\n                                       int* pbPolygon)\n{\n    CPLXMLNode *psGMLElement = NULL;\n\n    psGMLElement = CPLGetXMLNode(psXMLNode, \"STR\");\n    if (!psGMLElement)\n        psGMLElement =  CPLGetXMLNode(psXMLNode, \"STR\");\n    if (psGMLElement)\n        *pbPoint =1;\n    else {\n      psGMLElement= CPLGetXMLNode(psXMLNode, \"STR\");\n      if (psGMLElement)\n        *pbPolygon = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"STR\")))\n        *pbPolygon = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"STR\")))\n        *pbPolygon = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"STR\")))\n        *pbPolygon = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"STR\")))\n        *pbPolygon = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"STR\")))\n        *pbLine = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"STR\")))\n        *pbLine = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"STR\")))\n        *pbLine = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"STR\")))\n        *pbLine = 1;\n      else if ((psGMLElement= CPLGetXMLNode(psXMLNode, \"STR\")))\n        *pbPoint = 1;\n    }\n    return psGMLElement;\n}","24280":"static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)\n{\n    ssize_t ret;\n    guint watch;\n\n    assert(qemu_in_coroutine());\n    \n    watch = qio_channel_add_watch(ioc,\n                                  G_IO_OUT,\n                                  nbd_negotiate_continue,\n                                  qemu_coroutine_self(),\n                                  NULL);\n    ret = nbd_write(ioc, buffer, size, NULL);\n    g_source_remove(watch);\n    return ret;\n}","24291":"static __u32 cifs_ssetup_hdr(struct cifs_ses *ses, SESSION_SETUP_ANDX *pSMB)\n{\n\t__u32 capabilities = 0;\n\n\t\n\t\n\t\n\t\n\t\n\tpSMB->req.AndXCommand = 0xFF;\n\tpSMB->req.MaxBufferSize = cpu_to_le16(min_t(u32,\n\t\t\t\t\tCIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4,\n\t\t\t\t\tUSHRT_MAX));\n\tpSMB->req.MaxMpxCount = cpu_to_le16(ses->server->maxReq);\n\tpSMB->req.VcNumber = cpu_to_le16(1);\n\n\t\n\n\t\n\n\tcapabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |\n\t\t\tCAP_LARGE_WRITE_X | CAP_LARGE_READ_X;\n\n\tif (ses->server->sign)\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_UNICODE;\n\t\tcapabilities |= CAP_UNICODE;\n\t}\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_ERR_STATUS;\n\t\tcapabilities |= CAP_STATUS32;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_DFS;\n\t\tcapabilities |= CAP_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNIX)\n\t\tcapabilities |= CAP_UNIX;\n\n\treturn capabilities;\n}","24565":"genl_can_suspend_yes(VOID_ARGS)\n{\n    return TRUE;\n}","24333":"dissect_kafka_offset_fetch_response_partition(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                              int start_offset, kafka_api_version_t api_version)\n{\n    proto_item *ti;\n    proto_tree *subtree;\n    int         offset = start_offset;\n    kafka_packet_values_t packet_values;\n    memset(&packet_values, 0, sizeof(packet_values));\n\n    subtree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_kafka_partition, &ti, \"STR\");\n\n    offset = dissect_kafka_partition_id_ret(tvb, pinfo, subtree, offset, &packet_values.partition_id);\n    offset = dissect_kafka_offset_ret(tvb, pinfo, subtree, offset, &packet_values.offset);\n\n    if (api_version >= 5) {\n        offset = dissect_kafka_leader_epoch(tvb, pinfo, subtree, offset, api_version);\n    }\n\n\n    offset = dissect_kafka_string(subtree, hf_kafka_metadata, tvb, pinfo, offset, api_version >= 6, NULL, NULL);\n\n    offset = dissect_kafka_error(tvb, pinfo, subtree, offset);\n\n    if (packet_values.offset==-1) {\n        proto_item_append_text(ti, \"STR\",\n                               packet_values.partition_id);\n    } else {\n        proto_item_append_text(ti, \"STR\",\n                               packet_values.partition_id, packet_values.offset);\n    }\n\n    if (api_version >= 6) {\n        offset = dissect_kafka_tagged_fields(tvb, pinfo, subtree, offset, 0);\n    }\n\n    proto_item_set_end(ti, tvb, offset);\n\n    return offset;\n}","24491":"inline void WireFormatLite::WriteEnumNoTag(int value,\n                                           io::CodedOutputStream* output) {\n  output->WriteVarint32SignExtended(value);\n}","24739":"  void ValidateInputTensors(OpKernelContext* ctx, const Tensor& in0,\n                            const Tensor& in1) override {\n    OP_REQUIRES(\n        ctx, in0.dims() >= 2,\n        errors::InvalidArgument(\"STR\", in0.dims()));\n\n    OP_REQUIRES(\n        ctx, in1.dims() >= 2,\n        errors::InvalidArgument(\"STR\", in1.dims()));\n  }","24567":"mt_free(mrb_state *mrb, mt_tbl *t)\n{\n  mrb_free(mrb, t->ptr);\n  mrb_free(mrb, t);\n}","24415":"print_p2r_setparameters (const unsigned char *msg, size_t msglen)\n{\n  print_p2r_header (\"STR\", msg, msglen);\n  if (msglen < 10)\n    return;\n  DEBUGOUT_1 (\"STR\", msg[7]);\n  print_pr_data (msg, msglen, 8);\n}","24974":"static void fix_hostname(struct SessionHandle *data,\n                         struct connectdata *conn, struct hostname *host)\n{\n  size_t len;\n\n#ifndef USE_LIBIDN\n  (void)data;\n  (void)conn;\n#elif defined(CURL_DISABLE_VERBOSE_STRINGS)\n  (void)conn;\n#endif\n\n  \n  host->dispname = host->name;\n\n  len = strlen(host->name);\n  if(host->name[len-1] == '.')\n    \n    host->name[len-1]=0;\n\n  if(!is_ASCII_name(host->name)) {\n#ifdef USE_LIBIDN\n  \n  if(stringprep_check_version(LIBIDN_REQUIRED_VERSION)) {\n    char *ace_hostname = NULL;\n    int rc = idna_to_ascii_lz(host->name, &ace_hostname, 0);\n    infof (data, \"STR\",\n           stringprep_locale_charset ());\n    if(rc != IDNA_SUCCESS)\n      infof(data, \"STR\",\n            host->name, Curl_idn_strerror(conn, rc));\n    else {\n      \n      (void)tld_check_name(data, ace_hostname);\n\n      host->encalloc = ace_hostname;\n      \n      host->name = host->encalloc;\n    }\n  }\n#elif defined(USE_WIN32_IDN)\n  \n    char *ace_hostname = NULL;\n    int rc = curl_win32_idn_to_ascii(host->name, &ace_hostname);\n    if(rc == 0)\n      infof(data, \"STR\",\n            host->name);\n    else {\n      host->encalloc = ace_hostname;\n      \n      host->name = host->encalloc;\n    }\n#else\n    infof(data, \"STR\");\n#endif\n  }\n}","24880":"void *av_realloc(void *ptr, size_t size)\n{\n#if CONFIG_MEMALIGN_HACK\n    int diff;\n#endif\n\n    \n    if (size > (max_alloc_size - 32))\n        return NULL;\n\n#if CONFIG_MEMALIGN_HACK\n    \n    if (!ptr)\n        return av_malloc(size);\n    diff = ((char *)ptr)[-1];\n    av_assert0(diff>0 && diff<=ALIGN);\n    ptr = realloc((char *)ptr - diff, size + diff);\n    if (ptr)\n        ptr = (char *)ptr + diff;\n    return ptr;\n#elif HAVE_ALIGNED_MALLOC\n    return _aligned_realloc(ptr, size + !size, ALIGN);\n#else\n    return realloc(ptr, size + !size);\n#endif\n}","25032":"static int csnmp_config_add_host_collect(host_definition_t *host,\n                                         oconfig_item_t *ci) {\n  data_definition_t *data;\n  data_definition_t **data_list;\n  int data_list_len;\n\n  if (ci->values_num < 1) {\n    WARNING(\"STR\");\n    return (-1);\n  }\n\n  for (int i = 0; i < ci->values_num; i++)\n    if (ci->values[i].type != OCONFIG_TYPE_STRING) {\n      WARNING(\"STR\");\n      return (-1);\n    }\n\n  data_list_len = host->data_list_len + ci->values_num;\n  data_list =\n      realloc(host->data_list, sizeof(data_definition_t *) * data_list_len);\n  if (data_list == NULL)\n    return (-1);\n  host->data_list = data_list;\n\n  for (int i = 0; i < ci->values_num; i++) {\n    for (data = data_head; data != NULL; data = data->next)\n      if (strcasecmp(ci->values[i].value.string, data->name) == 0)\n        break;\n\n    if (data == NULL) {\n      WARNING(\"STR\",\n              ci->values[i].value.string);\n      continue;\n    }\n\n    DEBUG(\"STR\", host->name,\n          host->data_list_len, data->name);\n\n    host->data_list[host->data_list_len] = data;\n    host->data_list_len++;\n  } \n\n  return (0);\n} ","24255":"static void __init mp_override_legacy_irq(u8 bus_irq, u8 polarity, u8 trigger,\n\t\t\t\t\t  u32 gsi)\n{\n\tint ioapic;\n\tint pin;\n\tstruct mpc_intsrc mp_irq;\n\n\t\n\tioapic = mp_find_ioapic(gsi);\n\tif (ioapic < 0)\n\t\treturn;\n\tpin = mp_find_ioapic_pin(ioapic, gsi);\n\n\t\n\tif ((bus_irq == 0) && (trigger == 3))\n\t\ttrigger = 1;\n\n\tmp_irq.type = MP_INTSRC;\n\tmp_irq.irqtype = mp_INT;\n\tmp_irq.irqflag = (trigger << 2) | polarity;\n\tmp_irq.srcbus = MP_ISA_BUS;\n\tmp_irq.srcbusirq = bus_irq;\t\n\tmp_irq.dstapic = mpc_ioapic_id(ioapic); \n\tmp_irq.dstirq = pin;\t\n\n\tmp_save_irq(&mp_irq);\n\n\t\n\tif (gsi < nr_legacy_irqs() && isa_irq_to_gsi[gsi] == gsi)\n\t\tisa_irq_to_gsi[gsi] = ACPI_INVALID_GSI;\n\tisa_irq_to_gsi[bus_irq] = gsi;\n}","24441":"static ssize_t _epoll_read(oe_fd_t* epoll_, void* buf, size_t count)\n{\n    ssize_t ret = -1;\n    epoll_t* file = _cast_epoll(epoll_);\n\n    oe_errno = 0;\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    \n    if (oe_syscall_read_ocall(&ret, file->host_fd, buf, count) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}","24177":"static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,\n\t\t\t     struct prefix_info *pinfo, u32 portid, u32 seq,\n\t\t\t     int event, unsigned int flags)\n{\n\tstruct prefixmsg *pmsg;\n\tstruct nlmsghdr *nlh;\n\tstruct prefix_cacheinfo\tci;\n\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(*pmsg), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tpmsg = nlmsg_data(nlh);\n\tpmsg->prefix_family = AF_INET6;\n\tpmsg->prefix_pad1 = 0;\n\tpmsg->prefix_pad2 = 0;\n\tpmsg->prefix_ifindex = idev->dev->ifindex;\n\tpmsg->prefix_len = pinfo->prefix_len;\n\tpmsg->prefix_type = pinfo->type;\n\tpmsg->prefix_pad3 = 0;\n\tpmsg->prefix_flags = 0;\n\tif (pinfo->onlink)\n\t\tpmsg->prefix_flags |= IF_PREFIX_ONLINK;\n\tif (pinfo->autoconf)\n\t\tpmsg->prefix_flags |= IF_PREFIX_AUTOCONF;\n\n\tif (nla_put(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix))\n\t\tgoto nla_put_failure;\n\tci.preferred_time = ntohl(pinfo->prefered);\n\tci.valid_time = ntohl(pinfo->valid);\n\tif (nla_put(skb, PREFIX_CACHEINFO, sizeof(ci), &ci))\n\t\tgoto nla_put_failure;\n\treturn nlmsg_end(skb, nlh);\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}","23993":"int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\n\tpr_debug(\"STR\", event);\n\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\t\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\n\t\ttransaction->aid_len = skb->data[1];\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\n\t\t\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"STR\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}","24749":"static int em_lgdt(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct desc_ptr desc_ptr;\n\tint rc;\n\n\trc = read_descriptor(ctxt, ctxt->src.addr.mem,\n\t\t\t     &desc_ptr.size, &desc_ptr.address,\n\t\t\t     ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->ops->set_gdt(ctxt, &desc_ptr);\n\t\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}","24226":"static int gnutls_system_mutex_init(void **priv)\n{\n\tpthread_mutex_t *lock = malloc(sizeof(pthread_mutex_t));\n\tint ret;\n\n\tif (lock == NULL)\n\t\treturn GNUTLS_E_MEMORY_ERROR;\n\n\tret = pthread_mutex_init(lock, NULL);\n\tif (ret) {\n\t\tfree(lock);\n\t\tgnutls_assert();\n\t\treturn GNUTLS_E_LOCKING_ERROR;\n\t}\n\n\t*priv = lock;\n\n\treturn 0;\n}","24310":"static inline long div_ll_X_l_rem(long long divs, long div, long *rem)\n{\n\tlong dum2;\n\tasm(\"STR\"(*rem)\n\t    : \"STR\"(divs));\n\n\treturn dum2;\n\n}","24460":"int32_t ByteArray::Get(int32_t index) {\n  return InternalGet(index) & 0xff;\n}","24864":"static void exif_iif_add_tag(image_info_type *image_info, int section_index, char *name, int tag, int format, size_t length, void* value)\n{\n\texif_iif_add_value(image_info, section_index, name, tag, format, (int)length, value, image_info->motorola_intel);\n}","24727":"test_client_auth_request_fail (TestConnection *test,\n                               gconstpointer   data)\n{\n  GIOStream *connection;\n  GError *error = NULL;\n  GTlsInteraction *interaction;\n\n  test->database = g_tls_file_database_new (tls_test_file_path (\"STR\"), &error);\n  g_assert_no_error (error);\n  g_assert_nonnull (test->database);\n\n  connection = start_async_server_and_connect_to_it (test, G_TLS_AUTHENTICATION_REQUIRED);\n  test->client_connection = g_tls_client_connection_new (connection, test->identity, &error);\n  g_assert_no_error (error);\n  g_assert_nonnull (test->client_connection);\n  g_object_unref (connection);\n\n  g_tls_connection_set_database (G_TLS_CONNECTION (test->client_connection), test->database);\n\n  \n  interaction = mock_interaction_new_static_error (G_FILE_ERROR, G_FILE_ERROR_ACCES, \"STR\");\n  g_tls_connection_set_interaction (G_TLS_CONNECTION (test->client_connection), interaction);\n  g_object_unref (interaction);\n\n  \n  g_tls_client_connection_set_validation_flags (G_TLS_CLIENT_CONNECTION (test->client_connection),\n                                                G_TLS_CERTIFICATE_VALIDATE_ALL);\n\n  g_set_error_literal (&test->expected_client_close_error, G_TLS_ERROR, G_TLS_ERROR_CERTIFICATE_REQUIRED, \"\");\n\n  read_test_data_async (test);\n  g_main_loop_run (test->loop);\n  wait_until_server_finished (test);\n\n  \n  g_assert_error (test->read_error, G_FILE_ERROR, G_FILE_ERROR_ACCES);\n  g_assert_error (test->server_error, G_TLS_ERROR, G_TLS_ERROR_CERTIFICATE_REQUIRED);\n\n  g_io_stream_close (test->server_connection, NULL, NULL);\n  g_io_stream_close (test->client_connection, NULL, NULL);\n}","24118":"static void __mce_disable_bank(void *arg)\n{\n\tint bank = *((int *)arg);\n\t__clear_bit(bank, this_cpu_ptr(mce_poll_banks));\n\tcmci_disable_bank(bank);\n}","24572":"ews_config_lookup_worker_run (EConfigLookupWorker *lookup_worker,\n\t\t\t      EConfigLookup *config_lookup,\n\t\t\t      const ENamedParameters *params,\n\t\t\t      ENamedParameters **out_restart_params,\n\t\t\t      GCancellable *cancellable,\n\t\t\t      GError **error)\n{\n\tCamelEwsSettings *ews_settings = NULL;\n\tESource *source;\n\tconst gchar *email_address;\n\tconst gchar *password;\n\tconst gchar *extension_name;\n\n\tg_return_if_fail (E_IS_EWS_CONFIG_LOOKUP (lookup_worker));\n\tg_return_if_fail (E_IS_CONFIG_LOOKUP (config_lookup));\n\tg_return_if_fail (params != NULL);\n\n\temail_address = e_named_parameters_get (params, E_CONFIG_LOOKUP_PARAM_EMAIL_ADDRESS);\n\n\tif (!email_address || !*email_address)\n\t\treturn;\n\n\tif (!e_named_parameters_exists (params, E_CONFIG_LOOKUP_PARAM_PASSWORD)) {\n\t\tg_set_error (error, E_CONFIG_LOOKUP_WORKER_ERROR, E_CONFIG_LOOKUP_WORKER_ERROR_REQUIRES_PASSWORD,\n\t\t\t_(\"STR\"));\n\t\treturn;\n\t}\n\n\tews_settings = g_object_new (CAMEL_TYPE_EWS_SETTINGS, NULL);\n\tcamel_ews_settings_set_email (ews_settings, email_address);\n\n\textension_name = e_source_camel_get_extension_name (\"STR\");\n\tsource = e_config_lookup_get_source (config_lookup, E_CONFIG_LOOKUP_SOURCE_COLLECTION);\n\tif (source && e_source_has_extension (source, extension_name)) {\n\t\tESourceCamel *camel_extension;\n\t\tCamelSettings *settings;\n\n\t\tcamel_extension = e_source_get_extension (source, extension_name);\n\t\tsettings = e_source_camel_get_settings (camel_extension);\n\n\t\t\n\t\tif (CAMEL_IS_EWS_SETTINGS (settings))\n\t\t\tcamel_ews_settings_set_hosturl (ews_settings, camel_ews_settings_get_hosturl (CAMEL_EWS_SETTINGS (settings)));\n\t}\n\n\tpassword = e_named_parameters_get (params, E_CONFIG_LOOKUP_PARAM_PASSWORD);\n\n\tif (password) {\n\t\tconst gchar *servers;\n\n\t\tif (e_ews_autodiscover_ws_url_sync (source, ews_settings, email_address, password, cancellable, NULL)) {\n\t\t\tews_config_lookup_worker_result_from_settings (lookup_worker, config_lookup, email_address, ews_settings, params);\n\t\t}\n\n\t\tservers = e_named_parameters_get (params, E_CONFIG_LOOKUP_PARAM_SERVERS);\n\n\t\tif (servers && *servers) {\n\t\t\tgchar **servers_strv;\n\t\t\tgint ii;\n\n\t\t\tservers_strv = g_strsplit (servers, \"STR\", 0);\n\n\t\t\tfor (ii = 0; servers_strv && servers_strv[ii] && !g_cancellable_is_cancelled (cancellable); ii++) {\n\t\t\t\tconst gchar *server = servers_strv[ii];\n\t\t\t\tgchar *tmp = NULL;\n\n\t\t\t\tif (*server && !strstr (server, \"STR\")) {\n\t\t\t\t\ttmp = g_strconcat (\"STR\", NULL);\n\t\t\t\t\tserver = tmp;\n\t\t\t\t}\n\n\t\t\t\tcamel_ews_settings_set_hosturl (ews_settings, server);\n\n\t\t\t\tif (e_ews_autodiscover_ws_url_sync (source, ews_settings, email_address, password, cancellable, NULL)) {\n\t\t\t\t\tews_config_lookup_worker_result_from_settings (lookup_worker, config_lookup, email_address, ews_settings, params);\n\t\t\t\t}\n\n\t\t\t\tg_free (tmp);\n\t\t\t}\n\n\t\t\tg_strfreev (servers_strv);\n\t\t}\n\n\t\tif (out_restart_params)\n\t\t\t*out_restart_params = e_named_parameters_new_clone (params);\n\t}\n\n\tg_clear_object (&ews_settings);\n}","25055":"BROTLI_BOOL BrotliDecoderHuffmanTreeGroupInit(BrotliDecoderState* s,\n    HuffmanTreeGroup* group, uint32_t alphabet_size_max,\n    uint32_t alphabet_size_limit, uint32_t ntrees) {\n  \n  const size_t max_table_size =\n      kMaxHuffmanTableSize[(alphabet_size_limit + 31) >> 5];\n  const size_t code_size = sizeof(HuffmanCode) * ntrees * max_table_size;\n  const size_t htree_size = sizeof(HuffmanCode*) * ntrees;\n  \n  HuffmanCode** p = (HuffmanCode**)BROTLI_DECODER_ALLOC(s,\n      code_size + htree_size);\n  group->alphabet_size_max = (uint16_t)alphabet_size_max;\n  group->alphabet_size_limit = (uint16_t)alphabet_size_limit;\n  group->num_htrees = (uint16_t)ntrees;\n  group->htrees = p;\n  group->codes = (HuffmanCode*)(&p[ntrees]);\n  return !!p;\n}","24510":"bool CephxAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n\t\t\t\t\t      bufferlist& authorizer_data, bufferlist& authorizer_reply,\n                                              EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,  uint64_t *auid)\n{\n  bufferlist::iterator iter = authorizer_data.begin();\n\n  if (!authorizer_data.length()) {\n    ldout(cct, 1) << \"STR\" << dendl;\n    return false;\n  }\n\n  CephXServiceTicketInfo auth_ticket_info;\n\n  bool isvalid = cephx_verify_authorizer(cct, keys, iter, auth_ticket_info, authorizer_reply);\n\n  if (isvalid) {\n    caps_info = auth_ticket_info.ticket.caps;\n    entity_name = auth_ticket_info.ticket.name;\n    global_id = auth_ticket_info.ticket.global_id;\n    session_key = auth_ticket_info.session_key;\n    if (auid) *auid = auth_ticket_info.ticket.auid;\n  }\n\n  return isvalid;\n}","24667":"static MagickBooleanType IsWEBPImageLossless(const unsigned char *stream,\n  const size_t length)\n{\n\n\n\n\n\n\n\n\n\n\n\n\n  ssize_t\n    offset;\n\n  \n  if (stream[VP8_CHUNK_INDEX] != EXTENDED_HEADER)\n    return(stream[VP8_CHUNK_INDEX] == LOSSLESS_FLAG ? MagickTrue : MagickFalse);\n  \n  offset=RIFF_HEADER_SIZE+TAG_SIZE+CHUNK_SIZE_BYTES+VP8X_CHUNK_SIZE;\n  while (offset <= (ssize_t) (length-TAG_SIZE))\n  {\n    uint32_t\n      chunk_size,\n      chunk_size_pad;\n\n    chunk_size=ReadWebPLSBWord(stream+offset+TAG_SIZE);\n    if (chunk_size > MAX_CHUNK_PAYLOAD)\n      break;\n    chunk_size_pad=(CHUNK_HEADER_SIZE+chunk_size+1) & ~1;\n    if (memcmp(stream+offset,VP8_CHUNK_HEADER,VP8_CHUNK_HEADER_SIZE) == 0)\n      return(*(stream+offset+VP8_CHUNK_HEADER_SIZE) == LOSSLESS_FLAG ?\n        MagickTrue : MagickFalse);\n    offset+=chunk_size_pad;\n  }\n  return(MagickFalse);\n}","24753":"static void jas_icctxtdesc_destroy(jas_iccattrval_t *attrval)\n{\n\tjas_icctxtdesc_t *txtdesc = &attrval->data.txtdesc;\n\tif (txtdesc->ascdata)\n\t\tjas_free(txtdesc->ascdata);\n\tif (txtdesc->ucdata)\n\t\tjas_free(txtdesc->ucdata);\n}","23908":"static void evtchn_fifo_handle_events(unsigned cpu)\n{\n\t__evtchn_fifo_handle_events(cpu, false);\n}","23953":"  ::testing::AssertionResult operator()(const char *, const T &value) const {\n    ::testing::AssertionResult result = check_write<char>(value, \"STR\");\n    return result ? check_write<wchar_t>(value, \"STR\") : result;\n  }","25033":"cdf_calloc(const char *file __attribute__((__unused__)),\n    size_t line __attribute__((__unused__)), size_t n, size_t u)\n{\n\tDPRINTF((\"STR\"\n\t    SIZE_T_FORMAT \"STR\", file, line, __func__, n, u));\n\treturn calloc(n, u);\n}","24174":"    GC_debug_malloc_atomic_ignore_off_page(size_t lb, GC_EXTRA_PARAMS)\n{\n    void * result = GC_malloc_atomic_ignore_off_page(lb + DEBUG_BYTES);\n\n    if (result == 0) {\n        GC_err_printf(\"STR\"\n                      \"STR\", (unsigned long)lb, s, i);\n        return(0);\n    }\n    if (!GC_debugging_started) {\n        GC_start_debugging();\n    }\n    ADD_CALL_CHAIN(result, ra);\n    return (GC_store_debug_info(result, (word)lb, s, i));\n}","24790":"static inline bool should_drop_frame(struct sk_buff *skb, int present_fcs_len,\n\t\t\t\t     unsigned int rtap_space)\n{\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_hdr *hdr;\n\n\thdr = (void *)(skb->data + rtap_space);\n\n\tif (status->flag & (RX_FLAG_FAILED_FCS_CRC |\n\t\t\t    RX_FLAG_FAILED_PLCP_CRC |\n\t\t\t    RX_FLAG_ONLY_MONITOR |\n\t\t\t    RX_FLAG_NO_PSDU))\n\t\treturn true;\n\n\tif (unlikely(skb->len < 16 + present_fcs_len + rtap_space))\n\t\treturn true;\n\n\tif (ieee80211_is_ctl(hdr->frame_control) &&\n\t    !ieee80211_is_pspoll(hdr->frame_control) &&\n\t    !ieee80211_is_back_req(hdr->frame_control))\n\t\treturn true;\n\n\treturn false;\n}","24218":"void ssl_set_client_disabled(SSL *s)\n\t{\n\tCERT *c = s->cert;\n\tc->mask_a = 0;\n\tc->mask_k = 0;\n\t\n\tif (!SSL_CLIENT_USE_TLS1_2_CIPHERS(s))\n\t\tc->mask_ssl = SSL_TLSV1_2;\n\telse\n\t\tc->mask_ssl = 0;\n\tssl_set_sig_mask(&c->mask_a, s, SSL_SECOP_SIGALG_MASK);\n\t\n\tif (c->mask_a & SSL_aRSA)\n\t\tc->mask_k |= SSL_kDHr|SSL_kECDHr;\n\tif (c->mask_a & SSL_aDSS)\n\t\tc->mask_k |= SSL_kDHd;\n\tif (c->mask_a & SSL_aECDSA)\n\t\tc->mask_k |= SSL_kECDHe;\n#ifndef OPENSSL_NO_KRB5\n\tif (!kssl_tgt_is_available(s->kssl_ctx))\n\t\t{\n\t\tc->mask_a |= SSL_aKRB5;\n\t\tc->mask_k |= SSL_kKRB5;\n\t\t}\n#endif\n#ifndef OPENSSL_NO_PSK\n\t\n\tif (!s->psk_client_callback)\n\t\t{\n\t\tc->mask_a |= SSL_aPSK;\n\t\tc->mask_k |= SSL_kPSK;\n\t\t}\n#endif \n\tc->valid = 1;\n\t}","24330":"static int sysvipc_msg_proc_show(struct seq_file *s, void *it)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(s);\n\tstruct msg_queue *msq = it;\n\n\tseq_printf(s,\n\t\t   \"STR\",\n\t\t   msq->q_perm.key,\n\t\t   msq->q_perm.id,\n\t\t   msq->q_perm.mode,\n\t\t   msq->q_cbytes,\n\t\t   msq->q_qnum,\n\t\t   msq->q_lspid,\n\t\t   msq->q_lrpid,\n\t\t   from_kuid_munged(user_ns, msq->q_perm.uid),\n\t\t   from_kgid_munged(user_ns, msq->q_perm.gid),\n\t\t   from_kuid_munged(user_ns, msq->q_perm.cuid),\n\t\t   from_kgid_munged(user_ns, msq->q_perm.cgid),\n\t\t   msq->q_stime,\n\t\t   msq->q_rtime,\n\t\t   msq->q_ctime);\n\n\treturn 0;\n}","24899":"port::Status CudnnSupport::DoFusedConvolve(\n    Stream* stream, const dnn::BatchDescriptor& conv_input_descriptor,\n    const DeviceMemory<float>& conv_input_data, float conv_input_scale,\n    const dnn::FilterDescriptor& filter_descriptor,\n    const DeviceMemory<float>& filter_data,\n    const dnn::ConvolutionDescriptor& convolution_descriptor,\n    const DeviceMemory<float>& side_input_data, float side_input_scale,\n    const dnn::BatchDescriptor& bias_descriptor,\n    const DeviceMemory<float>& biases, dnn::ActivationMode activation_mode,\n    const dnn::BatchDescriptor& output_descriptor,\n    DeviceMemory<float>* output_data, ScratchAllocator* scratch_allocator,\n    const dnn::AlgorithmConfig& algorithm_config,\n    dnn::ProfileResult* output_profile_result) {\n  return DoFusedConvolveImpl(\n      stream, conv_input_descriptor, conv_input_data, conv_input_scale,\n      filter_descriptor, filter_data, convolution_descriptor, side_input_data,\n      side_input_scale, bias_descriptor, biases, activation_mode,\n      output_descriptor, output_data,\n      GetConvAccumulatorType(dnn::DataType::kFloat), scratch_allocator,\n      algorithm_config, output_profile_result);\n}","24861":"const char *diff_unique_abbrev(const unsigned char *sha1, int len)\n{\n\tint abblen;\n\tconst char *abbrev;\n\tif (len == 40)\n\t\treturn sha1_to_hex(sha1);\n\n\tabbrev = find_unique_abbrev(sha1, len);\n\tabblen = strlen(abbrev);\n\tif (abblen < 37) {\n\t\tstatic char hex[41];\n\t\tif (len < abblen && abblen <= len + 2)\n\t\t\tsprintf(hex, \"STR\");\n\t\telse\n\t\t\tsprintf(hex, \"STR\", abbrev);\n\t\treturn hex;\n\t}\n\treturn sha1_to_hex(sha1);\n}","23936":"e_data_server_util_set_dbus_call_timeout (gint timeout_msec)\n{\n\tdefault_dbus_timeout = timeout_msec;\n}","24381":"START_TEST(input_prop_parser)\n{\n\tstruct parser_test_val {\n\t\tconst char *prop;\n\t\tbool success;\n\t\tsize_t nvals;\n\t\tuint32_t values[20];\n\t} tests[] = {\n\t\t{ \"STR\", true, 1, {INPUT_PROP_BUTTONPAD}},\n\t\t{ \"STR\", true, 2,\n\t\t\t{ INPUT_PROP_BUTTONPAD,\n\t\t\t  INPUT_PROP_POINTER }},\n\t\t{ \"STR\", true, 3,\n\t\t\t{ INPUT_PROP_BUTTONPAD,\n\t\t\t  INPUT_PROP_POINTER,\n\t\t\t  INPUT_PROP_SEMI_MT }},\n\t\t{ .prop = \"\", .success = false },\n\t\t{ .prop = \"STR\", .success = false },\n\t\t{ .prop = \"STR\", .success = false },\n\t\t{ .prop = \"STR\", .success = false },\n\t\t{ .prop = \"STR\", .success = false },\n\t\t{ .prop = \"STR\", .success = false },\n\t\t{ .prop = \"STR\", .success = false },\n\t\t{ .prop = NULL },\n\t};\n\tstruct parser_test_val *t;\n\n\tfor (int i = 0; tests[i].prop; i++) {\n\t\tbool success;\n\t\tuint32_t props[32];\n\t\tsize_t nprops = ARRAY_LENGTH(props);\n\n\t\tt = &tests[i];\n\t\tsuccess = parse_input_prop_property(t->prop, props, &nprops);\n\t\tck_assert(success == t->success);\n\t\tif (!success)\n\t\t\tcontinue;\n\n\t\tck_assert_int_eq(nprops, t->nvals);\n\t\tfor (size_t j = 0; j < t->nvals; j++) {\n\t\t\tck_assert_int_eq(t->values[j], props[j]);\n\t\t}\n\t}\n}","24927":"void testCacheManager::setUp()\n{\n    Mem::Init();\n}","24896":"opj_image_t* OPJ_CALLCONV opj_image_create(OPJ_UINT32 numcmpts,\n        opj_image_cmptparm_t *cmptparms, OPJ_COLOR_SPACE clrspc)\n{\n    OPJ_UINT32 compno;\n    opj_image_t *image = NULL;\n\n    image = (opj_image_t*) opj_calloc(1, sizeof(opj_image_t));\n    if (image) {\n        image->color_space = clrspc;\n        image->numcomps = numcmpts;\n        \n        image->comps = (opj_image_comp_t*)opj_calloc(1,\n                       image->numcomps * sizeof(opj_image_comp_t));\n        if (!image->comps) {\n            \n            \n            opj_image_destroy(image);\n            return NULL;\n        }\n        \n        for (compno = 0; compno < numcmpts; compno++) {\n            opj_image_comp_t *comp = &image->comps[compno];\n            comp->dx = cmptparms[compno].dx;\n            comp->dy = cmptparms[compno].dy;\n            comp->w = cmptparms[compno].w;\n            comp->h = cmptparms[compno].h;\n            comp->x0 = cmptparms[compno].x0;\n            comp->y0 = cmptparms[compno].y0;\n            comp->prec = cmptparms[compno].prec;\n            comp->bpp = cmptparms[compno].bpp;\n            comp->sgnd = cmptparms[compno].sgnd;\n            comp->data = (OPJ_INT32*) opj_calloc(comp->w * comp->h, sizeof(OPJ_INT32));\n            if (!comp->data) {\n                \n                \n                opj_image_destroy(image);\n                return NULL;\n            }\n        }\n    }\n\n    return image;\n}","24722":"initialize(int argc, VALUE argv[], VALUE self)\n{\n    ffi_cif * cif;\n    ffi_type **arg_types;\n    ffi_status result;\n    VALUE ptr, args, ret_type, abi, kwds;\n    long i;\n\n    rb_scan_args(argc, argv, \"STR\", &ptr, &args, &ret_type, &abi, &kwds);\n    if(NIL_P(abi)) abi = INT2NUM(FFI_DEFAULT_ABI);\n\n    Check_Type(args, T_ARRAY);\n    Check_Max_Args(\"STR\", RARRAY_LENINT(args));\n\n    rb_iv_set(self, \"STR\", ptr);\n    rb_iv_set(self, \"STR\", args);\n    rb_iv_set(self, \"STR\", ret_type);\n    rb_iv_set(self, \"STR\", abi);\n\n    if (!NIL_P(kwds)) rb_hash_foreach(kwds, parse_keyword_arg_i, self);\n\n    TypedData_Get_Struct(self, ffi_cif, &function_data_type, cif);\n\n    arg_types = xcalloc(RARRAY_LEN(args) + 1, sizeof(ffi_type *));\n\n    for (i = 0; i < RARRAY_LEN(args); i++) {\n\tint type = NUM2INT(RARRAY_AREF(args, i));\n\targ_types[i] = INT2FFI_TYPE(type);\n    }\n    arg_types[RARRAY_LEN(args)] = NULL;\n\n    result = ffi_prep_cif (\n\t    cif,\n\t    NUM2INT(abi),\n\t    RARRAY_LENINT(args),\n\t    INT2FFI_TYPE(NUM2INT(ret_type)),\n\t    arg_types);\n\n    if (result)\n\trb_raise(rb_eRuntimeError, \"STR\", result);\n\n    return self;\n}","24251":"gs_arg_get_codepoint *gs_main_inst_get_arg_decode(gs_main_instance * minst)\n{\n    return minst->get_codepoint;\n}","24107":"static PHP_MINIT_FUNCTION(pcre)\n{\n\tREGISTER_INI_ENTRIES();\n\t\n\tREGISTER_LONG_CONSTANT(\"STR\", PREG_PATTERN_ORDER, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STR\", PREG_SET_ORDER, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STR\", PREG_OFFSET_CAPTURE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STR\", PREG_SPLIT_NO_EMPTY, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STR\", PREG_SPLIT_DELIM_CAPTURE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STR\", PREG_SPLIT_OFFSET_CAPTURE, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STR\", PREG_GREP_INVERT, CONST_CS | CONST_PERSISTENT);\n\n\tREGISTER_LONG_CONSTANT(\"STR\", PHP_PCRE_NO_ERROR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STR\", PHP_PCRE_INTERNAL_ERROR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STR\", PHP_PCRE_BACKTRACK_LIMIT_ERROR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STR\", PHP_PCRE_RECURSION_LIMIT_ERROR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STR\", PHP_PCRE_BAD_UTF8_ERROR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"STR\", PHP_PCRE_BAD_UTF8_OFFSET_ERROR, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_STRING_CONSTANT(\"STR\", (char *)pcre_version(), CONST_CS | CONST_PERSISTENT);\n\n\treturn SUCCESS;\n}","24086":"xmlOutputBufferFlush(xmlOutputBufferPtr out) {\n    int nbchars = 0, ret = 0;\n\n    if ((out == NULL) || (out->error)) return(-1);\n    \n    if ((out->conv != NULL) && (out->encoder != NULL)) {\n\t\n\tdo {\n\t    nbchars = xmlCharEncOutput(out, 0);\n\t    if (nbchars < 0) {\n\t\txmlIOErr(XML_IO_ENCODER, NULL);\n\t\tout->error = XML_IO_ENCODER;\n\t\treturn(-1);\n\t    }\n\t} while (nbchars);\n    }\n\n    \n    if ((out->conv != NULL) && (out->encoder != NULL) &&\n\t(out->writecallback != NULL)) {\n\tret = out->writecallback(out->context,\n                                 (const char *)xmlBufContent(out->conv),\n                                 xmlBufUse(out->conv));\n\tif (ret >= 0)\n\t    xmlBufShrink(out->conv, ret);\n    } else if (out->writecallback != NULL) {\n\tret = out->writecallback(out->context,\n                                 (const char *)xmlBufContent(out->buffer),\n                                 xmlBufUse(out->buffer));\n\tif (ret >= 0)\n\t    xmlBufShrink(out->buffer, ret);\n    }\n    if (ret < 0) {\n\txmlIOErr(XML_IO_FLUSH, NULL);\n\tout->error = XML_IO_FLUSH;\n\treturn(ret);\n    }\n    out->written += ret;\n\n#ifdef DEBUG_INPUT\n    xmlGenericError(xmlGenericErrorContext,\n\t    \"STR\", ret);\n#endif\n    return(ret);\n}","24750":"R_API char *r_str_from_ut64(ut64 val) {\n\tint i = 0;\n\tchar *v = (char *)&val;\n\tchar *str = (char *)calloc(1, 9);\n\tif (!str) {\n\t\treturn NULL;\n\t}\n\twhile (i < 8 && *v) {\n\t\tstr[i++] = *v++;\n\t}\n\treturn str;\n}","24895":"static int __init fm10k_init_module(void)\n{\n\tpr_info(\"STR\", fm10k_driver_string, fm10k_driver_version);\n\tpr_info(\"STR\", fm10k_copyright);\n\n\t\n\tfm10k_workqueue = alloc_workqueue(\"STR\", WQ_MEM_RECLAIM, 0,\n\t\t\t\t\t  fm10k_driver_name);\n\n\tfm10k_dbg_init();\n\n\treturn fm10k_register_pci_driver();\n}","23864":"get_strings_2_svc(gstrings_arg *arg, struct svc_req *rqstp)\n{\n    static gstrings_ret             ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_gstrings_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n\n    ret.api_version = handle->api_version;\n\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n\n    if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                        rqst2name(rqstp),\n                                                        ACL_INQUIRE,\n                                                        arg->princ,\n                                                        NULL))) {\n        ret.code = KADM5_AUTH_GET;\n        log_unauth(\"STR\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_get_strings((void *)handle, arg->princ, &ret.strings,\n                                     &ret.count);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"STR\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}"},"target":{"24286":1,"24372":0,"24726":0,"24716":0,"25001":1,"24168":0,"25019":0,"25030":0,"24386":0,"24700":1,"24181":1,"24263":1,"24079":1,"23839":0,"24094":0,"24334":0,"24469":0,"24054":1,"24115":1,"24972":1,"24542":0,"24492":1,"24018":1,"24935":0,"23850":0,"24766":0,"24890":0,"24322":0,"24656":0,"24304":0,"24791":0,"23810":1,"25034":0,"24147":1,"24657":0,"24294":0,"24669":0,"25014":0,"24526":1,"24881":0,"24361":1,"24830":1,"23957":0,"24977":1,"23959":1,"24601":1,"24853":1,"25008":0,"24424":0,"24443":1,"25026":0,"24360":1,"24615":0,"25028":0,"24130":0,"24060":0,"24275":0,"24023":0,"24996":0,"24874":1,"24759":0,"24172":1,"24227":1,"24765":1,"25012":1,"24110":0,"24341":0,"24069":1,"24327":0,"24897":1,"24406":0,"24563":1,"24423":0,"24453":0,"24290":1,"24461":1,"24148":1,"24950":1,"24480":1,"23840":0,"23949":1,"24007":0,"24754":1,"25046":1,"24975":1,"24507":1,"24822":1,"24577":1,"23997":1,"24188":0,"24536":0,"25039":1,"24589":0,"24122":0,"24625":1,"24506":0,"24706":0,"24449":1,"24723":1,"24265":1,"23927":0,"24143":1,"25015":1,"24246":1,"24141":0,"24169":1,"24555":1,"24582":1,"24253":0,"24408":1,"24471":0,"25009":0,"23982":0,"25018":1,"24629":1,"24427":1,"24325":0,"24704":1,"24326":1,"24514":0,"24056":1,"24900":0,"24302":0,"24556":0,"24134":1,"23884":1,"24593":0,"24065":0,"23901":0,"23987":1,"24215":1,"24006":0,"24677":0,"24245":0,"25031":0,"24123":0,"23844":1,"24216":1,"24971":0,"24856":0,"24301":0,"24276":1,"24316":0,"24840":1,"24725":1,"25007":0,"23940":0,"23806":1,"23857":1,"24490":1,"24061":1,"24001":0,"23905":0,"24210":1,"24584":1,"24223":0,"24599":0,"24298":0,"23915":1,"24951":0,"23853":0,"24812":0,"24630":0,"25038":0,"24162":1,"24104":1,"23973":1,"24481":1,"23992":1,"24863":0,"24777":0,"24278":0,"24182":1,"24829":1,"24016":1,"24742":0,"24179":0,"24234":1,"23943":0,"24930":0,"24098":1,"24836":1,"24463":0,"24170":1,"23999":1,"24554":0,"24026":0,"24027":1,"24048":1,"24588":0,"24250":1,"24631":0,"24938":1,"24992":1,"25057":1,"24776":0,"24433":0,"24522":1,"24789":1,"24697":0,"24475":1,"24663":1,"24769":1,"24470":1,"24540":1,"24099":1,"24674":0,"23920":1,"24477":1,"24462":1,"25044":1,"24014":1,"24644":1,"25000":1,"23888":1,"24397":0,"23815":1,"24627":0,"25045":0,"23922":0,"23923":1,"24898":0,"24730":0,"23828":0,"24268":0,"24346":0,"24032":1,"24220":1,"24870":1,"24041":1,"24009":0,"24944":1,"24681":0,"24594":1,"24083":0,"24292":1,"23951":1,"25022":0,"24852":0,"23875":1,"24736":0,"24578":0,"24883":0,"24206":0,"24183":1,"24078":0,"24729":1,"23879":1,"24597":0,"24648":1,"24090":1,"24029":1,"24793":0,"24136":0,"23970":1,"24814":0,"24139":1,"24402":0,"23887":1,"24695":1,"24512":1,"24439":1,"24920":0,"24678":1,"24185":0,"24366":1,"24860":1,"24000":1,"24498":0,"24487":0,"24117":1,"24384":0,"24806":1,"24980":0,"24502":1,"23968":1,"24520":1,"24948":1,"23966":1,"24688":0,"24369":0,"24532":1,"24993":1,"24284":0,"24468":1,"24207":0,"24809":0,"24429":0,"25040":1,"24445":1,"24270":1,"24659":0,"23938":1,"24859":1,"24634":0,"24917":1,"24459":1,"24247":0,"24926":0,"24933":1,"24008":1,"25020":1,"24527":0,"24666":0,"24257":1,"23909":0,"24244":1,"24825":1,"24854":1,"25053":0,"24904":0,"24165":0,"24800":0,"24692":0,"24940":1,"24045":1,"23894":0,"25056":1,"24932":0,"25042":0,"24796":1,"23933":0,"23916":1,"24684":0,"24425":0,"23859":1,"24089":1,"24456":1,"24046":0,"24368":0,"23889":1,"24335":1,"24616":0,"24637":1,"24956":0,"24720":0,"24954":1,"24307":1,"23983":0,"24380":0,"24158":1,"23876":1,"24379":1,"24869":1,"24128":0,"24285":0,"24473":0,"24186":1,"24344":0,"24734":0,"24269":1,"24167":0,"24946":0,"24321":0,"23890":0,"24444":1,"23952":0,"24356":1,"24632":0,"24039":1,"24495":0,"24620":0,"24042":0,"24576":1,"23974":0,"24436":1,"24901":1,"24040":1,"23969":1,"24848":1,"25011":1,"24328":1,"23998":1,"24049":0,"24015":0,"24199":1,"24862":1,"24342":0,"24817":0,"24077":0,"24024":0,"24377":1,"24200":1,"24876":0,"24084":1,"24296":1,"23826":1,"24511":0,"23956":1,"24682":0,"24731":1,"24786":1,"24919":0,"24673":1,"24509":1,"24966":1,"24313":1,"23914":0,"24842":0,"24431":0,"24918":1,"24761":0,"24414":1,"24912":1,"23924":1,"24983":0,"23874":1,"24297":0,"24345":0,"24892":0,"23880":0,"24939":1,"24815":1,"24771":1,"24091":1,"24163":0,"24320":1,"24082":0,"24317":0,"24619":0,"24516":0,"24405":1,"23871":1,"24073":0,"24539":0,"24100":0,"23895":0,"23929":1,"24978":1,"24623":1,"24175":1,"25036":0,"24713":1,"24887":0,"23913":1,"24062":0,"24324":1,"24960":0,"24696":0,"24997":0,"24391":1,"25051":0,"24553":1,"23945":0,"24679":1,"24968":1,"24850":1,"23881":0,"24085":0,"24209":0,"24093":1,"23900":1,"24518":0,"24651":0,"24004":0,"23954":0,"23984":1,"24903":0,"24371":0,"24559":1,"24957":1,"24867":1,"24152":1,"24784":1,"24990":1,"24531":1,"24340":0,"24038":1,"24394":0,"24988":0,"25061":0,"24010":1,"23856":0,"24886":1,"24363":1,"24412":1,"25004":0,"24835":0,"23855":0,"24105":0,"23885":1,"24823":0,"24066":0,"23950":0,"25052":0,"24068":0,"24103":1,"24252":1,"24211":1,"24984":1,"24961":1,"23965":0,"24937":1,"24813":1,"24095":1,"23971":0,"23918":1,"24150":0,"24144":0,"24053":0,"24392":0,"23867":1,"24804":0,"24403":1,"24467":1,"24081":0,"23925":0,"24219":1,"24055":1,"24299":1,"24212":1,"23814":1,"23886":1,"24248":1,"24382":0,"24274":1,"23996":0,"24131":0,"23870":0,"24037":0,"24180":1,"24442":0,"24795":0,"24517":1,"24756":1,"25023":1,"24256":0,"24022":0,"24624":1,"23979":0,"24235":0,"23834":0,"24106":1,"24851":0,"24611":0,"24743":0,"24323":1,"24035":0,"24499":1,"24868":0,"24633":1,"24587":0,"24063":1,"24108":1,"24232":0,"23841":1,"23851":0,"24142":1,"23910":0,"24273":1,"24279":1,"23869":1,"24699":1,"24192":0,"24740":1,"23877":0,"24906":1,"24757":1,"24762":0,"24156":1,"25005":1,"24120":0,"24241":1,"23852":0,"23866":1,"24717":0,"25048":0,"23898":1,"24092":1,"24877":1,"23830":0,"24198":1,"24204":0,"23991":0,"25058":0,"24838":0,"24653":0,"24146":0,"24833":0,"24133":0,"24476":1,"24847":1,"24636":0,"23977":1,"24497":1,"24281":0,"23899":0,"24465":1,"24670":1,"24595":0,"25024":0,"24732":1,"24401":1,"24125":1,"24293":1,"23975":1,"24710":1,"24243":1,"23941":1,"24751":0,"24076":1,"24349":1,"24515":0,"24171":0,"24260":0,"23976":0,"24519":0,"23832":0,"24351":1,"23809":1,"24831":0,"25049":1,"24834":0,"23793":1,"24728":0,"24385":1,"24952":0,"24891":0,"24428":0,"24121":1,"23805":1,"24808":0,"23789":1,"24052":1,"24973":0,"23988":0,"24849":1,"24718":1,"24894":1,"24295":0,"23863":1,"24638":0,"24287":0,"23994":0,"24760":0,"24941":0,"24746":1,"24910":0,"23958":0,"24916":1,"24839":0,"24981":0,"24550":0,"24702":0,"24693":0,"24365":0,"24410":0,"23906":0,"24797":1,"24803":1,"24785":1,"25059":1,"23944":1,"24404":1,"24357":0,"24096":0,"24031":0,"23937":1,"23865":0,"23804":1,"23854":1,"23891":0,"24773":1,"23825":1,"24355":0,"24036":0,"24417":0,"24608":0,"24626":1,"24810":1,"25016":0,"24546":0,"24264":0,"24591":1,"24114":1,"24057":1,"24482":0,"24758":1,"24166":0,"23883":1,"24719":1,"24642":1,"24159":0,"24194":0,"24641":1,"24982":1,"24602":0,"24605":1,"24109":1,"24741":1,"24709":1,"24020":0,"24157":1,"23990":0,"24151":0,"24501":1,"24821":0,"24586":1,"24419":0,"24047":0,"24155":0,"24311":1,"24254":1,"24030":0,"24455":1,"24088":1,"24802":1,"24995":1,"23845":0,"24612":1,"24033":0,"24649":0,"24019":0,"23955":0,"25006":0,"24652":1,"24478":1,"24888":0,"24233":0,"24694":0,"23849":0,"24841":0,"24197":1,"24003":0,"24943":0,"24783":1,"24650":1,"23989":0,"24395":1,"24958":1,"24097":1,"24606":1,"24913":0,"24529":0,"24315":1,"24549":0,"23980":0,"24127":0,"23847":1,"24882":1,"24610":1,"24149":0,"24618":0,"24370":0,"24486":1,"24537":0,"24021":1,"24872":1,"24314":0,"24914":1,"23843":1,"24929":1,"24788":0,"24609":1,"23873":0,"24855":0,"24820":0,"24187":0,"25013":0,"23846":0,"24496":0,"24153":0,"24058":0,"24261":0,"23860":0,"24566":1,"24845":0,"24339":1,"24683":1,"24145":0,"24457":0,"24196":0,"23963":1,"24521":0,"24976":1,"24573":0,"24781":0,"24488":0,"24635":0,"24570":0,"24660":1,"24654":1,"24846":1,"24438":1,"25043":0,"24538":0,"24580":0,"23995":1,"24416":0,"24787":0,"23964":0,"23833":1,"24962":1,"24289":1,"24598":0,"24647":1,"24524":1,"24331":0,"24818":1,"24643":1,"24466":0,"24735":0,"23926":0,"24505":0,"24420":1,"24249":0,"24464":1,"24239":1,"24985":1,"24843":1,"24230":0,"24646":1,"25029":1,"24690":1,"24059":0,"24947":1,"24160":1,"24011":0,"23907":0,"24530":1,"24873":0,"24376":0,"23972":0,"24581":1,"24208":0,"24025":0,"24715":0,"24574":0,"24583":0,"24072":0,"24071":0,"25050":0,"24970":0,"24686":0,"23878":1,"24687":0,"24451":0,"24005":1,"24579":0,"24945":1,"23919":0,"24585":0,"24398":0,"24454":1,"24902":1,"23912":1,"24489":1,"23978":0,"24621":1,"24738":1,"23862":0,"24303":1,"24132":0,"24701":0,"24923":0,"24332":1,"24763":0,"24388":0,"24228":0,"24184":1,"24399":0,"24229":1,"24309":0,"24525":1,"24617":0,"24811":1,"24087":0,"24955":1,"24017":0,"24893":0,"24592":0,"24737":1,"24367":1,"24879":0,"24907":0,"23794":1,"23790":1,"24028":0,"23820":1,"23872":1,"24824":1,"24794":1,"24865":1,"24411":0,"24942":1,"24534":1,"24421":1,"24508":0,"24548":0,"24600":1,"24312":0,"23882":0,"25041":0,"24969":1,"23904":0,"24213":0,"24953":0,"24603":1,"24319":0,"25060":0,"24350":0,"23827":0,"24979":1,"23939":0,"24409":1,"24628":1,"24205":1,"24112":0,"24875":1,"24568":1,"23892":0,"24733":0,"24708":1,"24949":1,"24884":1,"24959":0,"24135":0,"25017":0,"23835":1,"24965":0,"24819":0,"24222":0,"24262":1,"24483":1,"23946":1,"24164":0,"23947":0,"23836":1,"24396":0,"24703":1,"24437":0,"24535":1,"24111":0,"24113":1,"24999":1,"23858":1,"24662":0,"24807":1,"24543":1,"25003":1,"24827":1,"24002":1,"24413":0,"23799":1,"24596":0,"24242":0,"24034":1,"23932":1,"24547":0,"24544":0,"25035":1,"24805":1,"24373":1,"24337":1,"24362":1,"24393":0,"24500":1,"23921":1,"23829":1,"24124":0,"24792":0,"24138":0,"24963":0,"24561":0,"24513":0,"23986":0,"24921":1,"24801":1,"24343":0,"23911":1,"24154":1,"24775":0,"24866":1,"24432":1,"24714":0,"24224":1,"24318":0,"24622":1,"24655":1,"23961":0,"24878":0,"24240":0,"24772":1,"24748":1,"24458":0,"24640":1,"24173":1,"24353":1,"24689":0,"24193":0,"24043":0,"24905":1,"24931":0,"24934":0,"24494":1,"24195":1,"24348":0,"24504":0,"24828":0,"24545":1,"24214":0,"24178":1,"24799":0,"24101":0,"24282":1,"23842":0,"24013":1,"24745":0,"23985":1,"24503":0,"24986":1,"24614":1,"25047":1,"24558":1,"24493":0,"23893":1,"24358":1,"24129":1,"24994":1,"24798":1,"24668":1,"24378":1,"24176":1,"24201":0,"24698":0,"24221":0,"24991":1,"24217":1,"24871":1,"24400":0,"25010":1,"24374":0,"24707":1,"24306":0,"23928":0,"24922":1,"24236":0,"25025":0,"23917":0,"25021":0,"24064":1,"24658":1,"23848":1,"24755":0,"24202":0,"24140":1,"24564":0,"23948":1,"23817":1,"24925":1,"23831":1,"24231":0,"24238":1,"23838":0,"24998":1,"24383":1,"24826":1,"24964":1,"24691":0,"25054":1,"23823":1,"24575":0,"24858":1,"24752":1,"24924":0,"24909":0,"24430":0,"24774":0,"24336":1,"24645":1,"24857":0,"24832":1,"23934":1,"24407":0,"24724":1,"24267":1,"24528":0,"24676":1,"24665":1,"23861":1,"24450":0,"23903":1,"24768":0,"24375":0,"24928":1,"24387":1,"24191":1,"24075":1,"25027":0,"23819":1,"24225":1,"24523":1,"24911":0,"23935":1,"25037":1,"23896":0,"24664":0,"24837":0,"24044":0,"24767":1,"24237":0,"24661":1,"23803":1,"23931":0,"24967":1,"24780":1,"24448":0,"24671":1,"24560":0,"24080":1,"24571":1,"24426":0,"24434":0,"24551":1,"24354":0,"24705":0,"24283":1,"24272":1,"24747":0,"24607":0,"24816":0,"24604":1,"23902":0,"24051":1,"24987":1,"24721":0,"24485":1,"24308":0,"24712":0,"24562":0,"24590":1,"24435":0,"24779":1,"24552":0,"24422":0,"24989":0,"24271":0,"24389":0,"24190":0,"24889":0,"24446":1,"25002":0,"23868":0,"24137":0,"24070":0,"23981":0,"24782":0,"24613":1,"24484":0,"24277":0,"23837":0,"24074":0,"24672":0,"24352":0,"23897":0,"24338":1,"24012":1,"24258":1,"24675":1,"24329":1,"24908":1,"24119":0,"24764":1,"24915":0,"24050":0,"24266":0,"24126":1,"23942":1,"24116":0,"24447":0,"23930":1,"24479":1,"24557":1,"24300":1,"24440":1,"24778":1,"24770":1,"23967":1,"24418":0,"24305":1,"24161":1,"24259":1,"24533":0,"24347":0,"24102":0,"24189":0,"24390":1,"24472":1,"24711":0,"24288":1,"24885":1,"23962":1,"24685":1,"24452":0,"24639":1,"24359":0,"24680":0,"24569":0,"24844":1,"23960":0,"24203":1,"24744":0,"24541":0,"24067":1,"24936":0,"24474":1,"24364":0,"24280":1,"24291":0,"24565":0,"24333":0,"24491":0,"24739":1,"24567":0,"24415":0,"24974":1,"24880":0,"25032":0,"24255":1,"24441":1,"24177":0,"23993":1,"24749":0,"24226":0,"24310":1,"24460":1,"24864":1,"24727":0,"24118":0,"24572":1,"25055":1,"24510":1,"24667":1,"24753":1,"23908":1,"23953":0,"25033":0,"24174":1,"24790":0,"24218":1,"24330":0,"24899":0,"24861":0,"23936":0,"24381":0,"24927":1,"24896":1,"24722":1,"24251":0,"24107":1,"24086":0,"24750":0,"24895":1,"23864":1},"cwe":{"24286":["CWE-200"],"24372":["CWE-20","CWE-703"],"24726":["CWE-119"],"24716":["CWE-787"],"25001":["CWE-20"],"24168":["CWE-476"],"25019":["CWE-401"],"25030":[],"24386":["CWE-416","CWE-362"],"24700":["CWE-787"],"24181":[],"24263":["CWE-787"],"24079":[],"23839":["CWE-20","CWE-190"],"24094":["CWE-787"],"24334":[],"24469":["CWE-703","CWE-125"],"24054":["CWE-362"],"24115":["CWE-787"],"24972":["CWE-400"],"24542":["CWE-190","CWE-787"],"24492":[],"24018":["CWE-459"],"24935":["CWE-20","CWE-269"],"23850":["CWE-20"],"24766":["CWE-78"],"24890":["CWE-190"],"24322":["CWE-703"],"24656":["CWE-787"],"24304":["CWE-254"],"24791":["CWE-835"],"23810":["CWE-120","CWE-787"],"25034":["CWE-134"],"24147":["CWE-358"],"24657":["CWE-125"],"24294":["CWE-444"],"24669":["CWE-552"],"25014":[],"24526":["CWE-362"],"24881":["CWE-20"],"24361":["CWE-125","CWE-787"],"24830":[],"23957":["CWE-770"],"24977":["CWE-476"],"23959":[],"24601":["CWE-476"],"24853":["CWE-119","CWE-788"],"25008":["CWE-770"],"24424":["CWE-787"],"24443":["CWE-190"],"25026":["CWE-476","CWE-90"],"24360":["CWE-190"],"24615":["CWE-703"],"25028":["CWE-703"],"24130":[],"24060":["CWE-119"],"24275":["CWE-326","CWE-203"],"24023":[],"24996":["CWE-416"],"24874":[],"24759":["CWE-416"],"24172":["CWE-362"],"24227":["CWE-119"],"24765":[],"25012":["CWE-119","CWE-125"],"24110":[],"24341":["CWE-119"],"24069":["CWE-190"],"24327":["CWE-287","CWE-284"],"24897":["CWE-416"],"24406":[],"24563":["CWE-369"],"24423":["CWE-476"],"24453":["CWE-200","CWE-119"],"24290":["CWE-125","CWE-787"],"24461":[],"24148":["CWE-20"],"24950":["CWE-200","CWE-552"],"24480":["CWE-476"],"23840":["CWE-617"],"23949":["CWE-295"],"24007":["CWE-190","CWE-125"],"24754":["CWE-399"],"25046":["CWE-119"],"24975":["CWE-401"],"24507":["CWE-20"],"24822":[],"24577":["CWE-476"],"23997":["CWE-416"],"24188":["CWE-613"],"24536":["CWE-125"],"25039":["CWE-703"],"24589":["CWE-20"],"24122":["CWE-284"],"24625":["CWE-18","CWE-763"],"24506":[],"24706":[],"24449":["CWE-125"],"24723":[],"24265":["CWE-119","CWE-787"],"23927":["CWE-284"],"24143":["CWE-120"],"25015":["CWE-476"],"24246":["CWE-20"],"24141":["CWE-119"],"24169":["CWE-125"],"24555":["CWE-362"],"24582":["CWE-200"],"24253":["CWE-20"],"24408":["CWE-369"],"24471":[],"25009":["CWE-459"],"23982":["CWE-119"],"25018":["CWE-416"],"24629":["CWE-189"],"24427":["CWE-74"],"24325":["CWE-787"],"24704":["CWE-20","CWE-22"],"24326":[],"24514":["CWE-362"],"24056":["CWE-787"],"24900":["CWE-295"],"24302":["CWE-310"],"24556":["CWE-862"],"24134":[],"23884":["CWE-787"],"24593":["CWE-20"],"24065":[],"23901":["CWE-552","CWE-703"],"23987":["CWE-20"],"24215":["CWE-399"],"24006":["CWE-416","CWE-362"],"24677":[],"24245":["CWE-399"],"25031":["CWE-264"],"24123":[],"23844":["CWE-476"],"24216":["CWE-416"],"24971":["CWE-119","CWE-787"],"24856":["CWE-59","CWE-61"],"24301":["CWE-369"],"24276":["CWE-416"],"24316":[],"24840":["CWE-399"],"24725":[],"25007":["CWE-119","CWE-787"],"23940":["CWE-125"],"23806":["CWE-125"],"23857":[],"24490":["CWE-189"],"24061":["CWE-120","CWE-119","CWE-787"],"24001":["CWE-190"],"23905":["CWE-264"],"24210":[],"24584":["CWE-401"],"24223":["CWE-400","CWE-401"],"24599":["CWE-416"],"24298":["CWE-20"],"23915":["CWE-404","CWE-703"],"24951":["CWE-369"],"23853":["CWE-416","CWE-284"],"24812":["CWE-119","CWE-787"],"24630":["CWE-119","CWE-787"],"25038":["CWE-703"],"24162":[],"24104":["CWE-787"],"23973":[],"24481":["CWE-347"],"23992":["CWE-400"],"24863":["CWE-703"],"24777":[],"24278":["CWE-190"],"24182":["CWE-125","CWE-787"],"24829":["CWE-125"],"24016":["CWE-416"],"24742":["CWE-362","CWE-347"],"24179":["CWE-20"],"24234":["CWE-125","CWE-787"],"23943":[],"24930":["CWE-476"],"24098":[],"24836":[],"24463":["CWE-190"],"24170":[],"23999":["CWE-362"],"24554":["CWE-369"],"24026":["CWE-401"],"24027":["CWE-416"],"24048":["CWE-264"],"24588":["CWE-119","CWE-787"],"24250":["CWE-399","CWE-125"],"24631":["CWE-399","CWE-284"],"24938":["CWE-20"],"24992":["CWE-770"],"25057":["CWE-189"],"24776":["CWE-476"],"24433":["CWE-20"],"24522":["CWE-269"],"24789":[],"24697":["CWE-617"],"24475":["CWE-416"],"24663":["CWE-190","CWE-787"],"24769":[],"24470":["CWE-295"],"24540":["CWE-290"],"24099":["CWE-125"],"24674":["CWE-20"],"23920":["CWE-119","CWE-787"],"24477":["CWE-20"],"24462":["CWE-119"],"25044":["CWE-125"],"24014":["CWE-863"],"24644":["CWE-703","CWE-189"],"25000":["CWE-20"],"23888":["CWE-703"],"24397":["CWE-863"],"23815":["CWE-200","CWE-787"],"24627":[],"25045":["CWE-770"],"23922":["CWE-119","CWE-787"],"23923":["CWE-295"],"24898":["CWE-121","CWE-787"],"24730":["CWE-295"],"23828":["CWE-400","CWE-401"],"24268":["CWE-703"],"24346":["CWE-125"],"24032":["CWE-400"],"24220":["CWE-703","CWE-264"],"24870":["CWE-345"],"24041":["CWE-125","CWE-369"],"24009":["CWE-119"],"24944":["CWE-200"],"24681":["CWE-476"],"24594":["CWE-125"],"24083":["CWE-399"],"24292":["CWE-189"],"23951":["CWE-416","CWE-401"],"25022":["CWE-400"],"24852":["CWE-125"],"23875":["CWE-120"],"24736":["CWE-119","CWE-295","CWE-787"],"24578":["CWE-125","CWE-345"],"24883":["CWE-444"],"24206":["CWE-125"],"24183":["CWE-125"],"24078":["CWE-119","CWE-787"],"24729":["CWE-310"],"23879":["CWE-787"],"24597":["CWE-400"],"24648":[],"24090":["CWE-125"],"24029":["CWE-416"],"24793":["CWE-59","CWE-61"],"24136":["CWE-20","CWE-190"],"23970":["CWE-125"],"24814":["CWE-125"],"24139":[],"24402":["CWE-416"],"23887":["CWE-125","CWE-787"],"24695":[],"24512":["CWE-401"],"24439":[],"24920":["CWE-212"],"24678":[],"24185":["CWE-78"],"24366":["CWE-362","CWE-119","CWE-787"],"24860":["CWE-399"],"24000":["CWE-459"],"24498":["CWE-787"],"24487":["CWE-119","CWE-787"],"24117":["CWE-125"],"24384":["CWE-307"],"24806":["CWE-20","CWE-190"],"24980":["CWE-125"],"24502":["CWE-310"],"23968":["CWE-754"],"24520":["CWE-415"],"24948":["CWE-252"],"23966":["CWE-416"],"24688":["CWE-459"],"24369":["CWE-770"],"24532":["CWE-362"],"24993":["CWE-200"],"24284":["CWE-416"],"24468":["CWE-674"],"24207":["CWE-269","CWE-94"],"24809":["CWE-416"],"24429":["CWE-416"],"25040":["CWE-416"],"24445":["CWE-125","CWE-787"],"24270":["CWE-119"],"24659":["CWE-189"],"23938":["CWE-20"],"24859":["CWE-400","CWE-401"],"24634":["CWE-19"],"24917":["CWE-59","CWE-61"],"24459":["CWE-416"],"24247":["CWE-835"],"24926":["CWE-119"],"24933":["CWE-119"],"24008":["CWE-362"],"25020":["CWE-212","CWE-326","CWE-61"],"24527":[],"24666":["CWE-476"],"24257":["CWE-190"],"23909":["CWE-134"],"24244":["CWE-770"],"24825":["CWE-241","CWE-19"],"24854":["CWE-200","CWE-909"],"25053":["CWE-787"],"24904":["CWE-264"],"24165":["CWE-20"],"24800":["CWE-125"],"24692":["CWE-119"],"24940":[],"24045":["CWE-119"],"23894":["CWE-787"],"25056":["CWE-401"],"24932":["CWE-399"],"25042":[],"24796":["CWE-189"],"23933":["CWE-295"],"23916":["CWE-125"],"24684":["CWE-770"],"24425":["CWE-703"],"23859":["CWE-200","CWE-125"],"24089":["CWE-125"],"24456":["CWE-119"],"24046":[],"24368":["CWE-200"],"23889":["CWE-125"],"24335":["CWE-78"],"24616":["CWE-212"],"24637":["CWE-190"],"24956":["CWE-703"],"24720":["CWE-125","CWE-787"],"24954":["CWE-20","CWE-362"],"24307":["CWE-119","CWE-787"],"23983":[],"24380":["CWE-476"],"24158":["CWE-119","CWE-787"],"23876":["CWE-20"],"24379":["CWE-787"],"24869":["CWE-362","CWE-476"],"24128":["CWE-703"],"24285":["CWE-20"],"24473":["CWE-125","CWE-345"],"24186":["CWE-200","CWE-119","CWE-125"],"24344":["CWE-310"],"24734":["CWE-703","CWE-189"],"24269":["CWE-787"],"24167":["CWE-770"],"24946":["CWE-532"],"24321":["CWE-476","CWE-415"],"23890":["CWE-119","CWE-787"],"24444":[],"23952":["CWE-416"],"24356":["CWE-189"],"24632":["CWE-787"],"24039":["CWE-732"],"24495":["CWE-264"],"24620":["CWE-787"],"24042":["CWE-703"],"24576":["CWE-119"],"23974":["CWE-362"],"24436":["CWE-703","CWE-189"],"24901":["CWE-189"],"24040":["CWE-613","CWE-703"],"23969":["CWE-295"],"24848":["CWE-119"],"25011":["CWE-20"],"24328":["CWE-416"],"23998":["CWE-22"],"24049":["CWE-119","CWE-787"],"24015":["CWE-415","CWE-703"],"24199":["CWE-119","CWE-703","CWE-120"],"24862":[],"24342":["CWE-125"],"24817":["CWE-400","CWE-703"],"24077":["CWE-200"],"24024":["CWE-476","CWE-369"],"24377":["CWE-330"],"24200":[],"24876":["CWE-200","CWE-909"],"24084":["CWE-190"],"24296":["CWE-787"],"23826":["CWE-787"],"24511":[],"23956":[],"24682":["CWE-674","CWE-787"],"24731":["CWE-770"],"24786":["CWE-200"],"24919":[],"24673":["CWE-787"],"24509":["CWE-78"],"24966":["CWE-476","CWE-119"],"24313":["CWE-787"],"23914":["CWE-400"],"24842":["CWE-120"],"24431":["CWE-362"],"24918":["CWE-125"],"24761":["CWE-119","CWE-787"],"24414":["CWE-310"],"24912":["CWE-703"],"23924":["CWE-703"],"24983":["CWE-190","CWE-787"],"23874":["CWE-476"],"24297":["CWE-209"],"24345":["CWE-476"],"24892":["CWE-400","CWE-401"],"23880":["CWE-416","CWE-787"],"24939":["CWE-125"],"24815":["CWE-20","CWE-200","CWE-362"],"24771":["CWE-119"],"24091":[],"24163":["CWE-20"],"24320":["CWE-415"],"24082":["CWE-400"],"24317":["CWE-416","CWE-284"],"24619":["CWE-20"],"24516":["CWE-400"],"24405":["CWE-787"],"23871":["CWE-787"],"24073":["CWE-770"],"24539":["CWE-190"],"24100":["CWE-200"],"23895":["CWE-703"],"23929":["CWE-310"],"24978":["CWE-59"],"24623":["CWE-125"],"24175":["CWE-20"],"25036":["CWE-476"],"24713":["CWE-20"],"24887":["CWE-399"],"23913":["CWE-119","CWE-772","CWE-401"],"24062":[],"24324":["CWE-400","CWE-703"],"24960":[],"24696":[],"24997":["CWE-399"],"24391":["CWE-362"],"25051":[],"24553":["CWE-476"],"23945":["CWE-59","CWE-61"],"24679":["CWE-190"],"24968":[],"24850":["CWE-404","CWE-703"],"23881":["CWE-20"],"24085":["CWE-416"],"24209":["CWE-120","CWE-787"],"24093":["CWE-399"],"23900":[],"24518":["CWE-787"],"24651":["CWE-119"],"24004":["CWE-120"],"23954":[],"23984":["CWE-416"],"24903":["CWE-94"],"24371":["CWE-89"],"24559":["CWE-787"],"24957":["CWE-190"],"24867":["CWE-310"],"24152":[],"24784":["CWE-787"],"24990":["CWE-20"],"24531":["CWE-416"],"24340":[],"24038":["CWE-20"],"24394":["CWE-284","CWE-693"],"24988":["CWE-347"],"25061":["CWE-476"],"24010":["CWE-400","CWE-703"],"23856":["CWE-787"],"24886":["CWE-200"],"24363":["CWE-787"],"24412":["CWE-20"],"25004":[],"24835":["CWE-125"],"23855":["CWE-190"],"24105":[],"23885":["CWE-617","CWE-703"],"24823":["CWE-703","CWE-189"],"24066":["CWE-120"],"23950":["CWE-703"],"25052":["CWE-22"],"24068":["CWE-415"],"24103":[],"24252":["CWE-59"],"24211":["CWE-125","CWE-787"],"24984":[],"24961":["CWE-416"],"23965":["CWE-416"],"24937":["CWE-125","CWE-787"],"24813":["CWE-428","CWE-295"],"24095":["CWE-119","CWE-787"],"23971":["CWE-269"],"23918":["CWE-703","CWE-189"],"24150":["CWE-310"],"24144":["CWE-284","CWE-264"],"24053":[],"24392":["CWE-787"],"23867":["CWE-17"],"24804":["CWE-416","CWE-200"],"24403":["CWE-399","CWE-401"],"24467":["CWE-20"],"24081":["CWE-20"],"23925":[],"24219":["CWE-416"],"24055":[],"24299":["CWE-369"],"24212":["CWE-119","CWE-787"],"23814":["CWE-732"],"23886":["CWE-287","CWE-284"],"24248":["CWE-354"],"24382":["CWE-78"],"24274":["CWE-787"],"23996":[],"24131":["CWE-703"],"23870":["CWE-287","CWE-284"],"24037":["CWE-119","CWE-125"],"24180":["CWE-399"],"24442":["CWE-770"],"24795":["CWE-416"],"24517":["CWE-787"],"24756":["CWE-416"],"25023":["CWE-415","CWE-119"],"24256":["CWE-125","CWE-787"],"24022":["CWE-125"],"24624":["CWE-787"],"23979":["CWE-476"],"24235":["CWE-287"],"23834":["CWE-125"],"24106":[],"24851":["CWE-119"],"24611":["CWE-20"],"24743":["CWE-787"],"24323":["CWE-476"],"24035":["CWE-20","CWE-269"],"24499":["CWE-88"],"24868":["CWE-287"],"24633":["CWE-400"],"24587":["CWE-787"],"24063":["CWE-200"],"24108":["CWE-120","CWE-119","CWE-787"],"24232":["CWE-416"],"23841":["CWE-787"],"23851":["CWE-200"],"24142":[],"23910":["CWE-22"],"24273":["CWE-787"],"24279":["CWE-284","CWE-787"],"23869":[],"24699":[],"24192":["CWE-200","CWE-119"],"24740":[],"23877":["CWE-310"],"24906":["CWE-119","CWE-787"],"24757":["CWE-400","CWE-401"],"24762":["CWE-200"],"24156":["CWE-476","CWE-284"],"25005":["CWE-200","CWE-668"],"24120":["CWE-662"],"24241":["CWE-125","CWE-787"],"23852":["CWE-476"],"23866":[],"24717":["CWE-362"],"25048":["CWE-74"],"23898":["CWE-476","CWE-125"],"24092":["CWE-787"],"24877":["CWE-20","CWE-703"],"23830":["CWE-119"],"24198":["CWE-310"],"24204":["CWE-17"],"23991":["CWE-416"],"25058":["CWE-125"],"24838":["CWE-617"],"24653":["CWE-284","CWE-295"],"24146":["CWE-617","CWE-703"],"24833":[],"24133":["CWE-125"],"24476":["CWE-284","CWE-264"],"24847":["CWE-400"],"24636":["CWE-909"],"23977":["CWE-295"],"24497":["CWE-362"],"24281":["CWE-416"],"23899":["CWE-476"],"24465":["CWE-20"],"24670":["CWE-78"],"24595":["CWE-416"],"25024":["CWE-416"],"24732":["CWE-254"],"24401":["CWE-400","CWE-703"],"24125":["CWE-125"],"24293":["CWE-1021"],"23975":["CWE-190"],"24710":[],"24243":["CWE-362","CWE-787"],"23941":["CWE-476"],"24751":["CWE-134","CWE-119","CWE-787"],"24076":["CWE-122","CWE-787"],"24349":["CWE-416"],"24515":["CWE-20"],"24171":["CWE-400"],"24260":["CWE-119"],"23976":["CWE-284","CWE-264"],"24519":["CWE-787"],"23832":["CWE-120"],"24351":["CWE-787"],"23809":[],"24831":["CWE-787"],"25049":[],"24834":["CWE-264"],"23793":["CWE-200"],"24728":["CWE-476"],"24385":["CWE-416","CWE-415"],"24952":["CWE-416"],"24891":["CWE-416"],"24428":["CWE-416","CWE-295"],"24121":["CWE-189"],"23805":["CWE-787"],"24808":[],"23789":["CWE-125","CWE-787"],"24052":[],"24973":["CWE-476","CWE-415"],"23988":["CWE-119"],"24849":["CWE-284"],"24718":["CWE-862"],"24894":[],"24295":["CWE-703"],"23863":["CWE-125"],"24638":["CWE-119"],"24287":["CWE-284","CWE-264"],"23994":["CWE-416"],"24760":["CWE-476"],"24941":["CWE-119","CWE-787"],"24746":["CWE-125"],"24910":["CWE-20"],"23958":["CWE-119"],"24916":["CWE-119","CWE-787"],"24839":["CWE-190"],"24981":["CWE-400","CWE-401"],"24550":["CWE-20","CWE-190"],"24702":["CWE-400","CWE-401"],"24693":["CWE-617","CWE-362"],"24365":[],"24410":["CWE-703"],"23906":[],"24797":["CWE-476"],"24803":["CWE-20"],"24785":["CWE-200","CWE-401"],"25059":[],"23944":["CWE-787"],"24404":["CWE-200"],"24357":[],"24096":["CWE-787"],"24031":["CWE-119"],"23937":["CWE-126","CWE-787"],"23865":["CWE-254"],"23804":["CWE-203"],"23854":["CWE-20"],"23891":["CWE-125"],"24773":["CWE-787"],"23825":["CWE-189"],"24355":["CWE-190"],"24036":["CWE-22"],"24417":[],"24608":["CWE-310"],"24626":["CWE-125"],"24810":["CWE-406"],"25016":[],"24546":["CWE-416","CWE-119"],"24264":["CWE-362"],"24591":["CWE-416"],"24114":["CWE-266"],"24057":["CWE-327"],"24482":["CWE-22"],"24758":["CWE-189"],"24166":[],"23883":["CWE-913"],"24719":["CWE-20"],"24642":["CWE-476"],"24159":[],"24194":["CWE-200"],"24641":["CWE-78","CWE-77"],"24982":["CWE-20"],"24602":["CWE-59","CWE-61"],"24605":["CWE-787"],"24109":["CWE-787"],"24741":["CWE-835"],"24709":["CWE-200","CWE-327","CWE-347"],"24020":["CWE-269"],"24157":["CWE-20","CWE-119"],"23990":["CWE-119","CWE-772","CWE-401"],"24151":["CWE-668"],"24501":[],"24821":["CWE-416","CWE-362"],"24586":["CWE-125"],"24419":["CWE-459"],"24047":[],"24155":["CWE-703","CWE-787"],"24311":["CWE-200"],"24254":["CWE-20"],"24030":["CWE-269"],"24455":["CWE-189"],"24088":["CWE-190"],"24802":["CWE-703"],"24995":["CWE-476"],"23845":["CWE-399"],"24612":["CWE-200"],"24033":["CWE-415"],"24649":["CWE-703"],"24019":["CWE-770"],"23955":["CWE-119","CWE-787"],"25006":["CWE-415","CWE-190","CWE-369"],"24652":["CWE-125"],"24478":[],"24888":["CWE-611","CWE-776","CWE-415","CWE-125"],"24233":["CWE-125"],"24694":["CWE-416","CWE-703"],"23849":["CWE-310"],"24841":["CWE-20","CWE-200"],"24197":["CWE-200"],"24003":["CWE-787"],"24943":["CWE-125"],"24783":["CWE-20"],"24650":["CWE-674"],"23989":[],"24395":["CWE-190","CWE-125"],"24958":["CWE-327"],"24097":["CWE-416"],"24606":["CWE-787"],"24913":["CWE-77"],"24529":["CWE-200"],"24315":["CWE-119","CWE-787"],"24549":["CWE-476"],"23980":["CWE-399"],"24127":["CWE-399"],"23847":["CWE-119"],"24882":[],"24610":["CWE-264"],"24149":[],"24618":["CWE-476"],"24370":["CWE-200"],"24486":["CWE-119"],"24537":["CWE-416","CWE-703"],"24021":["CWE-125","CWE-787"],"24872":["CWE-703","CWE-125"],"24314":["CWE-119"],"24914":["CWE-415","CWE-190","CWE-369"],"23843":["CWE-310"],"24929":["CWE-19"],"24788":["CWE-399","CWE-404"],"24609":["CWE-20"],"23873":["CWE-190"],"24855":["CWE-310"],"24820":["CWE-787"],"24187":["CWE-119","CWE-703"],"25013":["CWE-682"],"23846":["CWE-284","CWE-436"],"24496":["CWE-119","CWE-787"],"24153":[],"24058":["CWE-119","CWE-787"],"24261":["CWE-20","CWE-129"],"23860":["CWE-476"],"24566":["CWE-476","CWE-284"],"24845":["CWE-20"],"24339":[],"24683":["CWE-362"],"24145":[],"24457":["CWE-284","CWE-264"],"24196":["CWE-459"],"23963":["CWE-287"],"24521":[],"24976":["CWE-190"],"24573":["CWE-399"],"24781":["CWE-125"],"24488":[],"24635":[],"24570":["CWE-416"],"24660":["CWE-310"],"24654":["CWE-787"],"24846":["CWE-416"],"24438":[],"25043":["CWE-843"],"24538":["CWE-416"],"24580":["CWE-703"],"23995":["CWE-20"],"24416":["CWE-835"],"24787":["CWE-119"],"23964":["CWE-787"],"23833":["CWE-416"],"24962":["CWE-125"],"24289":["CWE-476"],"24598":["CWE-290"],"24647":["CWE-434"],"24524":["CWE-617","CWE-703"],"24331":["CWE-787"],"24818":["CWE-415"],"24643":["CWE-190"],"24466":["CWE-119","CWE-703","CWE-787"],"24735":["CWE-125"],"23926":["CWE-200","CWE-119"],"24505":["CWE-295"],"24420":["CWE-416"],"24249":["CWE-190","CWE-787"],"24464":["CWE-416","CWE-787"],"24239":["CWE-327"],"24985":[],"24843":["CWE-703"],"24230":["CWE-476"],"24646":["CWE-20"],"25029":["CWE-131"],"24690":["CWE-20","CWE-476"],"24059":["CWE-399"],"24947":["CWE-787"],"24160":["CWE-703"],"24011":["CWE-787"],"23907":["CWE-476","CWE-401"],"24530":[],"24873":["CWE-119","CWE-787"],"24376":["CWE-703"],"23972":["CWE-459"],"24581":[],"24208":["CWE-400","CWE-401"],"24025":["CWE-125"],"24715":["CWE-362","CWE-119"],"24574":[],"24583":["CWE-787"],"24072":["CWE-399"],"24071":[],"25050":["CWE-200"],"24970":[],"24686":["CWE-416"],"23878":["CWE-200","CWE-787"],"24687":["CWE-200"],"24451":["CWE-349"],"24005":["CWE-703","CWE-667"],"24579":["CWE-20","CWE-476"],"24945":["CWE-20"],"23919":["CWE-20"],"24585":["CWE-476"],"24398":[],"24454":["CWE-190"],"24902":["CWE-22"],"23912":["CWE-310"],"24489":["CWE-476"],"23978":[],"24621":["CWE-444"],"24738":["CWE-116"],"23862":["CWE-326"],"24303":["CWE-401"],"24132":["CWE-415"],"24701":[],"24923":["CWE-200"],"24332":[],"24763":[],"24388":["CWE-284"],"24228":["CWE-284"],"24184":["CWE-22"],"24399":["CWE-613"],"24229":[],"24309":["CWE-77"],"24525":["CWE-119","CWE-787"],"24617":["CWE-78"],"24811":["CWE-77"],"24087":["CWE-703"],"24955":["CWE-125"],"24017":["CWE-125","CWE-787"],"24893":["CWE-200"],"24592":[],"24737":["CWE-119"],"24367":[],"24879":["CWE-362"],"24907":["CWE-835"],"23794":["CWE-399"],"23790":["CWE-125"],"24028":["CWE-241"],"23820":["CWE-122"],"23872":["CWE-254"],"24824":["CWE-276"],"24794":[],"24865":["CWE-20","CWE-269"],"24411":["CWE-125"],"24942":["CWE-94","CWE-787"],"24534":["CWE-20","CWE-787"],"24421":["CWE-399"],"24508":["CWE-787"],"24548":["CWE-863"],"24600":["CWE-119"],"24312":["CWE-416"],"23882":["CWE-703"],"25041":["CWE-416","CWE-787"],"24969":["CWE-190"],"23904":[],"24213":["CWE-415","CWE-119"],"24953":[],"24603":["CWE-703","CWE-125"],"24319":[],"25060":["CWE-119","CWE-787"],"24350":["CWE-200","CWE-61"],"23827":["CWE-200"],"24979":["CWE-415"],"23939":["CWE-20"],"24409":["CWE-200"],"24628":["CWE-19"],"24205":["CWE-416"],"24112":[],"24875":[],"24568":[],"23892":["CWE-665"],"24733":["CWE-476"],"24708":["CWE-787"],"24949":["CWE-200"],"24884":["CWE-362","CWE-401"],"24959":["CWE-617"],"24135":["CWE-416"],"25017":["CWE-125"],"23835":["CWE-476","CWE-284"],"24965":["CWE-190","CWE-369"],"24819":[],"24222":[],"24262":["CWE-399"],"24483":[],"23946":[],"24164":["CWE-284","CWE-295"],"23947":["CWE-323"],"23836":["CWE-295"],"24396":["CWE-476"],"24703":["CWE-189"],"24437":["CWE-20"],"24535":["CWE-476"],"24111":["CWE-120","CWE-787"],"24113":["CWE-787"],"24999":["CWE-476"],"23858":["CWE-119"],"24662":["CWE-125"],"24807":["CWE-125","CWE-787"],"24543":["CWE-203"],"25003":["CWE-125"],"24827":[],"24002":["CWE-200"],"24413":[],"23799":["CWE-787"],"24596":["CWE-787"],"24242":["CWE-20"],"24034":["CWE-119","CWE-772","CWE-401"],"23932":["CWE-362"],"24547":["CWE-125"],"24544":["CWE-295"],"25035":["CWE-787"],"24805":[],"24373":["CWE-119","CWE-787"],"24337":["CWE-416","CWE-362"],"24362":["CWE-241","CWE-19"],"24393":["CWE-22"],"24500":[],"23921":[],"23829":["CWE-20","CWE-706"],"24124":["CWE-190"],"24792":["CWE-476"],"24138":["CWE-125"],"24963":[],"24561":["CWE-415"],"24513":["CWE-613"],"23986":[],"24921":["CWE-476","CWE-787"],"24801":["CWE-416"],"24343":[],"23911":["CWE-703"],"24154":["CWE-400","CWE-703","CWE-770"],"24775":["CWE-703"],"24866":["CWE-200","CWE-203"],"24432":["CWE-200","CWE-787"],"24714":["CWE-125"],"24224":["CWE-770"],"24318":[],"24622":["CWE-287","CWE-284"],"24655":["CWE-190"],"23961":["CWE-190"],"24878":["CWE-703"],"24240":["CWE-354"],"24772":["CWE-20"],"24748":["CWE-835"],"24458":["CWE-362"],"24640":["CWE-476","CWE-125"],"24173":["CWE-119"],"24353":["CWE-200","CWE-552"],"24689":[],"24193":["CWE-613"],"24043":["CWE-416"],"24905":["CWE-476"],"24931":[],"24934":["CWE-476"],"24494":["CWE-399"],"24195":["CWE-416"],"24348":[],"24504":["CWE-345"],"24828":["CWE-787"],"24545":[],"24214":["CWE-20"],"24178":["CWE-190"],"24799":["CWE-787"],"24101":["CWE-667"],"24282":[],"23842":["CWE-416"],"24013":["CWE-330"],"24745":["CWE-125"],"23985":[],"24503":["CWE-125","CWE-369"],"24986":["CWE-416"],"24614":[],"25047":["CWE-200"],"24558":["CWE-119","CWE-772","CWE-401"],"24493":["CWE-190"],"23893":["CWE-416"],"24358":["CWE-241","CWE-19"],"24129":["CWE-20","CWE-703"],"24994":["CWE-20"],"24798":["CWE-119"],"24668":["CWE-416"],"24378":["CWE-400","CWE-401"],"24176":["CWE-190","CWE-125"],"24201":["CWE-416"],"24698":["CWE-20"],"24221":["CWE-200"],"24991":["CWE-703"],"24217":["CWE-120","CWE-787"],"24871":["CWE-190"],"24400":[],"25010":[],"24374":["CWE-20"],"24707":[],"24306":["CWE-190"],"23928":["CWE-20"],"24922":["CWE-787"],"24236":["CWE-120"],"25025":["CWE-476"],"23917":["CWE-284","CWE-264"],"25021":[],"24064":["CWE-125"],"24658":["CWE-120","CWE-787"],"23848":["CWE-125","CWE-835"],"24755":[],"24202":["CWE-617","CWE-703"],"24140":["CWE-20"],"24564":[],"23948":["CWE-200"],"23817":["CWE-400"],"24925":[],"23831":["CWE-189"],"24231":["CWE-200"],"24238":["CWE-703","CWE-189"],"23838":[],"24998":["CWE-347"],"24383":["CWE-119","CWE-787"],"24826":[],"24964":["CWE-59"],"24691":["CWE-611","CWE-776","CWE-415","CWE-125"],"25054":["CWE-284"],"23823":["CWE-787"],"24575":["CWE-787"],"24858":["CWE-284","CWE-264"],"24752":[],"24924":["CWE-189"],"24909":["CWE-369"],"24430":["CWE-20"],"24774":[],"24336":["CWE-20"],"24645":["CWE-476"],"24857":["CWE-120"],"24832":["CWE-330"],"23934":["CWE-416"],"24407":["CWE-200"],"24724":["CWE-89"],"24267":["CWE-327"],"24528":["CWE-703"],"24676":["CWE-20"],"24665":["CWE-22"],"23861":[],"24450":[],"23903":["CWE-703"],"24768":["CWE-125"],"24375":["CWE-787"],"24928":["CWE-119","CWE-284"],"24387":["CWE-200"],"24191":["CWE-416"],"24075":["CWE-416"],"25027":["CWE-787"],"23819":["CWE-362"],"24225":["CWE-200","CWE-119"],"24523":["CWE-125"],"24911":[],"23935":["CWE-22"],"25037":["CWE-125"],"23896":["CWE-400","CWE-703"],"24664":[],"24837":[],"24044":["CWE-276","CWE-703","CWE-863"],"24767":[],"24237":["CWE-400"],"24661":["CWE-787"],"23803":["CWE-22"],"23931":["CWE-190"],"24967":[],"24780":[],"24448":["CWE-732"],"24671":["CWE-125"],"24560":["CWE-770"],"24080":["CWE-125","CWE-787"],"24571":["CWE-284","CWE-264"],"24426":["CWE-787"],"24434":["CWE-772"],"24551":["CWE-843"],"24354":["CWE-416"],"24705":["CWE-284","CWE-295"],"24283":["CWE-200"],"24272":["CWE-119","CWE-787"],"24747":["CWE-476","CWE-284"],"24607":["CWE-264"],"24816":["CWE-362"],"24604":["CWE-399"],"23902":["CWE-119"],"24051":["CWE-22"],"24987":["CWE-703"],"24721":["CWE-119"],"24485":["CWE-703","CWE-835"],"24308":["CWE-617","CWE-703"],"24712":["CWE-18"],"24562":["CWE-20"],"24590":[],"24435":["CWE-284","CWE-295"],"24779":["CWE-20","CWE-706"],"24552":["CWE-476"],"24422":["CWE-787"],"24989":["CWE-770"],"24271":["CWE-125"],"24389":[],"24190":["CWE-120"],"24889":["CWE-703"],"24446":["CWE-189"],"25002":["CWE-119"],"23868":["CWE-20","CWE-269"],"24137":["CWE-20"],"24070":["CWE-125"],"23981":["CWE-703","CWE-189"],"24782":["CWE-416","CWE-703"],"24613":["CWE-787"],"24484":["CWE-125"],"24277":["CWE-416"],"23837":["CWE-703","CWE-189"],"24074":[],"24672":["CWE-400","CWE-401"],"24352":[],"23897":["CWE-200"],"24338":["CWE-415"],"24012":["CWE-415"],"24258":["CWE-120","CWE-119","CWE-787"],"24675":["CWE-476"],"24329":["CWE-269"],"24908":["CWE-362"],"24119":["CWE-835"],"24764":["CWE-320"],"24915":[],"24050":["CWE-119","CWE-787"],"24266":["CWE-212"],"24126":[],"23942":["CWE-119","CWE-787"],"24116":["CWE-122"],"24447":["CWE-200","CWE-552"],"23930":["CWE-284","CWE-732"],"24479":["CWE-119"],"24557":["CWE-362"],"24300":["CWE-787"],"24440":["CWE-358"],"24778":["CWE-476"],"24770":["CWE-787"],"23967":["CWE-444","CWE-61"],"24418":["CWE-416"],"24305":["CWE-22"],"24161":[],"24259":["CWE-254"],"24533":["CWE-20"],"24347":["CWE-362","CWE-347"],"24102":["CWE-406"],"24189":[],"24390":["CWE-326"],"24472":["CWE-209"],"24711":["CWE-787"],"24288":[],"24885":["CWE-416"],"23962":["CWE-189"],"24685":["CWE-476"],"24452":["CWE-703","CWE-125"],"24639":["CWE-190"],"24359":["CWE-119"],"24680":["CWE-863"],"24569":["CWE-399"],"24844":["CWE-120"],"23960":["CWE-189"],"24203":["CWE-190","CWE-252"],"24744":["CWE-400","CWE-703","CWE-835"],"24541":["CWE-459"],"24067":["CWE-476"],"24936":[],"24474":[],"24364":["CWE-200","CWE-119"],"24280":["CWE-20"],"24291":["CWE-476"],"24565":["CWE-120","CWE-269"],"24333":["CWE-401"],"24491":["CWE-703"],"24739":["CWE-125"],"24567":["CWE-787"],"24415":["CWE-20"],"24974":["CWE-119"],"24880":["CWE-476"],"25032":["CWE-415"],"24255":["CWE-120"],"24441":["CWE-200","CWE-552"],"24177":[],"23993":["CWE-120"],"24749":[],"24226":["CWE-20"],"24310":["CWE-189"],"24460":["CWE-119","CWE-703"],"24864":["CWE-125"],"24727":["CWE-295"],"24118":["CWE-362"],"24572":["CWE-295"],"25055":["CWE-120"],"24510":["CWE-287","CWE-284"],"24667":["CWE-125"],"24753":[],"23908":["CWE-400","CWE-703"],"23953":["CWE-134","CWE-119","CWE-787"],"25033":["CWE-787"],"24174":["CWE-119"],"24790":[],"24218":[],"24330":["CWE-362","CWE-401"],"24899":["CWE-20"],"24861":["CWE-119"],"23936":["CWE-295"],"24381":["CWE-134"],"24927":["CWE-401"],"24896":["CWE-787"],"24722":["CWE-119"],"24251":[],"24107":[],"24086":["CWE-134"],"24750":["CWE-78"],"24895":["CWE-476"],"23864":["CWE-119","CWE-772","CWE-401"]},"project":{"24286":"wesnoth","24372":"tensorflow","24726":"php-src","24716":"gpac","25001":"mongo","24168":"linux","25019":"linux","25030":"ekiga","24386":"linux","24700":"qpdf","24181":"qemu-kvm","24263":"u-boot","24079":"librsvg","23839":"tinyexr","24094":"sqlite","24334":"nghttp2","24469":"linux","24054":"mysql-server","24115":"linux","24972":"envoy","24542":"gpac","24492":"gdm","24018":"linux","24935":"linux","23850":"quagga","24766":"vim","24890":"linux-2.6","24322":"linux","24656":"wget","24304":"libvirt","24791":"qemu","23810":"acrn-hypervisor","25034":"libxml2","24147":"suricata","24657":"oniguruma","24294":"squid","24669":"mongoose","25014":"server","24526":"linux","24881":"linux","24361":"tensorflow","24830":"librsvg","23957":"cimg","24977":"bitlbee","23959":"linux","24601":"jasper","24853":"radare2","25008":"cimg","24424":"folly","24443":"php-src","25026":"krb5","24360":"php-src","24615":"bluez","25028":"linux","24130":"samba","24060":"libxml2","24275":"wolfssl","24023":"linux","24996":"radare2","24874":"epiphany","24759":"linux","24172":"linux","24227":"git","24765":"njs","25012":"FreeRDP","24110":"cyrus-imapd","24341":"postgres","24069":"libexpat","24327":"ceph","24897":"gpac","24406":"mysql-server","24563":"tensorflow","24423":"libarchive","24453":"linux","24290":"tensorflow","24461":"linux-2.6","24148":"gnupg","24950":"openenclave","24480":"radare2","23840":"server","23949":"stunnel","24007":"FreeRDP","24754":"linux","25046":"zziplib","24975":"qemu","24507":"gnutls","24822":"linux","24577":"linux","23997":"qemu","24188":"mongo","24536":"CImg","25039":"linux","24589":"linux-2.6","24122":"linux","24625":"krb5","24506":"bind9","24706":"linux","24449":"ImageMagick","24723":"pango","24265":"linux","23927":"linux","24143":"mutt","25015":"linux","24246":"taglib","24141":"bdwgc","24169":"tcpdump","24555":"linux","24582":"tcmu-runner","24253":"systemd","24408":"ImageMagick","24471":"src","25009":"linux","23982":"php-src","25018":"qemu","24629":"jasper","24427":"roundcubemail","24325":"FFmpeg","24704":"cantata","24326":"libgit2","24514":"postgres","24056":"LIEF","24900":"mysql-server","24302":"openssl","24556":"linux","24134":"libseccomp","23884":"linux","24593":"mono","24065":"redcarpet","23901":"util-linux","23987":"mono","24215":"linux","24006":"linux","24677":"clamav-devel","24245":"samba","25031":"dcmtk","24123":"gst-plugins-base","23844":"FFmpeg","24216":"qemu","24971":"krb5","24856":"net-snmp","24301":"libcaca","24276":"linux","24316":"linux","24840":"pacemaker","24725":"linux","25007":"git","23940":"tensorflow","23806":"folly","23857":"librsvg","24490":"jasper","24061":"iperf","24001":"ntp","23905":"mono","24210":"open-vm-tools","24584":"passenger","24223":"gpac","24599":"node","24298":"linux","23915":"server","24951":"ImageMagick","23853":"transmission","24812":"gpac","24630":"linux","25038":"envoy","24162":"tk","24104":"re2c","23973":"src","24481":"evolution","23992":"envoy","24863":"qemu","24777":"augeas","24278":"icu","24182":"tcpdump","24829":"mbedtls","24016":"php-src","24742":"linux","24179":"libvpx","24234":"tcpdump","23943":"linux-2.6","24930":"Onigmo","24098":"libssh","24836":"u-boot","24463":"qemu","24170":"php-src","23999":"linux","24554":"FFmpeg","24026":"gpac","24027":"linux","24048":"linux-2.6","24588":"CImg","24250":"tcpreplay","24631":"linux","24938":"php-src","24992":"mod_h2","25057":"libevent","24776":"unicorn","24433":"linux","24522":"linux","24789":"lwip","24697":"soundtouch","24475":"mruby","24663":"redis","24769":"cyrus-imapd","24470":"openssl","24540":"linux","24099":"qemu","24674":"NetworkManager","23920":"faad2","24477":"linux","24462":"php-src","25044":"libsixel","24014":"mongo","24644":"linux","25000":"thrift","23888":"linux","24397":"linux","23815":"FreeRDP","24627":"git","25045":"cimg","23922":"linux","23923":"evolution-ews","24898":"vim","24730":"evolution-data-server","23828":"linux","24268":"server","24346":"libarchive","24032":"ovs","24220":"linux","24870":"cryptsetup","24041":"opencv","24009":"postgres","24944":"wolfssl","24681":"linux","24594":"radare2","24083":"util-linux","24292":"libxml2","23951":"linux","25022":"envoy","24852":"cpython","23875":"ipmitool","24736":"mujs","24578":"wolfssl","24883":"node","24206":"irssi","24183":"opencv","24078":"linux","24729":"polarssl","23879":"libtpms","24597":"unbound","24648":"gdm","24090":"openexr","24029":"qemu","24793":"net-snmp","24136":"jasper","23970":"gpac","24814":"CImg","24139":"enlightenment","24402":"linux","23887":"tensorflow","24695":"linux","24512":"qemu","24439":"ghostpdl","24920":"libvirt","24678":"linux","24185":"radare2","24366":"linux","24860":"samba","24000":"linux","24498":"linux","24487":"fontforge","24117":"php-src","24384":"linux","24806":"jasper","24980":"libarchive","24502":"openssl","23968":"glib","24520":"libgd","24948":"libnbd","23966":"php-src","24688":"linux","24369":"cimg","24532":"linux-2.6","24993":"keepalived","24284":"ImageMagick","24468":"mujs","24207":"firejail","24809":"node","24429":"linux","25040":"bluez","24445":"tensorflow","24270":"w3m","24659":"jasper","23938":"qemu","24859":"linux","24634":"ntp","24917":"libarchive","24459":"libxml2","24247":"openssl","24926":"net","24933":"qemu","24008":"linux","25020":"at91bootstrap","24527":"linux","24666":"linux","24257":"ImageMagick","23909":"libinput","24244":"qemu","24825":"linux","24854":"curl","25053":"liblouis","24904":"mysql-server","24165":"librsvg","24800":"frr","24692":"xserver","24940":"linux","24045":"jasper","23894":"mbedtls","25056":"FreeRDP","24932":"linux","25042":"poppler","24796":"libevent","23933":"evolution-ews","23916":"OpenSC","24684":"ceph","24425":"fdkaac","23859":"libjpeg-turbo","24089":"LuaJIT","24456":"ext-http","24046":"Little-CMS","24368":"tip","23889":"qpdf","24335":"radare2","24616":"libvirt","24637":"ImageMagick","24956":"LibRaw","24720":"tensorflow","24954":"linux","24307":"linux","23983":"git","24380":"linux","24158":"linux","23876":"FFmpeg","24379":"linux","24869":"linux","24128":"linux","24285":"linux","24473":"wolfssl","24186":"krb5","24344":"gnutls","24734":"postgres","24269":"edk2","24167":"cimg","24946":"pam_tacplus","24321":"mruby","23890":"optee_os","24444":"linux-2.6","23952":"server","24356":"jasper","24632":"gpac","24039":"logrotate","24495":"net","24620":"qpdf","24042":"linux","24576":"gdk-pixbuf","23974":"postgres","24436":"php-src","24901":"php-src","24040":"unbound","23969":"stunnel","24848":"jasper","25011":"kvm","24328":"linux","23998":"abrt","24049":"ImageMagick","24015":"radare2","24199":"linux","24862":"libzmq","24342":"linux","24817":"envoy","24077":"linux","24024":"tensorflow","24377":"linux","24200":"server","24876":"curl","24084":"net","24296":"uriparser","23826":"libtpms","24511":"qemu-kvm","23956":"php-src","24682":"sqlite","24731":"systemd","24786":"libreport","24919":"Little-CMS","24673":"linux","24509":"radare2","24966":"linux","24313":"core","23914":"envoy","24842":"brotli","24431":"linux","24918":"linux","24761":"php-radius","24414":"jansson","24912":"agoo","23924":"linux","24983":"perl5","23874":"inspircd","24297":"postgres","24345":"linux-2.6","24892":"linux","23880":"nDPI","24939":"php-src","24815":"linux","24771":"qemu","24091":"net","24163":"linux","24320":"upx","24082":"envoy","24317":"linux","24619":"mono","24516":"envoy","24405":"qpdf","23871":"qpdf","24073":"cimg","24539":"linux","24100":"curl","23895":"FFmpeg","23929":"polarssl","24978":"libarchive","24623":"libtiff","24175":"mongo","25036":"libgit2","24713":"jasper","24887":"openssl","23913":"krb5","24062":"mysql-server","24324":"php-src","24960":"linux","24696":"linux-2.6","24997":"linux","24391":"linux","25051":"php-src","24553":"vim","23945":"proftpd","24679":"p11-kit","24968":"mod_h2","24850":"linux","23881":"mono","24085":"linux","24209":"pjproject","24093":"util-linux","23900":"clamav-devel","24518":"qpdf","24651":"linux","24004":"server","23954":"iproute2","23984":"linux","24903":"postgres","24371":"domoticz","24559":"qpdf","24957":"dpdk","24867":"libssh","24152":"samba","24784":"qpdf","24990":"libvpx","24531":"miniupnp","24340":"server","24038":"net","24394":"electron","24988":"fastecdsa","25061":"linux","24010":"radare2","23856":"ImageMagick","24886":"linux","24363":"pdfresurrect","24412":"monkey","25004":"bash","24835":"frr","23855":"libgphoto2","24105":"electron","23885":"tensorflow","24823":"postgres","24066":"brotli","23950":"varnish-cache","25052":"core","24068":"linux","24103":"linux","24252":"abrt","24211":"tensorflow","24984":"nfdump","24961":"linux","23965":"server","24937":"tensorflow","24813":"veyon","24095":"linux","23971":"cgal","23918":"linux","24150":"network-manager-applet","24144":"linux","24053":"gnome-bluetooth","24392":"libtiff","23867":"linux-2.6","24804":"linux","24403":"ImageMagick","24467":"znc","24081":"libgdata","23925":"gnome-screensaver","24219":"linux","24055":"librsvg","24299":"tensorflow","24212":"radare2","23814":"qemu","23886":"ceph","24248":"keepkey-firmware","24382":"xrootd","24274":"qpdf","23996":"jdk17u","24131":"LibRaw","23870":"ceph","24037":"radare2","24180":"pacemaker","24442":"envoy","24795":"linux","24517":"qpdf","24756":"gpac","25023":"OpenSC","24256":"LibRaw","24022":"pjproject","24624":"qpdf","23979":"mujs","24235":"memcached","23834":"OpenSC","24106":"xrdp","24851":"vte","24611":"suricata","24743":"asylo","24323":"openssl","24035":"linux","24499":"git","24868":"PackageKit","24633":"unbound","24587":"rizin","24063":"tip","24108":"iperf","24232":"linux","23841":"qpdf","23851":"linux-2.6","24142":"linux","23910":"ntp","24273":"mutt","24279":"zlib","23869":"openssl","24699":"perl5","24192":"linux","24740":"openssl","23877":"linux","24906":"FFmpeg","24757":"linux","24762":"curl","24156":"linux","25005":"electron","24120":"linux","24241":"linux","23852":"wireshark","23866":"librsvg","24717":"linux","25048":"flatpak","23898":"FreeRDP","24092":"linux","24877":"tensorflow","23830":"curl","24198":"polarssl","24204":"linux-2.6","23991":"vim","25058":"quassel","24838":"server","24653":"mysql-server","24146":"ovs","24833":"poppler","24133":"ovs","24476":"linux","24847":"ovs","24636":"linux","23977":"mysql-server","24497":"linux-2.6","24281":"jerryscript","23899":"sqlite","24465":"systemd","24670":"newsbeuter","24595":"curl","25024":"radare2","24732":"openssl","24401":"radare2","24125":"linux","24293":"cockpit","23975":"dpdk","24710":"augeas","24243":"linux","23941":"openssl","24751":"fmt","24076":"mruby","24349":"linux","24515":"linux","24171":"envoy","24260":"mupdf","23976":"linux","24519":"unbound","23832":"linux","24351":"libtpms","23809":"linux","24831":"exim","25049":"php-src","24834":"linux-2.6","23793":"tip","24728":"gpac","24385":"linux","24952":"vim","24891":"linux","24428":"curl","24121":"grep","23805":"qpdf","24808":"node","23789":"tensorflow","24052":"php-src","24973":"upx","23988":"libxml2","24849":"curl","24718":"linux","24894":"linux-2.6","24295":"linux","23863":"linux","24638":"linux","24287":"linux","23994":"vim","24760":"FFmpeg","24941":"collectd","24746":"linux","24910":"linux","23958":"libidn","24916":"linux","24839":"php-src","24981":"gpac","24550":"tinyexr","24702":"gpac","24693":"linux","24365":"linux","24410":"krb5","23906":"mysql-server","24797":"FreeRDP","24803":"tinygltf","24785":"linux","25059":"krecipes","23944":"qpdf","24404":"tip","24357":"augeas","24096":"rdesktop","24031":"kvm","23937":"vim","23865":"libvirt","23804":"openssl","23854":"tensorflow","23891":"OpenSC","24773":"gpac","23825":"bdwgc","24355":"gimp","24036":"envoy","24417":"linux","24608":"network-manager-applet","24626":"LuaJIT","24810":"nbdkit","25016":"linux-2.6","24546":"postgres","24264":"postgres","24591":"envoy","24114":"samba","24057":"linux","24482":"file-roller","24758":"libevent","24166":"server","23883":"isolated-vm","24719":"libvpx","24642":"qemu","24159":"linux","24194":"trojita","24641":"neomutt","24982":"libgd","24602":"net-snmp","24605":"linux","24109":"tigervnc","24741":"qemu","24709":"wolfssl","24020":"systemd","24157":"file","23990":"krb5","24151":"flatpak","24501":"openssl","24821":"linux","24586":"pjproject","24419":"linux","24047":"git","24155":"SDL","24311":"tip","24254":"linux","24030":"ioq3","24455":"grep","24088":"rizin","24802":"linux","24995":"exiv2","23845":"libxml2","24612":"samba","24033":"libgd","24649":"LibRaw","24019":"cimg","23955":"linux","25006":"jasper","24652":"libgd","24478":"envoy","24888":"libexpat","24233":"perl5","24694":"linux","23849":"openssl","24841":"linux","24197":"sound","24003":"gdk-pixbuf","24943":"vim","24783":"linux-2.6","24650":"mujs","23989":"cyrus-imapd","24395":"FreeRDP","24958":"optee_os","24097":"linux","24606":"qemu","24913":"thrift","24529":"kvm","24315":"wireshark","24549":"gpac","23980":"qemu","24127":"kvm","23847":"php-src","24882":"wayland","24610":"linux-2.6","24149":"openssh-portable","24618":"poppler","24370":"linux","24486":"libxml2","24537":"server","24021":"radare2","24872":"linux","24314":"qemu","24914":"jasper","23843":"jansson","24929":"php-src","24788":"linux","24609":"net","23873":"cpython","24855":"libgadu","24820":"qpdf","24187":"linux","25013":"linux-stable","23846":"flatpak","24496":"ImageMagick","24153":"systemd","24058":"FFmpeg","24261":"linux","23860":"php-src","24566":"linux","24845":"libvpx","24339":"xrdp","24683":"linux-2.6","24145":"gdm","24457":"monkey","24196":"linux","23963":"sssd","24521":"openssl","24976":"php-src","24573":"php-src","24781":"radare2","24488":"httpd","24635":"linux","24570":"php-src","24660":"linux","24654":"linux","24846":"linux","24438":"history","25043":"tensorflow","24538":"ovs","24580":"linux","23995":"linux","24416":"envoy","24787":"qemu","23964":"bpf","23833":"php-src","24962":"openexr","24289":"qemu","24598":"linux","24647":"crawl","24524":"mvfst","24331":"linux","24818":"docker-credential-helpers","24643":"redis","24466":"uwsgi","24735":"ovs","23926":"linux","24505":"evolution-ews","24420":"node","24249":"gpac","24464":"linux","24239":"linux","24985":"curl","24843":"gerbv","24230":"libvncserver","24646":"libreport","25029":"libtasn1","24690":"tensorflow","24059":"linux","24947":"ok-file-formats","24160":"jhead","24011":"linux","23907":"gpac","24530":"qemu","24873":"gpac","24376":"gimp","23972":"linux","24581":"node","24208":"linux","24025":"ghostpdl","24715":"linux","24574":"libvirt","24583":"gpac","24072":"linux","24071":"linux","25050":"linux","24970":"linux","24686":"linux","23878":"FreeRDP","24687":"linux","24451":"linux","24005":"linux","24579":"systemd","24945":"linux","23919":"samba","24585":"linux","24398":"linux-2.6","24454":"redis","24902":"webcc","23912":"openssl","24489":"libssh-mirror","23978":"xrdp","24621":"squid","24738":"squid","23862":"php-src","24303":"envoy","24132":"linux","24701":"kvm","24923":"linux","24332":"screen","24763":"qemu","24388":"cinnamon-screensaver","24228":"Fast-DDS","24184":"gnome-autoar","24399":"mongo","24229":"mysql-server","24309":"core","24525":"FFmpeg","24617":"mutt","24811":"core","24087":"bluez","24955":"qemu","24017":"tcpdump","24893":"tcmu-runner","24592":"jdk17u","24737":"libtiff","24367":"bison","24879":"linux","24907":"mongo","23794":"linux","23790":"ImageMagick","24028":"linux","23820":"openjpeg","23872":"mysql-server","24824":"gvfs","24794":"augeas","24865":"linux","24411":"libgd","24942":"xorg-xserver","24534":"tigervnc","24421":"pacemaker","24508":"linux","24548":"linux","24600":"ruby","24312":"server","23882":"LibRaw","25041":"linux","24969":"php-src","23904":"mongo","24213":"OpenSC","24953":"nautilus","24603":"ettercap","24319":"vim","25060":"linux","24350":"passenger","23827":"linux","24979":"net-snmp","23939":"ruby","24409":"ghostpdl","24628":"php-src","24205":"fontforge","24112":"php-src","24875":"libjpeg-turbo","24568":"electron","23892":"linux","24733":"ImageMagick","24708":"re2c","24949":"linux-2.6","24884":"linux","24959":"server","24135":"jerryscript","25017":"oniguruma","23835":"linux","24965":"cpython","24819":"php-src","24222":"openssl","24262":"linux","24483":"curl","23946":"linux","24164":"mysql-server","23947":"ceph","23836":"stunnel","24396":"clamav-devel","24703":"grep","24437":"mongo","24535":"vim","24111":"uftpd","24113":"qpdf","24999":"ntp","23858":"gnutls","24662":"cgal","24807":"tensorflow","24543":"nettle","25003":"libgd","24827":"Little-CMS","24002":"linux","24413":"mysql-server","23799":"hermes","24596":"libtpms","24242":"bash","24034":"krb5","23932":"linux","24547":"cpython","24544":"glib-networking","25035":"linux","24805":"librsvg","24373":"php-radius","24337":"linux","24362":"linux","24393":"envoy","24500":"php-src","23921":"libvncserver","23829":"libgit2","24124":"cpio","24792":"ImageMagick","24138":"aspell","24963":"bash","24561":"libyang","24513":"mongo","23986":"linux","24921":"tensorflow","24801":"curl","24343":"krecipes","23911":"linux","24154":"fizz","24775":"gimp","24866":"openssl","24432":"rizin","24714":"CImg","24224":"envoy","24318":"linux","24622":"booth","24655":"php-src","23961":"net","24878":"qemu","24240":"wireshark","24772":"core","24748":"ImageMagick","24458":"postgres","24640":"FreeRDP","24173":"linux-2.6","24353":"openenclave","24689":"linux-2.6","24193":"mongo","24043":"server","24905":"openssl","24931":"node-sqlite3","24934":"qemu","24494":"util-linux","24195":"php-src","24348":"openjpeg","24504":"tensorflow","24828":"vim","24545":"linux","24214":"gnupg","24178":"linux-2.6","24799":"gdal","24101":"libvirt","24282":"php-src","23842":"server","24013":"linux","24745":"radare2","23985":"openssl","24503":"tensorflow","24986":"jerryscript","24614":"librsvg","25047":"wesnoth","24558":"krb5","24493":"cpython","23893":"Crow","24358":"linux","24129":"tensorflow","24994":"linux","24798":"bdwgc","24668":"linux","24378":"linux","24176":"ImageMagick","24201":"linux","24698":"net","24221":"linux","24991":"gpac","24217":"linux","24871":"openexr","24400":"pam_pkcs11","25010":"libvncserver","24374":"gdk-pixbuf","24707":"jdk8u","24306":"linux","23928":"libxml2","24922":"linux","24236":"cups","25025":"libarchive","23917":"linux","25021":"linux-2.6","24064":"pjproject","24658":"tcpdump","23848":"gnome-session","24755":"kvm","24202":"mvfst","24140":"mongo","24564":"linux","23948":"ocaml","23817":"net","24925":"linux","23831":"grep","24231":"samba","24238":"linux","23838":"ghostpdl","24998":"fastecdsa","24383":"libtiff","24826":"qemu","24964":"abrt","24691":"libexpat","25054":"linux","23823":"qpdf","24575":"radare2","24858":"linux","24752":"gnome-screensaver","24924":"jasper","24909":"ImageMagick","24430":"openssl","24774":"linux-2.6","24336":"linux","24645":"vim","24857":"freetype2-demos","24832":"linux","23934":"tip","24407":"linux-2.6","24724":"postgres","24267":"linux","24528":"linux","24676":"libreport","24665":"libreport","23861":"linux","24450":"kvm","23903":"protobuf","24768":"ImageMagick","24375":"gpac","24928":"openjpeg","24387":"linux","24191":"linux","24075":"irssi","25027":"123elf","23819":"linux","24225":"linux","24523":"ghostpdl","24911":"qemu","23935":"php-src","25037":"admesh","23896":"envoy","24664":"gnome-screensaver","24837":"ncurses","24044":"linux","24767":"ncurses","24237":"ovs","24661":"qpdf","23803":"poco","23931":"LibRaw","24967":"Little-CMS","24780":"gnome-screensaver","24448":"logrotate","24671":"pjproject","24560":"redis","24080":"tensorflow","24571":"linux","24426":"oniguruma","24434":"rsyslog","24551":"tensorflow","24354":"envoy","24705":"mysql-server","24283":"wesnoth","24272":"libsndfile","24747":"linux","24607":"clutter","24816":"linux","24604":"linux","23902":"suhosin","24051":"php-src","24987":"linux","24721":"tidy-html5","24485":"linux","24308":"mvfst","24712":"krb5","24562":"librsvg","24590":"gnulib","24435":"mysql-server","24779":"libgit2","24552":"linux","24422":"php-src","24989":"envoy","24271":"Little-CMS","24389":"nautilus","24190":"server","24889":"protobuf","24446":"linux-2.6","25002":"net","23868":"linux","24137":"samba","24070":"gpac","23981":"linux","24782":"server","24613":"qpdf","24484":"OpenSC","24277":"envoy","23837":"linux","24074":"nautilus","24672":"gpac","24352":"Little-CMS","23897":"linux","24338":"psutil","24012":"php-src","24258":"linux","24675":"envoy","24329":"linux","24908":"linux","24119":"qemu","24764":"openssl","24915":"linux","24050":"krb5","24266":"libvirt","24126":"electron","23942":"openssl","24116":"vim","24447":"openenclave","23930":"firejail","24479":"net","24557":"linux","24300":"php-src","24440":"suricata","24778":"ImageMagick6","24770":"gdk-pixbuf","23967":"agoo","24418":"linux","24305":"neomutt","24161":"mysql-server","24259":"mysql-server","24533":"linux-2.6","24347":"linux","24102":"nbdkit","24189":"libvncserver","24390":"openssl","24472":"util-linux","24711":"sqlite","24288":"tk","24885":"linux","23962":"jasper","24685":"linux","24452":"redis","24639":"libxml2","24359":"w3m","24680":"linux","24569":"pacemaker","24844":"brotli","23960":"linux","24203":"glibc","24744":"linux","24541":"linux","24067":"linux-2.6","24936":"mongo","24474":"libssh","24364":"mapserver","24280":"qemu","24291":"linux","24565":"NetHack","24333":"wireshark","24491":"protobuf","24739":"tensorflow","24567":"mruby","24415":"gnupg","24974":"curl","24880":"FFmpeg","25032":"collectd","24255":"linux","24441":"openenclave","24177":"net","23993":"linux","24749":"kvm","24226":"gnutls","24310":"linux","24460":"sfntly","24864":"php-src","24727":"glib-networking","24118":"linux","24572":"evolution-ews","25055":"brotli","24510":"ceph","24667":"ImageMagick","24753":"jasper","23908":"linux","23953":"fmt","25033":"file","24174":"bdwgc","24790":"linux","24218":"openssl","24330":"linux","24899":"tensorflow","24861":"git","23936":"evolution-data-server","24381":"libinput","24927":"squid","24896":"openjpeg","24722":"ruby","24251":"ghostpdl","24107":"php-src","24086":"libxml2","24750":"radare2","24895":"linux","23864":"krb5"},"size":{"24286":60,"24372":36,"24726":24,"24716":33,"25001":20,"24168":15,"25019":19,"25030":16,"24386":6,"24700":9,"24181":70,"24263":15,"24079":21,"23839":3,"24094":33,"24334":18,"24469":14,"24054":29,"24115":14,"24972":20,"24542":21,"24492":10,"24018":6,"24935":63,"23850":12,"24766":4,"24890":14,"24322":27,"24656":9,"24304":27,"24791":15,"23810":28,"25034":54,"24147":39,"24657":6,"24294":27,"24669":5,"25014":54,"24526":24,"24881":85,"24361":27,"24830":11,"23957":38,"24977":11,"23959":36,"24601":20,"24853":30,"25008":12,"24424":62,"24443":41,"25026":40,"24360":13,"24615":7,"25028":78,"24130":16,"24060":30,"24275":13,"24023":11,"24996":32,"24874":40,"24759":4,"24172":25,"24227":9,"24765":75,"25012":11,"24110":11,"24341":82,"24069":42,"24327":8,"24897":36,"24406":57,"24563":70,"24423":5,"24453":35,"24290":43,"24461":53,"24148":9,"24950":35,"24480":38,"23840":1,"23949":52,"24007":8,"24754":9,"25046":2,"24975":27,"24507":16,"24822":19,"24577":24,"23997":20,"24188":30,"24536":68,"25039":15,"24589":22,"24122":11,"24625":18,"24506":33,"24706":12,"24449":85,"24723":49,"24265":61,"23927":9,"24143":51,"25015":34,"24246":37,"24141":12,"24169":43,"24555":13,"24582":9,"24253":3,"24408":107,"24471":27,"25009":10,"23982":54,"25018":19,"24629":47,"24427":32,"24325":9,"24704":10,"24326":9,"24514":8,"24056":33,"24900":58,"24302":8,"24556":16,"24134":5,"23884":7,"24593":64,"24065":18,"23901":17,"23987":69,"24215":25,"24006":4,"24677":20,"24245":9,"25031":25,"24123":40,"23844":20,"24216":14,"24971":40,"24856":23,"24301":30,"24276":15,"24316":4,"24840":12,"24725":13,"25007":8,"23940":10,"23806":27,"23857":14,"24490":11,"24061":4,"24001":8,"23905":13,"24210":32,"24584":27,"24223":13,"24599":32,"24298":32,"23915":57,"24951":64,"23853":19,"24812":89,"24630":15,"25038":21,"24162":11,"24104":4,"23973":24,"24481":75,"23992":28,"24863":9,"24777":76,"24278":19,"24182":5,"24829":39,"24016":23,"24742":17,"24179":29,"24234":7,"23943":43,"24930":18,"24098":56,"24836":18,"24463":5,"24170":33,"23999":19,"24554":9,"24026":4,"24027":61,"24048":82,"24588":37,"24250":21,"24631":4,"24938":18,"24992":7,"25057":72,"24776":51,"24433":13,"24522":12,"24789":74,"24697":11,"24475":9,"24663":20,"24769":64,"24470":50,"24540":69,"24099":34,"24674":26,"23920":26,"24477":13,"24462":50,"25044":15,"24014":38,"24644":25,"25000":2,"23888":45,"24397":7,"23815":69,"24627":4,"25045":3,"23922":4,"23923":41,"24898":10,"24730":10,"23828":9,"24268":17,"24346":20,"24032":19,"24220":54,"24870":37,"24041":55,"24009":9,"24944":46,"24681":10,"24594":28,"24083":38,"24292":70,"23951":30,"25022":1,"24852":39,"23875":76,"24736":23,"24578":11,"24883":3,"24206":15,"24183":7,"24078":83,"24729":12,"23879":21,"24597":45,"24648":17,"24090":22,"24029":52,"24793":20,"24136":25,"23970":22,"24814":7,"24139":54,"24402":56,"23887":45,"24695":42,"24512":8,"24439":25,"24920":83,"24678":13,"24185":4,"24366":34,"24860":25,"24000":29,"24498":5,"24487":8,"24117":10,"24384":23,"24806":41,"24980":40,"24502":38,"23968":34,"24520":13,"24948":13,"23966":61,"24688":8,"24369":3,"24532":5,"24993":55,"24284":4,"24468":7,"24207":14,"24809":38,"24429":29,"25040":26,"24445":30,"24270":74,"24659":35,"23938":32,"24859":35,"24634":70,"24917":33,"24459":61,"24247":4,"24926":9,"24933":24,"24008":12,"25020":15,"24527":10,"24666":9,"24257":30,"23909":13,"24244":18,"24825":18,"24854":69,"25053":21,"24904":19,"24165":17,"24800":41,"24692":34,"24940":43,"24045":11,"23894":69,"25056":85,"24932":11,"25042":42,"24796":59,"23933":31,"23916":34,"24684":4,"24425":5,"23859":30,"24089":10,"24456":43,"24046":13,"24368":7,"23889":14,"24335":39,"24616":39,"24637":15,"24956":15,"24720":37,"24954":19,"24307":13,"23983":12,"24380":35,"24158":46,"23876":21,"24379":86,"24869":16,"24128":5,"24285":111,"24473":22,"24186":41,"24344":4,"24734":7,"24269":50,"24167":12,"24946":9,"24321":9,"23890":19,"24444":1,"23952":31,"24356":30,"24632":27,"24039":52,"24495":39,"24620":18,"24042":14,"24576":27,"23974":6,"24436":56,"24901":67,"24040":56,"23969":79,"24848":12,"25011":39,"24328":74,"23998":28,"24049":30,"24015":17,"24199":44,"24862":26,"24342":24,"24817":22,"24077":9,"24024":10,"24377":56,"24200":26,"24876":53,"24084":31,"24296":57,"23826":35,"24511":70,"23956":46,"24682":8,"24731":63,"24786":22,"24919":18,"24673":6,"24509":51,"24966":15,"24313":65,"23914":3,"24842":25,"24431":20,"24918":73,"24761":27,"24414":20,"24912":28,"23924":63,"24983":11,"23874":5,"24297":7,"24345":21,"24892":14,"23880":12,"24939":76,"24815":44,"24771":31,"24091":39,"24163":43,"24320":16,"24082":94,"24317":53,"24619":46,"24516":3,"24405":5,"23871":5,"24073":4,"24539":37,"24100":92,"23895":80,"23929":46,"24978":17,"24623":16,"24175":8,"25036":57,"24713":53,"24887":7,"23913":56,"24062":4,"24324":47,"24960":36,"24696":46,"24997":5,"24391":32,"25051":77,"24553":72,"23945":18,"24679":31,"24968":12,"24850":22,"23881":25,"24085":4,"24209":27,"24093":33,"23900":69,"24518":4,"24651":28,"24004":12,"23954":20,"23984":96,"24903":20,"24371":7,"24559":29,"24957":84,"24867":79,"24152":45,"24784":4,"24990":84,"24531":64,"24340":2,"24038":44,"24394":13,"24988":3,"25061":29,"24010":22,"23856":25,"24886":14,"24363":25,"24412":37,"25004":44,"24835":11,"23855":35,"24105":6,"23885":33,"24823":12,"24066":4,"23950":43,"25052":9,"24068":8,"24103":46,"24252":28,"24211":42,"24984":30,"24961":9,"23965":24,"24937":36,"24813":50,"24095":7,"23971":11,"23918":51,"24150":19,"24144":5,"24053":40,"24392":9,"23867":72,"24804":17,"24403":130,"24467":6,"24081":39,"23925":23,"24219":80,"24055":20,"24299":45,"24212":10,"23814":67,"23886":6,"24248":49,"24382":4,"24274":15,"23996":13,"24131":12,"23870":3,"24037":15,"24180":27,"24442":3,"24795":12,"24517":17,"24756":75,"25023":34,"24256":32,"24022":8,"24624":60,"23979":65,"24235":34,"23834":15,"24106":8,"24851":43,"24611":23,"24743":25,"24323":12,"24035":8,"24499":32,"24868":6,"24633":19,"24587":48,"24063":26,"24108":15,"24232":61,"23841":27,"23851":28,"24142":8,"23910":51,"24273":74,"24279":34,"23869":49,"24699":71,"24192":6,"24740":24,"23877":39,"24906":39,"24757":84,"24762":26,"24156":71,"25005":26,"24120":9,"24241":71,"23852":53,"23866":14,"24717":7,"25048":27,"23898":52,"24092":30,"24877":9,"23830":23,"24198":9,"24204":3,"23991":11,"25058":28,"24838":5,"24653":43,"24146":16,"24833":1,"24133":5,"24476":12,"24847":26,"24636":17,"23977":45,"24497":49,"24281":27,"23899":11,"24465":19,"24670":18,"24595":12,"25024":50,"24732":52,"24401":11,"24125":6,"24293":16,"23975":80,"24710":32,"24243":38,"23941":5,"24751":3,"24076":64,"24349":16,"24515":76,"24171":33,"24260":16,"23976":29,"24519":33,"23832":17,"24351":50,"23809":9,"24831":13,"25049":31,"24834":8,"23793":4,"24728":10,"24385":41,"24952":5,"24891":23,"24428":29,"24121":18,"23805":26,"24808":12,"23789":4,"24052":23,"24973":21,"23988":23,"24849":63,"24718":38,"24894":17,"24295":11,"23863":49,"24638":11,"24287":6,"23994":4,"24760":10,"24941":71,"24746":41,"24910":10,"23958":15,"24916":70,"24839":15,"24981":58,"24550":11,"24702":12,"24693":43,"24365":5,"24410":17,"23906":49,"24797":16,"24803":9,"24785":57,"25059":4,"23944":18,"24404":9,"24357":35,"24096":25,"24031":45,"23937":70,"23865":38,"23804":62,"23854":25,"23891":32,"24773":24,"23825":27,"24355":17,"24036":54,"24417":26,"24608":4,"24626":8,"24810":13,"25016":28,"24546":12,"24264":22,"24591":4,"24114":35,"24057":67,"24482":21,"24758":29,"24166":9,"23883":15,"24719":40,"24642":28,"24159":11,"24194":20,"24641":9,"24982":5,"24602":30,"24605":36,"24109":42,"24741":9,"24709":77,"24020":10,"24157":52,"23990":57,"24151":23,"24501":46,"24821":8,"24586":54,"24419":26,"24047":11,"24155":25,"24311":7,"24254":26,"24030":37,"24455":11,"24088":65,"24802":39,"24995":30,"23845":34,"24612":50,"24033":13,"24649":18,"24019":4,"23955":5,"25006":63,"24652":29,"24478":24,"24888":12,"24233":12,"24694":27,"23849":4,"24841":10,"24197":101,"24003":10,"24943":10,"24783":29,"24650":9,"23989":63,"24395":7,"24958":92,"24097":45,"24606":24,"24913":15,"24529":46,"24315":22,"24549":5,"23980":6,"24127":11,"23847":86,"24882":30,"24610":31,"24149":13,"24618":10,"24370":20,"24486":22,"24537":1,"24021":48,"24872":45,"24314":34,"24914":52,"23843":76,"24929":52,"24788":17,"24609":45,"23873":46,"24855":54,"24820":102,"24187":5,"25013":68,"23846":9,"24496":80,"24153":101,"24058":32,"24261":9,"23860":10,"24566":26,"24845":13,"24339":16,"24683":77,"24145":7,"24457":62,"24196":21,"23963":77,"24521":4,"24976":14,"24573":6,"24781":60,"24488":32,"24635":53,"24570":19,"24660":4,"24654":34,"24846":23,"24438":50,"25043":5,"24538":11,"24580":41,"23995":25,"24416":1,"24787":26,"23964":5,"23833":11,"24962":28,"24289":9,"24598":12,"24647":31,"24524":80,"24331":7,"24818":7,"24643":35,"24466":72,"24735":5,"23926":8,"24505":55,"24420":48,"24249":15,"24464":11,"24239":90,"24985":48,"24843":41,"24230":15,"24646":58,"25029":25,"24690":56,"24059":7,"24947":44,"24160":36,"24011":21,"23907":3,"24530":63,"24873":8,"24376":10,"23972":13,"24581":32,"24208":70,"24025":4,"24715":42,"24574":68,"24583":10,"24072":16,"24071":13,"25050":14,"24970":9,"24686":39,"23878":37,"24687":17,"24451":29,"24005":16,"24579":43,"24945":12,"23919":4,"24585":17,"24398":4,"24454":8,"24902":9,"23912":14,"24489":25,"23978":20,"24621":5,"24738":15,"23862":28,"24303":5,"24132":5,"24701":5,"24923":56,"24332":9,"24763":8,"24388":9,"24228":14,"24184":47,"24399":3,"24229":24,"24309":31,"24525":33,"24617":35,"24811":38,"24087":51,"24955":24,"24017":55,"24893":14,"24592":23,"24737":32,"24367":25,"24879":11,"24907":10,"23794":71,"23790":15,"24028":40,"23820":33,"23872":13,"24824":33,"24794":58,"24865":37,"24411":24,"24942":69,"24534":1,"24421":12,"24508":12,"24548":46,"24600":63,"24312":7,"23882":43,"25041":17,"24969":10,"23904":46,"24213":27,"24953":5,"24603":39,"24319":38,"25060":42,"24350":30,"23827":19,"24979":30,"23939":32,"24409":49,"24628":24,"24205":34,"24112":20,"24875":35,"24568":3,"23892":10,"24733":46,"24708":35,"24949":30,"24884":20,"24959":4,"24135":68,"25017":6,"23835":13,"24965":6,"24819":12,"24222":19,"24262":76,"24483":4,"23946":33,"24164":84,"23947":5,"23836":13,"24396":33,"24703":11,"24437":15,"24535":23,"24111":17,"24113":14,"24999":19,"23858":54,"24662":3,"24807":8,"24543":25,"25003":13,"24827":53,"24002":28,"24413":35,"23799":37,"24596":6,"24242":6,"24034":67,"23932":17,"24547":11,"24544":5,"25035":10,"24805":44,"24373":11,"24337":32,"24362":14,"24393":4,"24500":30,"23921":43,"23829":23,"24124":58,"24792":10,"24138":11,"24963":44,"24561":42,"24513":89,"23986":17,"24921":18,"24801":79,"24343":4,"23911":32,"24154":51,"24775":67,"24866":24,"24432":32,"24714":5,"24224":4,"24318":40,"24622":50,"24655":22,"23961":12,"24878":21,"24240":18,"24772":47,"24748":22,"24458":10,"24640":11,"24173":15,"24353":14,"24689":12,"24193":14,"24043":21,"24905":30,"24931":6,"24934":34,"24494":31,"24195":21,"24348":57,"24504":3,"24828":26,"24545":47,"24214":21,"24178":80,"24799":4,"24101":9,"24282":26,"23842":6,"24013":5,"24745":13,"23985":58,"24503":3,"24986":54,"24614":65,"25047":16,"24558":54,"24493":6,"23893":7,"24358":4,"24129":25,"24994":64,"24798":52,"24668":74,"24378":37,"24176":7,"24201":16,"24698":17,"24221":20,"24991":21,"24217":23,"24871":51,"24400":51,"25010":21,"24374":9,"24707":15,"24306":22,"23928":6,"24922":59,"24236":6,"25025":20,"23917":21,"25021":8,"24064":36,"24658":13,"23848":11,"24755":38,"24202":8,"24140":19,"24564":73,"23948":7,"23817":78,"24925":64,"23831":21,"24231":21,"24238":25,"23838":18,"24998":27,"24383":45,"24826":17,"24964":32,"24691":8,"25054":38,"23823":15,"24575":34,"24858":25,"24752":28,"24924":8,"24909":13,"24430":18,"24774":7,"24336":40,"24645":25,"24857":11,"24832":5,"23934":31,"24407":11,"24724":42,"24267":14,"24528":13,"24676":10,"24665":20,"23861":43,"24450":30,"23903":69,"24768":5,"24375":29,"24928":50,"24387":24,"24191":35,"24075":52,"25027":4,"23819":18,"24225":44,"24523":34,"24911":38,"23935":18,"25037":16,"23896":7,"24664":38,"24837":20,"24044":37,"24767":13,"24237":14,"24661":41,"23803":15,"23931":38,"24967":43,"24780":6,"24448":8,"24671":19,"24560":13,"24080":25,"24571":6,"24426":8,"24434":57,"24551":52,"24354":1,"24705":80,"24283":65,"24272":8,"24747":5,"24607":13,"24816":14,"24604":69,"23902":7,"24051":40,"24987":51,"24721":90,"24485":14,"24308":63,"24712":13,"24562":11,"24590":68,"24435":76,"24779":34,"24552":22,"24422":4,"24989":13,"24271":57,"24389":4,"24190":16,"24889":3,"24446":34,"25002":36,"23868":12,"24137":8,"24070":9,"23981":44,"24782":1,"24613":37,"24484":23,"24277":86,"23837":19,"24074":4,"24672":6,"24352":49,"23897":11,"24338":85,"24012":25,"24258":46,"24675":5,"24329":63,"24908":18,"24119":5,"24764":79,"24915":9,"24050":24,"24266":114,"24126":48,"23942":59,"24116":26,"24447":14,"23930":39,"24479":28,"24557":62,"24300":27,"24440":43,"24778":122,"24770":30,"23967":45,"24418":7,"24305":24,"24161":18,"24259":5,"24533":5,"24347":26,"24102":45,"24189":26,"24390":48,"24472":41,"24711":32,"24288":24,"24885":59,"23962":17,"24685":9,"24452":17,"24639":27,"24359":91,"24680":32,"24569":14,"24844":6,"23960":11,"24203":23,"24744":14,"24541":4,"24067":81,"24936":13,"24474":5,"24364":37,"24280":16,"24291":44,"24565":4,"24333":39,"24491":4,"24739":10,"24567":5,"24415":8,"24974":63,"24880":26,"25032":44,"24255":42,"24441":17,"24177":38,"23993":51,"24749":15,"24226":19,"24310":9,"24460":3,"24864":4,"24727":43,"24118":6,"24572":89,"25055":18,"24510":25,"24667":44,"24753":8,"23908":4,"23953":4,"25033":7,"24174":15,"24790":24,"24218":37,"24330":24,"24899":21,"24861":19,"23936":4,"24381":44,"24927":4,"24896":43,"24722":43,"24251":4,"24107":22,"24086":51,"24750":12,"24895":13,"23864":57}}